<?xml version="1.0" encoding="UTF-8" standalone="no"?><bugrepository><bug fixdate="2015-03-06 06:30:06" id="8453" opendate="2015-03-06 04:48:11"><buginformation><summary>[CAMEL-8453] camel-avro throws SAXParseException when used from spring or blueprint - ASF JIRA</summary><description>Getting this exception when using avro dataformat from spring: org.xml.sax.SAXParseException; lineNumber: 27; columnNumber: 88; cvc-complex-type.3.2.2: Attribute 'instanceClass' is not allowed to appear in element 'avro'. Don't think this has ever worked from spring.</description></buginformation><fixedFiles><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.model.dataformat.AvroDataFormat.java</file><file>gelog.camel-git.components.camel-avro.src.main.java.org.apache.camel.dataformat.avro.AvroDataFormat.java</file><file>gelog.camel-git.components.camel-avro.src.test.java.org.apache.camel.dataformat.avro.AvroMarshalAndUnmarshalSpringTest.java</file></fixedFiles></bug><bug fixdate="2015-03-06 11:14:05" id="8450" opendate="2015-03-06 11:10:33"><buginformation><summary>[CAMEL-8450] Netty component should not stop/null static timer when stopping - ASF JIRA</summary><description>NettyComponent.timer is static. It is initialized/started on component startup and stopped/nulled on component shutdown. The static timer is shared between. It means that when you start two bundles using camel-netty and then stop one of it, then the remaining running bundle will not be able to create new endpoints dynamically, because of the nulled timer in the component (until some other bundle using Netty component is started and reinitalizes the timer again). IMHO, we should not stop neither null the static timer. It can be shared between components and initialized/started when the first NettyComponent instance is created, but it should last forever. We technically could count the number of the component instances, and stops the timer when there is no NettyComponent available, but I don't see a point in this kind of micro-optimization. This is only one timer instance per application.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-netty.src.main.java.org.apache.camel.component.netty.NettyComponent.java</file><file>gelog.camel-git.components.camel-netty.src.test.java.org.apache.camel.component.netty.NettyConcurrentTimerAccessTest.java</file></fixedFiles></bug><bug fixdate="2015-03-04 09:04:08" id="8436" opendate="2015-03-04 02:52:14"><buginformation><summary>[CAMEL-8436] camel-spring-boot - Some routes not being initialized after CamelContext have been removed from CamelAutoConfiguration - ASF JIRA</summary><description>In our project we have several classes that extend SpringRouteBuilder and that are annotated with @Component. Some days ago we've noticed that most of them stopped being initialized on application startup. Found out that our issues started from this commit: https://github.com/apache/camel/commit/6bcc0b6110a762623888ded294c78dc168a18e75 If I roll it back everything is fine again.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-spring-boot.src.test.java.org.apache.camel.spring.boot.componentroute.ComponentRoute.java</file><file>gelog.camel-git.components.camel-spring-boot.src.test.java.org.apache.camel.spring.boot.duplicatedrouteid.DuplicatedRouteIdTest.java</file><file>gelog.camel-git.components.camel-spring-boot.src.main.java.org.apache.camel.spring.boot.CamelAutoConfiguration.java</file><file>gelog.camel-git.components.camel-spring-boot.src.test.java.org.apache.camel.spring.boot.DuplicatedRouteIdTest.java</file><file>gelog.camel-git.components.camel-spring-boot.src.main.java.org.apache.camel.spring.boot.CamelSpringBootInitializationException.java</file><file>gelog.camel-git.components.camel-spring-boot.src.main.java.org.apache.camel.spring.boot.RoutesCollector.java</file></fixedFiles></bug><bug fixdate="2015-03-05 06:34:34" id="8434" opendate="2015-03-04 10:13:32"><buginformation><summary>[CAMEL-8434] Camel HDFS2 - Unable to consume an empty file - ASF JIRA</summary><description>It is not possible to consume an empty file with camel HDFS2 consumer.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-hdfs2.src.main.java.org.apache.camel.component.hdfs2.HdfsConsumer.java</file><file>gelog.camel-git.components.camel-hdfs.src.main.java.org.apache.camel.component.hdfs.HdfsConsumer.java</file><file>gelog.camel-git.components.camel-hdfs.src.test.java.org.apache.camel.component.hdfs.HdfsConsumerTest.java</file><file>gelog.camel-git.components.camel-hdfs.src.main.java.org.apache.camel.component.hdfs.HdfsInputStream.java</file><file>gelog.camel-git.components.camel-hdfs2.src.main.java.org.apache.camel.component.hdfs2.HdfsInputStream.java</file><file>gelog.camel-git.components.camel-hdfs2.src.test.java.org.apache.camel.component.hdfs2.HdfsConsumerTest.java</file><file>gelog.camel-git.components.camel-hdfs2.src.main.java.org.apache.camel.component.hdfs2.HdfsFileType.java</file><file>gelog.camel-git.components.camel-hdfs.src.main.java.org.apache.camel.component.hdfs.HdfsFileType.java</file></fixedFiles></bug><bug fixdate="2015-03-04 12:37:43" id="8432" opendate="2015-03-04 12:42:25"><buginformation><summary>[CAMEL-8432] camel-mqtt: MQTT wildcard ('+') subscription broken - ASF JIRA</summary><description>MQTT single-level wildcards ("+" character) are broken within topic subscriptions. This is due to URL encoding/decoding that is done on the component URI, which results in the "+" being replaced with a space. I also tried with "%2B" instead of the "+" sign, which gave the same result. A search led me to CAMEL-8056, which mentions needing to override the useRawUri method to return true. I'm working on a patch and updated unit tests for this.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-mqtt.src.test.java.org.apache.camel.component.mqtt.MQTTBaseTest.java</file><file>a.components.camel-mqtt.src.test.java.org.apache.camel.component.mqtt.MQTTConfigurationTest.java</file><file>gelog.camel-git.components.camel-mqtt.src.main.java.org.apache.camel.component.mqtt.MQTTComponent.java</file><file>....java.org.apache.camel.component.mqtt.MQTTComponent.java</file><file>....apache.camel.component.mqtt.MQTTComponent.java</file><file>gelog.camel-git.components.camel-mqtt.src.test.java.org.apache.camel.component.mqtt.MQTTConfigurationTest.java</file><file>a.components.camel-mqtt.src.main.java.org.apache.camel.component.mqtt.MQTTComponent.java</file><file>a.components.camel-mqtt.src.test.java.org.apache.camel.component.mqtt.MQTTBaseTest.java</file><file>gelog.camel-git.components.camel-mqtt.src.test.java.org.apache.camel.component.mqtt.MQTTConsumerWildcardTopicsTest.java</file></fixedFiles></bug><bug fixdate="2015-03-04 07:43:59" id="8430" opendate="2015-03-03 12:18:35"><buginformation><summary>[CAMEL-8430] Camel HDFS2 - readSuffix option does not work - ASF JIRA</summary><description>Option readSuffix does not work. It staticly uses constant HdfsConstants.DEFAULT_READ_SUFFIX.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-hdfs.src.test.java.org.apache.camel.component.hdfs.HdfsConsumerTest.java</file><file>gelog.camel-git.components.camel-hdfs2.src.test.java.org.apache.camel.component.hdfs2.HdfsConsumerTest.java</file><file>gelog.camel-git.components.camel-hdfs.src.main.java.org.apache.camel.component.hdfs.HdfsInputStream.java</file><file>gelog.camel-git.components.camel-hdfs2.src.main.java.org.apache.camel.component.hdfs2.HdfsInputStream.java</file></fixedFiles></bug><bug fixdate="2015-03-03 09:12:48" id="8427" opendate="2015-03-02 11:13:58"><buginformation><summary>[CAMEL-8427] camel-scala - Testing with useOverridePropertiesWithPropertiesComponent issue - ASF JIRA</summary><description>A very simple project has been attached. The SFTP route has some properties which are being provided by using 'useOverridePropertiesWithPropertiesComponent' in CamelTestSupport. The test used to work fine before the latest March 2nd snapshot. It works with 2.14.1 version too. Now it fails with: &#13;
Caused by: java.lang.IllegalArgumentException: PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. Property with key [sftp.userName] not found in properties from text: sftp://{{sftp.userName}}@{{sftp.hostname}}{{sftp.folder}}?moveFailed={{sftp.moveFailedFolder}}&amp;privateKeyFile={{sftp.privateKeyFile}}&amp;privateKeyPassphrase={{sftp.privateKeyPassphrase}}&amp;readLock=changed&amp;readLockCheckInterval=10000&amp;readLockTimeout=40000&amp;streamDownload=true&amp;fastExistsCheck=true&amp;idempotent=true&amp;useFixedDelay=true&amp;delete=true&amp;recursive=true&amp;stepwise=false&#13;
	at org.apache.camel.component.properties.DefaultPropertiesParser$ParsingContext.getPropertyValue(DefaultPropertiesParser.java:268)</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-test.src.test.java.org.apache.camel.test.patterns.UseOverridePropertiesWithPropertiesComponentTest.java</file></fixedFiles></bug><bug fixdate="2015-03-02 07:08:43" id="8426" opendate="2015-03-02 06:27:38"><buginformation><summary>[CAMEL-8426] Handle invalid client id gracefully in Camel Box component - ASF JIRA</summary><description>Box component uses HtmlUnit to perform a login and authorization on user's behalf for OAuth. Box.com returns an error message instead of a login page on an invalid client id, which the component should handle gracefully, instead of the missing HTML element it throws currently.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-box.src.test.java.org.apache.camel.component.box.InvalidClientIdIntegrationTest.java</file><file>gelog.camel-git.components.camel-box.src.main.java.org.apache.camel.component.box.internal.LoginAuthFlowUI.java</file></fixedFiles></bug><bug fixdate="2015-03-02 06:54:12" id="8425" opendate="2015-03-02 06:27:15"><buginformation><summary>[CAMEL-8425] Handle invalid client id gracefully in Camel LinkedIn component - ASF JIRA</summary><description>LinkedIn component uses HtmlUnit to perform a login and authorization on user's behalf for OAuth. LinkedIn returns an error message instead of a login page on an invalid client id, which the component should handle gracefully, instead of the missing HTML element it throws currently. c</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-linkedin.camel-linkedin-api.src.test.java.org.apache.camel.component.linkedin.api.AbstractResourceIntegrationTest.java</file><file>gelog.camel-git.components.camel-linkedin.camel-linkedin-component.src.test.java.org.apache.camel.component.linkedin.ComponentConfigurationIntegrationTest.java</file><file>gelog.camel-git.components.camel-linkedin.camel-linkedin-api.src.main.java.org.apache.camel.component.linkedin.api.LinkedInOAuthRequestFilter.java</file></fixedFiles></bug><bug fixdate="2015-03-02 06:32:40" id="8424" opendate="2015-03-02 05:35:45"><buginformation><summary>[CAMEL-8424] Transaction being propagated ignoring REQUIRES_NEW when using direct component - ASF JIRA</summary><description>I found that when we are using exactly same propagation policy bean in different routes used together with "direct" component, then TransactionErrorHandler always propagates current transaction even if our policy is "PROPAGATION_REQUIRES_NEW". The failing code is: &#13;
    public TransactionErrorHandler(CamelContext camelContext, Processor output, CamelLogger logger, &#13;
            Processor redeliveryProcessor, RedeliveryPolicy redeliveryPolicy, ExceptionPolicyStrategy exceptionPolicyStrategy,&#13;
            TransactionTemplate transactionTemplate, Predicate retryWhile, ScheduledExecutorService executorService,&#13;
            LoggingLevel rollbackLoggingLevel) {&#13;
&#13;
        super(camelContext, output, logger, redeliveryProcessor, redeliveryPolicy, null, null, false, retryWhile, executorService);&#13;
        setExceptionPolicy(exceptionPolicyStrategy);&#13;
        this.transactionTemplate = transactionTemplate;&#13;
        this.rollbackLoggingLevel = rollbackLoggingLevel;&#13;
        this.transactionKey = ObjectHelper.getIdentityHashCode(transactionTemplate);&#13;
    }&#13;
&#13;
    @Override&#13;
    public void process(Exchange exchange) throws Exception {&#13;
        // we have to run this synchronously as Spring Transaction does *not* support&#13;
        // using multiple threads to span a transaction&#13;
        if (exchange.getUnitOfWork().isTransactedBy(transactionKey)) {&#13;
            // already transacted by this transaction template&#13;
            // so lets just let the error handler process it&#13;
            processByErrorHandler(exchange);&#13;
        } else {&#13;
            // not yet wrapped in transaction so lets do that&#13;
            // and then have it invoke the error handler from within that transaction&#13;
            processInTransaction(exchange);&#13;
        }&#13;
    }&#13;
 So then for each policy there is a hash code created, which then is used to verify whether current route is already transacted by this transaction policy. This makes "PROPAGATION_REQUIRES_NEW" ignored when used with "direct" component. So for example: &#13;
                from("activemq:queue:start").routeId("route1")&#13;
                        .transacted("PROPAGATION_REQUIRES_NEW")&#13;
                        .setExchangePattern(ExchangePattern.InOnly)&#13;
                        .to("activemq:queue:result1")&#13;
                        .to("direct:route2")&#13;
                        .throwException(new RuntimeException("Expected!"));&#13;
&#13;
                from("direct:route2").routeId("route2")&#13;
                        .transacted("PROPAGATION_REQUIRES_NEW")&#13;
                        .setExchangePattern(ExchangePattern.InOnly)&#13;
                        .to("activemq:queue:result2");&#13;
 The above route suppose to work in 2 different transactions, as our propagation is REQUIRES_NEW for both of them. But due to hash code verification and optimisation, route2 will participate in same transaction as route1 instead of new. This is rather buggy. Will create pull request in minutes.</description></buginformation><fixedFiles><file>gelog.camel-git.tests.camel-itest.src.test.java.org.apache.camel.itest.tx.Jms2RequiresNewTest.java</file><file>gelog.camel-git.components.camel-spring.src.main.java.org.apache.camel.spring.spi.TransactionErrorHandler.java</file></fixedFiles></bug><bug fixdate="2015-03-02 07:19:49" id="8417" opendate="2015-02-28 04:07:49"><buginformation><summary>[CAMEL-8417] RAW_TOKEN_START and RAW_TOKEN_END not removed when query parameter occurs multiple times - ASF JIRA</summary><description>The tokens RAW_TOKEN_START ("RAW(") and RAW_TOKEN_END (")") are not removed when the parameter value is a list. The bug is in "resolveRawParameterValues" in org.apache.camel.util.UriSupport (lines 323, 324): &#13;
                String value = entry.getValue().toString();&#13;
                if (value.startsWith(RAW_TOKEN_START) &amp;&amp; value.endsWith(RAW_TOKEN_END)) {&#13;
 This does not work when entry.getValue() contains a list.</description></buginformation><fixedFiles><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.util.URISupport.java</file><file>gelog.camel-git.camel-core.src.test.java.org.apache.camel.issues.EndpointWithRawUriParameterTest.java</file></fixedFiles></bug><bug fixdate="2015-02-26 12:33:23" id="8411" opendate="2015-02-26 12:30:59"><buginformation><summary>[CAMEL-8411] camel-netty-http - Checking for host header is invalid - ASF JIRA</summary><description>See http://camel.465427.n5.nabble.com/Camel-Netty-Http-HttpHeaders-case-sensitive-tp5763157.html The names() should be removed as it transfers the headers to a linked hash map instead of checking directly using the netty http headers which is case insensitive.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-netty-http.src.main.java.org.apache.camel.component.netty.http.handlers.HttpServerChannelHandler.java</file><file>gelog.camel-git.components.camel-netty4-http.src.main.java.org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.java</file></fixedFiles></bug><bug fixdate="2015-02-26 09:13:26" id="8409" opendate="2015-02-26 04:54:26"><buginformation><summary>[CAMEL-8409] Kafka producer: when no message key specified, use partition key - ASF JIRA</summary><description>CAMEL-8190 has introduced behavior that has the potential to break existing code (hence setting to Critical priority so this can be fixed prior to 2.14.2/2.15.0 releases). It broke my code (using 2.14.2-SNAPSHOT builds) in development and staging, and I didn't notice the problem until tonight. Prior to CAMEL-8190, the value of the KafkaConstants.PARTITION_KEY header was used for both the key and partitionKey of the kafka KeyedMessage. My downstream consumers depended on this for the correct key of the consumed message. CAMEL-8190, changed things so the key is set only via the KafkaConstants.KEY header, and since my code didn't set that header, the key started coming through as null to downstream consumers. I propose the following to fix this (will attach a patch shortly): If both KEY and PARTITION_KEY are specified, no change from CAMEL-8190 If just one is specified, call the KeyedMessage 3-argument constructor with the value (uses the value for both key and partitionKey) If neither are specified, pass null for both...but IMHO, a warning should be logged, as it seems unlikely that the user knowingly omitted both values.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-kafka.src.main.java.org.apache.camel.component.kafka.KafkaProducer.java</file><file>gelog.camel-git.components.camel-kafka.src.test.java.org.apache.camel.component.kafka.KafkaProducerTest.java</file><file>a.components.camel-kafka.src.test.java.org.apache.camel.component.kafka.KafkaProducerTest.java</file><file>a.components.camel-kafka.src.main.java.org.apache.camel.component.kafka.KafkaProducer.java</file><file>....org.apache.camel.component.kafka.KafkaProducer.java</file></fixedFiles></bug><bug fixdate="2015-02-26 01:02:08" id="8401" opendate="2015-02-25 01:06:08"><buginformation><summary>[CAMEL-8401] CamelOverruleFileName does not work correctly for remote file endpoints - ASF JIRA</summary><description>According to the docs, when using CamelOverruleFileName, the original CamelFileName should be restored after the overruling name is used once. This is not working when using a remote file endpoint, such as FTP. From the description of CAMEL-5269, it seems like this worked once, but it doesn't seem to anymore.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-ftp.src.test.java.org.apache.camel.component.file.remote.RemoteFileProduceOverruleOnlyOnceTest.java</file><file>gelog.camel-git.components.camel-ftp.src.main.java.org.apache.camel.component.file.remote.RemoteFileProducer.java</file></fixedFiles></bug><bug fixdate="2015-02-23 10:30:04" id="8395" opendate="2015-02-23 08:41:41"><buginformation><summary>[CAMEL-8395] Handle empty Salesforce picklist types - ASF JIRA</summary><description>Salesforce inbuilt/user customizable picklist types may be empty with no values defined. This breaks sobject-picklist.vm. It should instead generate an empty Enum with no values.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-salesforce.camel-salesforce-maven-plugin.src.main.java.org.apache.camel.maven.CamelSalesforceMojo.java</file></fixedFiles></bug><bug fixdate="2015-02-20 10:33:02" id="8382" opendate="2015-02-20 10:07:22"><buginformation><summary>[CAMEL-8382] dumpRoutesAsXml should resolve "from" endpoint property values as with "to" endpoint URI - ASF JIRA</summary><description>We have defined our routes with property keys for all endpoints ("from" and "to"). When using the dumpRoutesAsXml operation we see that the "from uri" value is the property key, however the "to uri" has been resolved to the actual property value. For example, given a RouteBuilder like the following: &#13;
        from("{{route1.uri}}")&#13;
            .routeId("myRoute")&#13;
            .to("{{route2.uri}}")&#13;
 dumpRoutesAsXml outputs the following: &#13;
    &lt;route customId="true" id="myRoute"&gt;&#13;
        &lt;from uri="{{route1.uri}}"/&gt;&#13;
        &lt;to uri="jms:myapp.route2" id="to2"/&gt;&#13;
    &lt;/route&gt;&#13;
 where "myapp.route2" is the resolved value of "route2.uri". Perhaps there is a good reason for this behaviour, but it appears to be inconsistent.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-spring.src.test.java.org.apache.camel.component.properties.SpringPropertiesRouteFromTest.java</file><file>gelog.camel-git.camel-core.src.test.java.org.apache.camel.component.properties.PropertiesComponentEndpointTest.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.model.DataFormatDefinition.java</file><file>gelog.camel-git.camel-core.src.test.java.org.apache.camel.component.properties.PropertiesRouteFromTest.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.model.ProcessorDefinition.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.model.ProcessorDefinitionHelper.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.model.RouteDefinitionHelper.java</file></fixedFiles></bug><bug fixdate="2015-02-18 08:38:32" id="8369" opendate="2015-02-17 10:27:38"><buginformation><summary>[CAMEL-8369] weaveAddLast does not work property when route ends with a split - ASF JIRA</summary><description>When using AdviceWithRouteBuilder to modify a route definition, weaveAddLast does not work correctly when the route ends with a split. It appears to add the additional components within the split, not afterwards. See attached testcase. Adding a trivial operation after the split in the original route builder fixes it.</description></buginformation><fixedFiles><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.builder.AdviceWithRouteBuilder.java</file><file>gelog.camel-git.camel-core.src.test.java.org.apache.camel.processor.interceptor.AdviceWithWeaveAfterLastSplitTest.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.model.ProcessorDefinitionHelper.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.builder.AdviceWithTasks.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.builder.AdviceWithBuilder.java</file></fixedFiles></bug><bug fixdate="2015-02-16 02:06:36" id="8359" opendate="2015-02-16 01:54:51"><buginformation><summary>[CAMEL-8359] LinkedIn consumer endpoints have to specify an empty 'fields' parameter - ASF JIRA</summary><description>LinkedIn consumer endpoints that take a 'fields' parameter should not have to specify an empty value for the optional field. This field is handled for producer endpoints as its default value is set in LinkedInEndpoint.interceptProperties(). This field should be automatically set to null if the api method requires it in LinkedInConsumer.interceptPropertyNames().</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-linkedin.camel-linkedin-component.src.main.java.org.apache.camel.component.linkedin.LinkedInEndpoint.java</file><file>gelog.camel-git.components.camel-linkedin.camel-linkedin-component.src.main.java.org.apache.camel.component.linkedin.LinkedInConsumer.java</file><file>gelog.camel-git.components.camel-linkedin.camel-linkedin-component.src.test.java.org.apache.camel.component.linkedin.PeopleResourceIntegrationTest.java</file></fixedFiles></bug><bug fixdate="2015-02-16 11:27:19" id="8358" opendate="2015-02-16 12:49:27"><buginformation><summary>[CAMEL-8358] Avoid using Olingo2 library classes from 'core' package as it has been designated internal and not part of the API exposed using OSGi headers - ASF JIRA</summary><description>Olingo2 library classes in 'core' are internal and should not be used. Even though the URI parser classes should really have been exposed through the public API. This includes a public URI parser URIInfo exposed through the api package, but its implementation URIInfoImpl is part of core and hence not exposed. This does not affect any public component classes in the Olingo2 component. See OLINGO-420.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-olingo2.camel-olingo2-api.src.main.java.org.apache.camel.component.olingo2.api.impl.SystemQueryOption.java</file><file>gelog.camel-git.components.camel-olingo2.camel-olingo2-component.src.main.java.org.apache.camel.component.olingo2.Olingo2Configuration.java</file><file>gelog.camel-git.components.camel-olingo2.camel-olingo2-api.src.main.java.org.apache.camel.component.olingo2.api.impl.ODataPathSegmentImpl.java</file><file>gelog.camel-git.components.camel-olingo2.camel-olingo2-api.src.main.java.org.apache.camel.component.olingo2.api.impl.UriType.java</file><file>gelog.camel-git.components.camel-olingo2.camel-olingo2-component.src.test.java.org.apache.camel.component.olingo2.Olingo2AppIntegrationTest.java</file><file>gelog.camel-git.components.camel-olingo2.camel-olingo2-api.src.main.java.org.apache.camel.component.olingo2.api.impl.UriInfoWithType.java</file><file>gelog.camel-git.components.camel-olingo2.camel-olingo2-api.src.test.java.org.apache.camel.component.olingo2.api.Olingo2AppIntegrationTest.java</file><file>gelog.camel-git.components.camel-olingo2.camel-olingo2-api.src.main.java.org.apache.camel.component.olingo2.api.impl.Olingo2AppImpl.java</file><file>gelog.camel-git.components.camel-olingo2.camel-olingo2-api.src.main.java.org.apache.camel.component.olingo2.api.impl.AbstractFutureCallback.java</file></fixedFiles></bug><bug fixdate="2015-03-03 02:06:07" id="8356" opendate="2015-02-14 12:05:33"><buginformation><summary>[CAMEL-8356] IOConverter.toInputStream(file, charset) returns strange behaving stream - ASF JIRA</summary><description>Calling IOConverter.toInputStream with either UTF-8 or ISO-8859-1 returns a stream that behaves strange on non-ascii-characters: putting this stream into an InputStreamReader will return false encoded characters a naive new BufferedReader(new InputStreamReader(new FileInputStream(file), charset)) will return the correctly encoded characters. I will attach some unit tests for this case.</description></buginformation><fixedFiles><file>gelog.camel-git.camel-core.src.test.java.org.apache.camel.converter.IOConverterCharsetTest.java</file><file>a.camel-core.src.main.java.org.apache.camel.converter.IOConverter.java</file><file>a.camel-core.src.test.java.org.apache.camel.converter.IOConverterCharsetTest.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.converter.IOConverter.java</file><file>gelog.camel-git.components.camel-jsonpath.src.test.java.org.apache.camel.jsonpath.JsonPathSourceTest.java</file><file>gelog.camel-git.components.camel-jsonpath.src.main.java.org.apache.camel.jsonpath.JsonPathEngine.java</file></fixedFiles></bug><bug fixdate="2015-02-14 01:40:40" id="8355" opendate="2015-02-14 10:30:13"><buginformation><summary>[CAMEL-8355] Dynamicity flag on Mongodb endpoint run a dropIndex() command on specified collection - ASF JIRA</summary><description>Using "dynamicity=true" on MongoDb endpoint is running a dropIndex command on the specified collection (CamelMongoDbCollection header), for each exchange going through.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-mongodb.src.main.java.org.apache.camel.component.mongodb.MongoDbEndpoint.java</file></fixedFiles></bug><bug fixdate="2015-02-15 08:17:52" id="8353" opendate="2015-02-14 08:12:56"><buginformation><summary>[CAMEL-8353] FileLockExclusiveReadLockStrategy - Should defer closing channel till release lock - ASF JIRA</summary><description>See nabble http://camel.465427.n5.nabble.com/FileLockExclusiveReadLockStrategy-doesn-t-hold-lock-and-error-on-commit-tp5762668.html The acquire lock method closes the channel if it acquired the lock, but that would make the lock invalid. Instead the channel should remain open and only closed when the lock is released.</description></buginformation><fixedFiles><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategy.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.Exchange.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.component.file.strategy.FileLockExclusiveReadLockStrategy.java</file></fixedFiles></bug><bug fixdate="2015-02-18 07:20:41" id="8352" opendate="2015-02-13 10:48:25"><buginformation><summary>[CAMEL-8352] NettyServerBossPoolBuilder build() method is package-protected - ASF JIRA</summary><description>The user documentation for camel-netty4 discusses creating worker and boss thread pools that are shared across camel-netty4 consumers. I am trying to do this, but discovered that the NettyServerBossPoolBuilder.build() method is package-protected, and I am therefore unable to use this builder to create the shared boss pool. Unit tests pass because the tests are within the same package, but the method needs to be public for anyone else to use.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-netty.src.main.java.org.apache.camel.component.netty.NettyClientBossPoolBuilder.java</file><file>gelog.camel-git.components.camel-netty.src.main.java.org.apache.camel.component.netty.NettyServerBossPoolBuilder.java</file><file>gelog.camel-git.components.camel-netty4.src.main.java.org.apache.camel.component.netty4.NettyServerBossPoolBuilder.java</file></fixedFiles></bug><bug fixdate="2015-03-04 06:53:06" id="8346" opendate="2015-02-13 06:26:48"><buginformation><summary>[CAMEL-8346] JsonPathEngine skips file encoding - ASF JIRA</summary><description>This occurs if one uses the camel file component with a charset parameter, e.g. file:/url?charset=UTF-8. It leads to strange effects: testing the same utf8-file under linux (default encoding:UTF-8) and german windows (default encoding:windows-1252) leads to problems with german umlauts. using a file in another encoding than the default (ISO-8859-1 on linux) leads also to problems with german umlauts. Both problems can be reproduced with the attached unit test files in 2.14.1. Problem 1 is hidden in 2.15-SNAPSHOT, because UTF-8 is hard-coded as file encoding (maybe ok, since JSON is almost never used with language specific encondings), Problem 2 also occurs in 2.15-SNAPSHOT I can provide or help with a fix (or pull request), if these problems are classified as true defects.</description></buginformation><fixedFiles><file>gelog.camel-git.camel-core.src.test.java.org.apache.camel.converter.IOConverterCharsetTest.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.converter.IOConverter.java</file><file>gelog.camel-git.components.camel-jsonpath.src.test.java.org.apache.camel.jsonpath.JsonPathSourceTest.java</file><file>gelog.camel-git.components.camel-jsonpath.src.main.java.org.apache.camel.jsonpath.JsonPathEngine.java</file></fixedFiles></bug><bug fixdate="2015-02-13 01:37:23" id="8344" opendate="2015-02-12 05:13:38"><buginformation><summary>[CAMEL-8344] Too restrictive OSGi Headers (blocks Spring 4 upgrade) - ASF JIRA</summary><description>Camel now officially supports Spring 4 yet the Manifest headers specify a verion &lt; 4 Ideally the version range should be [3.x.x,5) at least camel-spring and camel-cxf are affected. See also CAMEL-7861</description></buginformation><fixedFiles><file>gelog.camel-git.camel-core.src.test.java.org.apache.camel.converter.IOConverterCharsetTest.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.converter.IOConverter.java</file></fixedFiles></bug><bug fixdate="2015-02-12 03:00:00" id="8341" opendate="2015-02-12 12:44:51"><buginformation><summary>[CAMEL-8341] Usage of camel-rss depends on TCCL - ASF JIRA</summary><description>13:38:05,211 WARN  [org.apache.camel.component.rss.RssEntryPollingConsumer] (Camel (camel-2) thread #0 - rss://https://developer.jboss.org/blogs/feeds/posts) Consumer Consumer[rss://https://developer.jboss.org/blogs/feeds/posts?splitEntries=true] failed polling endpoint: Endpoint[rss://https://developer.jboss.org/blogs/feeds/posts?splitEntries=true]. Will try again at next poll. Caused by: [java.lang.ExceptionInInitializerError - null]: java.lang.ExceptionInInitializerError&#13;
	at com.sun.syndication.io.SyndFeedInput.build(SyndFeedInput.java:123)&#13;
	at org.apache.camel.component.rss.RssUtils.createFeed(RssUtils.java:34) [camel-rss-2.14.1.jar:2.14.1]&#13;
	at org.apache.camel.component.rss.RssEntryPollingConsumer.createFeed(RssEntryPollingConsumer.java:54) [camel-rss-2.14.1.jar:2.14.1]&#13;
	at org.apache.camel.component.feed.FeedEntryPollingConsumer.poll(FeedEntryPollingConsumer.java:47) [camel-atom-2.14.1.jar:2.14.1]&#13;
	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:187) [camel-core-2.14.1.jar:2.14.1]&#13;
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:114) [camel-core-2.14.1.jar:2.14.1]&#13;
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [rt.jar:1.8.0_31]&#13;
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) [rt.jar:1.8.0_31]&#13;
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) [rt.jar:1.8.0_31]&#13;
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) [rt.jar:1.8.0_31]&#13;
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [rt.jar:1.8.0_31]&#13;
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [rt.jar:1.8.0_31]&#13;
	at java.lang.Thread.run(Thread.java:745) [rt.jar:1.8.0_31]&#13;
Caused by: java.lang.NullPointerException&#13;
	at java.util.Properties$LineReader.readLine(Properties.java:434) [rt.jar:1.8.0_31]&#13;
	at java.util.Properties.load0(Properties.java:353) [rt.jar:1.8.0_31]&#13;
	at java.util.Properties.load(Properties.java:341) [rt.jar:1.8.0_31]&#13;
	at com.sun.syndication.io.impl.PropertiesLoader.&lt;init&gt;(PropertiesLoader.java:74)&#13;
	at com.sun.syndication.io.impl.PropertiesLoader.getPropertiesLoader(PropertiesLoader.java:46)&#13;
	at com.sun.syndication.io.impl.PluginManager.&lt;init&gt;(PluginManager.java:54)&#13;
	at com.sun.syndication.io.impl.PluginManager.&lt;init&gt;(PluginManager.java:46)&#13;
	at com.sun.syndication.feed.synd.impl.Converters.&lt;init&gt;(Converters.java:40)&#13;
	at com.sun.syndication.feed.synd.SyndFeedImpl.&lt;clinit&gt;(SyndFeedImpl.java:59)&#13;
 This is because of rome PropertiesLoader &#13;
    public static PropertiesLoader getPropertiesLoader() {&#13;
        synchronized(PropertiesLoader.class) {&#13;
            PropertiesLoader loader = (PropertiesLoader)&#13;
                clMap.get(Thread.currentThread().getContextClassLoader());&#13;
            if (loader == null) {&#13;
                try {&#13;
                    loader = new PropertiesLoader(MASTER_PLUGIN_FILE, EXTRA_PLUGIN_FILE);&#13;
                    clMap.put(Thread.currentThread().getContextClassLoader(), loader);&#13;
                }&#13;
                catch (IOException ex) {&#13;
                    throw new RuntimeException(ex);&#13;
                }&#13;
            }&#13;
            return loader;&#13;
        }&#13;
    }</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-rss.src.main.java.org.apache.camel.component.rss.RssUtils.java</file><file>gelog.camel-git.components.camel-rss.src.main.java.org.apache.camel.component.rss.RssEntryPollingConsumer.java</file></fixedFiles></bug><bug fixdate="2015-02-12 02:48:55" id="8339" opendate="2015-02-12 10:33:06"><buginformation><summary>[CAMEL-8339] Usage of camel-mail depends on TCCL - ASF JIRA</summary><description>javax.mail.Session uses TCCL to load resources &#13;
Thread.getContextClassLoader() line: 1432 [local variables unavailable]	&#13;
Session$3.run() line: 1199	&#13;
AccessController.doPrivileged(PrivilegedAction&lt;T&gt;) line: not available [native method]	&#13;
Session.getContextClassLoader() line: 1194	&#13;
Session.loadAllResources(String, Class, StreamLoader) line: 1137	&#13;
Session.loadProviders(Class) line: 917	&#13;
Session.&lt;init&gt;(Properties, Authenticator) line: 216	&#13;
Session.getInstance(Properties, Authenticator) line: 242	&#13;
MailConfiguration.createJavaMailSender() line: 175	&#13;
MailEndpoint.createProducer() line: 71	&#13;
 Both MailConfiguration &amp; MailProducer seem to rely on this</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-mail.src.main.java.org.apache.camel.component.mail.MailProducer.java</file><file>gelog.camel-git.components.camel-mail.src.main.java.org.apache.camel.component.mail.MailComponent.java</file><file>gelog.camel-git.components.camel-mail.src.main.java.org.apache.camel.component.mail.MailConfiguration.java</file></fixedFiles></bug><bug fixdate="2015-02-12 09:40:06" id="8338" opendate="2015-02-12 09:17:43"><buginformation><summary>[CAMEL-8338] ScriptBuilder relies on TCCL to discover engines - ASF JIRA</summary><description>ScriptBuilder uses javax.script.ScriptEngineManager default ctor, which does &#13;
    public ScriptEngineManager() {&#13;
        ClassLoader ctxtLoader = Thread.currentThread().getContextClassLoader();&#13;
        init(ctxtLoader);&#13;
    }&#13;
 This means we can only discover script engines that are visible on the TCCL</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-script.src.main.java.org.apache.camel.builder.script.ScriptBuilder.java</file></fixedFiles></bug><bug fixdate="2015-02-11 05:46:26" id="8336" opendate="2015-02-11 12:44:49"><buginformation><summary>[CAMEL-8336] XML Signature: XAdES: Wrong value for attribute "Qualifier" of element CommitmentTypeId - ASF JIRA</summary><description>If you specify in the XAdES Properties a value of the attribute attribute "Qualifier" of the element "CommitmentTypeId" then this value is not used, instead wrongly the value of the DataObjectFormatIdentifierQualifier is used.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-xmlsecurity.src.main.java.org.apache.camel.component.xmlsecurity.api.XAdESSignatureProperties.java</file><file>....xmlsecurity.api.XAdESSignatureProperties.java</file><file>gelog.camel-git.components.camel-xmlsecurity.src.test.java.org.apache.camel.component.xmlsecurity.XAdESSignaturePropertiesTest.java</file><file>a.components.camel-xmlsecurity.src.test.java.org.apache.camel.component.xmlsecurity.XAdESSignaturePropertiesTest.java</file><file>a.components.camel-xmlsecurity.src.main.java.org.apache.camel.component.xmlsecurity.api.XAdESSignatureProperties.java</file></fixedFiles></bug><bug fixdate="2015-02-10 08:47:50" id="8329" opendate="2015-02-10 08:40:05"><buginformation><summary>[CAMEL-8329] camel-sql - May not propagate headers for operations with no resultset - ASF JIRA</summary><description>See nabble http://camel.465427.n5.nabble.com/Camel-SQL-CamelSqlRetrieveGeneratedKeys-attribute-delete-all-headers-tp5762512.html</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-sql.src.test.java.org.apache.camel.component.sql.SqlGeneratedKeysTest.java</file><file>gelog.camel-git.components.camel-sql.src.main.java.org.apache.camel.component.sql.SqlProducer.java</file></fixedFiles></bug><bug fixdate="2015-02-10 07:29:47" id="8327" opendate="2015-02-09 04:13:52"><buginformation><summary>[CAMEL-8327] ContextTestSupport does not support weaveByType in test cases - ASF JIRA</summary><description>Update AdviceWithTypeTest test class to contain the below. On Camel-2.13.2 and below the test case would pass, on 2.13.3 and above the test case fails. AdviceWithTypeTest.java &#13;
    public void testUnknownType2() throws Exception {&#13;
       &#13;
        context.getRouteDefinitions().get(0).adviceWith(context, new AdviceWithRouteBuilder() {&#13;
            @Override&#13;
            public void configure() throws Exception {&#13;
                weaveByType(ChoiceDefinition.class).replace().to("mock:baz");&#13;
            }&#13;
        });&#13;
       &#13;
        getMockEndpoint("mock:baz").expectedMessageCount(1);&#13;
        template.sendBody("direct:start", "World");&#13;
        assertMockEndpointsSatisfied();&#13;
    }&#13;
 &#13;
 &#13;
    @Override&#13;
    protected RouteBuilder createRouteBuilder() throws Exception {&#13;
        return new RouteBuilder() {&#13;
            @Override&#13;
            public void configure() throws Exception {&#13;
                // START SNIPPET: e5&#13;
                from("direct:start")&#13;
                    .transform(simple("Hello ${body}"))&#13;
                    .log("Got ${body}")&#13;
                    .to("mock:result")&#13;
                    .choice()&#13;
                    .when(header("foo").isEqualTo("bar"))&#13;
                       .to("mock:resultA")&#13;
                    .otherwise()&#13;
                       .to("mock:resultB");&#13;
                // END SNIPPET: e5&#13;
            }&#13;
        };&#13;
    }</description></buginformation><fixedFiles><file>gelog.camel-git.camel-core.src.test.java.org.apache.camel.issues.AdviceWithWeaveByTypeCBRTest.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.model.ProcessorDefinitionHelper.java</file><file>gelog.camel-git.camel-core.src.test.java.org.apache.camel.model.ProcessorDefinitionHelperTest.java</file></fixedFiles></bug><bug fixdate="2015-02-09 05:32:58" id="8315" opendate="2015-02-05 07:28:06"><buginformation><summary>[CAMEL-8315] set Component Option "responseHeaderSize",but no effect - ASF JIRA</summary><description>I set the option "responseHeaderSize" like : JettyHttpComponent jettyHttpComponent=(JettyHttpComponent) getContext().getComponent("jetty"); jettyHttpComponent.setResponseHeaderSize(51202); But there is no effect;then I checked the camel-jetty.jar's source,and found in JettyHttpComponent.createSocketConnector: if (responseHeaderSize != null) { answer.setResponseBufferSize(responseHeaderSize); }</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-jetty8.src.main.java.org.apache.camel.component.jetty8.JettyHttpComponent8.java</file></fixedFiles></bug><bug fixdate="2015-02-04 01:23:17" id="8313" opendate="2015-02-04 12:55:36"><buginformation><summary>[CAMEL-8313] AddNamespace should not override the element's namespace - ASF JIRA</summary><description>I am running a web service in Cxf PAYLOAD mode and in one of the use cases I need to convert the body into Node (Element) and I am doing that by cxfpayload.getBody().get(0) This makes the namespaces from nsMap to be copied on to the element. While doing so, if the nsMap contains a namespace prefix that is also part of the element's attribute, it is being overwritten in the addNamespace(Element element, Map&lt;String, String&gt; nsMap) method. But when same prefix in soap Envelope and body contains different namespace values, that makes the body (XML) invalid. Here is a sample soap request that contains same namespace prefix ns1 in soap:Envelope and soap:Body but contains different namespace values. &#13;
&lt;soapenv:Envelope &#13;
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" &#13;
xmlns:ns="http://www.example.com/location/consumerfundbalances/1/" &#13;
xmlns:ns1="http://www.example.com/consumerfundbalances/retrievefundbalances/bi/1/"&gt;&#13;
&lt;soapenv:Body&gt;&#13;
&lt;ns1:retrieveFundBalances &#13;
xmlns="http://www.example.com/consumerfundbalances/retrievefundbalances/bi/1/"&#13;
xmlns:ns1="http://www.example.com/location/consumerfundbalances/1/"&gt;&#13;
&lt;retrieveFundBalances&gt;&#13;
&lt;fundBalancesRequestIdentifier/&gt;&#13;
&lt;/retrieveFundBalances&gt;&#13;
&lt;/ns1:retrieveFundBalances&gt;&#13;
&lt;/soapenv:Body&gt;&#13;
&lt;/soapenv:Envelope&gt;&#13;
 Now when I convert the payload into DOM Node, here is output XML namespace value for prefix ns1 is being replaced with the envelope. &#13;
&lt;ns1:retrieveFundBalances &#13;
xmlns:ns1="http://www.example.com/consumerfundbalances/retrievefundbalances/bi/1/" &#13;
xmlns="http://www.example.com/consumerfundbalances/retrievefundbalances/bi/1/" &#13;
xmlns:ns="http://www.example.com/location/consumerfundbalances/1/"&gt;&#13;
&lt;retrieveFundBalances&gt;&#13;
&lt;fundBalancesRequestIdentifier/&gt;&#13;
&lt;/retrieveFundBalances&gt;&#13;
&lt;/ns1:retrieveFundBalances&gt;</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-cxf.src.test.java.org.apache.camel.component.cxf.DefaultCxfBindingTest.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.component.rest.RestEndpoint.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.management.mbean.ManagedRestRegistry.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.model.rest.RestDefinition.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.api.management.mbean.CamelOpenMBeanTypes.java</file><file>gelog.camel-git.components.camel-cxf.src.main.java.org.apache.camel.component.cxf.DefaultCxfBinding.java</file><file>gelog.camel-git.camel-core.src.test.java.org.apache.camel.management.ManagedRestRegistryTest.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.impl.DefaultRestRegistry.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.spi.RestRegistry.java</file><file>gelog.camel-git.components.camel-cxf.src.main.java.org.apache.camel.component.cxf.CxfPayload.java</file></fixedFiles></bug><bug fixdate="2015-02-15 05:07:54" id="8303" opendate="2015-02-01 10:53:07"><buginformation><summary>[CAMEL-8303] InvalidPayloadException when storing a String using camel-couchdb - ASF JIRA</summary><description>According to the documentation, it should be possible to send through an Exchange with the body containing a String "If the body is an instance of String, then it will be marshalled into a GSON object before insert." When doing this, an InvalidPayloadException occurs. The culprit is this line in the CouchDbProducer: "return new Gson().toJsonTree(body)" According to the Gson documentation, this should not be executed on Generic types as the String will not be parsed, but stored in a JsonPrimitive as opposed to the expected JsonObject. In order to correct it, is to use the code which parses the String (Sorry, don't have time just now to do a proper patch): try { return new JsonParser().parse((String)body); } catch(JsonSyntaxException jse) { throw new InvalidPayloadException(exchange, body != null ? body.getClass() : null); } It's also worth mentioning that existing test cases does not result in this Exception and the original 2.14.1 code base as long as my local modified version both passes the tests.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-couchdb.src.main.java.org.apache.camel.component.couchdb.CouchDbProducer.java</file></fixedFiles></bug><bug fixdate="2015-02-02 09:07:55" id="8296" opendate="2015-01-29 01:20:39"><buginformation><summary>[CAMEL-8296] camel-box - OSGi troubles - NoClassDefFoundError: org.apache.commons.lang.NotImplementedException - ASF JIRA</summary><description>Download empty karaf 3.0.2 Install camel-blueprint and camel-box features Run sample box route and get this exception &#13;
java.lang.NoClassDefFoundError: org/apache/commons/lang/NotImplementedException&#13;
        at org.apache.camel.component.box.internal.BoxClientHelper.createBoxClient(BoxClientHelper.java:97)&#13;
        at org.apache.camel.component.box.BoxComponent.getBoxClient(BoxComponent.java:59)&#13;
        at org.apache.camel.component.box.BoxEndpoint.createBoxClient(BoxEndpoint.java:127)&#13;
        at org.apache.camel.component.box.BoxEndpoint.afterConfigureProperties(BoxEndpoint.java:102)&#13;
        at org.apache.camel.util.component.AbstractApiEndpoint.configureProperties(AbstractApiEndpoint.java:115)&#13;
        at org.apache.camel.util.component.AbstractApiComponent.createEndpoint(AbstractApiComponent.java:96)&#13;
        at org.apache.camel.impl.DefaultComponent.createEndpoint(DefaultComponent.java:122)&#13;
        at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:525)&#13;
        at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:71)&#13;
        at org.apache.camel.model.RouteDefinition.resolveEndpoint(RouteDefinition.java:202)&#13;
        at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:106)&#13;
        at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:112)&#13;
        at org.apache.camel.model.FromDefinition.resolveEndpoint(FromDefinition.java:72)&#13;
        at org.apache.camel.impl.DefaultRouteContext.getEndpoint(DefaultRouteContext.java:88)&#13;
        at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:923)&#13;
        at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:187)&#13;
        at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:794)&#13;
        at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:2184)&#13;
        at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1916)&#13;
        at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1777)&#13;
        at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)&#13;
        at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1745)&#13;
        at org.apache.camel.blueprint.BlueprintCamelContext.start(BlueprintCamelContext.java:177)&#13;
        at org.apache.camel.blueprint.BlueprintCamelContext.maybeStart(BlueprintCamelContext.java:209)&#13;
        at org.apache.camel.blueprint.BlueprintCamelContext.serviceChanged(BlueprintCamelContext.java:147)&#13;
        at org.apache.felix.framework.util.EventDispatcher.invokeServiceListenerCallback(EventDispatcher.java:932)&#13;
        at org.apache.felix.framework.util.EventDispatcher.fireEventImmediately(EventDispatcher.java:793)&#13;
        at org.apache.felix.framework.util.EventDispatcher.fireServiceEvent(EventDispatcher.java:543)&#13;
        at org.apache.felix.framework.Felix.fireServiceEvent(Felix.java:4419)&#13;
        at org.apache.felix.framework.Felix.registerService(Felix.java:3423)&#13;
        at org.apache.felix.framework.BundleContextImpl.registerService(BundleContextImpl.java:346)&#13;
        at org.apache.felix.framework.BundleContextImpl.registerService(BundleContextImpl.java:352)&#13;
        at org.apache.camel.blueprint.BlueprintCamelContext.init(BlueprintCamelContext.java:97)&#13;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&#13;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)&#13;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&#13;
        at java.lang.reflect.Method.invoke(Method.java:601)&#13;
        at org.apache.aries.blueprint.utils.ReflectionUtils.invoke(ReflectionUtils.java:297)&#13;
        at org.apache.aries.blueprint.container.BeanRecipe.invoke(BeanRecipe.java:958)&#13;
        at org.apache.aries.blueprint.container.BeanRecipe.runBeanProcInit(BeanRecipe.java:712)&#13;
        at org.apache.aries.blueprint.container.BeanRecipe.internalCreate2(BeanRecipe.java:824)&#13;
        at org.apache.aries.blueprint.container.BeanRecipe.internalCreate(BeanRecipe.java:787)&#13;
        at org.apache.aries.blueprint.di.AbstractRecipe$1.call(AbstractRecipe.java:79)&#13;
        at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)&#13;
        at java.util.concurrent.FutureTask.run(FutureTask.java:166)&#13;
        at org.apache.aries.blueprint.di.AbstractRecipe.create(AbstractRecipe.java:88)&#13;
        at org.apache.aries.blueprint.container.BlueprintRepository.createInstances(BlueprintRepository.java:245)&#13;
        at org.apache.aries.blueprint.container.BlueprintRepository.createAll(BlueprintRepository.java:183)&#13;
        at org.apache.aries.blueprint.container.BlueprintContainerImpl.instantiateEagerComponents(BlueprintContainerImpl&#13;
.java:681)&#13;
        at org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:378)&#13;
        at org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:269)&#13;
        at org.apache.aries.blueprint.container.BlueprintExtender.createContainer(BlueprintExtender.java:276)&#13;
        at org.apache.aries.blueprint.container.BlueprintExtender.createContainer(BlueprintExtender.java:245)&#13;
        at org.apache.aries.blueprint.container.BlueprintExtender.modifiedBundle(BlueprintExtender.java:235)&#13;
        at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.customizerModified(BundleHookBundleTracker&#13;
.java:500)&#13;
        at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.customizerModified(BundleHookBundleTracker&#13;
.java:433)&#13;
        at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$AbstractTracked.track(BundleHookBundleTracker.java&#13;
:725)&#13;
        at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.bundleChanged(BundleHookBundleTracker.java&#13;
:463)&#13;
        at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$BundleEventHook.event(BundleHookBundleTracker.java&#13;
:422)&#13;
        at org.apache.felix.framework.util.SecureAction.invokeBundleEventHook(SecureAction.java:1103)&#13;
        at org.apache.felix.framework.util.EventDispatcher.createWhitelistFromHooks(EventDispatcher.java:695)&#13;
        at org.apache.felix.framework.util.EventDispatcher.fireBundleEvent(EventDispatcher.java:483)&#13;
        at org.apache.felix.framework.Felix.fireBundleEvent(Felix.java:4403)&#13;
        at org.apache.felix.framework.Felix.startBundle(Felix.java:2092)&#13;
        at org.apache.felix.framework.BundleImpl.start(BundleImpl.java:955)&#13;
        at org.apache.felix.framework.BundleImpl.start(BundleImpl.java:942)&#13;
        at org.apache.karaf.bundle.command.Restart.doExecute(Restart.java:48)&#13;
        at org.apache.karaf.bundle.command.BundlesCommand.doExecute(BundlesCommand.java:50)&#13;
        at org.apache.karaf.bundle.command.BundlesCommandWithConfirmation.doExecute(BundlesCommandWithConfirmation.java:&#13;
41)&#13;
        at org.apache.karaf.shell.console.AbstractAction.execute(AbstractAction.java:33)&#13;
        at org.apache.karaf.shell.console.OsgiCommandSupport.execute(OsgiCommandSupport.java:39)&#13;
        at org.apache.karaf.shell.commands.basic.AbstractCommand.execute(AbstractCommand.java:33)&#13;
        at Proxydce7d8d9_a802_4295_bc90_9f32a888e927.execute(Unknown Source)&#13;
        at Proxydce7d8d9_a802_4295_bc90_9f32a888e927.execute(Unknown Source)&#13;
        at org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)&#13;
        at org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:477)&#13;
        at org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:403)&#13;
        at org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)&#13;
        at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)&#13;
        at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)&#13;
        at org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:92)&#13;
        at org.apache.karaf.shell.console.impl.jline.ConsoleImpl.run(ConsoleImpl.java:203)&#13;
        at org.apache.karaf.shell.console.impl.jline.LocalConsoleManager$2$1$1.run(LocalConsoleManager.java:115)&#13;
        at java.security.AccessController.doPrivileged(Native Method)&#13;
        at org.apache.karaf.jaas.modules.JaasHelper.doAs(JaasHelper.java:57)&#13;
        at org.apache.karaf.shell.console.impl.jline.LocalConsoleManager$2$1.run(LocalConsoleManager.java:108)&#13;
Caused by: java.lang.ClassNotFoundException: org.apache.commons.lang.NotImplementedException not found by wrap_mvn_net.b&#13;
ox_boxjavalibv2_3.0.9 [89]&#13;
        at org.apache.felix.framework.BundleWiringImpl.findClassOrResourceByDelegation(BundleWiringImpl.java:1532)&#13;
        at org.apache.felix.framework.BundleWiringImpl.access$400(BundleWiringImpl.java:75)&#13;
        at org.apache.felix.framework.BundleWiringImpl$BundleClassLoader.loadClass(BundleWiringImpl.java:1955)&#13;
        at java.lang.ClassLoader.loadClass(ClassLoader.java:356)&#13;
        ... 86 more&#13;
 Headers for box sdk show that it is missing two packages: &#13;
org.apache.commons.lang;resolution:=optional,&#13;
org.apache.commons.lang.builder;resolution:=optional,&#13;
 Headers for 84 | Active | 50 | 3.3.2 | Apache Commons Lang shows that it exports following packages: &#13;
Export-Package =&#13;
        org.apache.commons.lang3;version=3.3.2,&#13;
        org.apache.commons.lang3.builder;version=3.3.2,&#13;
        org.apache.commons.lang3.concurrent;version=3.3.2,&#13;
        org.apache.commons.lang3.event;version=3.3.2,&#13;
        org.apache.commons.lang3.exception;version=3.3.2,&#13;
        org.apache.commons.lang3.math;version=3.3.2,&#13;
        org.apache.commons.lang3.mutable;version=3.3.2,&#13;
        org.apache.commons.lang3.reflect;version=3.3.2,&#13;
        org.apache.commons.lang3.text;version=3.3.2,&#13;
        org.apache.commons.lang3.text.translate;version=3.3.2,&#13;
        org.apache.commons.lang3.time;version=3.3.2,&#13;
        org.apache.commons.lang3.tuple;version=3.3.2</description></buginformation><fixedFiles><file>gelog.camel-git.camel-core.src.test.java.org.apache.camel.converter.IOConverterCharsetTest.java</file><file>gelog.camel-git.camel-core.src.main.java.org.apache.camel.converter.IOConverter.java</file></fixedFiles></bug><bug fixdate="2015-01-29 12:33:08" id="8295" opendate="2015-01-29 11:31:01"><buginformation><summary>[CAMEL-8295] Change Camel Context Name on Camel Spring Boot - ASF JIRA</summary><description>Cant change the Camel Context Name fully, if the RouteBuilder ran already. This Code is not working for the JMX MBeans MyAppConfig.java &#13;
@Configuration&#13;
public class MyAppConfig {&#13;
 &#13;
  ...&#13;
 &#13;
  @Bean&#13;
  CamelContextConfiguration contextConfiguration() {&#13;
    return new CamelContextConfiguration() {&#13;
      @Override&#13;
      public void beforeApplicationStart(CamelContext context) {&#13;
        ((SpringCamelContext)context).setName("foo");&#13;
      }&#13;
    };&#13;
  }&#13;
}&#13;
 The JMX MBeans are not updated after the RouteBuilde ran: The Context Name Changed, but the JMX Object Name not. "foo" != "camel-1"</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-spring-boot.src.test.java.org.apache.camel.spring.boot.CamelAutoConfigurationTest.java</file><file>gelog.camel-git.components.camel-spring-boot.src.main.java.org.apache.camel.spring.boot.CamelConfigurationProperties.java</file><file>gelog.camel-git.components.camel-spring-boot.src.main.java.org.apache.camel.spring.boot.CamelAutoConfiguration.java</file></fixedFiles></bug><bug fixdate="2015-02-12 06:26:33" id="8274" opendate="2015-01-23 05:41:50"><buginformation><summary>[CAMEL-8274] camel-hbase - The maxResults option has no effect on the number of results - ASF JIRA</summary><description>The max result option defined on the endpoint does not stop the hbase scanner. To be more convenient, the max result should also be dynamicaly passed as a header (for example with a "CamelHBaseMaxScanResults" header).</description></buginformation><fixedFiles><file>a.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.model.HBaseRow.java</file><file>a.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.model.HBaseCell.java</file><file>a.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.mapping.HeaderMappingStrategy.java</file><file>a.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.HBaseConstants.java</file><file>a.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.HBaseProducer.java</file></fixedFiles></bug><bug fixdate="2015-02-06 11:34:36" id="8272" opendate="2015-01-23 11:47:30"><buginformation><summary>[CAMEL-8272] Camel-box socks proxy implementation is incomplete - ASF JIRA</summary><description>org.apache.camel.component.box.internal.LoginAuthFlowUI looks for http.route.socks-proxy and sets up a socks proxy for the webClient org.apache.camel.component.box.internal.BoxClientHelper just passes the httpParams on to the underlying HttpClient but the box api uses a vanilla DefaultHttpClient which doesn't talk SOCKS. The attached patch adds socks proxy support to the main restful box transactions.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-box.src.main.java.org.apache.camel.component.box.BoxConverter.java</file><file>gelog.camel-git.components.camel-box.src.main.java.org.apache.camel.component.box.internal.BoxClientHelper.java</file></fixedFiles></bug><bug fixdate="2015-02-12 06:24:51" id="8268" opendate="2015-01-23 07:35:25"><buginformation><summary>[CAMEL-8268] camel-hbase - The scan method is not thread safe when using a filter list - ASF JIRA</summary><description>The scan method is not thread safe when using a filter list. A concurrent call on the endpoint will produce wrong values because the same FilterList is used between threads. Cloning the passed filter list solve the problem.</description></buginformation><fixedFiles><file>gelog.camel-git.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.HBaseConstants.java</file><file>gelog.camel-git.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.HBaseEndpoint.java</file><file>gelog.camel-git.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.filters.ModelAwareRowPrefixMatchingFilter.java</file><file>a.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.HBaseProducer.java</file><file>a.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.model.HBaseRow.java</file><file>gelog.camel-git.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.HBaseProducer.java</file><file>gelog.camel-git.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.model.HBaseCell.java</file><file>a.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.model.HBaseCell.java</file><file>gelog.camel-git.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.model.HBaseRow.java</file><file>gelog.camel-git.components.camel-hbase.src.test.java.org.apache.camel.component.hbase.HBaseProducerTest.java</file><file>a.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.mapping.HeaderMappingStrategy.java</file><file>a.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.HBaseConstants.java</file><file>gelog.camel-git.components.camel-hbase.src.main.java.org.apache.camel.component.hbase.mapping.HeaderMappingStrategy.java</file></fixedFiles></bug></bugrepository>