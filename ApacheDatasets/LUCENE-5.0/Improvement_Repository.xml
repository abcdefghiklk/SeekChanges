<?xml version="1.0" encoding="UTF-8" standalone="no"?><bugrepository><bug fixdate="2015-02-01 09:50:54" id="6212" opendate="2015-01-30 02:16:16"><buginformation><summary>[LUCENE-6212] Remove IndexWriter's per-document analyzer add/updateDocument APIs - ASF JIRA</summary><description>IndexWriter already takes an analyzer up-front (via IndexWriterConfig), but it also allows you to specify a different one for each add/updateDocument. I think this is quite dangerous/trappy since it means you can easily index tokens for that document that don't match at search-time based on the search-time analyzer. I think we should remove this trap in 5.0.</description></buginformation><fixedFiles><file>lucene.analysis.uima.src.test.org.apache.lucene.analysis.uima.UIMABaseAnalyzerTest.java</file><file>lucene.classification.src.test.org.apache.lucene.classification.ClassificationTestBase.java</file><file>solr.core.src.java.org.apache.solr.update.DefaultSolrCoreState.java</file><file>lucene.classification.src.test.org.apache.lucene.classification.utils.DocToDoubleVectorUtilsTest.java</file><file>solr.core.src.test.org.apache.solr.core.TestInfoStreamLogging.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestPayloads.java</file><file>solr.core.src.java.org.apache.solr.update.DirectUpdateHandler2.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexWriterExceptions.java</file><file>lucene.core.src.java.org.apache.lucene.index.TrackingIndexWriter.java</file><file>solr.core.src.java.org.apache.solr.update.SolrIndexConfig.java</file><file>lucene.classification.src.test.org.apache.lucene.classification.utils.DataSplitterTest.java</file><file>solr.core.src.test.org.apache.solr.core.TestConfig.java</file><file>solr.core.src.test.org.apache.solr.update.SolrIndexConfigTest.java</file><file>solr.core.src.java.org.apache.solr.core.SolrCore.java</file><file>solr.core.src.test.org.apache.solr.core.TestSolrIndexConfig.java</file><file>lucene.highlighter.src.test.org.apache.lucene.search.highlight.HighlighterTest.java</file><file>lucene.core.src.java.org.apache.lucene.index.IndexWriter.java</file><file>solr.core.src.java.org.apache.solr.update.SolrIndexWriter.java</file><file>solr.core.src.java.org.apache.solr.update.SolrIndexSplitter.java</file><file>lucene.core.src.test.org.apache.lucene.analysis.TestMockAnalyzer.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestControlledRealTimeReopenThread.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.RandomIndexWriter.java</file><file>lucene.misc.src.java.org.apache.lucene.index.SortingMergePolicy.java</file><file>solr.core.src.test.org.apache.solr.core.TestMergePolicyConfig.java</file></fixedFiles></bug><bug fixdate="2015-01-15 07:22:19" id="6185" opendate="2015-01-15 06:10:04"><buginformation><summary>[LUCENE-6185] Fix IndexSearcher with threads to not collect documents out of order - ASF JIRA</summary><description>When created with an executor, IndexSearcher searches all leaves in a different task and eventually merges the results when all tasks are completed. However, this merging logic involves a TopFieldCollector which is collected out-of-order. I think it should just use TopDocs.merge?</description></buginformation><fixedFiles><file>lucene.test-framework.src.java.org.apache.lucene.search.AssertingIndexSearcher.java</file><file>lucene.core.src.java.org.apache.lucene.search.IndexSearcher.java</file><file>lucene.test-framework.src.java.org.apache.lucene.search.AssertingLeafCollector.java</file><file>lucene.test-framework.src.java.org.apache.lucene.search.AssertingCollector.java</file></fixedFiles></bug><bug fixdate="2015-01-15 10:24:21" id="6179" opendate="2015-01-13 03:16:19"><buginformation><summary>[LUCENE-6179] Remove out-of-order scoring - ASF JIRA</summary><description>Out-of-order currently adds complexity that I would like to remove. Here is a selection of issues that come from out-of-order scoring. lots of specializations with collectors: we have two versions of every top score/field collector depending on whether it should support out-of-order collection or not it feels like it should be an implementation detail of our bulk scorers but it also makes our APIs more complicated, eg. LeafCollector.acceptsDocsOutOfOrder if you create a TopFieldCollector, how do you know if you should pass docsScoredInOrder=true or false? To make the decision, you actually need to know whether your query supports out-of-order scoring while the API is on Weight. I initially wanted to keep it and improve the decision process in LUCENE-6172 but I'm not sure it's the right approach as it would require to make the API even more complicated... hence the suggestion to remove out-of-order scoring completely.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.search.MultiCollector.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.AnalyzingInfixSuggester.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestBooleanScorer.java</file><file>lucene.join.src.test.org.apache.lucene.search.join.TestBlockJoin.java</file><file>solr.core.src.java.org.apache.solr.search.ExportQParserPlugin.java</file><file>lucene.test-framework.src.java.org.apache.lucene.search.BooleanQuery2.java</file><file>solr.core.src.java.org.apache.solr.search.CollapsingQParserPlugin.java</file><file>solr.core.src.java.org.apache.solr.search.DocSetCollector.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToParentBlockJoinQuery.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestTermScorer.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestPositiveScoresOnlyCollector.java</file><file>lucene.facet.src.test.org.apache.lucene.facet.TestDrillSideways.java</file><file>lucene.grouping.src.java.org.apache.lucene.search.grouping.AbstractAllGroupHeadsCollector.java</file><file>lucene.test-framework.src.java.org.apache.lucene.search.AssertingWeight.java</file><file>solr.core.src.java.org.apache.solr.search.Grouping.java</file><file>lucene.core.src.java.org.apache.lucene.search.FilterLeafCollector.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestBooleanQueryVisitSubscorers.java</file><file>solr.core.src.java.org.apache.solr.search.grouping.distributed.command.QueryCommand.java</file><file>lucene.core.src.java.org.apache.lucene.search.BooleanScorer.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestBoolean2.java</file><file>lucene.highlighter.src.test.org.apache.lucene.search.highlight.HighlighterPhraseTest.java</file><file>lucene.benchmark.src.java.org.apache.lucene.benchmark.byTask.tasks.SearchWithCollectorTask.java</file><file>lucene.test-framework.src.java.org.apache.lucene.search.AssertingBulkScorer.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestBooleanUnevenly.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestTimeLimitingCollector.java</file><file>lucene.core.src.java.org.apache.lucene.search.CachingCollector.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestSloppyPhraseQuery.java</file><file>lucene.core.src.java.org.apache.lucene.search.IndexSearcher.java</file><file>lucene.benchmark.src.java.org.apache.lucene.benchmark.byTask.tasks.ReadTask.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestTopDocsCollector.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestDocBoost.java</file><file>lucene.join.src.test.org.apache.lucene.search.join.TestJoinUtil.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestOmitTf.java</file><file>lucene.grouping.src.java.org.apache.lucene.search.grouping.AbstractDistinctValuesCollector.java</file><file>lucene.test-framework.src.java.org.apache.lucene.search.CheckHits.java</file><file>solr.core.src.java.org.apache.solr.search.ReRankQParserPlugin.java</file><file>lucene.sandbox.src.test.org.apache.lucene.search.TestTermAutomatonQuery.java</file><file>lucene.test-framework.src.java.org.apache.lucene.search.AssertingBulkOutOfOrderScorer.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestTopScoreDocCollector.java</file><file>solr.core.src.java.org.apache.solr.search.EarlyTerminatingCollector.java</file><file>lucene.core.src.java.org.apache.lucene.search.Weight.java</file><file>lucene.test-framework.src.java.org.apache.lucene.search.AssertingLeafCollector.java</file><file>lucene.core.src.java.org.apache.lucene.search.TopFieldCollector.java</file><file>solr.core.src.java.org.apache.solr.handler.component.ExpandComponent.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestBooleanOr.java</file><file>lucene.test-framework.src.java.org.apache.lucene.search.RandomOrderCollector.java</file><file>solr.core.src.test.org.apache.solr.search.TestSort.java</file><file>lucene.core.src.java.org.apache.lucene.search.TopScoreDocCollector.java</file><file>lucene.grouping.src.java.org.apache.lucene.search.grouping.AbstractAllGroupsCollector.java</file><file>lucene.facet.src.java.org.apache.lucene.facet.DrillSidewaysQuery.java</file><file>lucene.core.src.java.org.apache.lucene.search.LeafCollector.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToChildBlockJoinQuery.java</file><file>lucene.queryparser.src.test.org.apache.lucene.queryparser.surround.query.BooleanQueryTst.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestSubScorerFreqs.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestEarlyTermination.java</file><file>lucene.core.src.java.org.apache.lucene.search.TotalHitCountCollector.java</file><file>lucene.grouping.src.java.org.apache.lucene.search.grouping.AbstractFirstPassGroupingCollector.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestBooleanCoord.java</file><file>solr.core.src.test.org.apache.solr.search.TestRankQueryPlugin.java</file><file>lucene.core.src.java.org.apache.lucene.search.SimpleCollector.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestMultiTermConstantScore.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestBooleanMinShouldMatch.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToParentBlockJoinIndexSearcher.java</file><file>solr.core.src.java.org.apache.solr.search.DelegatingCollector.java</file><file>lucene.core.src.test.org.apache.lucene.search.JustCompileSearch.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestTopFieldCollector.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.TermsIncludingScoreQuery.java</file><file>lucene.facet.src.test.org.apache.lucene.facet.AssertingSubDocsAtOnceCollector.java</file><file>lucene.facet.src.java.org.apache.lucene.facet.FacetsCollector.java</file><file>lucene.queries.src.java.org.apache.lucene.queries.CustomScoreQuery.java</file><file>solr.contrib.analytics.src.java.org.apache.solr.analytics.accumulator.ValueAccumulator.java</file><file>lucene.core.src.test.org.apache.lucene.search.MultiCollectorTest.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestSimilarity.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestCachingCollector.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToParentBlockJoinCollector.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestTopDocsMerge.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestDisjunctionMaxQuery.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestElevationComparator.java</file><file>lucene.grouping.src.java.org.apache.lucene.search.grouping.BlockGroupingCollector.java</file><file>lucene.test-framework.src.java.org.apache.lucene.search.AssertingCollector.java</file><file>lucene.test-framework.src.java.org.apache.lucene.search.QueryUtils.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestScoreCachingWrappingScorer.java</file><file>lucene.misc.src.test.org.apache.lucene.search.TestEarlyTerminatingSortingCollector.java</file><file>lucene.misc.src.java.org.apache.lucene.search.EarlyTerminatingSortingCollector.java</file><file>lucene.facet.src.java.org.apache.lucene.facet.DrillSideways.java</file><file>lucene.memory.src.java.org.apache.lucene.index.memory.MemoryIndex.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestScorerPerf.java</file><file>lucene.core.src.java.org.apache.lucene.search.SortRescorer.java</file><file>lucene.core.src.java.org.apache.lucene.search.ConstantScoreQuery.java</file><file>lucene.core.src.java.org.apache.lucene.search.FilteredQuery.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestBooleanQuery.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.TermsCollector.java</file><file>solr.core.src.java.org.apache.solr.search.SolrIndexSearcher.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestConstantScoreQuery.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.TermsWithScoreCollector.java</file><file>lucene.core.src.java.org.apache.lucene.search.BooleanQuery.java</file></fixedFiles></bug><bug fixdate="2015-01-12 11:10:07" id="6178" opendate="2015-01-12 08:37:01"><buginformation><summary>[LUCENE-6178] don't score MUST_NOT clauses with BooleanScorer - ASF JIRA</summary><description>Its similar to the conjunction case: we should just use BS2 since it has advance(). Even in the dense case I think its currently better since it avoids calling score() in cases where BS1 calls it redundantly.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.search.BooleanQuery.java</file></fixedFiles></bug><bug fixdate="2015-01-05 03:53:23" id="6160" opendate="2015-01-03 11:41:51"><buginformation><summary>[LUCENE-6160] Add whitespace to temp test folder names - ASF JIRA</summary><description>Currently we rely too much on the fact that Uwe Schindler likes to run lucene tests with c:\Users\Uwe Schindler\... to find bugs. Instead we should just turn one of the dashes into a space so problems fail everywhere i think?</description></buginformation><fixedFiles><file>lucene.test-framework.src.java.org.apache.lucene.util.TestRuleTemporaryFilesCleanup.java</file></fixedFiles></bug><bug fixdate="2015-01-05 09:12:37" id="6157" opendate="2015-01-02 07:39:21"><buginformation><summary>[LUCENE-6157] Add the ability to compute fine-grained statistics on the filter cache - ASF JIRA</summary><description>The filter cache exposes some useful statistics about its usage, eg. hit count, eviction count, etc. In some cases it could be useful to give users the ability to compute finer-grained statistics though, for example by breaking up statistics by segment, index or by type of filter.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.search.LRUFilterCache.java</file><file>lucene.core.src.java.org.apache.lucene.search.FilterCachingPolicy.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestLRUFilterCache.java</file><file>lucene.core.src.java.org.apache.lucene.search.FilterCache.java</file></fixedFiles></bug><bug fixdate="2015-01-07 07:54:20" id="6149" opendate="2014-12-31 12:02:11"><buginformation><summary>[LUCENE-6149] Infix suggesters' highlighting, allTermsRequired options are hardwired and not configurable for non-contextual lookup - ASF JIRA</summary><description>Highlighting and allTermsRequired are hardwired in AnalyzingInfixSuggester for non-contextual lookup (via Lookup) see true, true below: AnalyzingInfixSuggester.java (extends Lookup.java) &#13;
public List&lt;LookupResult&gt; lookup(CharSequence key, Set&lt;BytesRef&gt; contexts, boolean onlyMorePopular, int num) throws IOException {&#13;
    return lookup(key, contexts, num, true, true);&#13;
}&#13;
&#13;
/** Lookup, without any context. */&#13;
public List&lt;LookupResult&gt; lookup(CharSequence key, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {&#13;
    return lookup(key, null, num, allTermsRequired, doHighlight);&#13;
  }&#13;
 Lookup.java &#13;
public List&lt;LookupResult&gt; lookup(CharSequence key, boolean onlyMorePopular, int num) throws IOException {&#13;
    return lookup(key, null, onlyMorePopular, num);&#13;
}&#13;
 The above means the majority of the current infix suggester lookup always return highlighted results with allTermsRequired in effect. There is no way to change this despite the options and improvement of LUCENE-6050, made to incorporate Boolean lookup clauses (MUST/SHOULD). This shortcoming has also been reported in SOLR-6648. The suggesters (AnalyzingInfixSuggester, BlendedInfixSuggester) should provide a proper mechanism to set defaults for highlighting and "allTermsRequired", e.g. in constructors (and in Solr factories, thus configurable via solrconfig.xml).</description></buginformation><fixedFiles><file>a.lucene.suggest.src.test.org.apache.lucene.search.suggest.analyzing.AnalyzingInfixSuggesterTest.java</file><file>a.lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.AnalyzingInfixSuggester.java</file><file>a.lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.BlendedInfixSuggester.java</file></fixedFiles></bug><bug fixdate="2015-01-02 07:44:00" id="6148" opendate="2014-12-31 10:20:13"><buginformation><summary>[LUCENE-6148] Accountable.getChildResources should return a Collection - ASF JIRA</summary><description>Since the child resources must be a snapshot, their size has to be known anyway so returning a collection instead of an iterable would make consumption easier without introducing limitations.</description></buginformation><fixedFiles><file>lucene.codecs.src.java.org.apache.lucene.codecs.blocktreeords.OrdsFieldReader.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.BaseBitSetTestCase.java</file><file>lucene.core.src.java.org.apache.lucene.util.Accountables.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.blocktree.FieldReader.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.AnalyzingInfixSuggester.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.MemoryDocValuesProducer.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingPostingsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.index.SegmentReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blockterms.BlockTermsReader.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingNormsFormat.java</file><file>solr.core.src.java.org.apache.solr.spelling.suggest.SolrSuggester.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blocktreeords.OrdsBlockTreeTermsReader.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingTermVectorsFormat.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.TestUtil.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingTermVectorsReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.simpletext.SimpleTextNormsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.util.Accountable.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.ramonly.RAMOnlyPostingsFormat.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.bloom.BloomFilteringPostingsFormat.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.MemoryPostingsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.util.fst.FST.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.simpletext.SimpleTextFieldsReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blockterms.VariableGapTermsIndexReader.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingStoredFieldsIndexReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.DirectDocValuesProducer.java</file><file>solr.core.src.java.org.apache.solr.handler.component.SuggestComponent.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.BitDocIdSetCachingWrapperFilter.java</file><file>lucene.sandbox.src.java.org.apache.lucene.codecs.idversion.VersionFieldReader.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.FreeTextSuggester.java</file><file>lucene.core.src.java.org.apache.lucene.index.SegmentDocValuesProducer.java</file><file>lucene.core.src.java.org.apache.lucene.search.CachingWrapperFilter.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.FSTOrdTermsReader.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.blocktree.BlockTreeTermsReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.DirectPostingsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.perfield.PerFieldDocValuesFormat.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingStoredFieldsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.store.NRTCachingDirectory.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingDocValuesFormat.java</file><file>lucene.core.src.java.org.apache.lucene.search.LRUFilterCache.java</file><file>lucene.core.src.java.org.apache.lucene.store.RAMDirectory.java</file><file>lucene.sandbox.src.java.org.apache.lucene.codecs.idversion.VersionBlockTreeTermsReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blockterms.FixedGapTermsIndexReader.java</file><file>lucene.misc.src.java.org.apache.lucene.uninverting.FieldCacheImpl.java</file><file>lucene.core.src.java.org.apache.lucene.index.MultiDocValues.java</file><file>lucene.facet.src.java.org.apache.lucene.facet.taxonomy.CachedOrdinalsReader.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.perfield.PerFieldPostingsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.search.FilteredDocIdSet.java</file><file>lucene.core.src.java.org.apache.lucene.store.RAMOutputStream.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.AnalyzingSuggester.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.FSTTermsReader.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50DocValuesProducer.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingStoredFieldsReader.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.fst.FSTCompletionLookup.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.fst.WFSTCompletionLookup.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50NormsProducer.java</file></fixedFiles></bug><bug fixdate="2014-12-30 05:48:44" id="6145" opendate="2014-12-30 04:30:22"><buginformation><summary>[LUCENE-6145] Make EarlyTerminatingSortingCollector smarter about when it can early terminate - ASF JIRA</summary><description>Today EarlyTerminatingSortingCollector only early-terminates if the sort order matches exactly the index-time sort order. It should also early-terminate when the sort order is a prefix of the index-time sort order.</description></buginformation><fixedFiles><file>lucene.misc.src.test.org.apache.lucene.search.TestEarlyTerminatingSortingCollector.java</file><file>lucene.misc.src.java.org.apache.lucene.search.EarlyTerminatingSortingCollector.java</file><file>lucene.misc.src.test.org.apache.lucene.index.TestSortingMergePolicy.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.AnalyzingInfixSuggester.java</file><file>lucene.misc.src.java.org.apache.lucene.index.SortingMergePolicy.java</file></fixedFiles></bug><bug fixdate="2014-12-29 01:45:09" id="6142" opendate="2014-12-29 09:52:17"><buginformation><summary>[LUCENE-6142] Faster merging with Lucene41StoredFieldsFormat - ASF JIRA</summary><description>This format is slow at merging with foreign codecs so we could implement getMergeInstance on it too (like on LUCENE-6115) to make the upgrade to the 5.0 codec easier.</description></buginformation><fixedFiles><file>lucene.backward-codecs.src.test.org.apache.lucene.codecs.lucene41.TestLucene41StoredFieldsFormat.java</file><file>lucene.backward-codecs.src.java.org.apache.lucene.codecs.lucene41.Lucene41StoredFieldsReader.java</file></fixedFiles></bug><bug fixdate="2014-12-24 09:25:38" id="6129" opendate="2014-12-22 03:02:35"><buginformation><summary>[LUCENE-6129] Assert that terms enums, docs enums and doc values are not leaked across threads - ASF JIRA</summary><description>Terms enums, docs enums and doc values should only be consumed in the thread that they have been acquired in. We could add checks to Asserting* to make sure they never leak?</description></buginformation><fixedFiles><file>lucene.test-framework.src.java.org.apache.lucene.index.AssertingLeafReader.java</file></fixedFiles></bug><bug fixdate="2015-01-05 03:00:49" id="6119" opendate="2014-12-17 11:05:40"><buginformation><summary>[LUCENE-6119] Add auto-io-throttle to ConcurrentMergeScheduler - ASF JIRA</summary><description>This method returns number of "incoming" bytes IW has written since it was opened, excluding merging. It tracks flushed segments, new commits (segments_N), incoming files/segments by addIndexes, newly written live docs / doc values updates files. It's an easy statistic for IW to track and should be useful to help applications more intelligently set defaults for IO throttling (RateLimiter). For example, an application that does hardly any indexing but finally triggered a large merge can afford to heavily throttle that large merge so it won't interfere with ongoing searches. But an application that's causing IW to write new bytes at 50 MB/sec must set a correspondingly higher IO throttling otherwise merges will clearly fall behind.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.util.PrintStreamInfoStream.java</file><file>lucene.test-framework.src.java.org.apache.lucene.store.MockDirectoryWrapper.java</file><file>lucene.core.src.java.org.apache.lucene.index.MergePolicy.java</file><file>lucene.core.src.java.org.apache.lucene.index.MergeRateLimiter.java</file><file>lucene.core.src.test.org.apache.lucene.store.TestAdaptiveRateLimitedDirectoryWrapper.java</file><file>lucene.core.src.java.org.apache.lucene.store.AdaptiveRateLimitedDirectoryWrapper.java</file><file>lucene.core.src.java.org.apache.lucene.index.MergeScheduler.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexWriterNewBytesWritten.java</file><file>solr.test-framework.src.java.org.apache.solr.core.MockFSDirectoryFactory.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.simpletext.SimpleTextCompoundFormat.java</file><file>lucene.core.src.test.org.apache.lucene.store.TestRateLimitedDirectoryWrapper.java</file><file>solr.core.src.java.org.apache.solr.core.CachingDirectoryFactory.java</file><file>solr.core.src.test.org.apache.solr.BasicFunctionalityTest.java</file><file>lucene.core.src.java.org.apache.lucene.store.RecordBytesWrittenIndexOutput.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexWriterExceptions.java</file><file>lucene.core.src.java.org.apache.lucene.index.DocumentsWriter.java</file><file>solr.test-framework.src.java.org.apache.solr.core.MockDirectoryFactory.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.CompoundFormat.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50CompoundFormat.java</file><file>lucene.core.src.java.org.apache.lucene.index.MappingMultiDocsEnum.java</file><file>lucene.core.src.java.org.apache.lucene.store.RateLimitedIndexOutput.java</file><file>lucene.core.src.java.org.apache.lucene.index.MappingMultiDocsAndPositionsEnum.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.StoredFieldsWriter.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestConcurrentMergeScheduler.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.cranky.CrankyCompoundFormat.java</file><file>solr.core.src.java.org.apache.solr.core.StandardDirectoryFactory.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingStoredFieldsWriter.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.BaseCompoundFormatTestCase.java</file><file>lucene.core.src.java.org.apache.lucene.index.MergeState.java</file><file>lucene.sandbox.src.test.org.apache.lucene.codecs.idversion.TestIDVersionPostingsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.index.DocumentsWriterFlushQueue.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingTermVectorsWriter.java</file><file>lucene.core.src.java.org.apache.lucene.index.SegmentMerger.java</file><file>lucene.core.src.java.org.apache.lucene.index.BufferedUpdatesStream.java</file><file>lucene.core.src.java.org.apache.lucene.store.RateLimitedDirectoryWrapper.java</file><file>lucene.core.src.java.org.apache.lucene.index.NoMergeScheduler.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.TermVectorsWriter.java</file><file>lucene.core.src.java.org.apache.lucene.store.FilterDirectory.java</file><file>lucene.core.src.java.org.apache.lucene.index.TieredMergePolicy.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestDoc.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestSegmentMerger.java</file><file>lucene.core.src.java.org.apache.lucene.index.ConcurrentMergeScheduler.java</file><file>lucene.core.src.java.org.apache.lucene.util.StringHelper.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexFileDeleter.java</file><file>lucene.core.src.java.org.apache.lucene.index.ReadersAndUpdates.java</file><file>lucene.core.src.java.org.apache.lucene.index.IndexWriter.java</file><file>lucene.core.src.test.org.apache.lucene.TestMergeSchedulerExternal.java</file><file>lucene.core.src.java.org.apache.lucene.store.RateLimiter.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexWriter.java</file><file>lucene.core.src.java.org.apache.lucene.index.DocumentsWriterPerThread.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.SuppressingConcurrentMergeScheduler.java</file><file>lucene.core.src.java.org.apache.lucene.index.CoalescedUpdates.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.LuceneTestCase.java</file></fixedFiles></bug><bug fixdate="2014-12-19 11:27:15" id="6118" opendate="2014-12-17 10:53:05"><buginformation><summary>[LUCENE-6118] Improve efficiency of the history structure for filter caching - ASF JIRA</summary><description>The filter caching uses a ring buffer that tracks frequencies of the hashcodes of the most-recently used filters. However it is based on an ArrayDeque&lt;Integer&gt; and a HashMap&lt;Integer&gt; which keep on (un)wrapping ints. Since the data-structure is very simple, we could try to do something better...</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.search.UsageTrackingFilterCachingPolicy.java</file><file>lucene.core.src.test.org.apache.lucene.util.TestFrequencyTrackingRingBuffer.java</file><file>lucene.core.src.java.org.apache.lucene.util.FrequencyTrackingRingBuffer.java</file></fixedFiles></bug><bug fixdate="2014-12-16 06:47:59" id="6116" opendate="2014-12-16 05:06:41"><buginformation><summary>[LUCENE-6116] Simplify RoaringDocIdSet.Iterator constructor - ASF JIRA</summary><description>The constructor duplicates the logic from firstDocFromNextBlock whichs looks for the next block that contains at least one document.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.util.RoaringDocIdSet.java</file></fixedFiles></bug><bug fixdate="2014-12-18 09:32:09" id="6115" opendate="2014-12-16 10:35:57"><buginformation><summary>[LUCENE-6115] Add getMergeInstance to CompressingStoredFieldsReader - ASF JIRA</summary><description>CompressingStoredFieldsReader is currently terrible at merging with different codecs or wrapped readers since it does not keep state. So if you want to get 5 documents that come from the same block, it means that you will have to decode the block header and decompress 5 times. It has some optimizations so that if you want to get the 2nd doc of the block then it will stop decompressing soon after the 2nd document, but it doesn't help much with merging since we want all documents. We should implement getMergeInstance and have a different behaviour when merging by decompressing everything up-front and then reusing for all documents of the block.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingStoredFieldsReader.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.compressing.CompressingCodec.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.BaseStoredFieldsFormatTestCase.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingStoredFieldsWriter.java</file></fixedFiles></bug><bug fixdate="2014-12-16 03:02:33" id="6107" opendate="2014-12-11 05:18:38"><buginformation><summary>[LUCENE-6107] Add statistics to LRUFilterCache - ASF JIRA</summary><description>It would be useful to have statistics about the usage of the filter cache to figure out whether the cache is useful at all and to help tune filter caching policies.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.search.LRUFilterCache.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestLRUFilterCache.java</file></fixedFiles></bug><bug fixdate="2014-12-15 11:06:31" id="6106" opendate="2014-12-11 03:42:54"><buginformation><summary>[LUCENE-6106] Improve FilterCachingPolicy statistics computation - ASF JIRA</summary><description>Currently FilterCachingPolicy.onCache is supposed to be called every time that FilterCache.onCache is used. However, this does not necessarily reflect how much a filter is used. For instance you can call cache and not use the filter, or call cache once and then use it a hundred times. It would be more useful to know how many times a filter has been used on a top level reader, and I think we can do this by doing something like below in the caching wrapper filter? &#13;
@Override&#13;
    public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {&#13;
      if (context.ord == 0) {&#13;
        // increment counter&#13;
      }&#13;
    }</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.search.LRUFilterCache.java</file><file>lucene.core.src.java.org.apache.lucene.search.FilterCachingPolicy.java</file><file>lucene.core.src.java.org.apache.lucene.search.UsageTrackingFilterCachingPolicy.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestLRUFilterCache.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.LuceneTestCase.java</file></fixedFiles></bug><bug fixdate="2014-12-15 06:39:49" id="6104" opendate="2014-12-10 09:34:53"><buginformation><summary>[LUCENE-6104] simplify internals of Lucene50NormsProducer - ASF JIRA</summary><description>This is tracking additional data structures, and has a lot of complexity, when we could just refactor the internal structure to be a bit cleaner. as a bonus, its less memory overhead, but a more thorough memory tree: it works like the docvalues one now.</description></buginformation><fixedFiles><file>lucene.codecs.src.java.org.apache.lucene.codecs.blocktreeords.OrdsFieldReader.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.BaseBitSetTestCase.java</file><file>lucene.core.src.java.org.apache.lucene.util.Accountables.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.blocktree.FieldReader.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.AnalyzingInfixSuggester.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.MemoryDocValuesProducer.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingPostingsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.index.SegmentReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blockterms.BlockTermsReader.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingNormsFormat.java</file><file>solr.core.src.java.org.apache.solr.spelling.suggest.SolrSuggester.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blocktreeords.OrdsBlockTreeTermsReader.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingTermVectorsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingTermVectorsReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.simpletext.SimpleTextNormsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.util.Accountable.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.ramonly.RAMOnlyPostingsFormat.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.bloom.BloomFilteringPostingsFormat.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.MemoryPostingsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.util.fst.FST.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.simpletext.SimpleTextFieldsReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blockterms.VariableGapTermsIndexReader.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingStoredFieldsIndexReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.DirectDocValuesProducer.java</file><file>solr.core.src.java.org.apache.solr.handler.component.SuggestComponent.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.BitDocIdSetCachingWrapperFilter.java</file><file>lucene.sandbox.src.java.org.apache.lucene.codecs.idversion.VersionFieldReader.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.FreeTextSuggester.java</file><file>lucene.core.src.java.org.apache.lucene.index.SegmentDocValuesProducer.java</file><file>lucene.core.src.java.org.apache.lucene.search.CachingWrapperFilter.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.FSTOrdTermsReader.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.blocktree.BlockTreeTermsReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.DirectPostingsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.perfield.PerFieldDocValuesFormat.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingStoredFieldsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.store.NRTCachingDirectory.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingDocValuesFormat.java</file><file>lucene.core.src.java.org.apache.lucene.search.LRUFilterCache.java</file><file>lucene.core.src.java.org.apache.lucene.store.RAMDirectory.java</file><file>lucene.sandbox.src.java.org.apache.lucene.codecs.idversion.VersionBlockTreeTermsReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blockterms.FixedGapTermsIndexReader.java</file><file>lucene.misc.src.java.org.apache.lucene.uninverting.FieldCacheImpl.java</file><file>lucene.core.src.java.org.apache.lucene.index.MultiDocValues.java</file><file>lucene.facet.src.java.org.apache.lucene.facet.taxonomy.CachedOrdinalsReader.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.perfield.PerFieldPostingsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.search.FilteredDocIdSet.java</file><file>lucene.core.src.java.org.apache.lucene.store.RAMOutputStream.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.AnalyzingSuggester.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.FSTTermsReader.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50DocValuesProducer.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingStoredFieldsReader.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.fst.FSTCompletionLookup.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.fst.WFSTCompletionLookup.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50NormsProducer.java</file></fixedFiles></bug><bug fixdate="2014-12-10 01:36:49" id="6100" opendate="2014-12-07 05:36:59"><buginformation><summary>[LUCENE-6100] Further tuning of Lucene50Codec(BEST_COMPRESSION) - ASF JIRA</summary><description>Currently this codec has two options: BEST_SPEED and BEST_COMPRESSION. But in the case of highly compressible data, the ratio for BEST_COMPRESSION is not much over BEST_SPEED, because they share the same underlying format which is not optimized for this here. block size is currently 24576 (32kb sliding window size minus 8kb "grace" to avoid going over it). And we compress this in a stateless manner, each block is its own stream and they dont share preset dictionary or anything. So we have a lot of waste in many cases, since zlib has to reboot itself, then we generally throw away 1/4 of the window and start over. I ran some experiments with highly compressible logs data: method time indexing(ms) time merging(ms) fdt fdx BEST_SPEED 101,729 15,638 372,845,282 406,964 BEST_COMPRESSION 114,364 23,474 269,387,347 275.909 patch (60KB) 105,533 18,914 237,284,342 117,639 The other experiments I ran were: method time indexing(ms) time merging(ms) fdt fdx crappy preset 130,854 38,095 234,603,971 274,500 64KB 107,256 21,570 236,004,297 111,135 crappy preset+64KB 121,503 30,030 222,422,924 110,751 For 'crappy preset' I just use arbitrary first 32KB bytes of original data as a preset dictionary for every block. This is effective, but slow because of some unnecessary overhead involved (like computing adler32 over and over of the preset dict for each block). However, this overhead is reduced with larger block sizes, and still offers benefits, so maybe in the future we can do it (especially e.g. if its per-chunk and we can bulk merge chunks without recompressing, etc). For 64KB, we measure removing the "grace" completely so it spills to another block each time. The proposed smaller "grace" amount still offers cpu savings, so I think we should keep it. But its not terrible if you go over.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50StoredFieldsFormat.java</file></fixedFiles></bug><bug fixdate="2014-12-08 08:16:31" id="6099" opendate="2014-12-07 12:42:48"><buginformation><summary>[LUCENE-6099] Add FilterDirectory.unwrap and FilterDirectoryReader.unwrap - ASF JIRA</summary><description>We already have the useful FilterLeafReader.unwrap, but not for these other filter classes....</description></buginformation><fixedFiles><file>lucene.core.src.test.org.apache.lucene.search.TestSearcherManager.java</file><file>lucene.core.src.java.org.apache.lucene.index.FilterDirectoryReader.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestFilterLeafReader.java</file><file>lucene.core.src.java.org.apache.lucene.store.FilterDirectory.java</file><file>lucene.core.src.test.org.apache.lucene.store.TestFilterDirectory.java</file><file>lucene.core.src.java.org.apache.lucene.index.FilterLeafReader.java</file></fixedFiles></bug><bug fixdate="2014-12-11 11:25:02" id="6096" opendate="2014-12-05 06:41:01"><buginformation><summary>[LUCENE-6096] Improve FilterCache.ramBytesUsed - ASF JIRA</summary><description>I worked on some tests to improve ram usage estimation of LRUFilterCache and found some issues: 1. It currently only takes into account filters and DocIdSets, not the internal overhead of the various hash tables and linked lists that are being maintained. If the filter cache mostly stores sparse doc id sets (or even worse DocIdSet.EMPTY instances that require 0 bytes since it's a singleton) then the memory usage can be significantly under-estimated. 2. It treats all filters as if they were singletons. The filter cache is essentially a Map&lt;SegmentCoreReaders, Map&lt;Filter, DocIdSet&gt;&gt; and it treats filters as if all filters that are equal are the same instance when it comes to memory usage. But this is not the case actually since the map on the second level uses the first-seen filter as a key, which might be different on different segments because of merging.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.search.LRUFilterCache.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestLRUFilterCache.java</file></fixedFiles></bug><bug fixdate="2014-12-11 11:21:31" id="6095" opendate="2014-12-05 06:11:02"><buginformation><summary>[LUCENE-6095] Remove RamUsageTester.IdentityHashSet - ASF JIRA</summary><description>RamUsageTester has an implementation of an identity hash set. I am not sure why it is there but now that RamUsageTester can only be used in the context of tests (ie. memory usage or speed are less of a concern) I think we can switch to Collections.newSetFromMap(new IdentityHashMap&lt;&gt;())?</description></buginformation><fixedFiles><file>lucene.core.src.test.org.apache.lucene.util.TestIdentityHashSet.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.RamUsageTester.java</file></fixedFiles></bug><bug fixdate="2014-12-03 10:47:14" id="6090" opendate="2014-12-03 08:12:45"><buginformation><summary>[LUCENE-6090] don't wrap Deflater in CompressionMode - ASF JIRA</summary><description>This outputs zlib header/footer and computes adler32 for each block. The space is nothing, but the adler32 computation on encode/decode has a cost, and we already have our own checksum. Since we currently compress/decompress at merge, this reduces the overall time of merging stored fields with deflate vs lz4, from 1.8x to 1.5x, reducing some of the pain.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressionMode.java</file></fixedFiles></bug><bug fixdate="2014-12-03 10:32:40" id="6088" opendate="2014-12-02 04:14:46"><buginformation><summary>[LUCENE-6088] Make TermsFilter implement Accountable - ASF JIRA</summary><description>Terms filters can sometimes be massive. Having their memory usage exposed can be useful eg. for the FilterCache.</description></buginformation><fixedFiles><file>lucene.queries.src.java.org.apache.lucene.queries.TermsFilter.java</file><file>lucene.queries.src.test.org.apache.lucene.queries.TermsFilterTest.java</file></fixedFiles></bug><bug fixdate="2014-12-02 02:55:14" id="6087" opendate="2014-12-02 09:56:18"><buginformation><summary>[LUCENE-6087] SearcherManager should accept foreign DirectoryReader on init - ASF JIRA</summary><description>Today you init SearcherManager either with a dir or an IndexWriter, but since we have a useful FilterDirectoryReader class to wrap the sub-readers, it's useful for apps to also pass their own wrapped DirectoryReader and have SearcherManager reopen from that.</description></buginformation><fixedFiles><file>lucene.core.src.test.org.apache.lucene.search.TestSearcherManager.java</file><file>lucene.core.src.java.org.apache.lucene.search.SearcherManager.java</file></fixedFiles></bug><bug fixdate="2014-12-11 03:03:32" id="6086" opendate="2014-12-02 09:01:44"><buginformation><summary>[LUCENE-6086] Minor optimizations to the encoding of numerics in stored fields - ASF JIRA</summary><description>LUCENE-5914 explored minor optimizations for numeric encoding in stored fields, I think we should try to push them to the default format.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingStoredFieldsReader.java</file><file>lucene.core.src.test.org.apache.lucene.codecs.compressing.TestCompressingStoredFieldsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.compressing.CompressingStoredFieldsWriter.java</file></fixedFiles></bug><bug fixdate="2014-12-02 09:37:14" id="6084" opendate="2014-12-01 10:57:26"><buginformation><summary>[LUCENE-6084] Add reasonable IndexOutput.toString - ASF JIRA</summary><description>In LUCENE-3539 we fixed IndexInput.toString to always include the resourceDescription. I think we should do the same for IndexOutput? I don't think Lucene currently uses/relies on IndexOutput.toString, but e.g. at least Elasticsearch does, and likely others, so I think it can only help if you can see which path is open by this IndexOutput.</description></buginformation><fixedFiles><file>lucene.facet.src.test.org.apache.lucene.facet.SlowRAMDirectory.java</file><file>lucene.core.src.java.org.apache.lucene.store.RAMOutputStream.java</file><file>lucene.core.src.java.org.apache.lucene.index.CorruptIndexException.java</file><file>lucene.core.src.java.org.apache.lucene.store.FSDirectory.java</file><file>lucene.core.src.java.org.apache.lucene.store.RateLimitedIndexOutput.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50PostingsWriter.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.ThrottledIndexOutput.java</file><file>lucene.core.src.java.org.apache.lucene.store.IndexOutput.java</file><file>lucene.misc.src.java.org.apache.lucene.store.NativeUnixDirectory.java</file><file>lucene.test-framework.src.java.org.apache.lucene.store.BaseDirectoryTestCase.java</file><file>lucene.core.src.java.org.apache.lucene.store.OutputStreamIndexOutput.java</file><file>lucene.test-framework.src.java.org.apache.lucene.store.MockIndexOutputWrapper.java</file><file>lucene.core.src.java.org.apache.lucene.store.RAMDirectory.java</file></fixedFiles></bug><bug fixdate="2014-11-27 04:34:21" id="6077" opendate="2014-11-26 01:54:45"><buginformation><summary>[LUCENE-6077] Add a filter cache - ASF JIRA</summary><description>Lucene already has filter caching abilities through CachingWrapperFilter, but CachingWrapperFilter requires you to know which filters you want to cache up-front. Caching filters is not trivial. If you cache too aggressively, then you slow things down since you need to iterate over all documents that match the filter in order to load it into an in-memory cacheable DocIdSet. On the other hand, if you don't cache at all, you are potentially missing interesting speed-ups on frequently-used filters. Something that would be nice would be to have a generic filter cache that would track usage for individual filters and make the decision to cache or not a filter on a given segments based on usage statistics and various heuristics, such as: the overhead to cache the filter (for instance some filters produce DocIdSets that are already cacheable) the cost to build the DocIdSet (the getDocIdSet method is very expensive on some filters such as MultiTermQueryWrapperFilter that potentially need to merge lots of postings lists) the segment we are searching on (flush segments will likely be merged right away so it's probably not worth building a cache on such segments)</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.search.CachingWrapperFilter.java</file><file>lucene.core.src.java.org.apache.lucene.search.UsageTrackingFilterCachingPolicy.java</file><file>lucene.core.src.test.org.apache.lucene.util.TestFrequencyTrackingRingBuffer.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestCachingWrapperFilter.java</file><file>lucene.core.src.java.org.apache.lucene.search.LRUFilterCache.java</file><file>lucene.core.src.java.org.apache.lucene.search.FilterCachingPolicy.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestLRUFilterCache.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.BitDocIdSetCachingWrapperFilter.java</file><file>lucene.core.src.java.org.apache.lucene.search.FilterCache.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.LuceneTestCase.java</file><file>lucene.misc.src.test.org.apache.lucene.index.sorter.TestBlockJoinSorter.java</file><file>lucene.facet.src.test.org.apache.lucene.facet.range.TestRangeFacetCounts.java</file><file>lucene.core.src.java.org.apache.lucene.util.FrequencyTrackingRingBuffer.java</file></fixedFiles></bug><bug fixdate="2014-11-19 12:05:52" id="6063" opendate="2014-11-14 09:04:29"><buginformation><summary>[LUCENE-6063] Allow overriding ConcurrentMergeScheduler's denial-of-service protection - ASF JIRA</summary><description>In LUCENE-5310 we explored improving CMS/SMS sharing/concurrency, but the issue never "converged", so I want to break out one small part of it here: the ability to override CMS's default "aggressive" denial-of-service protection where it forcefully stalls the incoming threads that are responsible for creating too many segments. More advanced applications can more gracefully handle the "too many merges" by e.g. slowing down the incoming indexing rate at a higher level.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.index.ConcurrentMergeScheduler.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestConcurrentMergeScheduler.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.LuceneTestCase.java</file></fixedFiles></bug><bug fixdate="2014-11-14 08:33:51" id="6057" opendate="2014-11-10 05:59:56"><buginformation><summary>[LUCENE-6057] Clarify the Sort(SortField...) constructor) - ASF JIRA</summary><description>I don't really know which version this affects, but I clarified the documentation of the Sort(SortField...) constructor to ease the understanding for new users. Pull Request: https://github.com/apache/lucene-solr/pull/20</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.search.Sort.java</file></fixedFiles></bug><bug fixdate="2014-11-11 05:31:35" id="6053" opendate="2014-11-07 11:50:30"><buginformation><summary>[LUCENE-6053] Serbian Analyzer - ASF JIRA</summary><description>This is analyzer for Serbian language, so far consisting only of a normalizer. Serbian language uses both Cyrillic and Latin alphabet, so the normalizer works with both alphabets. In the future, I'll see to add stopwords, stemmer and so on.</description></buginformation><fixedFiles><file>lucene.analysis.common.src.java.org.apache.lucene.analysis.sr.SerbianNormalizationFilter.java</file><file>lucene.analysis.common.src.test.org.apache.lucene.analysis.sr.TestSerbianNormalizationFilter.java</file><file>lucene.analysis.common.src.java.org.apache.lucene.analysis.sr.SerbianNormalizationFilterFactory.java</file><file>lucene.analysis.common.src.test.org.apache.lucene.analysis.sr.TestSerbianNormalizationFilterFactory.java</file></fixedFiles></bug><bug fixdate="2014-11-02 11:54:24" id="6041" opendate="2014-10-31 06:31:54"><buginformation><summary>[LUCENE-6041] remove sugar FieldInfo.isIndexed and .hasDocValues - ASF JIRA</summary><description>Follow-on from LUCENE-6039; these two booleans don't really exist: they are just sugar to check for IndexOptions.NO and DocValuesType.NO. I think for the low-level schema API in Lucene we should not expose such sugar: callers should have to be explicit.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.index.CheckIndex.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.perfield.PerFieldPostingsFormat.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestDocValuesIndexing.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestSegmentReader.java</file><file>lucene.core.src.java.org.apache.lucene.index.MultiFields.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.perfield.PerFieldDocValuesFormat.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.AssertingLeafReader.java</file><file>lucene.core.src.java.org.apache.lucene.index.FreqProxTermsWriter.java</file><file>solr.core.src.java.org.apache.solr.schema.IndexSchema.java</file><file>lucene.core.src.java.org.apache.lucene.index.FieldInfos.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestDocumentWriter.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.BaseFieldInfoFormatTestCase.java</file><file>lucene.core.src.java.org.apache.lucene.index.DefaultIndexingChain.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestDirectoryReader.java</file><file>lucene.misc.src.java.org.apache.lucene.uninverting.DocTermOrds.java</file><file>lucene.core.src.java.org.apache.lucene.index.FieldInfo.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.LuceneTestCase.java</file><file>lucene.misc.src.java.org.apache.lucene.uninverting.FieldCacheImpl.java</file><file>lucene.misc.src.java.org.apache.lucene.uninverting.UninvertingReader.java</file><file>lucene.core.src.java.org.apache.lucene.index.SimpleMergedSegmentWarmer.java</file><file>lucene.core.src.java.org.apache.lucene.index.SegmentDocValuesProducer.java</file></fixedFiles></bug><bug fixdate="2014-11-05 04:35:37" id="6040" opendate="2014-10-31 05:51:31"><buginformation><summary>[LUCENE-6040] Speedup broadword bit selection - ASF JIRA</summary><description>Use table lookup instead of some broadword manipulations</description></buginformation><fixedFiles><file>a.lucene.core.src.java.org.apache.lucene.util.BroadWord.java</file><file>a.lucene.core.src.test.org.apache.lucene.util.TestBroadWord.java</file><file>a.lucene.core.src.java.org.apache.lucene.util.BitUtil.java</file><file>a.lucene.core.src.java.org.apache.lucene.util.packed.EliasFanoDecoder.java</file></fixedFiles></bug><bug fixdate="2014-10-31 09:18:43" id="6039" opendate="2014-10-31 10:47:35"><buginformation><summary>[LUCENE-6039] Add IndexOptions.NO and DocValuesType.NO, instead of null - ASF JIRA</summary><description>Idea from Simon: it seems dangerous for IndexOptions and DocValuesType via Indexable/FieldType and FieldInfo that we use null to mean it's not indexed or has no doc values. We should instead have an explicit choice (IndexOptions.NO, DocValuesType.NO) in the enum?</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.index.NumericDocValuesFieldUpdates.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.AnalyzingInfixSuggester.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.BaseStoredFieldsFormatTestCase.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blockterms.BlockTermsReader.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.BlendedInfixSuggester.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blockterms.BlockTermsWriter.java</file><file>lucene.highlighter.src.java.org.apache.lucene.search.postingshighlight.PostingsHighlighter.java</file><file>lucene.core.src.test.org.apache.lucene.analysis.TestMockAnalyzer.java</file><file>lucene.core.src.test.org.apache.lucene.document.TestFieldType.java</file><file>lucene.core.src.java.org.apache.lucene.index.DocsEnum.java</file><file>lucene.sandbox.src.java.org.apache.lucene.codecs.idversion.IDVersionSegmentTermsEnumFrame.java</file><file>lucene.core.src.java.org.apache.lucene.document.IntField.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexWriterExceptions.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.AssertingLeafReader.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestDocumentWriter.java</file><file>lucene.core.src.java.org.apache.lucene.document.DoubleField.java</file><file>lucene.core.src.test.org.apache.lucene.index.Test2BTerms.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestFieldsReader.java</file><file>lucene.queries.src.test.org.apache.lucene.queries.function.TestDocValuesFieldSources.java</file><file>lucene.highlighter.src.test.org.apache.lucene.search.postingshighlight.TestPostingsHighlighterRanking.java</file><file>lucene.core.src.java.org.apache.lucene.index.FreqProxFields.java</file><file>lucene.misc.src.java.org.apache.lucene.index.sorter.SortingLeafReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.FSTOrdTermsReader.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.blocktree.BlockTreeTermsReader.java</file><file>lucene.core.src.java.org.apache.lucene.document.SortedSetDocValuesField.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.simpletext.SimpleTextDocValuesWriter.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.blocktree.IntersectTermsEnum.java</file><file>lucene.core.src.java.org.apache.lucene.index.SlowCompositeReaderWrapper.java</file><file>lucene.core.src.java.org.apache.lucene.index.DocValuesType.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.FSTTermsWriter.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestExceedMaxTermLength.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.blocktree.SegmentTermsEnumFrame.java</file><file>lucene.core.src.java.org.apache.lucene.document.Field.java</file><file>lucene.core.src.java.org.apache.lucene.document.FloatField.java</file><file>lucene.core.src.test.org.apache.lucene.codecs.lucene50.TestBlockPostingsFormat2.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blocktreeords.OrdsIntersectTermsEnumFrame.java</file><file>lucene.core.src.java.org.apache.lucene.document.BinaryDocValuesField.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestAddIndexes.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.blocktree.BlockTreeTermsWriter.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.FSTOrdTermsWriter.java</file><file>lucene.core.src.java.org.apache.lucene.index.FreqProxTermsWriterPerField.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestCodecs.java</file><file>lucene.core.src.java.org.apache.lucene.index.DocValuesUpdate.java</file><file>lucene.core.src.java.org.apache.lucene.index.CheckIndex.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestOmitTf.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestPostingsOffsets.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.FSTTermsReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blocktreeords.OrdsSegmentTermsEnum.java</file><file>lucene.spatial.src.test.org.apache.lucene.spatial.bbox.TestBBoxStrategy.java</file><file>lucene.core.src.test.org.apache.lucene.document.TestDocument.java</file><file>lucene.core.src.java.org.apache.lucene.index.IndexWriter.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.blocktree.IntersectTermsEnumFrame.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexWriter.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.prefix.PrefixTreeStrategy.java</file><file>lucene.core.src.java.org.apache.lucene.index.IndexableFieldType.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.FSTTermOutputs.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blocktreeords.OrdsFieldReader.java</file><file>lucene.core.src.java.org.apache.lucene.index.IndexableField.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.blocktree.FieldReader.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingPostingsFormat.java</file><file>lucene.highlighter.src.test.org.apache.lucene.search.postingshighlight.TestPostingsHighlighter.java</file><file>lucene.core.src.java.org.apache.lucene.index.SegmentReader.java</file><file>lucene.test-framework.src.java.org.apache.lucene.analysis.BaseTokenStreamTestCase.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.BaseFieldInfoFormatTestCase.java</file><file>lucene.core.src.test.org.apache.lucene.index.Test2BPostings.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.bbox.BBoxStrategy.java</file><file>lucene.core.src.java.org.apache.lucene.index.DefaultIndexingChain.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexWriterNRTIsCurrent.java</file><file>lucene.core.src.test.org.apache.lucene.index.Test2BPostingsBytes.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50DocValuesFormat.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blocktreeords.OrdsSegmentTermsEnumFrame.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blocktreeords.OrdsBlockTreeTermsReader.java</file><file>lucene.core.src.java.org.apache.lucene.index.FieldInfo.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.PushPostingsWriterBase.java</file><file>lucene.misc.src.test.org.apache.lucene.index.sorter.SorterTestBase.java</file><file>lucene.spatial.src.test.org.apache.lucene.spatial.DistanceStrategyTest.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blocktreeords.OrdsBlockTreeTermsWriter.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestLongPostings.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.spell.SpellChecker.java</file><file>lucene.memory.src.test.org.apache.lucene.index.memory.TestMemoryIndexAgainstRAMDir.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50FieldInfosFormat.java</file><file>lucene.core.src.java.org.apache.lucene.index.FieldInfos.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.ramonly.RAMOnlyPostingsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.document.FieldType.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50PostingsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.index.IndexOptions.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.MemoryPostingsFormat.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.simpletext.SimpleTextFieldsReader.java</file><file>lucene.queries.src.java.org.apache.lucene.queries.function.valuesource.BytesRefFieldSource.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.blocktree.SegmentTermsEnum.java</file><file>lucene.core.src.java.org.apache.lucene.document.SortedDocValuesField.java</file><file>lucene.sandbox.src.java.org.apache.lucene.codecs.idversion.VersionFieldReader.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.FreeTextSuggester.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50PostingsReader.java</file><file>lucene.core.src.java.org.apache.lucene.index.BinaryDocValuesFieldUpdates.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.memory.DirectPostingsFormat.java</file><file>lucene.sandbox.src.java.org.apache.lucene.codecs.idversion.VersionBlockTreeTermsWriter.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.BasePostingsFormatTestCase.java</file><file>lucene.sandbox.src.java.org.apache.lucene.codecs.idversion.IDVersionSegmentTermsEnum.java</file><file>lucene.core.src.java.org.apache.lucene.document.Document.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestOmitPositions.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.simpletext.SimpleTextFieldInfosFormat.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.DocHelper.java</file><file>lucene.core.src.java.org.apache.lucene.document.LongField.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.DocValuesConsumer.java</file><file>lucene.test-framework.src.java.org.apache.lucene.codecs.asserting.AssertingDocValuesFormat.java</file><file>lucene.backward-codecs.src.test.org.apache.lucene.index.TestBackwardsCompatibility.java</file><file>lucene.sandbox.src.java.org.apache.lucene.codecs.idversion.IDVersionPostingsWriter.java</file><file>lucene.core.src.java.org.apache.lucene.index.DocValuesFieldUpdates.java</file><file>lucene.memory.src.java.org.apache.lucene.index.memory.MemoryIndex.java</file><file>lucene.core.src.java.org.apache.lucene.index.TermVectorsConsumerPerField.java</file><file>lucene.highlighter.src.test.org.apache.lucene.search.postingshighlight.TestMultiTermHighlighting.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexableField.java</file><file>lucene.core.src.java.org.apache.lucene.document.StringField.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestSegmentReader.java</file><file>lucene.sandbox.src.test.org.apache.lucene.codecs.idversion.StringAndPayloadField.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.simpletext.SimpleTextDocValuesReader.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blocktreeords.OrdsIntersectTermsEnum.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestBagOfPositions.java</file><file>lucene.queryparser.src.test.org.apache.lucene.queryparser.analyzing.TestAnalyzingQueryParser.java</file><file>lucene.core.src.java.org.apache.lucene.document.NumericDocValuesField.java</file><file>lucene.core.src.test.org.apache.lucene.codecs.lucene50.TestBlockPostingsFormat3.java</file><file>lucene.misc.src.java.org.apache.lucene.uninverting.UninvertingReader.java</file><file>lucene.core.src.java.org.apache.lucene.document.SortedNumericDocValuesField.java</file><file>lucene.core.src.java.org.apache.lucene.document.TextField.java</file></fixedFiles></bug><bug fixdate="2014-12-05 03:27:54" id="6034" opendate="2014-10-30 04:11:45"><buginformation><summary>[LUCENE-6034] MemoryIndex should be able to wrap TermVector Terms - ASF JIRA</summary><description>The default highlighter has a "WeightedSpanTermExtractor" that uses MemoryIndex for certain queries  basically phrases, SpanQueries, and the like. For lots of text, this aspect of highlighting is time consuming and consumes a fair amount of memory. What also consumes memory is that it wraps the tokenStream in CachingTokenFilter in this case. But if the underlying TokenStream is actually from TokenSources (wrapping TermVector Terms), this is all needless! Furthermore, MemoryIndex doesn't support payloads. The patch here has 3 aspects to it: Internal refactoring to MemoryIndex to simplify it by maintaining the fields in a sorted state using a TreeMap. The ramifications of this led to reduced LOC for this file, even with the other features I added. It also puts the FieldInfo on the Info, and thus there's one less data structure to keep around. I suppose if there are a huge variety of fields in MemoryIndex, the aggregated N*Log(N) field lookup could add up, but that seems very unlikely. I also brought in the MemoryIndexNormDocValues as a simple anonymous inner class - it's super-simple after all, not worth having in a separate file. New MemoryIndex.addField(String fieldName, Terms) method. In this case, MemoryIndex is providing the supporting wrappers around the underlying Terms so that it appears as an Index. In so doing, MemoryIndex supports payloads for such fields. WeightedSpanTermExtractor now detects TokenSources' wrapping of Terms and it supplies this to MemoryIndex.</description></buginformation><fixedFiles><file>lucene.memory.src.test.org.apache.lucene.index.memory.TestMemoryIndex.java</file><file>lucene.highlighter.src.test.org.apache.lucene.search.highlight.HighlighterTest.java</file><file>lucene.highlighter.src.java.org.apache.lucene.search.highlight.QueryScorer.java</file><file>lucene.highlighter.src.java.org.apache.lucene.search.highlight.TermVectorLeafReader.java</file><file>lucene.highlighter.src.java.org.apache.lucene.search.highlight.TokenSources.java</file><file>lucene.memory.src.java.org.apache.lucene.index.memory.MemoryIndexNormDocValues.java</file><file>lucene.memory.src.java.org.apache.lucene.index.memory.MemoryIndex.java</file><file>lucene.highlighter.src.java.org.apache.lucene.search.highlight.WeightedSpanTermExtractor.java</file></fixedFiles></bug><bug fixdate="2014-11-12 02:12:43" id="6033" opendate="2014-10-29 08:36:30"><buginformation><summary>[LUCENE-6033] Add CachingTokenFilter.isCached and switch LinkedList to ArrayList - ASF JIRA</summary><description>CachingTokenFilter could use a simple boolean isCached() method implemented as-such: &#13;
  /** If the underlying token stream was consumed and cached */&#13;
  public boolean isCached() {&#13;
    return cache != null;&#13;
  }&#13;
 It's useful for the highlighting code to remove its wrapping of CachingTokenFilter if after handing-off to parts of its framework it turns out that it wasn't used. Furthermore, use an ArrayList, not a LinkedList. ArrayList is leaner when the token count is high, and this class doesn't manipulate the list in a way that might favor LL. A separate patch will come that actually uses this method.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.analysis.CachingTokenFilter.java</file><file>lucene.core.src.test.org.apache.lucene.analysis.TestCachingTokenFilter.java</file></fixedFiles></bug><bug fixdate="2014-12-23 04:18:22" id="6031" opendate="2014-10-29 08:20:21"><buginformation><summary>[LUCENE-6031] TokenSources optimization, avoid sort - ASF JIRA</summary><description>TokenSources.java, in the highlight module, is a facade that returns a TokenStream for a field by either un-inverting &amp; converting the TermVector Terms, or by text re-analysis if TermVectors are unavailable or don't have the right options. TokenSources is used by the default highlighter, which is the most accurate highlighter we've got. When documents are large (say hundreds of kilobytes on up), I found that most of the highlighter's activity was up-front spent un-inverting &amp; converting the term vector to a TokenStream, not on the actual/real highlighting that follows. Much of that time was on a huge sort of hundreds of thousands of Tokens. Time was also spent doing lots of String conversion and char copying, and it used a lot of memory, too. In this patch, I overhauled TokenStreamFromTermPositionVector.java, and I removed similar logic in TokenSources that was used in circumstances when positions weren't available but offsets were. This class can un-invert term vectors that have positions and/or offsets (at least one). It doesn't sort. It places Tokens directly into an array of tokens directly indexed by position. When positions aren't available, the startOffset/8 is a substitute. I've got a more light-weight Token inner class used in place of the former and deprecated Token that ultimately forms a linked-list when the process is done. There is no string conversion; character copying is minimized. The Token array is GC'ed after initialization, it's only needed during construction. Misc: It implements reset() efficiently so it need not be wrapped in CachingTokenFilter (I'll supply a patch later on this). It only fetches payloads if you ask for them by adding the attribute (the default highlighter won't add the attribute). It exposes the underlying TermVector terms via a getter too, which is needed by another patch to follow later. A key assumption is that the position increment gap or first position isn't gigantic, as that will create wasted space and the linked-list formation ultimately has to visit all the slots. We also assume that there aren't a ton of tokens at the same position, since inserting new tokens in sorted order is O(N^2) where 'N' is the average co-occurring token length. My performance testing using Lucene's benchmark module on a megabyte document showed &gt;5x speedup, in conjunction with some other patches to be posted separately. This patch made the most difference.</description></buginformation><fixedFiles><file>lucene.highlighter.src.java.org.apache.lucene.search.highlight.TokenStreamFromTermVector.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.BaseTermVectorsFormatTestCase.java</file><file>lucene.highlighter.src.java.org.apache.lucene.search.highlight.TokenSources.java</file><file>lucene.highlighter.src.test.org.apache.lucene.search.highlight.TokenSourcesTest.java</file><file>lucene.highlighter.src.java.org.apache.lucene.search.highlight.TokenStreamFromTermPositionVector.java</file></fixedFiles></bug><bug fixdate="2014-10-31 08:25:51" id="6030" opendate="2014-10-28 06:20:37"><buginformation><summary>[LUCENE-6030] Add norms patched compression which uses table for most common values - ASF JIRA</summary><description>We have added the PATCHED norms sub format in lucene 50, which uses a bitset to mark documents that have the most common value (when &gt;97% of the documents have that value). This works well for fields that have a predominant value length, and then a small number of docs with some other random values. But another common case is having a handful of very common value lengths, like with a title field. We can use a table (see TABLE_COMPRESSION) to store the most common values, and save an oridinal for the "other" case, at which point we can lookup in the secondary patch table.</description></buginformation><fixedFiles><file>lucene.test-framework.src.java.org.apache.lucene.index.BaseNormsFormatTestCase.java</file><file>lucene.core.src.test.org.apache.lucene.codecs.lucene50.TestLucene50NormsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50NormsFormat.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50NormsConsumer.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50NormsProducer.java</file></fixedFiles></bug><bug fixdate="2014-10-30 04:15:58" id="6025" opendate="2014-10-26 10:10:21"><buginformation><summary>[LUCENE-6025] Add BitSet.prevSetBit - ASF JIRA</summary><description>This would allow the join module to work with any BitSet as opposed to only FixedBitSet.</description></buginformation><fixedFiles><file>lucene.test-framework.src.java.org.apache.lucene.util.BaseBitSetTestCase.java</file><file>lucene.core.src.java.org.apache.lucene.search.CachingWrapperFilter.java</file><file>lucene.join.src.test.org.apache.lucene.search.join.TestBlockJoin.java</file><file>solr.core.src.java.org.apache.solr.search.join.BlockJoinParentQParser.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToChildBlockJoinQuery.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToParentBlockJoinSortField.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.FixedBitSetCachingWrapperFilter.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.BitDocIdSetFilter.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToParentBlockJoinFieldComparator.java</file><file>lucene.join.src.test.org.apache.lucene.search.join.TestBlockJoinSorting.java</file><file>lucene.core.src.test.org.apache.lucene.util.TestDocIdSetBuilder.java</file><file>lucene.core.src.java.org.apache.lucene.util.BitDocIdSet.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToParentBlockJoinQuery.java</file><file>lucene.core.src.java.org.apache.lucene.util.DocIdSetBuilder.java</file><file>lucene.core.src.java.org.apache.lucene.search.MultiTermQueryWrapperFilter.java</file><file>lucene.join.src.test.org.apache.lucene.search.join.TestJoinUtil.java</file><file>lucene.join.src.test.org.apache.lucene.search.join.TestBlockJoinValidation.java</file><file>lucene.queries.src.java.org.apache.lucene.queries.BooleanFilter.java</file><file>solr.core.src.java.org.apache.solr.response.transform.ChildDocTransformerFactory.java</file><file>lucene.core.src.java.org.apache.lucene.util.SparseFixedBitSet.java</file><file>solr.core.src.test.org.apache.solr.update.AddBlockUpdateTest.java</file><file>lucene.core.src.java.org.apache.lucene.util.FixedBitSet.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.BitDocIdSetCachingWrapperFilter.java</file><file>lucene.queries.src.java.org.apache.lucene.queries.TermsFilter.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.BitSetCachingWrapperFilter.java</file><file>lucene.core.src.java.org.apache.lucene.util.BitSet.java</file></fixedFiles></bug><bug fixdate="2014-10-27 10:25:50" id="6024" opendate="2014-10-24 05:36:24"><buginformation><summary>[LUCENE-6024] Improve oal.util.BitSet's bulk and/or/and_not - ASF JIRA</summary><description>LUCENE-6021 introduced oal.util.BitSet with default impls taken from FixedBitSet. However, these default impls could be more efficient (and eg. perform an actual leap frog for AND and AND_NOT). Additionally, SparseFixedBitSet could benefit from some specialization.</description></buginformation><fixedFiles><file>lucene.test-framework.src.java.org.apache.lucene.util.BaseBitSetTestCase.java</file><file>lucene.core.src.test.org.apache.lucene.util.TestSparseFixedBitSet.java</file><file>lucene.core.src.java.org.apache.lucene.util.SparseFixedBitSet.java</file><file>lucene.core.src.java.org.apache.lucene.util.FixedBitSet.java</file><file>lucene.core.src.java.org.apache.lucene.util.BitSetIterator.java</file><file>lucene.core.src.java.org.apache.lucene.util.BitSet.java</file></fixedFiles></bug><bug fixdate="2014-10-23 05:52:27" id="6022" opendate="2014-10-23 04:44:51"><buginformation><summary>[LUCENE-6022] DocValuesDocIdSet: check deleted docs before doc values - ASF JIRA</summary><description>When live documents are not null, DocValuesDocIdSet checks if doc values match the document before the live docs. Given that checking if doc values match could involve a heavy computation (eg. geo distance) and that the default codec has live docs in memory but doc values on disk, I think it makes more sense to check live docs first?</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.search.DocValuesDocIdSet.java</file></fixedFiles></bug><bug fixdate="2014-10-27 12:47:58" id="6021" opendate="2014-10-23 03:24:10"><buginformation><summary>[LUCENE-6021] Make FixedBitSet and SparseFixedBitSet share a wider common interface - ASF JIRA</summary><description>Today, the only common interfaces that these two classes share are Bits and Accountable. I would like to add a BitSet base class that would be both extended by FixedBitSet and SparseFixedBitSet. The idea is to share more code between these two impls and make them interchangeable for more use-cases so that we could just use one or the other based on the density of the data that we are working on.</description></buginformation><fixedFiles><file>solr.core.src.test.org.apache.solr.search.TestSort.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.BaseBitSetTestCase.java</file><file>lucene.facet.src.java.org.apache.lucene.facet.DrillSidewaysScorer.java</file><file>lucene.core.src.java.org.apache.lucene.util.FixedBitDocIdSet.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToChildBlockJoinQuery.java</file><file>lucene.core.src.java.org.apache.lucene.search.SloppyPhraseScorer.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestFilteredSearch.java</file><file>solr.core.src.java.org.apache.solr.search.CollapsingQParserPlugin.java</file><file>lucene.core.src.test.org.apache.lucene.util.TestSparseFixedBitSet.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.FixedBitSetCachingWrapperFilter.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestCachingWrapperFilter.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestSortRandom.java</file><file>lucene.misc.src.test.org.apache.lucene.uninverting.TestFieldCacheSortRandom.java</file><file>lucene.misc.src.java.org.apache.lucene.index.PKIndexSplitter.java</file><file>lucene.facet.src.test.org.apache.lucene.facet.range.TestRangeFacetCounts.java</file><file>lucene.core.src.java.org.apache.lucene.search.DocValuesDocIdSet.java</file><file>lucene.core.src.java.org.apache.lucene.util.BitDocIdSet.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToParentBlockJoinQuery.java</file><file>lucene.core.src.java.org.apache.lucene.util.DocIdSetBuilder.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.TermsIncludingScoreQuery.java</file><file>lucene.facet.src.test.org.apache.lucene.facet.TestDrillSideways.java</file><file>lucene.facet.src.java.org.apache.lucene.facet.FacetsCollector.java</file><file>lucene.core.src.java.org.apache.lucene.util.BitSetIterator.java</file><file>lucene.core.src.java.org.apache.lucene.util.RoaringDocIdSet.java</file><file>lucene.core.src.java.org.apache.lucene.util.SparseFixedBitSet.java</file><file>lucene.core.src.java.org.apache.lucene.util.FixedBitSet.java</file><file>lucene.core.src.test.org.apache.lucene.util.TestFixedBitSet.java</file><file>lucene.facet.src.java.org.apache.lucene.facet.RandomSamplingFacetsCollector.java</file><file>lucene.core.src.test.org.apache.lucene.search.MockFilter.java</file><file>solr.core.src.test.org.apache.solr.search.TestFiltering.java</file><file>lucene.highlighter.src.test.org.apache.lucene.search.highlight.HighlighterPhraseTest.java</file><file>lucene.misc.src.java.org.apache.lucene.index.sorter.BlockJoinComparatorSource.java</file><file>lucene.queries.src.test.org.apache.lucene.queries.TermsFilterTest.java</file><file>lucene.queries.src.test.org.apache.lucene.queries.BooleanFilterTest.java</file><file>lucene.test-framework.src.java.org.apache.lucene.util.BaseDocIdSetTestCase.java</file><file>solr.core.src.java.org.apache.solr.response.SortingResponseWriter.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.bloom.FuzzySet.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.prefix.IntersectsPrefixTreeFilter.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToParentBlockJoinFieldComparator.java</file><file>lucene.core.src.test.org.apache.lucene.util.TestDocIdSetBuilder.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestScorerPerf.java</file><file>lucene.join.src.test.org.apache.lucene.search.join.TestJoinUtil.java</file><file>solr.core.src.java.org.apache.solr.search.DocSetBase.java</file><file>lucene.core.src.java.org.apache.lucene.util.SparseFixedBitDocIdSet.java</file><file>lucene.queries.src.java.org.apache.lucene.queries.BooleanFilter.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestFilteredQuery.java</file><file>lucene.core.src.test.org.apache.lucene.search.SingleDocTestFilter.java</file><file>solr.core.src.test.org.apache.solr.search.TestDocSet.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.prefix.WithinPrefixTreeFilter.java</file><file>lucene.sandbox.src.test.org.apache.lucene.search.TestTermAutomatonQuery.java</file><file>lucene.sandbox.src.java.org.apache.lucene.sandbox.queries.DuplicateFilter.java</file><file>lucene.grouping.src.test.org.apache.lucene.search.grouping.AllGroupHeadsCollectorTest.java</file><file>solr.core.src.java.org.apache.solr.handler.component.ExpandComponent.java</file><file>lucene.core.src.java.org.apache.lucene.util.BitSet.java</file><file>lucene.misc.src.test.org.apache.lucene.index.sorter.TestBlockJoinSorter.java</file><file>lucene.core.src.test.org.apache.lucene.util.TestFixedBitDocIdSet.java</file></fixedFiles></bug><bug fixdate="2014-10-22 01:52:15" id="6017" opendate="2014-10-22 10:01:04"><buginformation><summary>[LUCENE-6017] Specialize FixedBitSet.xor(DocIdSetIterator) like and/or/andNot - ASF JIRA</summary><description>As Uwe noticed on LUCENE-5441, FixedBitSet.xor(DocIdSetIterator) doesn't have the same optimization when the provided iterator is a FixedBitSetIterator as other bulk methods (and, or, ...).</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.util.FixedBitSet.java</file><file>lucene.core.src.test.org.apache.lucene.util.TestFixedBitSet.java</file></fixedFiles></bug><bug fixdate="2014-10-21 10:35:09" id="6013" opendate="2014-10-20 11:00:49"><buginformation><summary>[LUCENE-6013] Remove IndexableFieldType.indexed() - ASF JIRA</summary><description>Like LUCENE-6006, here's another pre-cursor for LUCENE-6005 ... because I think it's important to nail down Lucene's low-schema (FieldType/FieldInfos) semantics before adding a high-schema. IndexableFieldType.indexed() is redundant with IndexableFieldType.indexOptions() != null, so we should remove it, codecs shouldn't have to write/read it, high-schema should not configure it, etc. Similarly, the FieldInfo.indexed bit is redundant, so I removed it, but I left the sugar API (FieldInfo.isIndexed) and implement it as just checking IndexOptions != null.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.analysis.NumericTokenStream.java</file><file>lucene.core.src.java.org.apache.lucene.index.IndexableField.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.BasePostingsFormatTestCase.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.BaseStoredFieldsFormatTestCase.java</file><file>solr.core.src.test.org.apache.solr.update.TestExceedMaxTermLength.java</file><file>lucene.core.src.java.org.apache.lucene.document.Document.java</file><file>lucene.backward-codecs.src.java.org.apache.lucene.codecs.lucene40.Lucene40FieldInfosFormat.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.simpletext.SimpleTextFieldInfosFormat.java</file><file>lucene.core.src.java.org.apache.lucene.index.DefaultIndexingChain.java</file><file>lucene.test-framework.src.java.org.apache.lucene.index.DocHelper.java</file><file>lucene.core.src.java.org.apache.lucene.document.LongField.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestExceedMaxTermLength.java</file><file>lucene.core.src.java.org.apache.lucene.document.Field.java</file><file>lucene.backward-codecs.src.java.org.apache.lucene.codecs.lucene46.Lucene46FieldInfosFormat.java</file><file>lucene.core.src.java.org.apache.lucene.document.FloatField.java</file><file>lucene.core.src.test.org.apache.lucene.analysis.TestMockAnalyzer.java</file><file>lucene.core.src.test.org.apache.lucene.document.TestFieldType.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestAddIndexes.java</file><file>lucene.benchmark.src.java.org.apache.lucene.benchmark.byTask.feeds.DocMaker.java</file><file>lucene.benchmark.src.java.org.apache.lucene.benchmark.byTask.tasks.ReadTokensTask.java</file><file>lucene.core.src.java.org.apache.lucene.index.FieldInfo.java</file><file>lucene.core.src.java.org.apache.lucene.util.NumericUtils.java</file><file>lucene.core.src.java.org.apache.lucene.index.TermVectorsConsumerPerField.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestCodecs.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexableField.java</file><file>lucene.core.src.java.org.apache.lucene.document.IntField.java</file><file>lucene.core.src.java.org.apache.lucene.document.StringField.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestPostingsOffsets.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestSegmentReader.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexWriterExceptions.java</file><file>solr.core.src.test.org.apache.solr.search.TestStressLucene.java</file><file>lucene.backward-codecs.src.java.org.apache.lucene.codecs.lucene42.Lucene42FieldInfosFormat.java</file><file>lucene.core.src.java.org.apache.lucene.codecs.lucene50.Lucene50FieldInfosFormat.java</file><file>lucene.core.src.java.org.apache.lucene.index.FieldInfos.java</file><file>lucene.core.src.java.org.apache.lucene.document.DoubleField.java</file><file>lucene.core.src.java.org.apache.lucene.document.FieldType.java</file><file>solr.core.src.java.org.apache.solr.search.SolrIndexSearcher.java</file><file>lucene.core.src.test.org.apache.lucene.document.TestDocument.java</file><file>lucene.core.src.java.org.apache.lucene.document.DocumentStoredFieldVisitor.java</file><file>lucene.core.src.test.org.apache.lucene.index.Test4GBStoredFields.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestIndexWriter.java</file><file>lucene.core.src.java.org.apache.lucene.index.IndexableFieldType.java</file><file>lucene.core.src.test.org.apache.lucene.index.TestConsistentFieldNumbers.java</file><file>lucene.core.src.java.org.apache.lucene.document.TextField.java</file></fixedFiles></bug><bug fixdate="2014-10-16 02:46:10" id="6010" opendate="2014-10-16 12:46:17"><buginformation><summary>[LUCENE-6010] Remove dead code - ASF JIRA</summary><description>For instance OpenBitSet is not used anymore in our code. Let's take advantage of the major version bump to remove unused code.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.util.DoubleBarrelLRUCache.java</file><file>lucene.core.src.test.org.apache.lucene.util.TestOpenBitSet.java</file><file>lucene.core.src.java.org.apache.lucene.util.OpenBitSetDISI.java</file><file>lucene.core.src.java.org.apache.lucene.util.OpenBitSetIterator.java</file><file>lucene.codecs.src.java.org.apache.lucene.codecs.blockterms.BlockTermsReader.java</file><file>lucene.core.src.java.org.apache.lucene.util.fst.FST.java</file><file>lucene.core.src.test.org.apache.lucene.util.TestDoubleBarrelLRUCache.java</file><file>solr.core.src.java.org.apache.solr.schema.BoolField.java</file><file>lucene.core.src.java.org.apache.lucene.util.OpenBitSet.java</file><file>lucene.core.src.java.org.apache.lucene.index.FilterDirectoryReader.java</file><file>lucene.core.src.java.org.apache.lucene.util.FixedBitSet.java</file><file>lucene.core.src.java.org.apache.lucene.util.packed.PackedInts.java</file><file>lucene.core.src.java.org.apache.lucene.search.DocValuesDocIdSet.java</file></fixedFiles></bug><bug fixdate="2014-10-16 03:07:39" id="6009" opendate="2014-10-16 12:35:36"><buginformation><summary>[LUCENE-6009] Remove redundant == NO_MORE_DOCS checks - ASF JIRA</summary><description>When I added some new doc id sets, I took inspiration from FixedBitSet which had protection for bad users of its iterator by basically doing &#13;
if (doc == NO_MORE_DOCS || ++doc &gt;= numBits) {&#13;
  return doc = NO_MORE_DOCS;&#13;
}&#13;
 in order to not overflow the integer doc when the iterator was already exhausted. However, DocIdSetIterator clearly states that the behaviours of nextDoc() and advance() are undefined when the iterator is already exhausted so we do not need such protection. For the record, I don't expect better performance from this change since the branch is highly predictable (benchmarks seem to support this). At best it might just help inlining by making methods smaller.</description></buginformation><fixedFiles><file>lucene.core.src.java.org.apache.lucene.util.RoaringDocIdSet.java</file><file>lucene.core.src.java.org.apache.lucene.util.NotDocIdSet.java</file><file>lucene.core.src.java.org.apache.lucene.util.SparseFixedBitSet.java</file><file>lucene.core.src.java.org.apache.lucene.util.FixedBitSet.java</file></fixedFiles></bug></bugrepository>