<?xml version="1.0" encoding="UTF-8" standalone="no"?><bugrepository><bug fixdate="2015-01-14 02:51:17" id="6177" opendate="2015-01-12 03:48:04"><buginformation><summary>[LUCENE-6177] Add CustomAnalyzer - a builder that creates Analyzers from the factory classes - ASF JIRA</summary><description>I prepared some "generic Analyzer class CustomAnalyzer, that makes it easy to build analyzers like in Solr or Elasticsearch. Under the hood it uses the factory classes. The class is made like a builder: &#13;
Analyzer ana = CustomAnalyzer.builder(Path.get("/path/to/config/dir"))&#13;
  .withTokenizer("standard")&#13;
  .addTokenFilter("standard")&#13;
  .addTokenFilter("lowercase")&#13;
  .addTokenFilter("stop", "ignoreCase", "false", "words", "stopwords.txt", "format", "wordset")&#13;
  .build();&#13;
 It is possible to give the resource loader (used by stopwords and similar). By default it tries to load stuff from context classloader (without any class as reference so paths must be absolute - this is the behaviour ClasspathResourseLoader defaults to). In addition you can give a Lucene MatchVersion, by default it would use Version.LATEST (once LUCENE-5900 is completely fixed).</description></buginformation><fixedFiles><file>lucene.analysis.common.src.test.org.apache.lucene.analysis.custom.TestCustomAnalyzer.java</file><file>lucene.analysis.common.src.java.org.apache.lucene.analysis.custom.CustomAnalyzer.java</file></fixedFiles></bug><bug fixdate="2015-01-06 01:29:29" id="6155" opendate="2014-12-31 04:35:00"><buginformation><summary>[LUCENE-6155] Payload support for MemoryIndex - ASF JIRA</summary><description>MemoryIndex could be enhanced to support payloads. It should be optional, defaulting to false.</description></buginformation><fixedFiles><file>lucene.highlighter.src.test.org.apache.lucene.search.highlight.HighlighterTest.java</file><file>lucene.highlighter.src.java.org.apache.lucene.search.highlight.TokenStreamFromTermVector.java</file><file>lucene.highlighter.src.java.org.apache.lucene.search.highlight.QueryScorer.java</file><file>lucene.memory.src.test.org.apache.lucene.index.memory.TestMemoryIndexAgainstRAMDir.java</file><file>lucene.memory.src.java.org.apache.lucene.index.memory.MemoryIndex.java</file><file>lucene.highlighter.src.java.org.apache.lucene.search.highlight.WeightedSpanTermExtractor.java</file></fixedFiles></bug><bug fixdate="2014-11-11 06:49:58" id="6059" opendate="2014-11-10 09:16:57"><buginformation><summary>[LUCENE-6059] Add Daitch-Mokotoff Soundex phonetic filter from latest commons-codec 1.10 release - ASF JIRA</summary><description>The latest commons-codec release (1.10) has added a new phonetic encoder: Daitch-Mokotoff Soundex.</description></buginformation><fixedFiles><file>src.java.org.apache.lucene.analysis.phonetic.DaitchMokotoffSoundexFilterFactory.java</file><file>src.java.org.apache.lucene.analysis.phonetic.DaitchMokotoffSoundexFilter.java</file><file>src.test.org.apache.lucene.analysis.phonetic.TestDaitchMokotoffSoundexFilterFactory.java</file><file>src.test.org.apache.lucene.analysis.phonetic.TestDaitchMokotoffSoundexFilter.java</file></fixedFiles></bug><bug fixdate="2014-09-16 02:37:40" id="5820" opendate="2014-07-14 05:30:59"><buginformation><summary>[LUCENE-5820] SuggestStopFilter should have a factory - ASF JIRA</summary><description>While trying to use the new Suggester in Solr I realized that SuggestStopFilter did not have a factory. We should add one.</description></buginformation><fixedFiles><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.SuggestStopFilter.java</file><file>lucene.suggest.src.test.org.apache.lucene.search.suggest.analyzing.TestSuggestStopFilterFactory.java</file><file>lucene.suggest.src.java.org.apache.lucene.search.suggest.analyzing.SuggestStopFilterFactory.java</file><file>lucene.suggest.src.test.org.apache.lucene.search.suggest.analyzing.TestSuggestStopFilter.java</file></fixedFiles></bug><bug fixdate="2015-01-06 03:40:54" id="5702" opendate="2014-05-23 10:26:23"><buginformation><summary>[LUCENE-5702] Per-segment comparator API - ASF JIRA</summary><description>As a next step of LUCENE-5527, it would be nice to have per-segment comparators, and maybe even change the default behavior of our top* comparators so that they merge top hits in the end.</description></buginformation><fixedFiles><file>lucene.core.src.test.org.apache.lucene.search.TestElevationComparator.java</file><file>lucene.grouping.src.java.org.apache.lucene.search.grouping.BlockGroupingCollector.java</file><file>lucene.core.src.java.org.apache.lucene.search.TopScoreDocCollector.java</file><file>lucene.core.src.java.org.apache.lucene.search.FieldComparator.java</file><file>solr.core.src.java.org.apache.solr.handler.component.QueryElevationComponent.java</file><file>solr.core.src.java.org.apache.solr.search.ExportQParserPlugin.java</file><file>lucene.core.src.java.org.apache.lucene.search.LeafFieldComparator.java</file><file>lucene.misc.src.java.org.apache.lucene.search.BlockJoinComparatorSource.java</file><file>lucene.expressions.src.java.org.apache.lucene.expressions.ExpressionComparator.java</file><file>solr.core.src.java.org.apache.solr.handler.component.QueryComponent.java</file><file>lucene.core.src.java.org.apache.lucene.search.ReverseLeafFieldComparator.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToParentBlockJoinSortField.java</file><file>lucene.misc.src.java.org.apache.lucene.index.sorter.BlockJoinComparatorSource.java</file><file>lucene.grouping.src.java.org.apache.lucene.search.grouping.function.FunctionAllGroupHeadsCollector.java</file><file>lucene.queries.src.java.org.apache.lucene.queries.function.ValueSource.java</file><file>solr.core.src.java.org.apache.solr.schema.RandomSortField.java</file><file>lucene.grouping.src.java.org.apache.lucene.search.grouping.AbstractFirstPassGroupingCollector.java</file><file>solr.core.src.test.org.apache.solr.search.TestRankQueryPlugin.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestTopDocsCollector.java</file><file>lucene.core.src.java.org.apache.lucene.search.FieldValueHitQueue.java</file><file>lucene.misc.src.java.org.apache.lucene.index.Sorter.java</file><file>lucene.core.src.test.org.apache.lucene.search.JustCompileSearch.java</file><file>lucene.join.src.test.org.apache.lucene.search.join.TestJoinUtil.java</file><file>lucene.core.src.java.org.apache.lucene.search.SortRescorer.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestTopFieldCollector.java</file><file>lucene.core.src.java.org.apache.lucene.search.TopDocsCollector.java</file><file>lucene.sandbox.src.java.org.apache.lucene.sandbox.queries.SlowCollatedStringComparator.java</file><file>lucene.core.src.java.org.apache.lucene.search.SimpleFieldComparator.java</file><file>solr.core.src.java.org.apache.solr.search.SolrIndexSearcher.java</file><file>lucene.grouping.src.java.org.apache.lucene.search.grouping.term.TermAllGroupHeadsCollector.java</file><file>solr.core.src.java.org.apache.solr.search.ReRankQParserPlugin.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestTopScoreDocCollector.java</file><file>lucene.core.src.test.org.apache.lucene.search.TestSort.java</file><file>lucene.core.src.java.org.apache.lucene.search.MultiFieldComparator.java</file><file>lucene.join.src.java.org.apache.lucene.search.join.ToParentBlockJoinCollector.java</file><file>lucene.core.src.java.org.apache.lucene.search.TopFieldCollector.java</file><file>lucene.misc.src.java.org.apache.lucene.index.sorter.Sorter.java</file></fixedFiles></bug><bug fixdate="2014-06-05 02:50:06" id="5648" opendate="2014-05-06 02:05:22"><buginformation><summary>[LUCENE-5648] Index/search multi-valued time durations - ASF JIRA</summary><description>If you need to index a date/time duration, then the way to do that is to have a pair of date fields; one for the start and one for the end â€“ pretty straight-forward. But if you need to index a variable number of durations per document, then the options aren't pretty, ranging from denormalization, to joins, to using Lucene spatial with 2D as described here. Ideally it would be easier to index durations, and work in a more optimal way. This issue implements the aforementioned feature using Lucene-spatial with a new single-dimensional SpatialPrefixTree implementation. Unlike the other two SPT implementations, it's not based on floating point numbers. It will have a Date based customization that indexes levels at meaningful quantities like seconds, minutes, hours, etc. The point of that alignment is to make it faster to query across meaningful ranges (i.e. [2000 TO 2014]) and to enable a follow-on issue to facet on the data in a really fast way. I'll expect to have a working patch up this week.</description></buginformation><fixedFiles><file>lucene.spatial.src.test.org.apache.lucene.spatial.prefix.BaseNonFuzzySpatialOpStrategyTest.java</file><file>lucene.spatial.src.test.org.apache.lucene.spatial.prefix.tree.DateRangePrefixTreeTest.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.prefix.AbstractVisitingPrefixTreeFilter.java</file><file>lucene.spatial.src.test.org.apache.lucene.spatial.StrategyTestCase.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.prefix.ContainsPrefixTreeFilter.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.prefix.WithinPrefixTreeFilter.java</file><file>lucene.spatial.src.test.org.apache.lucene.spatial.prefix.DateNRStrategyTest.java</file><file>lucene.spatial.src.test.org.apache.lucene.spatial.prefix.SpatialOpRecursivePrefixTreeTest.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.prefix.RecursivePrefixTreeStrategy.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.NumberRangePrefixTreeStrategy.java</file><file>lucene.spatial.src.java.org.apache.lucene.spatial.prefix.tree.TreeCellIterator.java</file></fixedFiles></bug><bug fixdate="2014-11-11 06:05:59" id="4400" opendate="2012-09-17 04:46:33"><buginformation><summary>[LUCENE-4400] add support for new commons-codec encoder (nysiis) - ASF JIRA</summary><description>From Thomas on LUCENE-3720: btw. the next release will happen quite soon afaik and will also include a new phonetic encoder called Nysiis, which should perform slightly better than Soundex (see https://issues.apache.org/jira/browse/CODEC-63). Any feedback is very welcome! I didn't do this in LUCENE-3720 because I wanted to fix the bug separately, but this should be pretty easy to add.</description></buginformation><fixedFiles><file>src.test.org.apache.lucene.analysis.phonetic.TestPhoneticFilterFactory.java</file><file>src.java.org.apache.lucene.analysis.phonetic.PhoneticFilterFactory.java</file><file>src.test.org.apache.lucene.analysis.phonetic.TestPhoneticFilter.java</file></fixedFiles></bug></bugrepository>