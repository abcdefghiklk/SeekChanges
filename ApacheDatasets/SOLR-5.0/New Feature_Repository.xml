<?xml version="1.0" encoding="UTF-8" standalone="no"?><bugrepository><bug fixdate="2015-01-12 01:34:13" id="6916" opendate="2015-01-06 01:37:42"><buginformation><summary>[SOLR-6916] Option to use payloads with default highlighter - ASF JIRA</summary><description>MemoryIndex can now store payloads ( LUCENE-6155), and there's a corresponding boolean flag setter on QueryScorer (used by the default highlighter). We should add a parameter to toggle this. It will only take effect if hl.usePhraseHighlighter=true and the source of the tokens comes from re-analysis. This settings is ignored if the tokens come from term vectors which support payloads already (in Lucene/Solr 5) provided they are there. I suggest naming this boolean parameter hl.payloads.</description></buginformation><fixedFiles><file>solr.solrj.src.java.org.apache.solr.common.params.HighlightParams.java</file><file>solr.core.src.java.org.apache.solr.highlight.DefaultSolrHighlighter.java</file></fixedFiles></bug><bug fixdate="2015-01-07 04:15:33" id="6761" opendate="2014-11-19 04:04:57"><buginformation><summary>[SOLR-6761] Ability to ignore commit and optimize requests from clients when running in SolrCloud mode. - ASF JIRA</summary><description>In most SolrCloud environments, it's advisable to only rely on auto-commits (soft and hard) configured in solrconfig.xml and not send explicit commit requests from client applications. In fact, I've seen cases where improperly coded client applications can send commit requests too frequently, which can lead to harming the cluster's health. As a system administrator, I'd like the ability to disallow commit requests from client applications. Ideally, I could configure the updateHandler to ignore the requests and return an HTTP response code of my choosing as I may not want to break existing client applications by returning an error. In other words, I may want to just return 200 vs. 405. The same goes for optimize requests.</description></buginformation><fixedFiles><file>solr.core.src.java.org.apache.solr.update.processor.IgnoreCommitOptimizeUpdateProcessorFactory.java</file><file>solr.core.src.java.org.apache.solr.update.processor.IgnoreCommitUpdateProcessorFactory.java</file><file>solr.core.src.test.org.apache.solr.update.processor.IgnoreCommitOptimizeUpdateProcessorFactoryTest.java</file></fixedFiles></bug><bug fixdate="2014-10-17 05:36:32" id="6517" opendate="2014-09-13 10:54:15"><buginformation><summary>[SOLR-6517] CollectionsAPI call REBALANCELEADERS - ASF JIRA</summary><description>Perhaps the final piece of SOLR-6491. Once the preferred leadership roles are assigned, there has to be a command "make it so Mr. Solr". This is something of a placeholder to collect ideas. One wouldn't want to flood the system with hundreds of re-assignments at once. Should this be synchronous or asnych? Should it make the best attempt but not worry about perfection? Should it??? a collection=name parameter would be required and it would re-elect all the leaders that were on the 'wrong' node I'm thinking an optionally allowing one to specify a shard in the case where you wanted to make a very specific change. Note that there's no need to specify a particular replica, since there should be only a single preferredLeader per slice. This command would do nothing to any slice that did not have a replica with a preferredLeader role. Likewise it would do nothing if the slice in question already had the leader role assigned to the node with the preferredLeader role.</description></buginformation><fixedFiles><file>solr.core.src.java.org.apache.solr.cloud.ElectionContext.java</file><file>solr.core.src.java.org.apache.solr.cloud.ZkController.java</file><file>solr.core.src.test.org.apache.solr.cloud.OverseerRolesTest.java</file><file>solr.core.src.java.org.apache.solr.handler.admin.CollectionsHandler.java</file><file>solr.core.src.java.org.apache.solr.cloud.Overseer.java</file><file>solr.core.src.test.org.apache.solr.cloud.TestReplicaProperties.java</file><file>solr.solrj.src.java.org.apache.solr.common.cloud.ZkStateReader.java</file><file>solr.core.src.java.org.apache.solr.cloud.LeaderElector.java</file><file>solr.solrj.src.java.org.apache.solr.common.params.CollectionParams.java</file><file>solr.core.src.test.org.apache.solr.cloud.RollingRestartTest.java</file><file>solr.core.src.java.org.apache.solr.cloud.OverseerCollectionProcessor.java</file></fixedFiles></bug><bug fixdate="2014-12-01 03:58:01" id="6476" opendate="2014-09-03 08:42:12"><buginformation><summary>[SOLR-6476] Create a bulk mode for schema API - ASF JIRA</summary><description>The current schema API does one operation at a time and the normal usecase is that users add multiple fields/fieldtypes/copyFields etc in one shot. example &#13;
curl http://localhost:8983/solr/collection1/schema -H 'Content-type:application/json'  -d '{&#13;
    "add-field": {&#13;
        "name":"sell-by",&#13;
        "type":"tdate",&#13;
        "stored":true&#13;
    },&#13;
    "add-field":{&#13;
        "name":"catchall",&#13;
        "type":"text_general",&#13;
        "stored":false&#13;
    }&#13;
}&#13;
 or &#13;
curl http://localhost:8983/solr/collection1/schema -H 'Content-type:application/json'  -d '{&#13;
    "add-field":[ {&#13;
        "name":"sell-by",&#13;
        "type":"tdate",&#13;
        "stored":true&#13;
    },&#13;
    {&#13;
        "name":"catchall",&#13;
        "type":"text_general",&#13;
        "stored":false&#13;
    }]&#13;
}</description></buginformation><fixedFiles><file>solr.core.src.java.org.apache.solr.rest.schema.BaseFieldTypeResource.java</file><file>solr.core.src.java.org.apache.solr.rest.schema.FieldCollectionResource.java</file><file>solr.core.src.java.org.apache.solr.rest.schema.FieldTypeCollectionResource.java</file><file>solr.core.src.java.org.apache.solr.rest.schema.DynamicFieldResource.java</file><file>solr.core.src.java.org.apache.solr.schema.IndexSchema.java</file><file>solr.core.src.test.org.apache.solr.schema.TestSchemaManager.java</file><file>solr.core.src.java.org.apache.solr.rest.schema.CopyFieldCollectionResource.java</file><file>solr.core.src.test.org.apache.solr.rest.schema.TestBulkSchemaAPI.java</file><file>solr.core.src.java.org.apache.solr.schema.SchemaManager.java</file><file>solr.core.src.java.org.apache.solr.rest.schema.FieldTypeResource.java</file><file>solr.core.src.java.org.apache.solr.rest.schema.DynamicFieldCollectionResource.java</file><file>solr.core.src.test.org.apache.solr.schema.TestBulkSchemaConcurrent.java</file><file>solr.core.src.java.org.apache.solr.schema.ManagedIndexSchema.java</file><file>solr.core.src.java.org.apache.solr.rest.schema.SchemaResource.java</file></fixedFiles></bug><bug fixdate="2015-01-12 11:57:11" id="6248" opendate="2014-07-15 06:20:29"><buginformation><summary>[SOLR-6248] MoreLikeThis Query Parser - ASF JIRA</summary><description>MLT Component doesn't let people highlight/paginate and the handler comes with an cost of maintaining another piece in the config. Also, any changes to the default (number of results to be fetched etc.) /select handler need to be copied/synced with this handler too. Having an MLT QParser would let users get back docs based on a query for them to paginate, highlight etc. It would also give them the flexibility to use this anywhere i.e. q,fq,bq etc. A bit of history about MLT (thanks to Hoss) MLT Handler pre-dates the existence of QParsers and was meant to take an arbitrary query as input, find docs that match that query, club them together to find interesting terms, and then use those terms as if they were my main query to generate a main result set. This result would then be used as the set to facet, highlight etc. The flow: Query -&gt; DocList(m) -&gt; Bag (terms) -&gt; Query -&gt; DocList(y) The MLT component on the other hand solved a very different purpose of augmenting the main result set. It is used to get similar docs for each of the doc in the main result set. DocSet(n) -&gt; n * Bag (terms) -&gt; n * (Query) -&gt; n * DocList(m) The new approach: All of this can be done better and cleaner (and makes more sense too) using an MLT QParser. An important thing to handle here is the case where the user doesn't have TermVectors, in which case, it does what happens right now i.e. parsing stored fields. Also, in case the user doesn't have a field (to be used for MLT) indexed, the field would need to be a TextField with an index analyzer defined. This analyzer will then be used to extract terms for MLT. In case of SolrCloud mode, '/get-termvectors' can be used after looking at the schema (if TermVectors are enabled for the field). If not, a /get call can be used to fetch the field and parse it.</description></buginformation><fixedFiles><file>solr.core.src.test.org.apache.solr.handler.SimpleMLTQParserTest.java</file><file>solr.core.src.test.org.apache.solr.handler.DistributedCloudMLTQParserTest.java</file><file>lucene.queries.src.java.org.apache.lucene.queries.mlt.MoreLikeThis.java</file><file>solr.core.src.test.org.apache.solr.search.mlt.SimpleMLTQParserTest.java</file><file>solr.core.src.java.org.apache.solr.search.mlt.SolrCloudMLTQParser.java</file><file>solr.core.src.java.org.apache.solr.search.mlt.LWMoreLikeThis.java</file><file>solr.core.src.java.org.apache.solr.search.mlt.SimpleMLTQParser.java</file><file>solr.core.src.test.org.apache.solr.search.mlt.CloudMLTQParserTest.java</file><file>solr.core.src.java.org.apache.solr.search.mlt.CloudMLTQParser.java</file><file>solr.core.src.test.org.apache.solr.handler.CloudMLTQParserTest.java</file><file>solr.core.src.java.org.apache.solr.search.mlt.MLTQParserPlugin.java</file><file>solr.core.src.test.org.apache.solr.handler.SingleMLTQParserTest.java</file><file>solr.core.src.java.org.apache.solr.search.mlt.MLTQueryParser.java</file><file>solr.core.src.test.org.apache.solr.search.QueryEqualityTest.java</file><file>solr.core.src.java.org.apache.solr.search.QParserPlugin.java</file></fixedFiles></bug><bug fixdate="2014-06-05 03:07:20" id="6103" opendate="2014-05-21 03:28:46"><buginformation><summary>[SOLR-6103] Add DateRangeField - ASF JIRA</summary><description>LUCENE-5648 introduced a date range index &amp; search capability in the spatial module. This issue is for a corresponding Solr FieldType to be named "DateRangeField". LUCENE-5648 includes a parseCalendar(String) method that parses a superset of Solr's strict date format. It also parses partial dates (e.g.: 2014-10 has month specificity), and the trailing 'Z' is optional, and a leading +/- may be present (minus indicates BC era), and "*" means all-time. The proposed field type would use it to parse a string and also both ends of a range query, but furthermore it will also allow an arbitrary range query of the form &lt;calspec&gt; TO &lt;calspec&gt; such as: 2000 TO 2014-05-21T10 Which parses as the year 2000 thru 2014 May 21st 10am (GMT). I suggest this syntax because it is aligned with Lucene's range query syntax.</description></buginformation><fixedFiles><file>solr.core.src.java.org.apache.solr.schema.AbstractSpatialFieldType.java</file><file>solr.core.src.test.org.apache.solr.schema.DateRangeFieldTest.java</file></fixedFiles></bug><bug fixdate="2014-04-05 12:14:39" id="5302" opendate="2013-10-04 02:57:51"><buginformation><summary>[SOLR-5302] Analytics Component - ASF JIRA</summary><description>This ticket is to track a "replacement" for the StatsComponent. The AnalyticsComponent supports the following features: All functionality of StatsComponent (SOLR-4499) Field Faceting ( SOLR-3435) Support for limit Sorting (bucket name or any stat in the bucket Support for offset Range Faceting Supports all options of standard range faceting Query Faceting (SOLR-2925) Ability to use overall/field facet statistics as input to range/query faceting (ie calc min/max date and then facet over that range Support for more complex aggregate/mapping operations (SOLR-1622) Aggregations: min, max, sum, sum-of-square, count, missing, stddev, mean, median, percentiles Operations: negation, abs, add, multiply, divide, power, log, date math, string reversal, string concat Easily pluggable framework to add additional operations New / cleaner output format Outstanding Issues: Multi-value field support for stats (supported for faceting) Multi-shard support (may not be possible for some operations, eg median)</description></buginformation><fixedFiles><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.MultiplyDoubleFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.expression.MultiDelegateExpression.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.PercentileCalculator.java</file><file>solr.core.src.java.org.apache.solr.analytics.request.QueryFacetRequest.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.DateMathFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.request.AbstractFieldFacetRequest.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.AnalyticsParams.java</file><file>solr.core.src.java.org.apache.solr.analytics.accumulator.ValueAccumulator.java</file><file>solr.core.src.java.org.apache.solr.analytics.accumulator.facet.RangeFacetAccumulator.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.NegateDoubleFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.plugin.AnalyticsStatisticsCollector.java</file><file>solr.core.src.java.org.apache.solr.analytics.request.FacetRequest.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.FilterFieldSource.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.RangeEndpointCalculator.java</file><file>solr.core.src.test.org.apache.solr.analytics.facet.AbstractAnalyticsFacetTest.java</file><file>solr.core.src.java.org.apache.solr.analytics.accumulator.FacetingAccumulator.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.AddDoubleFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.DivDoubleFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.statistics.AbstractDelegatingStatsCollector.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.MultiDoubleFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.accumulator.BasicAccumulator.java</file><file>solr.core.src.java.org.apache.solr.analytics.expression.ExpressionFactory.java</file><file>solr.core.src.java.org.apache.solr.analytics.request.AnalyticsContentHandler.java</file><file>solr.core.src.java.org.apache.solr.analytics.expression.BaseExpression.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.MissFieldSource.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.ConstStringSource.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.AnalyticsParsers.java</file><file>solr.core.src.test.org.apache.solr.analytics.facet.FieldFacetTest.java</file><file>solr.core.src.test.org.apache.solr.analytics.facet.QueryFacetTest.java</file><file>solr.core.src.java.org.apache.solr.analytics.expression.Expression.java</file><file>solr.core.src.java.org.apache.solr.core.SolrCore.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.DateFieldSource.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.LogDoubleFunction.java</file><file>solr.core.src.java.org.apache.solr.handler.component.SearchHandler.java</file><file>solr.core.src.java.org.apache.solr.analytics.request.RangeFacetRequest.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.ConcatStringFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.accumulator.facet.FacetValueAccumulator.java</file><file>solr.core.src.java.org.apache.solr.analytics.expression.DualDelegateExpression.java</file><file>solr.core.src.java.org.apache.solr.analytics.statistics.UniqueStatsCollector.java</file><file>solr.core.src.test.org.apache.solr.analytics.AbstractAnalyticsStatsTest.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.PowDoubleFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.statistics.NumericStatsCollector.java</file><file>solr.core.src.java.org.apache.solr.analytics.statistics.StatsCollector.java</file><file>solr.core.src.java.org.apache.solr.analytics.expression.SingleDelegateExpression.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.ReverseStringFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.MultiStringFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.MedianCalculator.java</file><file>solr.core.src.java.org.apache.solr.analytics.statistics.MedianStatsCollector.java</file><file>solr.core.src.java.org.apache.solr.analytics.statistics.MinMaxStatsCollector.java</file><file>solr.core.src.java.org.apache.solr.analytics.accumulator.facet.FieldFacetAccumulator.java</file><file>solr.core.src.java.org.apache.solr.analytics.accumulator.facet.QueryFacetAccumulator.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.ConstDoubleSource.java</file><file>solr.core.src.test.org.apache.solr.analytics.AnalyticsStatsTest.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.DualDoubleFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.request.AnalyticsStats.java</file><file>solr.core.src.java.org.apache.solr.analytics.statistics.PercentileStatsCollector.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.SingleDoubleFunction.java</file><file>solr.core.src.test.org.apache.solr.analytics.NoFacetTest.java</file><file>solr.core.src.test.org.apache.solr.analytics.facet.FieldFacetExtrasTest.java</file><file>solr.core.src.test.org.apache.solr.analytics.facet.FacetTest.java</file><file>solr.core.src.java.org.apache.solr.analytics.statistics.StatsCollectorSupplierFactory.java</file><file>solr.core.src.test.org.apache.solr.analytics.util.valuesource.FunctionTest.java</file><file>solr.core.src.java.org.apache.solr.handler.component.AnalyticsComponent.java</file><file>solr.core.src.java.org.apache.solr.analytics.request.ExpressionRequest.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.SingleStringFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.request.AnalyticsRequestFactory.java</file><file>solr.core.src.test.org.apache.solr.analytics.expression.ExpressionTest.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.AbsoluteValueDoubleFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.MultiDateFunction.java</file><file>solr.core.src.java.org.apache.solr.analytics.request.AnalyticsRequest.java</file><file>solr.core.src.test.org.apache.solr.analytics.facet.RangeFacetTest.java</file><file>solr.core.src.java.org.apache.solr.analytics.util.valuesource.ConstDateSource.java</file><file>solr.core.src.java.org.apache.solr.analytics.request.FieldFacetRequest.java</file></fixedFiles></bug><bug fixdate="2014-08-22 01:12:41" id="4895" opendate="2013-06-04 12:30:42"><buginformation><summary>[SOLR-4895] Throw an error when a rollback is attempted in SolrCloud mode. - ASF JIRA</summary><description/></buginformation><fixedFiles><file>solr.core.src.java.org.apache.solr.update.processor.RunUpdateProcessorFactory.java</file><file>solr.core.src.java.org.apache.solr.update.DirectUpdateHandler2.java</file></fixedFiles></bug><bug fixdate="2014-12-03 12:09:32" id="4799" opendate="2013-05-08 02:04:03"><buginformation><summary>[SOLR-4799] DIH: join="zipper" aka merge join for nested EntityProcessors - ASF JIRA</summary><description>DIH is mostly considered as a playground tool, and real usages end up with SolrJ. I want to contribute few improvements target DIH performance. This one provides performant approach for joining SQL Entities with miserable memory at contrast to http://wiki.apache.org/solr/DataImportHandler#CachedSqlEntityProcessor The idea is: parent table is explicitly ordered by it’s PK in SQL children table is explicitly ordered by parent_id FK in SQL children entity processor joins ordered resultsets by ‘zipper’ algorithm. example usage for what's committed: &#13;
&lt;dataConfig&gt;&#13;
	&lt;document&gt;&#13;
		&lt;entity name="parent" processor="SqlEntityProcessor" query="SELECT * FROM PARENT ORDER BY id"&gt;		&#13;
			&lt;entity name="child_1" processor="SqlEntityProcessor"&#13;
				where="parent_id=parent.id" query="SELECT * FROM CHILD_1 ORDER BY parent_id" join="zipper" &gt;&#13;
			&lt;/entity&gt;			&#13;
		&lt;/entity&gt;&#13;
	&lt;/document&gt;&#13;
&lt;/dataConfig&gt;&#13;
 mind about: ordering both sides specifying join="zipper" at children entity note that it works with any entity processors</description></buginformation><fixedFiles><file>a.solr.contrib.dataimporthandler-extras.src.java.org.apache.solr.handler.dataimport.TikaEntityProcessor.java</file><file>a.solr.contrib.dataimporthandler.src.java.org.apache.solr.handler.dataimport.DIHCacheSupport.java</file><file>a.solr.contrib.dataimporthandler.src.java.org.apache.solr.handler.dataimport.EntityProcessorBase.java</file><file>a.solr.contrib.dataimporthandler.src.test.org.apache.solr.handler.dataimport.MockSolrEntityProcessor.java</file><file>a.solr.contrib.dataimporthandler.src.test.org.apache.solr.handler.dataimport.TestSolrEntityProcessorUnit.java</file><file>a.solr.contrib.dataimporthandler.src.test.org.apache.solr.handler.dataimport.AbstractSqlEntityProcessorTestCase.java</file><file>a.solr.contrib.dataimporthandler.src.test.org.apache.solr.handler.dataimport.TestSqlEntityProcessor.java</file></fixedFiles></bug><bug fixdate="2015-01-11 03:21:11" id="4580" opendate="2013-03-14 07:13:56"><buginformation><summary>[SOLR-4580] Support for protecting content in ZK - ASF JIRA</summary><description>We want to protect content in zookeeper. In order to run a CloudSolrServer in "client-space" you will have to open for access to zookeeper from client-space. If you do not trust persons or systems in client-space you want to protect zookeeper against evilness from client-space - e.g. Changing configuration Trying to mess up system by manipulating clusterstate Add a delete-collection job to be carried out by the Overseer etc Even if you do not open for zookeeper access to someone outside your "secure zone" you might want to protect zookeeper content from being manipulated by e.g. Malware that found its way into secure zone Other systems also using zookeeper etc.</description></buginformation><fixedFiles><file>solr.core.src.test.org.apache.solr.cloud.OverseerCollectionProcessorTest.java</file><file>solr.core.src.test.org.apache.solr.cloud.OverriddenZkACLAndCredentialsProvidersTest.java</file><file>solr.solrj.src.java.org.apache.solr.common.cloud.VMParamsAllAndReadonlyDigestZkACLProvider.java</file><file>solr.core.src.java.org.apache.solr.cloud.SolrZkServer.java</file><file>solr.solrj.src.java.org.apache.solr.common.cloud.ZkCmdExecutor.java</file><file>solr.core.src.java.org.apache.solr.core.ConfigSolr.java</file><file>solr.core.src.test.org.apache.solr.cloud.VMParamsZkACLAndCredentialsProvidersTest.java</file><file>solr.core.src.java.org.apache.solr.cloud.Overseer.java</file><file>solr.solrj.src.java.org.apache.solr.common.cloud.SolrZkClient.java</file><file>solr.core.src.test.org.apache.solr.cloud.OutOfBoxZkACLAndCredentialsProvidersTest.java</file><file>solr.solrj.src.java.org.apache.solr.common.cloud.ZkACLProvider.java</file><file>solr.solrj.src.java.org.apache.solr.common.StringUtils.java</file><file>solr.test-framework.src.java.org.apache.solr.cloud.MiniSolrCloudCluster.java</file><file>solr.core.src.java.org.apache.solr.core.ConfigSolrXmlOld.java</file><file>solr.solrj.src.java.org.apache.solr.common.cloud.VMParamsSingleSetCredentialsDigestZkCredentialsProvider.java</file><file>solr.core.src.java.org.apache.solr.cloud.DistributedMap.java</file><file>solr.core.src.java.org.apache.solr.core.ZkContainer.java</file><file>solr.core.src.java.org.apache.solr.cloud.ZkController.java</file><file>solr.core.src.java.org.apache.solr.core.ConfigSolrXml.java</file><file>solr.solrj.src.java.org.apache.solr.common.cloud.DefaultZkCredentialsProvider.java</file><file>solr.core.src.java.org.apache.solr.cloud.DistributedQueue.java</file><file>solr.solrj.src.java.org.apache.solr.common.cloud.DefaultConnectionStrategy.java</file><file>solr.solrj.src.java.org.apache.solr.common.cloud.DefaultZkACLProvider.java</file><file>solr.solrj.src.java.org.apache.solr.common.cloud.ZkCredentialsProvider.java</file><file>solr.solrj.src.java.org.apache.solr.common.cloud.ZkClientConnectionStrategy.java</file><file>solr.core.src.java.org.apache.solr.cloud.ZkCLI.java</file></fixedFiles></bug><bug fixdate="2015-03-13 07:33:34" id="1632" opendate="2009-12-08 04:17:20"><buginformation><summary>[SOLR-1632] Distributed IDF - ASF JIRA</summary><description>Distributed IDF is a valuable enhancement for distributed search across non-uniform shards. This issue tracks the proposed implementation of an API to support this functionality in Solr.</description></buginformation><fixedFiles><file>solr.test-framework.src.java.org.apache.solr.SolrTestCaseJ4.java</file><file>solr.core.src.java.org.apache.solr.search.stats.LRUStatsCache.java</file><file>trunk.src.java.org.apache.solr.handler.component.SearchHandler.java</file><file>src.java.org.apache.solr.search.ExactDFCache.java</file><file>solr.test-framework.src.java.org.apache.solr.BaseDistributedSearchTestCase.java</file><file>a.solr.core.src.java.org.apache.solr.handler.component.ShardRequest.java</file><file>solr.core.src.java.org.apache.solr.search.stats.LocalStatsSource.java</file><file>trunk.src.java.org.apache.solr.handler.component.ShardRequest.java</file><file>solr.core.src.java.org.apache.solr.search.stats.StatsUtil.java</file><file>a.solr.core.src.java.org.apache.solr.handler.component.SearchHandler.java</file><file>src.java.org.apache.solr.handler.component.ShardRequest.java</file><file>src.java.org.apache.solr.handler.component.QueryComponent.java</file><file>solr.core.src.java.org.apache.solr.search.stats.ExactSharedStatsCache.java</file><file>solr.core.src.java.org.apache.solr.search.stats.StatsSource.java</file><file>solr.core.src.java.org.apache.solr.search.DFCache.java</file><file>solr.core.src.java.org.apache.solr.search.stats.ExactStatsCache.java</file><file>solr.core.src.java.org.apache.solr.search.DefaultDFCache.java</file><file>trunk.src.java.org.apache.solr.search.DFCache.java</file><file>src.java.org.apache.solr.handler.component.SearchHandler.java</file><file>a.solr.core.src.java.org.apache.solr.core.SolrCore.java</file><file>solr.core.src.java.org.apache.solr.handler.component.ShardRequest.java</file><file>trunk.src.test.org.apache.solr.search.TestLRUDFCache.java</file><file>solr.solrj.src.java.org.apache.solr.common.params.ShardParams.java</file><file>solr.core.src.java.org.apache.solr.search.stats.TermStats.java</file><file>solr.core.src.java.org.apache.solr.search.ExactDFCache.java</file><file>solr.core.src.test.org.apache.solr.search.stats.TestLRUStatsCache.java</file><file>trunk.src.java.org.apache.solr.handler.component.QueryComponent.java</file><file>trunk.src.java.org.apache.solr.core.SolrCore.java</file><file>src.java.org.apache.solr.core.SolrCore.java</file><file>trunk.src.java.org.apache.solr.util.SolrPluginUtils.java</file><file>solr.core.src.java.org.apache.solr.search.stats.StatsCache.java</file><file>trunk.src.common.org.apache.solr.common.params.ShardParams.java</file><file>a.solr.core.src.java.org.apache.solr.handler.component.QueryComponent.java</file><file>solr.core.src.java.org.apache.solr.search.LRUDFCache.java</file><file>solr.core.src.test.org.apache.solr.search.TestExactDFCache.java</file><file>solr.core.src.java.org.apache.solr.search.stats.DefaultStatsCache.java</file><file>solr.core.src.java.org.apache.solr.handler.component.QueryComponent.java</file><file>trunk.src.java.org.apache.solr.search.ExactDFCache.java</file><file>trunk.src.java.org.apache.solr.search.SolrIndexSearcher.java</file><file>solr.core.src.java.org.apache.solr.search.stats.CollectionStats.java</file><file>solr.core.src.test.org.apache.solr.search.TestDefaultDFCache.java</file><file>solr.core.src.java.org.apache.solr.search.DFSource.java</file><file>a.solr.core.src.java.org.apache.solr.search.SolrIndexSearcher.java</file><file>trunk.src.test.org.apache.solr.search.TestExactDFCache.java</file><file>a.solr.test-framework.src.java.org.apache.solr.BaseDistributedSearchTestCase.java</file><file>trunk.src.java.org.apache.solr.core.SolrConfig.java</file><file>src.java.org.apache.solr.search.DFCache.java</file><file>solr.core.src.test.org.apache.solr.search.stats.TestBaseStatsCache.java</file><file>solr.core.src.java.org.apache.solr.util.SolrPluginUtils.java</file><file>solr.core.src.java.org.apache.solr.search.stats.CachedSearcherStats.java</file><file>trunk.src.java.org.apache.solr.search.DefaultDFCache.java</file><file>trunk.src.java.org.apache.solr.search.LRUDFCache.java</file><file>src.java.org.apache.solr.search.SolrIndexSearcher.java</file><file>trunk.src.java.org.apache.solr.search.DFSource.java</file><file>a.solr.core.src.java.org.apache.solr.core.SolrConfig.java</file><file>a.solr.solrj.src.java.org.apache.solr.common.params.ShardParams.java</file><file>solr.core.src.java.org.apache.solr.core.SolrConfig.java</file><file>solr.core.src.test.org.apache.solr.search.stats.TestDefaultStatsCache.java</file><file>solr.core.src.java.org.apache.solr.search.stats.LocalStatsCache.java</file><file>solr.core.src.java.org.apache.solr.search.SolrIndexSearcher.java</file><file>solr.core.src.java.org.apache.solr.core.SolrCore.java</file><file>solr.core.src.java.org.apache.solr.handler.component.SearchHandler.java</file><file>trunk.src.test.org.apache.solr.search.TestDefaultDFCache.java</file><file>solr.core.src.test.org.apache.solr.search.stats.TestExactStatsCache.java</file><file>src.java.org.apache.solr.core.SolrConfig.java</file><file>solr.core.src.test.org.apache.solr.search.stats.TestExactSharedStatsCache.java</file><file>src.java.org.apache.solr.search.DFSource.java</file><file>solr.core.src.test.org.apache.solr.search.TestLRUDFCache.java</file><file>src.java.org.apache.solr.util.SolrPluginUtils.java</file></fixedFiles></bug></bugrepository>