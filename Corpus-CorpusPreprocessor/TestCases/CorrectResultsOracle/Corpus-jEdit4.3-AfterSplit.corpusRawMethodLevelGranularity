public  abbrev editor  grid bag layout layout new  grid bag layout set layout layout  grid bag constraints cons new  grid bag constraints cons anchor cons west cons fill cons both cons weightx f cons gridx cons gridy j label label new j label j edit get property abbrev editor abbrev  swing constants right label set border new  empty border layout set constraints label cons add label cons gridx cons weightx f abbrev new j text field layout set constraints abbrev cons add abbrev cons gridx cons weightx f cons gridwidth cons gridy label new j label j edit get property abbrev editor before label set border new  empty border layout set constraints label cons add label cons gridy cons weighty f before caret new j text area j scroll pane scroller new j scroll pane before caret layout set constraints scroller cons add scroller cons gridy cons weighty f label new j label j edit get property abbrev editor after label set border new  empty border layout set constraints label cons add label cons gridy cons weighty f after caret new j text area scroller new j scroll pane after caret layout set constraints scroller cons add scroller 
public  string get abbrev return abbrev get text 
public void set abbrev  string abbrev this abbrev set text abbrev 
public  string get expansion  string builder buf new  string builder  string before caret text before caret get text  string after caret text after caret get text for int i i before caret text length i char ch before caret text char at i switch ch case n buf append n break case t buf append t break case buf append break default buf append ch break if after caret text length buf append for int i i after caret text length i char ch after caret text char at i switch ch case n buf append n break case t buf append t break case buf append break default buf append ch break return buf to string 
public void set expansion  string expansion if expansion null before caret set text null after caret set text null return  string before caret text null  string after caret text null  string builder buf new  string builder for int i i expansion length i char ch expansion char at i if ch i expansion length ch expansion char at i switch ch case t buf append t break case n buf append n break case before caret text buf to string buf set length break default buf append ch break else buf append ch if before caret text null before caret text buf to string else after caret text buf to string before caret set text before caret text after caret set text after caret text 
public j text field get abbrev field return abbrev 
public j text area get before caret text area return before caret 
public j text area get after caret text area return after caret 
 returns if abbreviations should be expanded after the user finishes typing a word public static boolean get expand on input return expand on input 
 sets if abbreviations should be expanded after the user finishes typing a word param expand on input  if true typing a non alphanumeric character will automatically attempt to expand the current abbrev public static void set expand on input boolean expand on input  abbrevs expand on input expand on input 
 expands the abbrev at the caret position in the specified view param view  the view param add  if true and abbrev not found will ask user if it should be added since j edit pre public static boolean expand abbrev  view view boolean add  figure out some minor things  buffer buffer view get buffer j edit text area text area view get text area if buffer is editable view get toolkit beep return false int line text area get caret line int line start buffer get line start offset line int caret text area get caret position  string line text buffer get line text line if line text length if add view get toolkit beep return false int pos caret line start if pos if add view get toolkit beep return false we reuse the pp vector to save time m pp remove all elements int word start  string abbrev  handle abbrevs of the form abbrev pos pos pos if line text char at pos word start line text index of word start  text utilities find word start line text word start buffer get string property no word sep abbrev line text substring word start pos positional parameters will be inserted where occurs in the expansion int last index for int i i abbrev length i if abbrev char at i m pp add element abbrev substring last index i last index i m pp add element abbrev substring last index the first element of pp is the abbrev itself abbrev m pp element at m pp remove element at  handle ordinary abbrevs else word start  text utilities find word start line text pos buffer get string property no word sep abbrev line text substring word start pos  expansion expand expand abbrev buffer get mode get name abbrev buffer get boolean property no tabs buffer get tab size m pp  maybe show add abbrev dialog if expand null if add new  add abbrev dialog view abbrev return false  insert the expansion else buffer remove line start word start pos word start int whitespace buffer insert indented line start word start expand text int newlines count newlines expand text expand caret position if expand caret position text area set caret position line start word start expand caret position newlines whitespace if expand pos param count m pp size view get status set message and clear j edit get property view status incomplete abbrev new  integer  integer value of m pp size  integer value of expand pos param count return true 
 returns the global abbreviation set since j edit pre public static  hashtable  string  string get global abbrevs if loaded load return global abbrevs 
 sets the global abbreviation set param global abbrevs  the new global abbrev set since j edit pre public static void set global abbrevs  hashtable  string  string global abbrevs abbrevs changed true  abbrevs global abbrevs global abbrevs 
 returns the mode specific abbreviation set since j edit pre public static  hashtable  string  hashtable  string  string get mode abbrevs if loaded load return modes 
 sets the mode specific abbreviation set param modes  the new mode abbrev set since j edit pre public static void set mode abbrevs  hashtable  string  hashtable  string  string modes abbrevs changed true  abbrevs modes modes 
 adds an abbreviation to the global abbreviation list param abbrev  the abbreviation param expansion  the expansion since j edit pre public static void add global abbrev  string abbrev  string expansion if loaded load global abbrevs put abbrev expansion abbrevs changed true 
 adds a mode specific abbrev param mode  the edit mode param abbrev  the abbrev param expansion  the expansion since j edit pre public static void add mode abbrev  string mode  string abbrev  string expansion if loaded load  hashtable  string  string mode abbrevs modes get mode if mode abbrevs null mode abbrevs new  hashtable  string  string modes put mode mode abbrevs mode abbrevs put abbrev expansion abbrevs changed true 
static void save j edit set boolean property view expand on input expand on input  string settings j edit get settings directory if abbrevs changed settings null  file file new  file  misc utilities construct path settings abbrevs save  file file new  file  misc utilities construct path settings abbrevs if file exists file last modified abbrevs mod time  log log  log warning  abbrevs class file changed on disk will not save abbrevs else j edit backup settings file file try save abbrevs new  output stream writer new  file output stream file encoding file delete file rename to file catch  exception e  log log  log error  abbrevs class  error while saving file  log log  log error  abbrevs class e abbrevs mod time file last modified 
private  abbrevs 
private static void load global abbrevs new  hashtable  string  string modes new  hashtable  string  hashtable  string  string  string settings j edit get settings directory if settings null  file file new  file  misc utilities construct path settings abbrevs abbrevs mod time file last modified try load abbrevs new  input stream reader new  file input stream file encoding loaded true catch  file not found exception fnf catch  exception e  log log  log error  abbrevs class  error while loading file  log log  log error  abbrevs class e only load global abbrevs if user abbrevs file could not be loaded if loaded try load abbrevs new  input stream reader  abbrevs class get resource as stream default abbrevs encoding catch  exception e  log log  log error  abbrevs class  error while loading default abbrevs  log log  log error  abbrevs class e loaded true 
private static int count newlines  string s int end int counter for int i i end i if s char at i n counter return counter 
private static  expansion expand abbrev  string mode  string abbrev int soft tab size  vector  string pp m pp pp if loaded load try mode specific abbrevs first  string expand null  hashtable  string  string mode abbrevs modes get mode if mode abbrevs null expand mode abbrevs get abbrev if expand null expand global abbrevs get abbrev if expand null return null else return new  expansion expand soft tab size m pp 
private static void load abbrevs  reader  in throws  exception  buffered reader in new  buffered reader  in try  hashtable  string  string current abbrevs global abbrevs  string line while line in read line null int index line index of if line length continue else if line starts with index if line equals global current abbrevs global abbrevs else  string mode line substring line length current abbrevs modes get mode if current abbrevs null current abbrevs new  hashtable  string  string modes put mode current abbrevs else if index current abbrevs put line substring index line substring index finally in close 
private static void save abbrevs  writer  out throws  exception  buffered writer out new  buffered writer  out  string line sep  system get property line separator write global abbrevs out write global out write line sep save abbrevs out global abbrevs write mode abbrevs  enumeration  string keys modes keys  enumeration  hashtable  string  string values modes elements while keys has more elements out write out write keys next element out write out write line sep save abbrevs out values next element out close 
private static void save abbrevs  writer out  hashtable  string  string abbrevs throws  exception  string line sep  system get property line separator  enumeration  string keys abbrevs keys  enumeration  string values abbrevs elements while keys has more elements  string abbrev keys next element out write abbrev out write out write values next element out write line sep 
 expansion  string text int soft tab size  list  string pp  string builder buf new  string builder boolean backslash false for int i i text length i char ch text char at i  handle backslash if backslash backslash false if ch caret position buf length else if ch n buf append n line count else if ch t if soft tab size buf append t else for int j j soft tab size j buf append else buf append ch else if ch backslash true  handle else if ch if i text length ch text char at i if  character is digit ch ch i int pos ch pos param count  math max pos pos param count n is indexed but vector contents is zero indexed if pos pp size buf append pp get pos else key will be key for example buf append else buf append at end is literal else buf append ch this text buf to string 
public  abbrevs option pane super abbrevs 
 override protected void  init set layout new  border layout j panel panel new j panel new  border layout expand on input new j check box j edit get property options abbrevs expand on input  abbrevs get expand on input panel add expand on input  border layout north j panel panel new j panel panel set layout new  box layout panel  box layout x axis panel set border new  empty border panel add  box create glue j label label new j label j edit get property options abbrevs set label set border new  empty border panel add label  map  string  hashtable  string  string  mode abbrevs  abbrevs get mode abbrevs mode abbrevs new  hash map  string  abbrevs model  mode modes j edit get modes  arrays sort modes new  standard utilities  string compare  mode true  string sets new  string modes length sets global for int i i modes length i  string name modes i get name sets i name mode abbrevs put name new  abbrevs model  mode abbrevs get name sets combo box new j combo box sets  action handler action handler new  action handler sets combo box add action listener action handler panel add sets combo box panel add  box create glue panel add panel  border layout south add  border layout north panel global abbrevs new  abbrevs model  abbrevs get global abbrevs abbrevs table new j table global abbrevs abbrevs table get column model get column set cell renderer new  renderer abbrevs table set auto resize mode j table auto resize all columns abbrevs table get table header set reordering allowed false abbrevs table get table header add mouse listener new  header mouse handler abbrevs table get selection model add list selection listener new  selection handler abbrevs table get selection model set selection mode  list selection model single selection abbrevs table add mouse listener new  table mouse handler  dimension d abbrevs table get preferred size d height  math min d height j scroll pane scroller new j scroll pane abbrevs table scroller set preferred size d add  border layout center scroller j panel buttons new j panel buttons set layout new  box layout buttons  box layout x axis buttons set border new  empty border add new  rollover button gui utilities load icon j edit get property options abbrevs add icon add set tool tip text j edit get property options abbrevs add add add action listener action handler buttons add add remove new  rollover button gui utilities load icon j edit get property options abbrevs remove icon remove set tool tip text j edit get property options abbrevs remove remove add action listener action handler buttons add remove edit new  rollover button gui utilities load icon j edit get property options abbrevs edit icon edit set tool tip text j edit get property options abbrevs edit edit add action listener action handler buttons add edit buttons add  box create glue add  border layout south buttons sets combo box set selected index j edit get integer property options abbrevs combobox index update enabled 
 override protected void  save if abbrevs table get cell editor null abbrevs table get cell editor stop cell editing  abbrevs set expand on input expand on input is selected  abbrevs set global abbrevs global abbrevs to hashtable  hashtable  string  hashtable  string  string mode hash new  hashtable  string  hashtable  string  string  set  map  entry  string  abbrevs model entry set mode abbrevs entry set for  map  entry  string  abbrevs model entry entry set mode hash put entry get key entry get value to hashtable  abbrevs set mode abbrevs mode hash 
private void update enabled int selected row abbrevs table get selected row edit set enabled selected row remove set enabled selected row 
private void edit  abbrevs model abbrevs model  abbrevs model abbrevs table get model int row abbrevs table get selected row  string abbrev  string abbrevs model get value at row  string expansion  string abbrevs model get value at row  string old abbrev abbrev  edit abbrev dialog dialog new  edit abbrev dialog gui utilities get parent dialog  abbrevs option pane this abbrev expansion abbrevs model to hashtable abbrev dialog get abbrev expansion dialog get expansion if abbrev null expansion null for int i i abbrevs model get row count i if abbrevs model get value at i equals old abbrev abbrevs model remove i break add abbrevs model abbrev expansion 
private void add  abbrevs model abbrevs model  string abbrev  string expansion for int i i abbrevs model get row count i if abbrevs model get value at i equals abbrev abbrevs model remove i break abbrevs model add abbrev expansion update enabled 
 override public void mouse clicked  mouse event evt switch abbrevs table get table header column at point evt get point case  abbrevs model abbrevs table get model sort break case  abbrevs model abbrevs table get model sort break 
 override public void mouse clicked  mouse event evt if evt get click count edit 
public void value changed  list selection event evt update enabled 
public void action performed  action event evt  abbrevs model abbrevs model  abbrevs model abbrevs table get model  object source evt get source if source sets combo box j edit set integer property options abbrevs combobox index sets combo box get selected index  string selected  string sets combo box get selected item if selected equals global abbrevs table set model global abbrevs else abbrevs table set model mode abbrevs get selected update enabled else if source add  edit abbrev dialog dialog new  edit abbrev dialog gui utilities get parent dialog  abbrevs option pane this null null abbrevs model to hashtable  string abbrev dialog get abbrev  string expansion dialog get expansion if abbrev null abbrev length expansion null expansion length add abbrevs model abbrev expansion else if source edit edit else if source remove int selected row abbrevs table get selected row abbrevs model remove selected row update enabled 
 override public  component get table cell renderer component j table table  object value boolean is selected boolean cell has focus int row int col  string value str value to string workaround for  swing s annoying processing of labels starting with html which often breaks if value str to lower case starts with html value str value str return super get table cell renderer component table value str is selected cell has focus row col 
 abbrevs model  map  string  string abbrev hash abbrevs new  vector  abbrev if abbrev hash null  set  map  entry  string  string entry set abbrev hash entry set for  map  entry  string  string entry entry set abbrevs add new  abbrev entry get key entry get value sort 
void sort int col last sort col  collections sort abbrevs new  abbrev compare col fire table data changed 
void add  string abbrev  string expansion abbrevs add new  abbrev abbrev expansion sort last sort 
void remove int index abbrevs remove index fire table structure changed 
public  hashtable  string  string to hashtable  hashtable  string  string hash new  hashtable  string  string for int i i abbrevs size i  abbrev abbrev abbrevs get i if abbrev abbrev length abbrev expand length hash put abbrev abbrev abbrev expand return hash 
public int get column count return 
public int get row count return abbrevs size 
public  object get value at int row int col  abbrev abbrev abbrevs get row switch col case return abbrev abbrev case return abbrev expand default return null 
 override public void set value at  object value int row int col if value null value  abbrev abbrev abbrevs get row if col abbrev abbrev  string value else abbrev expand  string value fire table rows updated row row 
 override public  string get column name int index switch index case return j edit get property options abbrevs abbrev case return j edit get property options abbrevs expand default return null 
 abbrev compare int col this col col 
public int compare  abbrev a  abbrev a if col  string abbrev a abbrev to lower case  string abbrev a abbrev to lower case return  standard utilities compare strings abbrev abbrev true else  string expand a expand to lower case  string expand a expand to lower case return  standard utilities compare strings expand expand true 
 abbrev 
 abbrev  string abbrev  string expand this abbrev abbrev this expand expand 
public  about dialog  view view super view j edit get property about title true set resizable false j button close btn new j button j edit get property common close close btn add action listener this get root pane set default button close btn j panel p new j panel new  border layout final  about panel about panel new  about panel j panel flow p new j panel new  flow layout flow p add close btn flow p add  box create rigid area new  dimension  dimension dim new  dimension p add  border layout west  box create rigid area dim p add  border layout east  box create rigid area dim p add  border layout north  box create rigid area new  dimension p add  border layout south flow p p add  border layout center about panel close btn set tool tip text j edit get property about navigate close btn add key listener new  key adapter public void key pressed  key event e about panel handle key event e set content pane p pack  dimension d  toolkit get default toolkit get screen size set location d width get width d height get height add window listener new  window adapter  override public void window closing  window event e close dialog set visible true 
public void action performed  action event e close dialog 
private void close dialog  about panel stop thread dispose 
 about panel  string mode if j edit get edit server null if j edit is background mode enabled mode j edit get property about mode server background else mode j edit get property about mode server else mode j edit get property about mode standalone  string args j edit get version mode  system get property java version s bottom line j edit get property about version args set font default font fm get font metrics default font  font metrics fm bottom get font metrics bottom line font i line height fm get height v lines new  vector  string image  image icon gui utilities load icon about png  media tracker tracker new  media tracker this tracker add image image get image try tracker wait for id catch  exception exc tell  about panel exc  dimension d new  dimension image get icon width image get icon height set size d set preferred size d w d width h d height i bottom line x offset w fm bottom string width s bottom line i bottom line y offset h i line height  string tokenizer st new  string tokenizer j edit get property about text n while st has more tokens v lines add st next token i line count v lines size i list height i line count i line height start thread update ui 
private void handle key event  key event e if e get key code  key event vk down skip drain false  collections rotate v lines else if e get key code  key event vk up skip drain false  collections rotate v lines else if e get key code  key event vk left e get key code  key event vk right e get key code  key event vk escape skip drain skip drain 
private void drain if skip drain return if buf image null pre computing all data that can be known at this time  dimension d get size buf image new  buffered image d width d height  buffered image type int rgb g buf image create graphics rectangle new  rectangle d  float i top padding d width d height i bottom padding i top padding makes sure every new line from below comes up smoothly cause it gets pre painted and clipped as needed i pipe line count int  math ceil rectangle height i line height y d height i bottom padding g set font default font gradient paint new  gradient paint rectangle width i top padding new  color rectangle width i top padding new  color g set rendering hint  rendering hints key antialiasing  rendering hints value antialias on g draw image image get image w h this g set font bottom line font g set paint new  color g draw string s bottom line i bottom line x offset i bottom line y offset  draw a highlight effect g set paint new  color g draw string s bottom line i bottom line x offset i bottom line y offset g set font default font g set paint  color black g draw rect w h g clip rectangle g set paint gradient paint int i drawn lines count y coor for int i i i line count i check whether the text line is above the canvas if so the code skips it y coor y i i line height if y coor i top padding continue good to go now draw only i pipe line count lines and get out from loop  string s line v lines get i int x w fm string width s line g draw string s line x y coor if i drawn lines count i pipe line count break y paint get graphics check if the end of the list has been reached if so rewind if y i list height i top padding y h i bottom padding 
 override public void update  graphics g paint g 
 override public void paint  graphics panel graphics if panel graphics null buf image null panel graphics draw image buf image w h this 
public void run try while do work drain  thread sleep sleep time catch  exception exc  log log  log error this exc do work false th null 
public void start thread if th null th new  thread this do work true th start 
public static void stop thread do work false 
public static void tell  object obj  string str obj null null obj to string j option pane show message dialog j edit get active view str  title 
 constructor that takes a name as an argument for use by subclasses param name  name of the option pane param caption  string to use as the caption of the context menu configuration list since j edit pre protected  abstract context option pane  string name  string caption super name this caption new j label caption 
 initializes the pane s ui protected void  init set layout new  border layout add  border layout north caption list model new  default list model reload context list get context menu list new j list list model list set selection mode  list selection model single selection list add list selection listener new  list handler add  border layout center new j scroll pane list buttons new j panel buttons set border new  empty border buttons set layout new  box layout buttons  box layout x axis  action handler action handler new  action handler add new  rollover button gui utilities load icon j edit get property options context add icon add set tool tip text j edit get property common add add add action listener action handler buttons add add buttons add  box create horizontal strut remove new  rollover button gui utilities load icon j edit get property options context remove icon remove set tool tip text j edit get property common remove remove add action listener action handler buttons add remove buttons add  box create horizontal strut move up new  rollover button gui utilities load icon j edit get property options context move up icon move up set tool tip text j edit get property common move up move up add action listener action handler buttons add move up buttons add  box create horizontal strut move down new  rollover button gui utilities load icon j edit get property options context move down icon move down set tool tip text j edit get property common move down move down add action listener action handler buttons add move down buttons add  box create glue add reset to defaults button reset new  rollover button gui utilities load icon j edit get property options context reset icon reset set tool tip text j edit get property options context reset reset add action listener action handler buttons add reset update buttons add  border layout south buttons 
 adds a widget to the buttons panel at the bottom  the component will be added at the very right of the button row separated from the normal buttons since j edit pre protected void add button j component c buttons add c 
public int compare  menu item obj  menu item obj return  standard utilities compare strings obj label obj label true 
protected void  save  string builder buf new  string builder for int i i list model get size i if i buf append buf append  menu item list model element at i action name save context menu buf to string 
private void update buttons int index list get selected index remove set enabled index list model get size move up set enabled index move down set enabled index index list model get size 
private void reload context list  string context menu list model clear  string tokenizer st new  string tokenizer context menu while st has more tokens  string action name st next token if action name equals list model add element new  abstract context option pane  menu item else  edit action action j edit get action action name if action null continue  string label action get label if label null continue list model add element new  abstract context option pane  menu item action name label 
 menu item  string action name  string label this action name action name this label gui utilities prettify menu label label 
public  string to string return label 
public void action performed  action event evt  object source evt get source if source add  context add dialog dialog new  context add dialog  abstract context option pane this  string selection dialog get selection if selection null return int index list get selected index if index index list model get size else index  menu item menu item if selection equals menu item new  abstract context option pane  menu item else menu item new  abstract context option pane  menu item selection j edit get action selection get label list model insert element at menu item index list set selected index index list ensure index is visible index else if source remove int index list get selected index list model remove element at index if list model get size list set selected index  math min list model get size index update buttons else if source move up int index list get selected index  object selected list get selected value list model remove element at index list model insert element at selected index list set selected index index list ensure index is visible index else if source move down int index list get selected index  object selected list get selected value list model remove element at index list model insert element at selected index list set selected index index list ensure index is visible index else if source reset  string dialog type options context reset dialog int result gui utilities confirm list dialog type null j option pane yes no option j option pane warning message if result j option pane yes option the user should be able to cancel the options dialog so we need to modify the list not the actual property since the default value is not available we reset fetch default value and re set to original  string org context j edit get property view context j edit reset property view context  string default context j edit get property view context j edit set property view context org context reload context list default context reset selection if user had more buttons than default list set selected index list ensure index is visible update buttons 
public void value changed  list selection event evt update buttons 
public  abstract input handler repeat count 
 adds a key binding to this input handler  the key binding is a list of white space separated key strokes of the form i modifiers key i where modifier is c for  control a for  alt or s for  shift and key is either a character a z or a field name in the  key event class prefixed with vk  e g back space param key binding  the key binding param action  the action since j edit pre public void add key binding  string key binding  string action add key binding key binding  object action 
 adds a key binding to this input handler  the key binding is a list of white space separated key strokes of the form i modifiers key i where modifier is c for  control a for  alt or s for  shift and key is either a character a z or a field name in the  key event class prefixed with vk  e g back space param key binding  the key binding param action  the action public void add key binding  string key binding e action add key binding key binding  object action 
 adds a key binding to this input handler  the key binding is a list of white space separated key strokes of the form i modifiers key i where modifier is c for  control a for  alt or s for  shift and key is either a character a z or a field name in the  key event class prefixed with vk  e g back space param key binding  the key binding param action  the action since j edit pre public void add key binding  string key binding  object action  hashtable current bindings  string prefix str null  string tokenizer st new  string tokenizer key binding while st has more tokens  string key code str st next token if prefix str null prefix str key code str else prefix str prefix str key code str  key event translator  key key stroke  key event translator parse key key code str if key stroke null return if st has more tokens  object o current get key stroke if o instanceof  hashtable current  hashtable o else  hashtable hash new  hashtable hash put prefix str prefix str o hash current put key stroke o current  hashtable o else current put key stroke action 
 removes a key binding from this input handler  this is not yet implemented param key binding  the key binding public void remove key binding  string key binding  hashtable current bindings  string tokenizer st new  string tokenizer key binding while st has more tokens  string key code str st next token  key event translator  key key stroke  key event translator parse key key code str if key stroke null return if st has more tokens  object o current get key stroke if o instanceof  hashtable current  hashtable o else if o null we have binding foo but user asks to remove foo bar current remove key stroke return else user asks to remove non existent return else current remove key stroke 
 removes all key bindings from this input handler public void remove all key bindings bindings clear 
 returns either an edit action or a hashtable if the specified key is a prefix param key binding  the key binding since j edit pre public  object get key binding  string key binding  hashtable current bindings  string tokenizer st new  string tokenizer key binding while st has more tokens  key event translator  key key stroke  key event translator parse key st next token if key stroke null return null if st has more tokens  object o current get key stroke if o instanceof  hashtable if st has more tokens return o else current  hashtable o else return o else return current get key stroke return null 
 returns the number of times the last action was executed  it can be used with smart home and smart end return the number of times the last action was executed since j edit pre public int get last action count return last action count 
 resets the last action count  this should be called when an editing operation that is not an action is invoked for example a mouse click since j edit pre public void reset last action count last action count 
public  key listener get key event interceptor return key event interceptor 
 sets the listener that will handle all key events in this view  for example the complete word command uses this so that all key events are passed to the word list popup while it is visible param key event interceptor the  key listener that will receive the events public void set key event interceptor  key listener key event interceptor this key event interceptor key event interceptor 
 returns if a prefix key has been pressed public boolean is prefix active return read next char null 
 replace the set of key bindings since j edit pre public void set bindings  hashtable bindings this bindings this current bindings bindings 
public void set current bindings  hashtable bindings current bindings bindings 
 if protected void send shortcut prefix off if shortcut on  shortcut prefix active event fire prefix state change null false shortcut on false 
 return a  string representation of the keyboard event for debugging purpose param evt the keyboard event return a  string representation for this keyboard event since j edit pre public static  string to string  key event evt  string id switch evt get id case  key event key pressed id key pressed break case  key event key released id key released break case  key event key typed id key typed break default id unknown type break  string builder b new  string builder b append id b append key code x append  integer to string evt get key code b append key char x append  integer to string evt get key char b append modifiers x append  integer to string evt get modifiers b append consumed b append evt is consumed return b to string 
param evt the keyboard event param from the source it can be link org gjt sp jedit  view view link org gjt sp jedit  view action bar or link org gjt sp jedit  view text area param mode the mode is press or type and is used for debug only param global tell if the event comes from the  default keyboard focus manager or not protected void process key event key stroke handling  key event evt int from  string mode boolean global  key event translator  key key stroke  key event translator translate key event evt if key stroke null key stroke set is from global context global if  debug dump key events  log log  log debug this  translated key mode key stroke from from boolean consumed false if handle key key stroke key stroke is phantom evt consume consumed true if  debug dump key events  log log  log debug this  translated key mode key stroke from from consumed consumed 
 creates a new option pane param internal name  the internal name  the option pane s label is set to the value of the property named code options i name i label code public  abstract option pane  string internal name this name internal name set layout grid bag new  grid bag layout 
 returns the internal name of this option pane  the option pane s label is set to the value of the property named code options i name i label code  override public  string get name return name 
 returns the component that should be displayed for this option pane  because this class extends  component it simply returns this public  component get component return this 
 do not override this method override link  init instead final in public void init if initialized initialized true  init 
 do not override this method override link  save instead final in public void save if initialized  save 
return a label which has the same tooltiptext as the  component that it is a label for  this is used to create labels from inside  abstract option pane since j edit pre public j label new label  string label  component comp j label retval new j label label try to get the tooltip of the component j component jc j component comp  string tttext jc get tool tip text retval set tool tip text tttext catch  exception e  there probably wasn t a tooltip or it wasn t a j component  we don t care return retval 
 adds a labeled component to the option pane  components are added in a vertical fashion one per row  the label is displayed to the left of the component param label  the label param comp  the component public void add component  string label  component comp j label l new label label comp l set border new  empty border add component l comp  grid bag constraints both 
 adds a labeled component to the option pane  components are added in a vertical fashion one per row  the label is displayed to the left of the component param label  the label param comp  the component param fill  fill parameter to  grid bag constraints for the right component public void add component  string label  component comp int fill j label l new label label comp l set border new  empty border add component l comp fill 
 adds a labeled component to the option pane  components are added in a vertical fashion one per row  the label is displayed to the left of the component param comp  the label param comp  the component since j edit pre public void add component  component comp  component comp add component comp comp  grid bag constraints both 
 adds a labeled component to the option pane  components are added in a vertical fashion one per row  the label is displayed to the left of the component param comp  the label param comp  the component param fill  fill parameter to  grid bag constraints for the right component since j edit pre public void add component  component comp  component comp int fill copy tool tips comp comp  grid bag constraints cons new  grid bag constraints cons gridy y cons gridheight cons gridwidth cons weightx f cons insets new  insets cons fill  grid bag constraints both grid bag set constraints comp cons add comp cons fill fill cons gridx cons weightx f grid bag set constraints comp cons add comp 
 adds a component to the option pane  components are added in a vertical fashion one per row param comp  the component public void add component  component comp  grid bag constraints cons new  grid bag constraints cons gridy y cons gridheight cons gridwidth  grid bag constraints remainder cons fill  grid bag constraints none cons anchor  grid bag constraints west cons weightx f cons insets new  insets grid bag set constraints comp cons add comp 
 adds a component to the option pane  components are added in a vertical fashion one per row param comp  the component param fill  fill parameter to  grid bag constraints since j edit pre public void add component  component comp int fill  grid bag constraints cons new  grid bag constraints cons gridy y cons gridheight cons gridwidth  grid bag constraints remainder cons fill fill cons anchor  grid bag constraints west cons weightx f cons insets new  insets grid bag set constraints comp cons add comp 
private static void copy tool tips  component c  component c int tooltips int jc  string text null j component jc null try jc j component c text jc get tool tip text jc if text null text length tooltips catch  exception e j component jc null try jc j component c  string text jc get tool tip text jc if text null text length text text tooltips catch  exception e if tooltips jc jc set tool tip text text jc set tool tip text text 
 adds a separator component since j edit pre public void add separator add component  box create vertical strut j separator sep new j separator  swing constants horizontal  grid bag constraints cons new  grid bag constraints cons gridy y cons gridheight cons gridwidth  grid bag constraints remainder cons fill  grid bag constraints both cons anchor  grid bag constraints west cons weightx f cons insets new  insets grid bag set constraints sep cons add sep add component  box create vertical strut 
 adds a separator component param label  the separator label property since j edit pre public void add separator  string label if y add component  box create vertical strut  box box new  box  box layout x axis  box box new  box  box layout y axis box add  box create glue box add new j separator  swing constants horizontal box add  box create glue box add box j label l new j label j edit get property label l set maximum size l get preferred size box add l  box box new  box  box layout y axis box add  box create glue box add new j separator  swing constants horizontal box add  box create glue box add box  grid bag constraints cons new  grid bag constraints cons gridy y cons gridheight cons gridwidth  grid bag constraints remainder cons fill  grid bag constraints both cons anchor  grid bag constraints west cons weightx f cons insets new  insets grid bag set constraints box cons add box 
 this method should create and arrange the components of the option pane and initialize the option data displayed to the user  this method is called when the option pane is first displayed and is not called again for the lifetime of the object protected void  init 
 called when the options dialog s ok button is clicked  this should save any properties being edited in this option pane protected void  save 
public  action bar  view view boolean temp this view view this temp temp set layout new  box layout this  box layout x axis set floatable false add  box create horizontal strut j label label new j label j edit get property view action prompt add label add  box create horizontal strut add action new  action text field action set enter adds to history false  dimension max action get preferred size max width  integer max value action set maximum size max action add action listener new  action handler action get document add document listener new  document handler if temp close new  rollover button gui utilities load icon closebox gif close add action listener new  action handler close set tool tip text j edit get property view action close tooltip add close if temp is true hide search bar after user is done with it this temp temp 
public  history text field get field return action 
public void go to action bar repeat count view get input handler get repeat count action set text null action request focus 
private void invoke  string cmd if popup null cmd popup list get selected value to string else cmd action get text trim int index cmd index of if index action add current to history  string prop name cmd substring index trim  string prop value cmd substring index trim  string code construct a  bean shell snippet instead of invoking directly so that user can record property changes in macros if prop name starts with buffer if prop name equals buffer mode code buffer set mode  standard utilities chars to escapes prop value else code buffer set string property  standard utilities chars to escapes prop name substring buffer length  standard utilities chars to escapes prop value code nbuffer properties changed else if prop name starts with buffer code j edit set property  standard utilities chars to escapes prop name substring  standard utilities chars to escapes prop value n j edit properties changed else code j edit set property  standard utilities chars to escapes prop name  standard utilities chars to escapes prop value n j edit properties changed  macros  recorder recorder view get macro recorder if recorder null recorder record code  bean shell eval view namespace code cmd null else if cmd length  string completions get completions cmd if completions length cmd completions else cmd null if popup null popup dispose popup null final  string final cmd cmd final  edit action act final cmd null null j edit get action final cmd if temp view remove tool bar this  swing utilities invoke later new  runnable public void run view get text area request focus if act null if final cmd null view get status set message and clear j edit get property view action no completions else view get input handler set repeat count repeat count view get input handler invoke action act 
private static  string get completions  string str str str to lower case  string actions j edit get action names  array list  string return value new  array list  string actions length for int i i actions length i if actions i to lower case contains str return value add actions i return return value to array new  string return value size 
private void complete boolean insert longest prefix  string text action get text trim  string completions get completions text if completions length if insert longest prefix action set text completions else if completions length if insert longest prefix  string prefix  misc utilities get longest prefix completions true if prefix contains text action set text prefix if popup null popup set model completions else popup new  completion popup completions return if popup null popup dispose popup null 
public void action performed  action event evt if evt get source close view remove tool bar  action bar this else invoke 
public void insert update  document event evt if popup null complete false 
public void remove update  document event evt if popup null complete false 
public void changed update  document event evt 
 action text field super action set select all on focus true 
 override public boolean is managing focus return false 
 override public boolean get focus traversal keys enabled return false 
 override public void process key event  key event evt evt  key event workaround process key event evt if evt null return switch evt get id case  key event key typed char ch evt get key char if non digit  character is digit ch super process key event evt repeat true repeat count  integer parse int action get text else non digit true if repeat pass to view evt else super process key event evt break case  key event key pressed int key code evt get key code if evt is action key evt is control down evt is alt down evt is meta down key code  key event vk back space key code  key event vk delete key code  key event vk enter key code  key event vk tab key code  key event vk escape non digit true if repeat pass to view evt break else if key code  key event vk tab complete true evt consume else if key code  key event vk escape evt consume if popup null popup dispose popup null action request focus else if temp view remove tool bar  action bar this view get edit pane focus on text area break else if key code  key event vk up key code  key event vk down popup null popup list process key event evt break super process key event evt break 
private void pass to view final  key event evt if temp view remove tool bar  action bar this view get text area request focus  swing utilities invoke later new  runnable public void run view get text area request focus view get input handler set repeat count repeat count view get input handler process key event evt  view action bar false 
 override public void add notify super add notify repeat non digit false 
 completion popup  string actions super view set content pane new j panel new  border layout  returns if this component can be traversed by pressing the  tab key  this returns false  override public boolean is managing focus return false  makes the tab key work in  java  override public boolean get focus traversal keys enabled return false list new  completion list actions list set visible row count list add mouse listener new  mouse handler list set selected index list set selection mode  list selection model single selection stupid scrollbar policy is an attempt to work around bugs people have been seeing with ibm s jdk  sep j scroll pane scroller new j scroll pane list  scroll pane constants vertical scrollbar always  scroll pane constants horizontal scrollbar never get content pane add scroller  border layout center gui utilities request focus this list pack  point p new  point get height  swing utilities convert point to screen p action set location p set visible true  key handler key handler new  key handler add key listener key handler list add key listener key handler 
void set model  string actions list set list data actions list set selected index 
 override public void mouse clicked  mouse event evt invoke 
 completion list  object data super data 
 override public void process key event  key event evt super process key event evt 
 override public void key typed  key event evt action process key event evt 
 override public void key pressed  key event evt int key code evt get key code if key code  key event vk escape action process key event evt else if key code  key event vk enter invoke else if key code  key event vk up int selected list get selected index if selected list set selected index list get model get size evt consume else if key code  key event vk down int selected list get selected index if selected list get model get size list set selected index evt consume 
 returns the action set that contains the specified action  this method is still here for binary compatility param action  the action return the action set that contains the given action since j edit pre  override public  action set get action set for action  string action return super get action set for action action 
 returns the specified action param name  the action name return a  edit action or null if it doesn t exist since j edit pre  override public  edit action get action  string name return super get action name 
 action list handler  string path j edit action set action set this path path this action set action set state stack new  stack  string code new  string builder is selected new  string builder 
 override public  input source resolve entity  string public id  string system id return xml utilities find entity system id actions dtd get class 
public void attribute  string aname  string value boolean is specified aname aname null null aname intern value value null null value intern if aname name action name value else if aname no repeat no repeat value true else if aname no record no record value true else if aname no remember last no remember last value true 
 override public void characters char c int off int len  string tag peek element if tag equals code code append c off len else if tag equals is selected is selected append c off len 
 override public void start element  string uri  string local name  string q name  attributes attrs  string tag push element q name if tag equals action action name attrs get value name no repeat true equals attrs get value no repeat no record true equals attrs get value no record no remember last true equals attrs get value no remember last code set length is selected set length 
 override public void end element  string uri  string local name  string q name  string tag peek element if q name equals tag if tag equals action  string selected is selected length is selected to string null j edit abstract edit action action action set create bean shell action action name code to string selected no repeat no record no remember last action set add action action no repeat no record no remember last false code set length is selected set length pop element else can t happen throw new  internal error 
 override public void start document try push element null catch  exception e  log log  log error this e 
private  string push element  string name name name null null name intern state stack push name return name 
private  string peek element return state stack peek 
private  string pop element return state stack pop 
 creates a new action set since j edit pre public  action set label no label set plugin bug 
 creates a new action set param plugin  the plugin param cached action names  the list of cached action names param cached action toggle flags  the list of cached action toggle flags param uri  the actions xml uri since j edit pre public  action set  plugin jar plugin  string cached action names boolean cached action toggle flags url uri this this plugin plugin this uri uri if cached action names null for int i i cached action names length i actions put cached action names i placeholder j edit set temporary property cached action names i toggle cached action toggle flags i true false loaded false 
 adds an action to the action set  it exists for binary compatibility issues param action  the action since j edit pre  override public void add action  edit action action super add action action 
protected  edit action get array int size return new  edit action size 
 returns an array of all actions in this action set p b  deferred loading b this will load the action set if necessary since j edit pre  override public  edit action get actions return super get actions 
 creates a new action set param label  the label shown in the shortcuts option pane since j edit pre public  action set  string label this set label label 
 return the action source label since j edit pre public  string get label return label 
 sets the action source label param label  the label since j edit pre public void set label  string label if label null throw new  null pointer exception this label label 
 return the plugin this action set was loaded from or null since j edit pre public  plugin jar get plugin jar return plugin 
 returns an array of all action names in this action set that should be cached namely code  bean shell action code s since j edit pre  override public  string get cacheable action names  linked list  string ret val new  linked list  string  enumeration e actions elements while e has more elements  object obj e next element if obj placeholder this should only be called with fully loaded action set  log log  log warning this  action set not up to date else if obj instanceof  bean shell action ret val add  bean shell action obj get name return ret val to array new  string ret val size 
protected  string get property  string name return j edit get property name 
public  abstract input handler get input handler return j edit get input handler 
public int compare to  object o return label compare to  action set o label 
 override public  string to string return label 
 creates a  bean shell action since pre protected  edit action create bean shell action  string action name  string code  string selected boolean no repeat boolean no record boolean no remember last return new  bean shell action action name code selected no repeat no record no remember last 
public  add abbrev dialog  view view  string abbrev super view j edit get property add abbrev title true this view view j panel content new j panel new  border layout content set border new  empty border set content pane content editor new  abbrev editor editor set abbrev abbrev editor set border new  empty border content add  border layout center editor  box box new  box  box layout x axis box add  box create glue global new j button j edit get property add abbrev global global add action listener new  action handler box add global box add  box create horizontal strut mode specific new j button j edit get property add abbrev mode mode specific add action listener new  action handler box add mode specific box add  box create horizontal strut cancel new j button j edit get property common cancel cancel add action listener new  action handler box add cancel box add  box create glue content add  border layout south box  key listener listener new  key handler add key listener listener editor get before caret text area add key listener listener editor get after caret text area add key listener listener set default close operation dispose on close if abbrev null gui utilities request focus this editor get abbrev field else gui utilities request focus this editor get before caret text area pack set location relative to view set visible true 
public void action performed  action event evt  object source evt get source if source global  string  abbrev editor get abbrev if  abbrev null  abbrev length get toolkit beep return  abbrevs add global abbrev  abbrev editor get expansion  abbrevs expand abbrev view false else if source mode specific  string  abbrev editor get abbrev if  abbrev null  abbrev length get toolkit beep return  abbrevs add mode abbrev view get buffer get mode get name  abbrev editor get expansion  abbrevs expand abbrev view false dispose 
public void key pressed  key event evt if evt get key code  key event vk escape dispose 
 creates a new all buffer set param glob  the filename glob since j edit pre public  all buffer set  string glob this glob glob 
 returns the filename filter since j edit pre public  string get file filter return glob 
 returns the  bean shell code that will recreate this file set since j edit pre  override public  string get code return new  all buffer set  standard utilities chars to escapes glob 
 override protected  string  get files  component comp  buffer buffers j edit get buffers  list  string return value new  array list  string buffers length  pattern filter try filter  pattern compile  standard utilities glob to re glob  pattern case insensitive catch  exception e  log log  log error this e return null for int i i buffers length i  buffer buffer buffers i if filter matcher buffer get name matches return value add buffer get path return return value to array new  string return value size 
protected  anchor  display manager display manager  text area text area this display manager display manager this text area text area 
 override public  string to string return get class get name physical line scroll line 
 some content is inserted param start line the start of the insert param num lines the number of insterted lines void content inserted int start line int num lines  the  anchor is changed only if the content was inserted before if physical line start line if physical line start line physical line num lines call changed true 
 method called before a content is removed from a buffer param start line the first line of the removed content param offset the offset in the start line param num lines the number of removed lines void pre content removed int start line int offset int num lines if  debug scroll debug  log log  log debug this pre content removed before this  the removed content starts before the  anchor we need to pull the anchor up if physical line start line if physical line start line call changed true else int end  math min start line num lines physical line  check the lines from the beginning of the removed content to the end or the physical line of the  anchor if it is before the end of the removed content int loop start start line treatment if the beginning of the deleted content is inside a physical line that has several line counts if display manager is line visible start line int screen line count display manager screen line mgr get screen line count start line if screen line count int line start offset text area get line start offset start line int start screen line text area get screen line of offset line start offset int delete start screen line text area get screen line of offset offset if start screen line delete start screen line loop start start line scroll line screen line count delete start screen line start screen line for int i start line i end i xxx if display manager is line visible i scroll line display manager screen line mgr get screen line count i physical line end start line call changed true if  debug scroll debug  log log  log debug this pre content removed after this 
param frames  the frames to be used in the animation param rate  the frame rate of the animation in frames per second param host  the container that the animation is used in public  animated icon  image icon  image frames int rate  component host super icon this icon icon this frames frames delay rate this host host 
public  image get frames return frames 
public  image get icon return icon 
public int get rate return delay 
public void set frames  image frames this frames frames 
public void set icon  image icon this icon icon 
public void set rate int rate delay rate 
 starts the animation rolling public void start if timer null return timer new  timer delay new  animator timer start 
 stops the animation and resets to frame public void stop current if timer null timer stop timer null set image icon host repaint 
public void action performed  action event evt current current frames length set image frames current host repaint 
public void set int new value m val new value 
public  anti alias boolean is enabled m val is enabled 
public  anti alias int val m val val 
public  anti alias  string v from string v 
public boolean equals  object other return to string equals other to string 
public void from string  string v for int i i combo choices length i if combo choices i equals v m val i 
public  string to string return combo choices m val to string 
public int val return m val 
public  appearance option pane super appearance 
 override protected void  init  look and feel add component new j label j edit get property options appearance lf note lfs ui manager get installed look and feels  string names new  string lfs length  string lf ui manager get look and feel get class get name int index for int i i names length i names i lfs i get name if lf equals lfs i get class name index i look and feel new j combo box names look and feel set selected index index look and feel add action listener new  action listener public void action performed  action event evt update enabled add component j edit get property options appearance lf look and feel add docking framework chooser  icon  theme  string themes  icon theme built in names icon themes new j combo box themes add component j edit get property options appearance icon theme icon themes old theme  icon theme get for int i i themes length i if themes i equals old theme icon themes set selected index i break  primary  metal l f font primary font new  font selector j edit get font property metal primary font add component j edit get property options appearance primary font primary font  secondary  metal l f font secondary font new  font selector j edit get font property metal secondary font add component j edit get property options appearance secondary font secondary font anti alias extras new j combo box  anti alias combo choices anti alias extras set selected index  anti alias appearance val anti alias extras set tool tip text j edit get property options textarea anti alias tooltip add component j edit get property options appearance fonts antialias anti alias extras update enabled  history count history new  numeric text field j edit get property history true add component j edit get property options appearance history history  menu spillover count menu spillover new  numeric text field j edit get property menu spillover true add component j edit get property options appearance menu spillover menu spillover continuous layout new j check box j edit get property options appearance continuous layout label continuous layout set selected j edit get boolean property appearance continuous layout add component continuous layout add separator options appearance startup label  show splash screen show splash new j check box j edit get property options appearance show splash  string settings directory j edit get settings directory if settings directory null show splash set selected true else show splash set selected new  file settings directory nosplash exists add component show splash  show tip of the day show tips new j check box j edit get property options appearance show tips show tips set selected j edit get boolean property tip show add component show tips add separator options appearance experimental label add component gui utilities create multiline label j edit get property options appearance experimental caption  use j edit colors in all text components text colors new j check box j edit get property options appearance text colors text colors set selected j edit get boolean property text colors add component text colors  decorate frames with look and feel jdk only decorate frames new j check box j edit get property options appearance decorate frames decorate frames set selected j edit get boolean property decorate frames add component decorate frames  decorate dialogs with look and feel jdk only decorate dialogs new j check box j edit get property options appearance decorate dialogs decorate dialogs set selected j edit get boolean property decorate dialogs add component decorate dialogs 
 override protected void  save  string lf lfs look and feel get selected index get class name j edit set property look and feel lf j edit set font property metal primary font primary font get font j edit set font property metal secondary font secondary font get font j edit set property history history get text j edit set property menu spillover menu spillover get text j edit set boolean property tip show show tips is selected j edit set boolean property appearance continuous layout continuous layout is selected  icon theme set icon themes get selected item to string j edit set property  view view docking framework property  string docking framework get selected item  anti alias nv  anti alias appearance int idx anti alias extras get selected index nv set idx primary font set anti alias enabled idx secondary font set anti alias enabled idx primary font repaint secondary font repaint this is handled a little differently from other j edit settings as the splash screen flag needs to be known very early in the startup sequence before the user properties have been loaded  string settings directory j edit get settings directory if settings directory null  file file new  file settings directory nosplash if show splash is selected file delete else  file output stream out null try out new  file output stream file out write n out close catch io exception io  log log  log error this io finally io utilities close quietly out j edit set boolean property text colors text colors is selected j edit set boolean property decorate frames decorate frames is selected j edit set boolean property decorate dialogs decorate dialogs is selected 
private void update enabled  string class name lfs look and feel get selected index get class name if class name equals javax swing plaf metal  metal look and feel class name equals com incors plaf kunststoff  kunststoff look and feel primary font set enabled true secondary font set enabled true else primary font set enabled false secondary font set enabled false 
private void add docking framework chooser  string frameworks  service manager get service names  view docking framework provider service docking framework new j combo box frameworks  string framework  view get docking framework name for int i i frameworks length i if frameworks i equals framework docking framework set selected index i break add component new j label j edit get property options appearance select framework label docking framework 
 returns a marked rewindable stream  calling reset method rewinds the stream to its beginning  but reset can fail if too long bytes were read public static  buffered input stream get marked stream  input stream in int buffer size  buffer io request get byte io buffer size  buffered input stream markable new  buffered input stream in buffer size assert markable mark supported markable mark buffer size return markable 
 returns wheather the stream is gzipped  this method reads a few bytes from the sample  so a caller must take care of mark to reuse the contents  wraping the stream by get marked stream is suitable public static boolean is gzipped  input stream sample throws io exception int magic gzip input stream gzip magic xff int magic gzip input stream gzip magic xff return sample read magic sample read magic 
 returns the user configured ordered list of encoding detectors  this method reads property encoding detectors public static  list  encoding detector get encoding detectors  list  encoding detector detectors new  array list  encoding detector  string prop name encoding detectors  string selected detectors j edit get property prop name bom xml pi if selected detectors null selected detectors length for  string name selected detectors split s  encoding detector service get encoding detector service name if service null detectors add service else  log log  log error  auto detection class get encoding detectors  no  encoding detector for the name name return detectors 
 returns an auto detected encoding from content of marked stream  this method assumes that marked stream is wrapped by get marked stream method public static  string get detected encoding  buffered input stream marked stream throws io exception  list  encoding detector detectors get encoding detectors for  encoding detector detector detectors fixme  here the method reset can fail if the previous detector read more than buffer size of marked stream marked stream reset  wrap once more so that calling mark or reset in detect encoding don t alter the mark position of marked stream  string detected detector detect encoding new  buffered input stream marked stream if detected null return detected return null 
 do some auto detection for a stream and hold the result in this instance param in the stream public  result  input stream in throws io exception  buffered input stream marked get marked stream in gzipped is gzipped marked if gzipped marked reset marked get marked stream new gzip input stream marked marked reset encoding  auto detection get detected encoding marked marked stream marked 
 returns the stream which can be read the contents of the original stream  some bytes ware read from original stream for auto detections  but they are rewinded at this method public  buffered input stream get rewinded stream throws io exception marked stream reset return marked stream 
 returns true if the stream is gzipped public boolean stream is gzipped return gzipped 
 returns the auto detected encoding  returns null if no encoding was detected public  string get detected encoding return encoding 
 returns a service of  encoding detector for name private static  encoding detector get encoding detector service  string name  string service class org gjt sp jedit io  encoding detector  object service  service manager get service service class name if service null service instanceof  encoding detector return  encoding detector service else return null 
public static void set interval int interval if interval if timer null timer stop timer null return interval if timer null timer new  timer interval new  autosave timer start else timer set delay interval 
public static void stop if timer null timer stop 
public void action performed  action event evt if j edit get integer property autosave return might come in handy useful some time  runtime runtime  runtime get runtime int free memory int runtime free memory int total memory int runtime total memory int used memory total memory free memory  log log  log debug this  java heap used memory  kb total memory  kb used memory total memory save list of open files if j edit get view count  perspective manager is perspective dirty  perspective manager set perspective dirty false  perspective manager save perspective true boolean autosave untitled j edit get boolean property autosave untitled  buffer buffer array j edit get buffers for int i i buffer array length i  buffer buffer buffer array i if autosave untitled buffer is untitled buffer autosave flush log  log flush stream 
private  autosave 
static void init  log log  log message  bean shell class  beanshell  init 
 evaluates the text selected in the specified text area since j edit pre public static void eval selection  view view j edit text area text area bsh eval selection view text area 
 prompts for a  bean shell expression to evaluate since j edit pre public static void show evaluate dialog  view view  string command gui utilities input view beanshell eval input null if command null if command ends with command command int repeat view get input handler get repeat count if view get macro recorder null view get macro recorder record repeat command  object return value null try for int i i repeat i return value bsh  eval view bsh get name space command catch  throwable e  log log  log error  bean shell class e bsh handle exception view null e if return value null  string args return value to string gui utilities message view beanshell eval args 
 evaluates the specified script for each selected line since j edit pre public static void show evaluate lines dialog  view view  string command gui utilities input view beanshell eval line null j edit text area text area view get text area  buffer buffer view get buffer if command null command length return  selection selection text area get selection if selection length view get toolkit beep return if command ends with command command  string script int lines text area get selected lines n for int i i lines length i n n line lines i n index line lines n start buffer get line start offset line n end buffer get line end offset line n text buffer get text start end start n new text command n if new text null n n buffer remove start end start n buffer insert start  string value of new text n n n if view get macro recorder null view get macro recorder record script try buffer begin compound edit bsh eval view script finally buffer end compound edit text area select none 
 runs a  bean shell script  errors are shown in a dialog box p  if the code in code parameter is non null the script is read from that stream otherwise it is read from the file identified by code path code p  the code script path code  bean shell variable is set to the path name of the script param view  the view  within the script references to code buffer code code text area code and code edit pane code are determined with reference to this parameter param path  the script file s vfs path param in  the reader to read the script from or code null code param own namespace  if set to code false code methods and variables defined in the script will be available to all future uses of  bean shell if set to code true code they will be lost as soon as the script finishes executing j edit uses a value of code false code when running startup scripts and a value of code true code when running all other macros since j edit pre public static void run script  view view  string path  reader in boolean own namespace try  run script view path in own namespace catch  throwable e  log log  log error  bean shell class e bsh handle exception view path e 
 runs a  bean shell script  errors are shown in a dialog box p  if the code in code parameter is non null the script is read from that stream otherwise it is read from the file identified by code path code p  the code script path code  bean shell variable is set to the path name of the script param view  the view  within the script references to code buffer code code text area code and code edit pane code are determined with reference to this parameter param path  the script file s vfs path param in  the reader to read the script from or code null code param namespace  the namespace to run the script in since j edit pre public static void run script  view view  string path  reader in  name space namespace try  run script view path in namespace catch  throwable e  log log  log error  bean shell class e bsh handle exception view path e 
 runs a  bean shell script  errors are passed to the caller p  if the code in code parameter is non null the script is read from that stream otherwise it is read from the file identified by code path code p  the code script path code  bean shell variable is set to the path name of the script param view  the view  within the script references to code buffer code code text area code and code edit pane code are determined with reference to this parameter param path  the script file s vfs path param in  the reader to read the script from or code null code param own namespace  if set to code false code methods and variables defined in the script will be available to all future uses of  bean shell if set to code true code they will be lost as soon as the script finishes executing j edit uses a value of code false code when running startup scripts and a value of code true code when running all other macros exception  exception instances are thrown when various  bean shell errors occur since j edit pre public static void  run script  view view  string path  reader in boolean own namespace throws  exception  run script view path in own namespace new  name space bsh get name space namespace bsh get name space 
 runs a  bean shell script  errors are passed to the caller p  if the code in code parameter is non null the script is read from that stream otherwise it is read from the file identified by code path code p  the code script path code  bean shell variable is set to the path name of the script param view  the view  within the script references to code buffer code code text area code and code edit pane code are determined with reference to this parameter param path  the script file s vfs path param in  the reader to read the script from or code null code param namespace  the namespace to run the script in exception  exception instances are thrown when various  bean shell errors occur since j edit pre public static void  run script  view view  string path  reader in  name space namespace throws  exception  log log  log message  bean shell class  running script path  interpreter interp  bean shell facade create interpreter namespace try if in null  buffer buffer j edit open temporary null null path false if buffer is loaded vfs manager wait for requests in new  string reader buffer get text buffer get length bsh setup default variables namespace view interp set script path path running true interp eval in namespace path catch  exception e  bean shell facade unwrap exception e finally running false try no need to do this for macros if namespace bsh get name space bsh reset default variables namespace interp unset script path catch  eval error e do nothing 
 evaluates the specified  bean shell expression  errors are reported in a dialog box param view  the view  within the script references to code buffer code code text area code and code edit pane code are determined with reference to this parameter param namespace  the namespace param command  the expression since j edit pre public static  object eval  view view  name space namespace  string command return bsh eval view namespace command 
 evaluates the specified  bean shell expression  unlike code eval code this method passes any exceptions to the caller param view  the view  within the script references to code buffer code code text area code and code edit pane code are determined with reference to this parameter param namespace  the namespace param command  the expression exception  exception instances are thrown when various  bean shell errors occur since j edit pre public static  object  eval  view view  name space namespace  string command throws  exception return bsh  eval view namespace command 
 caches a block of code returning a handle that can be passed to run cached block param id  an identifier  if null a unique identifier is generated param code  the code param namespace  if true the namespace will be set exception  exception instances are thrown when various  bean shell errors occur since j edit pre public static  bsh method cache block  string id  string code boolean namespace throws  exception return bsh cache block id code namespace 
 runs a cached block of code in the specified namespace  faster than evaluating the block each time param method  the method instance returned by cache block param view  the view param namespace  the namespace to run the code in exception  exception instances are thrown when various  bean shell errors occur since j edit pre public static  object run cached block  bsh method method  view view  name space namespace throws  exception return bsh run cached block method view namespace 
 returns if a  bean shell script or macro is currently running since j edit pre public static boolean is script running return running 
 returns the global namespace since j edit pre public static  name space get name space return bsh get name space 
deprecated  the code rethrow bsh errors code parameter is now obsolete call code  run script code or code run script code instead  deprecated public static void run script  view view  string path boolean own namespace boolean rethrow bsh errors run script view path null own namespace 
deprecated  the code rethrow bsh errors code parameter is now obsolete call code  run script code or code run script code instead  deprecated public static void run script  view view  string path  reader in boolean own namespace boolean rethrow bsh errors run script view path in own namespace 
deprecated  the code rethrow bsh errors code parameter is now obsolete call code  eval code or code eval code instead  deprecated public static  object eval  view view  string command boolean rethrow bsh errors return bsh eval view command 
deprecated  the code rethrow bsh errors code parameter is now obsolete call code  eval code or code eval code instead  deprecated public static  object eval  view view  name space namespace  string command boolean rethrow bsh errors return eval view namespace command 
 causes  bean shell internal structures to drop references to cached  class instances static void reset class manager bsh reset class manager 
private  my bean shell facade class manager set class loader new jar class loader 
 override protected void init super init global import package org gjt sp jedit browser global import package org gjt sp jedit bufferset global import package org gjt sp jedit statusbar global import package org gjt sp jedit gui global import package org gjt sp jedit help global import package org gjt sp jedit io global import package org gjt sp jedit menu global import package org gjt sp jedit msg global import package org gjt sp jedit options global import package org gjt sp jedit pluginmgr global import package org gjt sp jedit print global import package org gjt sp jedit search 
 override protected void setup default variables  name space namespace  view view throws  util eval error if view null  edit pane edit pane view get edit pane namespace set variable view view false namespace set variable edit pane edit pane false namespace set variable buffer edit pane get buffer false namespace set variable text area edit pane get text area false namespace set variable wm view get dockable window manager false 
 override protected void reset default variables  name space namespace throws  util eval error namespace set variable view null false namespace set variable edit pane null false namespace set variable buffer null false namespace set variable text area null false namespace set variable wm null false 
 override protected void handle exception  view view  string path  throwable t if t instanceof io exception vfs manager error view path ioerror read error new  string t to string else new  bean shell error dialog view t 
public  bean shell action  string name  string code  string is selected boolean no repeat boolean no record boolean no remember last super name  some characters that we like to use in action names are not allowed in  bean shell identifiers  string sanitized name name replace   replace   this code new  cached bsh method action  sanitized name code if is selected null this is selected new  cached bsh method selected  sanitized name is selected this no repeat no repeat this no record no record this no remember last no remember last j edit set temporary property name toggle is selected null true false 
public void invoke  view view try  bean shell run cached block code get view new  name space  bean shell get name space  bean shell action invoke catch  throwable e  log log  log error this e new  bean shell error dialog view e 
public boolean is selected  component comp if is selected null return false  name space global  bean shell get name space try  view view gui utilities get view comp undocumented hack to allow browser actions to work xxx clean up in global set variable  comp comp return  boolean true equals  bean shell run cached block is selected get view new  name space  bean shell get name space  bean shell action is selected catch  throwable e  log log  log error this e dialogs fuck things up if a menu is visible etc new  bean shell error dialog view e so that in the future we don t see streams of exceptions is selected null return false finally try global set variable  comp null catch  util eval error err  log log  log error this err 
public boolean no repeat return no repeat 
public boolean no record return no record 
 returns if this edit action should not be remembered as the most recently invoked action since j edit pre public boolean no remember last return no remember last 
public  string get code return code get source trim 
public  cached bsh method  string name  string source this name name this source source this cache null 
public  bsh method get throws java lang  exception if cache null  bsh method cached cache get if cached null return cached  bsh method new one  bean shell cache block name source true cache new  soft reference  bsh method new one return new one 
public  string get source return source 
public  bean shell error dialog  frame frame  throwable t super frame beanshell error t 
public  bean shell error dialog  view view  throwable t this  frame view t 
protected  bean shell facade class manager new  class manager impl global new  name space class manager j edit embedded  bean shell interpreter interp for methods create interpreter global init 
 initialize things  it is called by the constructor  you can override it to import other packages protected void init global import package org gjt sp jedit global import package org gjt sp jedit buffer global import package org gjt sp jedit syntax global import package org gjt sp jedit textarea global import package org gjt sp util 
 evaluates the text selected in the specified text area public void eval selection t param  text area text area  string command text area get selected text if command null text area get toolkit beep return  object return value eval param global command if return value null text area set selected text return value to string 
 evaluates the specified  bean shell expression with the global namespace param param  the parameter param command  the expression public  object eval t param  string command return eval param global command 
 evaluates the specified  bean shell expression  errors are reported in a dialog box param param  the parameter param namespace  the namespace param command  the expression public  object eval t param  name space namespace  string command try return  eval param namespace command catch  throwable e  log log  log error  bean shell facade class e handle exception param null e return null 
 evaluates the specified  bean shell expression  unlike code eval code this method passes any exceptions to the caller param view  the view  within the script references to code buffer code code text area code and code edit pane code are determined with reference to this parameter param namespace  the namespace param command  the expression exception  exception instances are thrown when various  bean shell errors occur public  object  eval t view  name space namespace  string command throws  exception  interpreter interp create interpreter namespace try setup default variables namespace view if  debug beanshell debug  log log  log debug  bean shell facade class command return interp eval command catch  exception e unwrap exception e never called return null finally try reset default variables namespace catch  util eval error e do nothing 
 caches a block of code returning a handle that can be passed to run cached block param id  an identifier param code  the code param namespace  if true the namespace will be set exception  exception instances are thrown when various  bean shell errors occur public  bsh method cache block  string id  string code boolean namespace throws  exception  make local namespace so that the method could be g ced if it becomes unnecessary  name space local new  name space global   internal  id  this name should be unique enough not to shadow any outer identifier  string name   run cached method if namespace  eval null local name ns nthis callstack set ns n code n return local get method name new  class  name space class else  eval null local name n code n return local get method name new  class 
 runs a cached block of code in the specified namespace  faster than evaluating the block each time param method  the method instance returned by cache block param namespace  the namespace to run the code in exception  exception instances are thrown when various  bean shell errors occur public  object run cached block  bsh method method t param  name space namespace throws  exception boolean use namespace if namespace null use namespace false namespace global else use namespace true try setup default variables namespace param  object ret val method invoke use namespace new  object namespace no args interp for methods new  call stack null if ret val instanceof  primitive if ret val  primitive void return null else return  primitive ret val get value else return ret val catch  exception e unwrap exception e never called return null finally reset default variables namespace 
 returns the global namespace public  name space get name space return global 
 causes  bean shell internal structures to drop references to cached  class instances void reset class manager class manager reset 
protected static  interpreter create interpreter  name space name space return new  interpreter null  system out  system err false name space 
 this extracts an exception from a wrapping exception as  bean shell sometimes throws  this gives the user a more accurate error traceback protected static void unwrap exception  exception e throws  exception if e instanceof  target error  throwable t  target error e get target if t instanceof  exception throw  exception t else if t instanceof  error throw  error t if e instanceof  invocation target exception  throwable t  invocation target exception e get target exception if t instanceof  exception throw  exception t else if t instanceof  error throw  error t throw e 
public  block name space  name space parent throws  eval error super parent parent get name  block name space 
 override the standard namespace behavior to make assignments happen in our parent enclosing namespace unless the variable has already been assigned here via a typed declaration or through the special set block variable used for untyped args in try catch p i e only allow typed var declaration to happen in this namespace  typed vars are handled in the ordinary way local scope  all untyped assignments are delegated to the enclosing context  note it may see like with the new scoping this test could be removed but it cannot  when recurse is false we still need to set the variable in our parent not here public void set variable  string name  object value boolean strict java boolean recurse throws  util eval error if we have var name set the var here in the block namespace super set variable name value strict java false else set the var in the enclosing parent namespace get parent set variable name value strict java recurse 
 set an untyped variable in the block namespace  the  block name space would normally delegate this set to the parent  typed variables are naturally set locally  this is used in try catch block argument public void set block variable  string name  object value throws  util eval error super set variable name value false strict false 
 we have the variable either it was declared here with a type giving it block local scope or an untyped var was explicitly set here via set block variable private boolean we have var  string name super variables contains key name not any faster i checked try return super get variable impl name false null catch  util eval error e return false 
do we need this private  name space get non block parent  name space parent super get parent if parent instanceof  block name space return  block name space parent get non block parent else return parent 
 get a this reference is our parent s this for the object closure e g  normally a this reference to a  block name space e g if resolves to the parent namespace e g the namespace containing the if statement see get block this  interpreter  this get this  interpreter declaring interpreter return get non block parent get this declaring interpreter 
super is our parent s super public  this get super  interpreter declaring interpreter return get non block parent get super declaring interpreter 
delegate import to our parent public void import class  string name get parent import class name 
delegate import to our parent public void import package  string name get parent import package name 
public void set method  string name  bsh method method throws  util eval error get parent set method name method 
 creates a new string literal matcher param pattern the search pattern param ignore case code true code if you want to ignore case public  boyer moore search matcher  string pattern boolean ignore case this pattern pattern to char array if ignore case for int i i this pattern length i this pattern i  character to upper case this pattern i this ignore case ignore case pattern end this pattern length 
 returns the offset of the first match of the specified text within this matcher param text  the text to search in param start  true if the start of the segment is the beginning of the buffer param end  true if the end of the segment is the end of the buffer param first time  if false and the search string matched at the start offset with length zero automatically find next match param reverse  if true searching will be performed in a backward direction return an array where the first element is the start offset of the match and the second element is the end offset of the match since j edit pre public  search matcher  match next match  char sequence text boolean start boolean end boolean first time boolean reverse int pos match text reverse if pos return null else return value start pos return value end pos pattern length return return value 
a good introduction to the  boyer  moore fast string matching algorithm may be found on  moore s website at http www cs utexas edu users moore best ideas string searching since j edit pre public int match  char sequence text boolean reverse lazily create skip and suffix arrays for either the search pattern or the reversed search pattern int skip suffix if reverse if back skip null back skip generate skip array true back suffix generate suffix array true skip back skip suffix back suffix else if fwd skip null fwd skip generate skip array false fwd suffix generate suffix array false skip fwd skip suffix fwd suffix position variable for pattern test position int pos position variable for pattern start int anchor last possible start position of a match with this pattern this is negative if the pattern is longer than the text causing the search loop below to immediately fail int last anchor reverse search offset pattern length length pattern length char ch int bad char int good suffix the search works by starting the anchor first character of the pattern at the initial offset as long as the anchor is far enough from the enough of the text for the pattern to match and until the pattern matches we compare the pattern to the text from the last character to the first character in reverse order where a character in the pattern mismatches we use the two heuristics based on the mismatch character and its position in the pattern to determine the furthest we can move the anchor without missing any potential pattern matches search while anchor pattern end text length for pos pattern end pos pos ch text char at pos anchor if ignore case ch  character to upper case ch pattern test if reverse ch pattern pattern end pos ch pattern pos character mismatch determine how many characters to skip heuristic bad char pos skip get skip index ch heuristic good suffix suffix pos skip the greater of the two distances provided by the heuristics int skip index bad char good suffix bad char good suffix anchor skip index go back to the while loop continue search match return the position of its first character return anchor mismatch return as defined by api return 
public  string to string return  boyer moore search matcher new  string pattern ignore case 
private int generate skip array boolean reverse initialize the skip array to all zeros int skip new int leave the table cleanly initialized for an empty pattern if pattern length return skip int pos do skip get skip index pattern reverse pattern end pos pos pos while pos pattern length return skip 
private static final int get skip index char ch return ch x ff 
private int generate suffix array boolean reverse int m pattern length int j m int suffix new int j int tmp new int j tmp m j for int i m i i while j m pattern reverse pattern end i i pattern reverse pattern end j j if suffix j suffix j j i j tmp j tmp i j int k tmp for j j m j the code above builds a indexed suffix array but we shift it to be indexed ignoring the original th element if j suffix j suffix j k suffix j if j k k tmp k return suffix 
public  bracket indent rule char open bracket char close bracket this open bracket open bracket this close bracket close bracket 
deprecated  use link get brackets j edit buffer int int int instead  brackets in comments or literals should be ignored for indent  but it can t be done without syntax parsing of a buffer  deprecated public  brackets get brackets  string line  brackets brackets new  brackets for int i i line length i char ch line char at i if ch open bracket  don t increase indent when we see an explicit fold if line length i if line substring i i equals i continue brackets open count else if ch close bracket if brackets open count brackets open count else brackets close count return brackets 
public  brackets get brackets j edit buffer buffer int line index return get brackets buffer line index buffer get line length line index 
public  brackets get brackets j edit buffer buffer int line index int begin int end  line scanner scanner new  line scanner begin end buffer mark tokens line index scanner return scanner result 
public  string to string return get class get name open bracket close bracket 
public  line scanner int begin int end this result new  brackets this scanned index this begin index begin this end index end 
boolean rejects token byte id  rejects comments and literals  accepts all others switch id case  token comment case  token comment case  token comment case  token comment case  token literal case  token literal case  token literal case  token literal return true default return false 
private void scan  segment seg int offset int length int index scanned index if index end index return if index begin index int num to skip begin index index if num to skip length return offset num to skip length num to skip index begin index if index length end index length end index index for int i i length i char c seg array seg offset offset i if c open bracket result open count else if c close bracket if result open count result open count else result close count 
public void handle token  segment seg byte id int offset int length  token marker  line context context if rejects token id scan seg offset length scanned index length 
public void set line context  token marker  line context line context 
public  browser colors option pane super browser colors 
protected void  init set layout new  border layout colors model new  browser colors model colors table new j table colors model colors table set auto resize mode j table auto resize all columns colors table get table header set reordering allowed false colors table add mouse listener new  mouse handler colors table get selection model add list selection listener new  selection handler  table column model tcm colors table get column model tcm get column set cell renderer new  browser colors model  color renderer  dimension d colors table get preferred size d height  math min d height j scroll pane scroller new j scroll pane colors table scroller set preferred size d add  border layout center scroller j panel buttons new j panel buttons set border new  empty border buttons set layout new  box layout buttons  box layout x axis  action handler action handler new  action handler add new  rollover button gui utilities load icon  plus png add set tool tip text j edit get property common add add add action listener action handler buttons add add buttons add  box create horizontal strut remove new  rollover button gui utilities load icon  minus png remove set tool tip text j edit get property common remove remove add action listener action handler buttons add remove buttons add  box create horizontal strut move up new  rollover button gui utilities load icon  arrow u png move up set tool tip text j edit get property common move up move up add action listener action handler buttons add move up buttons add  box create horizontal strut move down new  rollover button gui utilities load icon  arrow d png move down set tool tip text j edit get property common move down move down add action listener action handler buttons add move down buttons add  box create glue add  border layout south buttons update enabled 
protected void  save colors model save 
private void update enabled int selected row colors table get selected row remove set enabled selected row move up set enabled selected row move up set enabled selected row selected row colors model get row count 
private void set selected row int row colors table get selection model set selection interval row row colors table scroll rect to visible colors table get cell rect row true 
public void value changed  list selection event evt update enabled 
public void action performed  action event evt  object source evt get source if source add colors model add else if source remove int selected row colors table get selected row colors model remove selected row update enabled else if source move up int selected row colors table get selected row if selected row colors model move up selected row set selected row selected row update enabled else if source move down int selected row colors table get selected row if selected row colors table get row count colors model move down selected row set selected row selected row update enabled 
public void mouse clicked  mouse event evt  point p evt get point int row colors table row at point p int column colors table column at point p if row column return  color color j color chooser show dialog  browser colors option pane this j edit get property color chooser title  color colors model get value at row if color null colors model set value at color row 
 browser colors model entries new  array list  entry int i  string glob while glob j edit get property vfs browser colors i glob null entries add new  entry glob j edit get color property vfs browser colors i color  color black i 
void add entries add new  entry ui manager get color  tree foreground fire table rows inserted entries size entries size 
void remove int index entries remove index fire table rows deleted entries size entries size 
public void move up int index  entry entry entries get index entries remove index entries add index entry fire table rows updated index index 
public void move down int index  entry entry entries get index entries remove index entries add index entry fire table rows updated index index 
void save int i for i i entries size i  entry entry entries get i j edit set property vfs browser colors i glob entry glob j edit set color property vfs browser colors i color entry color j edit unset property vfs browser colors i glob j edit unset property vfs browser colors i color 
public int get column count return 
public int get row count return entries size 
public  object get value at int row int col  entry entry entries get row switch col case return entry glob case return entry color default return null 
public boolean is cell editable int row int col return col 
public void set value at  object value int row int col  entry entry entries get row if col entry glob  string value else entry color  color value fire table rows updated row row 
public  string get column name int index switch index case return j edit get property options browser colors glob case return j edit get property options browser colors color default return null 
public  class get column class int col switch col case return  string class case return  color class default throw new  internal error 
 entry  string glob  color color this glob glob this color color 
 color renderer set opaque true set border  syntax hilite option pane no focus border 
public  component get table cell renderer component j table table  object value boolean is selected boolean cell has focus int row int col if is selected set background table get selection background set foreground table get selection foreground else set background table get background set foreground table get foreground if value null set background  color value set border cell has focus ui manager get border  table focus cell highlight border  syntax hilite option pane no focus border return this 
public  browser commands menu vfs browser browser vfs file files this browser browser if files null vfs vfs vfs manager get vfs for path files get delete path int type files get type boolean file open j edit get buffer files get path null  we check this flag separately so that we can delete open files from the favorites boolean delete path open j edit get buffer files get delete path null boolean delete delete path open vfs get capabilities vfs delete cap boolean rename file open vfs get capabilities vfs rename cap for int i i files length i vfs file file files i vfs  vfs vfs manager get vfs for path file get delete path delete vfs  vfs  vfs get capabilities vfs delete cap if type file get type all good else this will disable most operations if files of multiple types are selected type set rename to false if file selected rename false show close item if at least one selected file is currently open if j edit get buffer file get path null file open true if type vfs file directory type vfs file filesystem if files length add create menu item browse if browser get mode vfs browser browser add create menu item browse window else if type vfs file file browser get mode vfs browser browser browser get mode vfs browser browser dialog add create menu item open add gui utilities load menu vfs browser get action context vfs browser open in add create menu item insert if file open add create menu item close else if type add create menu item open if rename add create menu item rename if delete add create menu item delete add create menu item copy path add create menu item paste if files length browser get selected files length add create menu item properties add separator add create menu item up add create menu item previous add create menu item next add create menu item reload add create menu item roots add create menu item home add create menu item synchronize add separator if browser get mode vfs browser browser add create menu item new file add create menu item new directory if browser get mode vfs browser browser add separator add create menu item search directory add separator add create menu item show hidden files if browser get mode vfs browser browser browser get mode vfs browser browser dialog add separator add create encoding menu add separator add create plugin menu browser update 
public void update if encoding menu items null j radio button menu item mi encoding menu items get browser current encoding if mi null mi set selected true other encoding set text j edit get property vfs browser other encoding label else other encoding set selected true other encoding set text j edit get property vfs browser other encoding label new  string browser current encoding 
private j menu item create menu item  string name return gui utilities load menu item vfs browser get action context vfs browser name false 
private j menu create encoding menu  action handler action handler new  action handler encoding menu items new  hash map  string j radio button menu item j menu encoding menu new j menu j edit get property vfs browser commands encoding label j menu menu encoding menu auto detect new j check box menu item j edit get property vfs browser commands encoding auto detect auto detect set selected browser auto detect encoding auto detect set action command auto detect auto detect add action listener action handler menu add auto detect menu add separator  button group grp new  button group  list j menu item encoding menu item list new  array list j menu item  string encodings  misc utilities get encodings true for int i i encodings length i  string encoding encodings i j radio button menu item mi new j radio button menu item encoding mi set action command encoding encoding mi add action listener action handler grp add mi encoding menu items put encoding mi encoding menu item list add mi  string system encoding  system get property file encoding if encoding menu items get system encoding null j radio button menu item mi new j radio button menu item system encoding mi set action command encoding system encoding mi add action listener action handler grp add mi encoding menu items put system encoding mi encoding menu item list add mi  collections sort encoding menu item list new  menu item text comparator  iterator iter encoding menu item list iterator while iter has next j radio button menu item mi j radio button menu item iter next if menu get menu component count j menu new menu new j menu j edit get property common more menu add new menu menu new menu menu add mi menu add separator other encoding new j radio button menu item other encoding set action command other encoding other encoding add action listener action handler grp add other encoding menu add other encoding return encoding menu 
private j menu create plugin menu vfs browser browser j menu plugin menu new j menu j edit get property vfs browser plugins label return j menu browser create plugins menu plugin menu false 
public void action performed  action event evt  string action command evt get action command if action command equals auto detect browser auto detect encoding auto detect is selected else if action command equals other encoding  string encoding gui utilities input browser encoding prompt null j edit get property buffer encoding  system get property file encoding if encoding null return browser current encoding encoding else if action command starts with encoding browser current encoding action command substring 
 creates a new browser i o request param type  the request type param browser  the vfs browser instance param path  the first path name to operate on param path  the second path name to operate on param load info a two element array filled out by the request element is the canonical path element is the file list  browser io request int type vfs browser browser  object session vfs vfs  string path  string path  object load info this type type this browser browser this session session this vfs vfs this path path this path path this load info load info 
public void run switch type case list directory list directory break case delete delete break case rename rename break case mkdir mkdir break 
public  string to string  string type string switch type case list directory type string list directory break case delete type string delete break case rename type string rename break case mkdir type string mkdir break default type string unknown break return get class get name type type string vfs vfs path path path path 
private void list directory vfs file directory null  string args path set status j edit get property vfs status listing directory args  string canon path path try set abortable true canon path vfs  canon path session path browser directory vfs  list files session canon path browser catch io exception io set abortable false  log log  log error this io  string pp io to string vfs manager error browser path ioerror directory error pp catch  work thread  abort a finally try vfs  end vfs session session browser catch io exception io set abortable false  log log  log error this io  string pp io to string vfs manager error browser path ioerror directory error pp set abortable false load info canon path load info directory 
private void delete try set abortable true  string args path set status j edit get property vfs status deleting args try path vfs  canon path session path browser if vfs  delete session path browser vfs manager error browser path ioerror delete error null catch io exception io set abortable false  log log  log error this io  string pp io to string vfs manager error browser path ioerror directory error pp catch  work thread  abort a finally try vfs  end vfs session session browser catch io exception io set abortable false  log log  log error this io  string pp io to string vfs manager error browser path ioerror directory error pp 
private void rename try set abortable true  string args path path set status j edit get property vfs status renaming args try path vfs  canon path session path browser path vfs  canon path session path browser vfs file file vfs  get file session path browser if file null if  operating system is case insensitive fs path equals ignore case path allow user to change name case else vfs manager error browser path ioerror rename exists new  string path return if vfs  rename session path path browser vfs manager error browser path ioerror rename error new  string path catch io exception io set abortable false  log log  log error this io  string pp io to string vfs manager error browser path ioerror directory error pp catch  work thread  abort a finally try vfs  end vfs session session browser catch io exception io set abortable false  log log  log error this io  string pp io to string vfs manager error browser path ioerror directory error pp 
private void mkdir try set abortable true  string args path set status j edit get property vfs status mkdir args try path vfs  canon path session path browser if vfs  mkdir session path browser vfs manager error browser path ioerror mkdir error null catch io exception io set abortable false  log log  log error this io args io to string vfs manager error browser path ioerror args catch  work thread  abort a finally try vfs  end vfs session session browser catch io exception io set abortable false  log log  log error this io  string args io to string vfs manager error browser path ioerror args 
public  browser option pane super browser general 
public void  init  default directory  string dirs j edit get property options browser general default path favorites j edit get property options browser general default path home j edit get property options browser general default path last j edit get property options browser general default path buffer j edit get property options browser general default path working default directory new j combo box dirs  string default dir j edit get property vfs browser default path if favorites equals default dir default directory set selected index else if home equals default dir default directory set selected index else if last equals default dir default directory set selected index else if buffer equals default dir default directory set selected index else if working equals default dir default directory set selected index add component j edit get property options browser general default path default directory  show tool bar show toolbar new j check box j edit get property options browser general show toolbar show toolbar set selected j edit get boolean property vfs browser show toolbar add component show toolbar  show menu bar show menubar new j check box j edit get property options browser general show menubar show menubar set selected j edit get boolean property vfs browser show menubar add component show menubar  show icons show icons new j check box j edit get property options browser general show icons show icons set selected j edit get boolean property vfs browser show icons add component show icons  show hidden files show hidden files new j check box j edit get property options browser general show hidden files show hidden files set selected j edit get boolean property vfs browser show hidden files add component show hidden files  ignore case when sorting sort ignore case new j check box j edit get property options browser general sort ignore case sort ignore case set selected j edit get boolean property vfs browser sort ignore case add component sort ignore case  mix files and directories sort mix files and dirs new j check box j edit get property options browser general sort mix files and dirs sort mix files and dirs set selected j edit get boolean property vfs browser sort mix files and dirs add component sort mix files and dirs  double click close double click close new j check box j edit get property options browser general double click close double click close set selected j edit get boolean property vfs browser double click close add component double click close split vfs file dialog horizontally current buffer filter new j check box j edit get property options browser general current buffer filter current buffer filter set selected j edit get boolean property vfs browser current buffer filter add component current buffer filter use default icons use default icons new j check box j edit get property options browser general use default icons use default icons set selected j edit get boolean property vfs browser use default icons add component use default icons 
public void  save  string dirs favorites home last buffer working j edit set property vfs browser default path dirs default directory get selected index j edit set boolean property vfs browser show toolbar show toolbar is selected j edit set boolean property vfs browser show menubar show menubar is selected j edit set boolean property vfs browser show icons show icons is selected j edit set boolean property vfs browser show hidden files show hidden files is selected j edit set boolean property vfs browser sort ignore case sort ignore case is selected j edit set boolean property vfs browser sort mix files and dirs sort mix files and dirs is selected j edit set boolean property vfs browser double click close double click close is selected j edit set boolean property vfs browser current buffer filter current buffer filter is selected j edit set boolean property vfs browser use default icons use default icons is selected 
 browser view final vfs browser browser this browser browser tmp expanded new  hash set  string  dockable window manager dwm j edit get active view get dockable window manager  key listener key listener dwm close listener vfs browser name parent directories new  parent directory list parent directories add key listener key listener parent directories set name parent parent directories get selection model set selection mode  list selection model single selection parent directories set cell renderer new  parent directory renderer parent directories set visible row count parent directories add mouse listener new  parent mouse handler final j scroll pane parent scroller new j scroll pane parent directories parent scroller set minimum size new  dimension table new vfs directory entry table this table add mouse listener new  table mouse handler table set name file j scroll pane table scroller new j scroll pane table table scroller set minimum size new  dimension table scroller get viewport set background table get background table scroller get viewport add mouse listener new  table mouse handler split pane new j split pane browser is horizontal layout j split pane horizontal split j split pane vertical split j edit get boolean property appearance continuous layout parent scroller table scroller split pane set one touch expandable true  swing utilities invoke later new  runnable public void run  string prop browser is horizontal layout vfs browser horizontal splitter vfs browser splitter int loc j edit get integer property prop if loc loc parent scroller get preferred size height split pane set divider location loc parent directories ensure index is visible parent directories get model get size if browser is multiple selection enabled table get selection model set selection mode  list selection model multiple interval selection else table get selection model set selection mode  list selection model single selection set layout new  border layout add  border layout center split pane properties changed 
public void focus on file view table request focus 
 override public void remove notify  string prop browser is horizontal layout vfs browser horizontal splitter vfs browser splitter j edit set integer property prop split pane get divider location super remove notify 
public vfs file get selected files return table get selected files 
public void select none table clear selection 
public void save expansion state tmp expanded clear table get expanded directories tmp expanded 
public void clear expansion state tmp expanded clear 
public void load directory  object node  string path boolean add to history path  misc utilities construct path browser get directory path vfs vfs vfs manager get vfs for path path  object session vfs create vfs session path this if session null return if node null parent directories set list data new  object new  loading placeholder  object load info new  object vfs manager run in work thread new  browser io request  browser io request list directory browser session vfs path null load info browser directory loaded node load info add to history 
 rebuild the parent view after a directory has been loaded param node param path param directory public void directory loaded  object node  string path java util  list vfs file directory  if reloading root update parent directory list if node null  default list model parent list new  default list model  string parent path for vfs  vfs vfs manager get vfs for path parent vfs file file null if  vfs instanceof  file vfs  object session  vfs create vfs session path browser try file  vfs  get file session parent browser if file null file set name  vfs get file name parent catch io exception e  log log  log error this e e if file null create a  directory entry manually instead of using  vfs  get file since so many vfs s have broken implementations of this method file new vfs file  vfs get file name parent parent parent vfs file directory l false parent list insert element at new vfs file  vfs get file name parent parent parent vfs file directory l false parent list insert element at file  string new parent  vfs get parent of path parent if new parent null  misc utilities paths equal parent new parent break else parent new parent parent directories set model parent list int index parent list get size parent directories set selected index index parent directories ensure index is visible index table set directory vfs manager get vfs for path path node directory tmp expanded 
public void update file view table repaint 
public void maybe reload directory  string path  string browser dir browser get directory  string symlink browser dir if  misc utilities is url browser dir symlink browser dir browser dir else symlink browser dir  misc utilities resolve symlinks browser dir if  misc utilities paths equal path symlink browser dir save expansion state load directory null browser dir false because this method is called for every vfs update we don t want to scan the tree all the time  so we use the following algorithm to determine if the path might be part of the tree if the path starts with the browser s current directory we do the tree scan if the browser s directory is favorites we have to do the tree scan as every path can appear under the favorites list if the browser s directory is roots and path is on the local filesystem do a tree scan if browser dir starts with  favorites vfs protocol browser dir starts with  file roots vfs protocol path starts with symlink browser dir return if browser dir starts with  file roots vfs protocol  misc utilities is url path  misc utilities get protocol of url path equals file return table maybe reload directory path 
public void properties changed show icons j edit get boolean property vfs browser show icons table properties changed gui utilities init continuous layout split pane split pane set border null 
 returns the associated code vfs browser code instance since j edit pre public vfs browser get browser return browser 
public vfs directory entry table get table return table 
public j list get parent directory list return parent directories 
private void show file popup vfs file files  component comp  point point popup new  browser commands menu browser files for the parent directory right click on the click we select the clicked item but when the popup goes away we select the currently showing directory popup add popup menu listener new  popup menu listener public void popup menu canceled  popup menu event e public void popup menu will become visible  popup menu event e public void popup menu will become invisible  popup menu event e we use  swing utilities invoke later so that the action is executed before the popup is hidden  swing utilities invoke later new  runnable public void run int index parent directories get model get size parent directories set selected index index gui utilities show popup menu popup comp point x point y 
 parent directory renderer plain font ui manager get font  tree font if plain font null plain font j edit get font property metal secondary font bold font new  font plain font get name  font bold plain font get size 
 override public  component get list cell renderer component j list list  object value int index boolean is selected boolean cell has focus super get list cell renderer component list value index is selected cell has focus  parent directory renderer this set border new  empty border index if value instanceof  loading placeholder  parent directory renderer this set font plain font set icon show icons  file cell renderer loading icon null set text j edit get property vfs browser tree loading else if value instanceof vfs file vfs file dir entry vfs file value  parent directory renderer this set font bold font set icon show icons  file cell renderer get icon for file dir entry true null set text dir entry get name else if value null set text vfs does not follow vfs api return this 
 override public void mouse pressed  mouse event evt int row parent directories location to index evt get point if row  object obj parent directories get model get element at row if obj instanceof vfs file vfs file dir entry vfs file obj if gui utilities is popup trigger evt if popup null popup is visible popup set visible false popup null else parent directories set selected index row show file popup new vfs file dir entry parent directories evt get point 
 override public void mouse released  mouse event evt if evt get click count gui utilities is middle button evt get modifiers return int row parent directories location to index evt get point if row  object obj parent directories get model get element at row if obj instanceof vfs file vfs file dir entry vfs file obj if gui utilities is popup trigger evt browser set directory dir entry get path if browser get mode vfs browser browser focus on file view 
 override public void mouse clicked  mouse event evt  point p evt get point int row table row at point p int column table column at point p if row return if column vfs directory entry table model  entry entry vfs directory entry table model  entry table get model get value at row if  file cell renderer  expansion toggle border is expansion toggle entry level p x return if evt get modifiers  input event button  mask evt get click count browser files activated evt is shift down vfs browser m open new view vfs browser m open true else if gui utilities is middle button evt get modifiers if evt is shift down table get selection model add selection interval row row else table get selection model set selection interval row row browser files activated evt is shift down vfs browser m open new view vfs browser m open true 
 override public void mouse pressed  mouse event evt  point p evt get point if evt get source table p x table get x p y table get y int row table row at point p int column table column at point p if column row vfs directory entry table model  entry entry vfs directory entry table model  entry table get model get value at row if  file cell renderer  expansion toggle border is expansion toggle entry level p x table toggle expanded row return if gui utilities is middle button evt get modifiers if row nothing else if evt is shift down table get selection model add selection interval row row else table get selection model set selection interval row row else if gui utilities is popup trigger evt if popup null popup is visible popup set visible false popup null return if row show file popup null table evt get point else if table get selection model is selected index row table get selection model set selection interval row row show file popup get selected files table evt get point 
 override public void mouse released  mouse event evt if gui utilities is popup trigger evt table get selected row browser files selected 
public  string get path int row  collection  string components new  linked list  string for int i i row i components add get model get element at i to string return get model get element at  text utilities join components  file separator 
 override protected void process key event  key event evt if evt get id  key event key pressed  action context ac vfs browser get action context int row parent directories get selected index switch evt get key code case  key event vk down evt consume if row parent directories get size height parent directories set selected index row break case  key event vk left if evt get modifiers  key event alt mask evt consume browser previous directory else super process event evt break case  key event vk right if evt get modifiers  key event alt mask evt consume browser next directory else super process event evt break case  key event vk tab evt consume if evt get modifiers  key event shift mask browser focus on default component else table request focus break case  key event vk up evt consume if row parent directories set selected index row break case  key event vk back space evt consume  edit action up ac get action vfs browser up ac invoke action evt up break case  key event vk f evt consume  edit action reload ac get action vfs browser reload ac invoke action evt reload break case  key event vk enter evt consume  string path get path row get browser set directory path table request focus break  these actions don t work because they look at the  entry table for the current selected item  we need actions that look at the parent directory list item instead case  key event vk delete evt consume ea ac get action vfs browser delete ac invoke action evt ea break case  key event ctrl mask  key event vk n evt consume ea ac get action vfs browser new file ac invoke action evt ea break case  key event vk insert evt consume ea ac get action vfs browser new directory ac invoke action evt ea break else if evt get id  key event key typed if evt is control down evt is alt down evt is meta down evt consume return switch evt get key char case evt consume if browser get mode vfs browser browser browser set directory  system get property user home break case evt consume if browser get mode vfs browser browser browser root directory break case evt consume if browser get mode vfs browser browser browser set directory browser get view get buffer get directory break if evt is consumed super process key event evt 
bsh allocation expression int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error type is either a class name or a primitive type  simple node type  simple node jjt get child args is either constructor arguments or array dimensions  simple node args  simple node jjt get child if type instanceof bsh ambiguous name bsh ambiguous name name bsh ambiguous name type if args instanceof bsh arguments return object allocation name bsh arguments args callstack interpreter else return object array allocation name bsh array dimensions args callstack interpreter else return primitive array allocation bsh primitive type type bsh array dimensions args callstack interpreter 
private  object object allocation bsh ambiguous name name node bsh arguments arguments node  call stack callstack  interpreter interpreter throws  eval error  name space namespace callstack top  object args arguments node get arguments callstack interpreter if args null throw new  eval error  null args in new this callstack  look for scripted class object  object obj name node to object callstack interpreter false force class  try regular class obj name node to object callstack interpreter true force class  class type null if obj instanceof  class identifier type  class identifier obj get target class else throw new  eval error  unknown class name node text this callstack  is an inner class style object allocation boolean has body jjt get num children if has body bsh block body bsh block jjt get child if type is interface return construct with interface body type args body callstack interpreter else return construct with class body type args body callstack interpreter else return construct object type args callstack 
private  object construct object  class type  object args  call stack callstack throws  eval error  object obj try obj  reflect construct object type args catch  reflect error e throw new  eval error  constructor error e get message this callstack catch  invocation target exception e  no need to wrap this debug  interpreter debug  the constructor threw an exception n t e get target exception throw new  target error  object constructor e get target exception this callstack true  string class name type get name  is it an inner class if class name index of return obj  temporary hack to support inner classes  if the obj is a non static inner class then import the context  this is not a sufficient emulation of inner classes  replace this later work through to class this  this ths callstack top get this null  name space instance name space  name get class name space ths get name space  change the parent which was the class static to the class instance  we really need to check if we re a static inner class here first but for some reason  java won t show the static modifier on our fake inner classes could generate a flag field if instance name space null class name starts with instance name space get name try  class generator get class generator set instance name space parent obj class name instance name space catch  util eval error e throw e to eval error this callstack return obj 
private  object construct with class body  class type  object args bsh block block  call stack callstack  interpreter interpreter throws  eval error  string name callstack top get name inner class count  modifiers modifiers new  modifiers modifiers add modifier  modifiers class public  class clas try clas  class generator get class generator generate class name modifiers null interfaces type super class block false is interface callstack interpreter catch  util eval error e throw e to eval error this callstack try return  reflect construct object clas args catch  exception e if e instanceof  invocation target exception e  exception  invocation target exception e get target exception throw new  eval error  error constructing inner class instance e this callstack 
private  object construct with interface body  class type  object args bsh block body  call stack callstack  interpreter interpreter throws  eval error  name space namespace callstack top  name space local new  name space namespace  anonymous block callstack push local body eval callstack interpreter true override namespace callstack pop statical import fields from the interface so that code inside can refer to the fields directly e g height local import static type try return local get this interpreter get interface type catch  util eval error e throw e to eval error this callstack 
private  object object array allocation bsh ambiguous name name node bsh array dimensions dimensions node  call stack callstack  interpreter interpreter throws  eval error  name space namespace callstack top  class type name node to class callstack interpreter if type null throw new  eval error  class name node get name namespace not found this callstack return array allocation dimensions node type callstack interpreter 
private  object primitive array allocation bsh primitive type type node bsh array dimensions dimensions node  call stack callstack  interpreter interpreter throws  eval error  class type type node get type return array allocation dimensions node type callstack interpreter 
private  object array allocation bsh array dimensions dimensions node  class type  call stack callstack  interpreter interpreter throws  eval error dimensions node can return either a fully intialized array or void when void the prescribed array dimensions defined and undefined are contained in the node  object result dimensions node eval type callstack interpreter if result  primitive void return result else return array new instance type dimensions node callstack 
 create an array of the dimensions specified in dimensions node dimensions node may contain a number of undefined as well as defined dimensions p  background in  java arrays are implemented in arrays of arrays style where for example a two dimensional array is a an array of arrays of some base type  each dimension type has a  java class type associated with it so if foo new int then the type of foo is int and the type of foo is int etc  arrays may also be specified with undefined trailing dimensions meaning that the lower order arrays are not allocated as objects e g if foo new int then foo null true and can later be assigned with the appropriate type e g foo new int  see  learning  java o  reilly  associates more background p  to create an array with undefined trailing dimensions using the reflection api we must use an array type to represent the lower order undefined dimensions as the base type for the array creation  java will then create the correct type by adding the dimensions of the base type to specified allocated dimensions yielding an array of dimensionality base specified with the base dimensons unallocated  to create the base array type we simply create a prototype zero length in each dimension array and use it to get its class  actually i think there is a way we could do it with  class for name but i don t trust this  the code is simpler than the explanation see below private  object array new instance  class type bsh array dimensions dimensions node  call stack callstack throws  eval error if dimensions node num undefined dims  object proto  array new instance type new int dimensions node num undefined dims zeros type proto get class try return  array new instance type dimensions node defined dimensions catch  negative array size exception e throw new  target error e this callstack catch  exception e throw new  eval error  can t construct primitive array e get message this callstack 
bsh ambiguous name int id super id 
public  name get name  name space namespace return namespace get name resolver text 
public  object to object  call stack callstack  interpreter interpreter throws  eval error return to object callstack interpreter false 
 object to object  call stack callstack  interpreter interpreter boolean force class throws  eval error try return get name callstack top to object callstack interpreter force class catch  util eval error e e print stack trace throw e to eval error this callstack 
public  class to class  call stack callstack  interpreter interpreter throws  eval error try return get name callstack top to class catch  class not found exception e throw new  eval error e get message this callstack catch  util eval error e  class path exception is a type of  util eval error throw e to eval error this callstack 
public lhs to lhs  call stack callstack  interpreter interpreter throws  eval error try return get name callstack top to lhs callstack interpreter catch  util eval error e throw e to eval error this callstack 
public  object eval  call stack callstack  interpreter interpreter throws  eval error throw new  interpreter error  don t know how to eval an ambiguous name  use to object if you want an object 
public  string to string return  ambigous name text 
bsh arguments int id super id 
 this node holds a set of arguments for a method invocation or constructor call  note arguments are not currently allowed to be void  disallowing voi ds here was an easy way to support the throwing of a more descriptive error message on use of an undefined argument to a method call very common  if it ever turns out that we need to support that for some reason we ll have to re evaluate how we get meta information about the arguments in the various invoke methods that take  object  we could either pass bsh arguments down to overloaded forms of the methods or throw an exception subtype including the argument position back up where the error message would be compounded public  object get arguments  call stack callstack  interpreter interpreter throws  eval error evaluate each child  object args new  object jjt get num children for int i i args length i args i  simple node jjt get child i eval callstack interpreter if args i  primitive void throw new  eval error  undefined argument  simple node jjt get child i get text this callstack return args 
bsh array dimensions int id super id 
public void add defined dimension num defined dims 
public void add undefined dimension num undefined dims 
public  object eval  class type  call stack callstack  interpreter interpreter throws  eval error if  interpreter debug  interpreter debug array base type type base type type return eval callstack interpreter 
 evaluate the structure of the array in one of two ways a an initializer exists evaluate it and return the fully constructed array object also record the dimensions of that array b evaluate and record the lengths in each dimension and return void  the structure of the array dims is maintained in dimensions public  object eval  call stack callstack  interpreter interpreter throws  eval error  simple node child  simple node jjt get child  child is array initializer  evaluate it and fill in the dimensions it returns  initialized arrays are always fully defined no undefined dimensions to worry about  the syntax uses the undefined dimension count e g int if child instanceof bsh array initializer if base type null throw new  eval error  internal  array  eval err unknown base type this callstack  object init value bsh array initializer child eval base type num undefined dims callstack interpreter  class array class init value get class int actual dimensions  reflect get array dimensions array class defined dimensions new int actual dimensions  compare with number of dimensions actually created with the number specified syntax uses the undefined ones here if defined dimensions length num undefined dims throw new  eval error  incompatible initializer  allocation calls for a num undefined dims dimensional array but initializer is a actual dimensions dimensional array this callstack fill in defined dimensions lengths  object array slice init value for int i i defined dimensions length i defined dimensions i  array get length array slice if defined dimensions i array slice  array get array slice return init value else  evaluate the defined dimensions of the array defined dimensions new int num defined dims for int i i num defined dims i try  object length  simple node jjt get child i eval callstack interpreter defined dimensions i  primitive length int value catch  exception e throw new  eval error  array index i does not evaluate to an integer this callstack return  primitive void 
bsh array initializer int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error throw new  eval error  array initializer has no base type this callstack 
 construct the array from the initializer syntax param base type the base class type of the array no dimensionality param dimensions the top number of dimensions of the array e g for a  string public  object eval  class base type int dimensions  call stack callstack  interpreter interpreter throws  eval error int num initializers jjt get num children allocate the array to store the initializers int dima new int dimensions description of the array  the other dimensions default to zero and are assigned when the values are set dima num initializers  object initializers  array new instance base type dima  evaluate the initializers for int i i num initializers i  simple node node  simple node jjt get child i  object current initializer if node instanceof bsh array initializer if dimensions throw new  eval error  invalid  location for  intializer position i this callstack current initializer bsh array initializer node eval base type dimensions callstack interpreter else current initializer node eval callstack interpreter if current initializer  primitive void throw new  eval error  void in array initializer position i this callstack  determine if any conversion is necessary on the initializers  quick test to see if conversions apply  if the dimensionality of the array is then the elements of the initializer can be primitives or boxable types  if it is greater then the values must be array object types and there are currently no conversions that we do on those  if we have conversions on those in the future then we need to get the real base type here instead of the dimensionless one  object value current initializer if dimensions  we do a bsh cast here strict java should be able to affect the cast there when we tighten control try value  types cast object current initializer base type  types cast catch  util eval error e throw e to eval error  error in array initializer this callstack unwrap any primitive map voids to null etc value  primitive unwrap value store the value in the array try  array set initializers i value catch  illegal argument exception e  interpreter debug illegal arg e throw type error base type current initializer i callstack catch  array store exception e i think this can happen  interpreter debug arraystore e throw type error base type current initializer i callstack return initializers 
private void throw type error  class base type  object initializer int arg num  call stack callstack throws  eval error  string rhs type if initializer instanceof  primitive rhs type  primitive initializer get type get name else rhs type  reflect normalize class name initializer get class throw new  eval error  incompatible type rhs type in initializer of array type base type at position arg num this callstack 
bsh assignment int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error bsh primary expression lhs node bsh primary expression jjt get child if lhs node null throw new  interpreter error  error null lh snode boolean strict java interpreter get strict java lhs lhs lhs node to lhs callstack interpreter if lhs null throw new  interpreter error  error null lhs  for operator assign operations save the lhs value before evaluating the rhs  this is correct  java behavior for postfix operations e g i i i should be not  object lhs value null if operator assign assign doesn t need the pre value try lhs value lhs get value catch  util eval error e throw e to eval error this callstack  simple node rhs node  simple node jjt get child  object rhs implement blocks foo if rhs node instanceof bsh block rsh else rhs rhs node eval callstack interpreter if rhs  primitive void throw new  eval error  void assignment this callstack try switch operator case assign return lhs assign rhs strict java case plusassign return lhs assign operation lhs value rhs plus strict java case minusassign return lhs assign operation lhs value rhs minus strict java case starassign return lhs assign operation lhs value rhs star strict java case slashassign return lhs assign operation lhs value rhs slash strict java case andassign case andassignx return lhs assign operation lhs value rhs bit and strict java case orassign case orassignx return lhs assign operation lhs value rhs bit or strict java case xorassign return lhs assign operation lhs value rhs xor strict java case modassign return lhs assign operation lhs value rhs mod strict java case lshiftassign case lshiftassignx return lhs assign operation lhs value rhs lshift strict java case rsignedshiftassign case rsignedshiftassignx return lhs assign operation lhs value rhs rsignedshift strict java case runsignedshiftassign case runsignedshiftassignx return lhs assign operation lhs value rhs runsignedshift strict java default throw new  interpreter error unimplemented operator in assignment bsh catch  util eval error e throw e to eval error this callstack 
private  object operation  object lhs  object rhs int kind throws  util eval error  implement  string value  according to the jls value may be anything  in  bean shell we ll disallow void undefined values or should we map them to the empty string if lhs instanceof  string rhs  primitive void if kind plus throw new  util eval error  use of non operator with  string lhs return  string lhs rhs if lhs instanceof  primitive rhs instanceof  primitive if lhs  primitive void rhs  primitive void throw new  util eval error  illegal use of undefined object or void literal else if lhs  primitive null rhs  primitive null throw new  util eval error  illegal use of null object or null literal if lhs instanceof  boolean lhs instanceof  character lhs instanceof  number lhs instanceof  primitive rhs instanceof  boolean rhs instanceof  character rhs instanceof  number rhs instanceof  primitive return  primitive binary operation lhs rhs kind throw new  util eval error  non primitive value in operator lhs get class token image kind rhs get class 
bsh binary expression int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error  object lhs  simple node jjt get child eval callstack interpreter  doing instanceof  next node is a type if kind instanceof null object ref is not instance of any type if lhs  primitive null return new  primitive false  class rhs bsh type jjt get child get type callstack interpreter primitive number or void cannot be tested for instanceof if lhs instanceof  primitive throw new  eval error  cannot be instance of primitive type  primitive number or void is not normally an instanceof anything  but for internal use we ll test true for the bsh  primitive class i e instanceof bsh  primitive will be true if lhs instanceof  primitive if rhs org gjt sp jedit bsh  primitive class return new  primitive true else return new  primitive false  general case performe the instanceof based on assignability boolean ret  types is java base assignable rhs lhs get class return new  primitive ret  the following two boolean checks were tacked on  this could probably be smoothed out  look ahead and short circuit evaluation of the rhs if we re a boolean and and the lhs is false if kind bool and kind bool andx  object obj lhs if is primitive value lhs obj  primitive lhs get value if obj instanceof  boolean  boolean obj boolean value false return new  primitive false  look ahead and short circuit evaluation of the rhs if we re a boolean and and the lhs is false if kind bool or kind bool orx  object obj lhs if is primitive value lhs obj  primitive lhs get value if obj instanceof  boolean  boolean obj boolean value true return new  primitive true end stuff that was tacked on for boolean short circuiting  are both the lhs and rhs either wrappers or primitive values do binary op boolean is lhs wrapper is wrapper lhs  object rhs  simple node jjt get child eval callstack interpreter boolean is rhs wrapper is wrapper rhs if is lhs wrapper is primitive value lhs is rhs wrapper is primitive value rhs  special case for eq on two wrapper objects if is lhs wrapper is rhs wrapper kind eq  don t auto unwrap wrappers preserve identity semantics fall through to object operations below else try return  primitive binary operation lhs rhs kind catch  util eval error e throw e to eval error this callstack  doing the following makes it hard to use untyped vars e g if arg null what if arg is a primitive  the answer is that we should test only if the var is typed need to get that info here else  do we have a mixture of primitive values and non primitives primitive value not null not void int prim count if is primitive value lhs prim count if is primitive value rhs prim count if prim count both primitive types should have been handled above throw new  interpreter error should not be here else if prim count mixture of one and the other throw new  eval error  operator token image kind inappropriate for object primitive combination this callstack else fall through to handle both non primitive types end check for primitive and non primitive mix  treat lhs and rhs as arbitrary objects and do the operation including null and void represented by their  primitive types  system out println binary op arbitrary obj lhs rhs switch kind case eq return new  primitive lhs rhs case ne return new  primitive lhs rhs case plus if lhs instanceof  string rhs instanceof  string return lhs to string rhs to string fall through to default case default if lhs instanceof  primitive rhs instanceof  primitive if lhs  primitive void rhs  primitive void throw new  eval error illegal use of undefined variable class or void literal this callstack else if lhs  primitive null rhs  primitive null throw new  eval error illegal use of null value or null literal this callstack throw new  eval error  operator token image kind inappropriate for objects this callstack 
private boolean is primitive value  object obj return obj instanceof  primitive obj  primitive void obj  primitive null 
private boolean is wrapper  object obj return obj instanceof  boolean obj instanceof  character obj instanceof  number 
bsh block int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error return eval callstack interpreter false 
param override namespace if set to true the block will be executed in the current namespace not a subordinate one p  if true no new  block namespace will be swapped onto the stack and the eval will happen in the current top namespace  this is used by  bsh method  try statement etc which must intialize the block first and also for those that perform multiple passes in the same block public  object eval  call stack callstack  interpreter interpreter boolean override namespace throws  eval error  object sync value null if is synchronized  first node is the expression on which to sync  simple node exp  simple node jjt get child sync value exp eval callstack interpreter  object ret if is synchronized  do the actual synchronization synchronized sync value ret eval block callstack interpreter override namespace null filter else ret eval block callstack interpreter override namespace null filter return ret 
 object eval block  call stack callstack  interpreter interpreter boolean override namespace  node filter node filter throws  eval error  object ret  primitive void  name space enclosing name space null if override namespace enclosing name space callstack top  block name space body name space new  block name space enclosing name space callstack swap body name space int start child is synchronized int num children jjt get num children try  evaluate block in two passes  first do class declarations then do everything else for int i start child i num children i  simple node node  simple node jjt get child i if node filter null node filter is visible node continue if node instanceof bsh class declaration node eval callstack interpreter for int i start child i num children i  simple node node  simple node jjt get child i if node instanceof bsh class declaration continue filter nodes if node filter null node filter is visible node continue ret node eval callstack interpreter statement or embedded block evaluated a return statement if ret instanceof  return control break finally make sure we put the namespace back when we leave if override namespace callstack swap enclosing name space return ret 
public bsh cast expression int id super id 
return the result of the cast public  object eval  call stack callstack  interpreter interpreter throws  eval error  name space namespace callstack top  class to type bsh type jjt get child get type callstack interpreter  simple node expression  simple node jjt get child evaluate the expression  object from value expression eval callstack interpreter  class from type from value get class todo need to add is java castable test for strict java as opposed to is java assignable try return  types cast object from value to type  types cast catch  util eval error e throw e to eval error this callstack 
bsh class declaration int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error int child resolve superclass if any  class super class null if extend bsh ambiguous name super node bsh ambiguous name jjt get child child super class super node to class callstack interpreter  get interfaces  class interfaces new  class num interfaces for int i i num interfaces i bsh ambiguous name node bsh ambiguous name jjt get child child interfaces i node to class callstack interpreter if interfaces i is interface throw new  eval error  type node text is not an interface this callstack bsh block block  get the class body bsh block if child jjt get num children block bsh block jjt get child child else block new bsh block  parser tree constants jjtblock try return  class generator get class generator generate class name modifiers interfaces super class block is interface callstack interpreter catch  util eval error e throw e to eval error this callstack 
public  string to string return  class declaration name 
param bases ur ls jar class loader seems to require absolute paths public  bsh class loader  bsh class manager class manager url bases super bases this class manager class manager 
param bcp ur ls jar class loader seems to require absolute paths public  bsh class loader  bsh class manager class manager  bsh class path bcp this class manager bcp get path components 
 for use by children param class manager ur ls jar class loader seems to require absolute paths protected  bsh class loader  bsh class manager class manager this class manager new url 
public void add url url url super add url url 
 this modification allows us to reload classes which are in the  java vm user classpath  we search first rather than delegate to the parent classloader or bootstrap path first  an exception is for  bean shell core classes which are always loaded from the same classloader as the interpreter public  class load class  string name boolean resolve throws  class not found exception  class c null  check first for classes loaded through this loader  the vm will not allow a class to be loaded twice c find loaded class name if c null return c  this is copied from  class manager impl  we should refactor this somehow if it sticks around if name starts with  class manager impl bsh package try return org gjt sp jedit bsh  interpreter class get class loader load class name catch  class not found exception e  try to find the class using our classloading mechanism  note i wish we didn t have to catch the exception here slow try c find class name catch  class not found exception e if c null throw new  class not found exception here in loa class if resolve resolve class c return c 
 find the correct source for the class  try designated loader if any  try our url class loader paths if any  try base loader if any  try system add some caching for not found classes protected  class find class  string name throws  class not found exception  deal with this cast somehow maybe have this class use  class manager impl type directly  don t add the method to  bsh class manager it s really an impl thing  class manager impl bcm  class manager impl get class manager  should we try to load the class ourselves or delegate look for overlay loader  deal with this cast somehow maybe have this class use  class manager impl type directly  don t add the method to  bsh class manager it s really an impl thing  class loader cl bcm get loader for class name  class c  if there is a designated loader and it s not us delegate to it if cl null cl this try return cl load class name catch  class not found exception e throw new  class not found exception  designated loader could not find class e  let url class loader try any paths it may have if get ur ls length try return super find class name catch  class not found exception e  system out println base loader here caught class not found name  if there is a base loader and it s not us delegate to it cl bcm get base loader if cl null cl this try return cl load class name catch  class not found exception e  try system loader return bcm plain class for name name 
 bsh class manager get class manager return class manager 
 create a new instance of the class manager  class manager instnaces are now associated with the interpreter see org gjt sp jedit bsh  interpreter get class manager get class manager see org gjt sp jedit bsh  interpreter set class loader  class loader set class loader public static  bsh class manager create class manager  interpreter interpreter  bsh class manager manager  do we have the necessary jdk packages and optional package if  capabilities class exists java lang ref  weak reference  capabilities class exists java util  hash map  capabilities class exists org gjt sp jedit bsh classpath  class manager impl try  try to load the module don t refer to it directly here or we re dependent upon it  class clas  class for name org gjt sp jedit bsh classpath  class manager impl manager  bsh class manager clas new instance catch  exception e throw new  interpreter error  error loading classmanager e else manager new  bsh class manager if interpreter null interpreter new  interpreter manager declaring interpreter interpreter return manager 
public boolean class exists  string name return class for name name null 
 load the specified class by name taking into account added classpath and reloaded classes etc  note  again this is just a trivial implementation  see bsh classpath  class manager impl for the fully functional class management package return the class or null public  class class for name  string name if is class being defined name throw new  interpreter error  attempting to load class in the process of being defined name  class clas null try clas plain class for name name catch  class not found exception e ignore try scripted class if clas null clas load source class name return clas 
protected  class load source class  string name  string file name name replace java  input stream in get resource as stream file name if in null return null try  system out println  loading class from source file file name declaring interpreter eval new  input stream reader in catch  eval error e ignore  system err println e try return plain class for name name catch  class not found exception e  system err println  class not found in source file name return null 
 perform a plain  class for name or call the externally provided classloader  if a  bsh class manager implementation is loaded the call will be delegated to it to allow for additional hooks p  this simply wraps that bottom level class lookup call and provides a central point for monitoring and handling certain  java version dependent bugs etc see class for name  string return the class public  class plain class for name  string name throws  class not found exception  class c null try if external class loader null c external class loader load class name else c  class for name name cache class info name c  original note  jdk under  win is throwing these to warn about lower case upper case possible mismatch e g bsh console bsh  console  update  prior to we were squeltching  no class def found errors which was very annoying i cannot reproduce the original problem and this was never a valid solution  if there are legacy v ms that have problems we can include a more specific test for them here catch  no class def found error e throw no class def found name e return c 
 get a resource url using the  bean shell classpath param path should be an absolute path public url get resource  string path url url null if external class loader null classloader wants no leading slash url external class loader get resource path substring if url null url  interpreter class get resource path return url 
 get a resource stream using the  bean shell classpath param path should be an absolute path public  input stream get resource as stream  string path  input stream in null if external class loader null classloader wants no leading slash in external class loader get resource as stream path substring if in null in  interpreter class get resource as stream path return in 
 cache info about whether name is a class or not param value if value is non null cache the class if value is null set the flag that it is not a class to speed later resolution public void cache class info  string name  class value if value null absolute class cache put name value else absolute non classes put name novalue 
 cache a resolved possibly overloaded method based on the argument types used to invoke it subject to classloader change  static and  object methods are cached separately to support fast lookup in the general case where either will do public void cache resolved method  class clas  class types  method method if  interpreter debug  interpreter debug cache resolved method putting clas method  signature key sk new  signature key clas method get name types if  modifier is static method get modifiers resolved static methods put sk method else resolved object methods put sk method 
 return a previously cached resolved method param only static specifies that only a static method may be returned return the  method or null protected  method get resolved method  class clas  string method name  class types boolean only static  signature key sk new  signature key clas method name types  try static and then object if allowed  note that the  java compiler should not allow both  method method  method resolved static methods get sk if method null only static method  method resolved object methods get sk if  interpreter debug if method null  interpreter debug get resolved method cache miss clas method name else  interpreter debug get resolved method cache hit clas method return method 
 clear the caches in  bsh class manager protected void clear caches absolute non classes new  hashtable absolute class cache new  hashtable resolved object methods new  hashtable resolved static methods new  hashtable 
 set an external class loader  bean shell will use this at the same point it would otherwise use the plain  class for name i e if no explicit classpath management is done from the script add class path set class path reload classes then  bean shell will only use the supplied classloader  if additional classpath management is done then  bean shell will perform that in addition to the supplied external classloader  however  bean shell is not currently able to reload classes supplied through the external classloader public void set class loader  class loader external cl external class loader external cl class loader changed 
public void add class path url path throws io exception 
 clear all loaders and start over  no class loading public void reset clear caches 
 set a new base classpath and create a new base classloader  this means all types change public void set class path url cp throws  util eval error throw cm unavailable 
 overlay the entire path with a new class loader  set the base path to the user path base path  no point in including the boot class path can t reload thos public void reload all classes throws  util eval error throw cm unavailable 
 reloading classes means creating a new classloader and using it whenever we are asked for classes in the appropriate space  for this we use a  discrete files class loader public void reload classes  string class names throws  util eval error throw cm unavailable 
 reload all classes in the specified package e g com sun tools  the special package name unpackaged can be used to refer to unpackaged classes public void reload package  string pack throws  util eval error throw cm unavailable 
 support for import  hide details in here as opposed to  name space protected void do super import throws  util eval error throw cm unavailable 
a super import import operation has been performed protected boolean has super import return false 
 return the name or null if none is found  throw an  class path exception containing detail if name is ambigous protected  string get class name by unq name  string name throws  util eval error throw cm unavailable 
public void add listener  listener l 
public void remove listener  listener l 
public void dump  print writer pw pw println  bsh class manager no class manager 
 flag the class name as being in the process of being defined  the class manager will not attempt to load it  note this implementation is temporary  we currently keep a flat namespace of the base name of classes i e  bean shell cannot be in the process of defining two classes in different packages with the same base name  to remove this limitation requires that we work through namespace imports in an analogous or using the same path as regular class import resolution  this workaround should handle most cases so we ll try it for now protected void defining class  string class name  string base name  name suffix class name int i base name index of if i base name base name substring i  string cur  string defining classes base names get base name if cur null throw new  interpreter error  defining class problem class name  bean shell cannot yet simultaneously define two or more dependant classes of the same name  attempt to define class name while defining cur defining classes put class name novalue defining classes base names put base name class name 
protected boolean is class being defined  string class name return defining classes get class name null 
 this method is a temporary workaround used with defining class  it is to be removed at some point protected  string get class being defined  string class name  string base name  name suffix class name return  string defining classes base names get base name 
 indicate that the specified class name has been defined and may be loaded normally protected void done defining class  string class name  string base name  name suffix class name defining classes remove class name defining classes base names remove base name 
public  class define class  string name byte code throw new  interpreter error  can t create class name without class manager package  old implementation injected classes into the parent classloader  this was incorrect behavior for several reasons  the biggest problem is that classes could therefore only be defined once across all executions of the script  class loader cl this get class get class loader  class clas try clas  class  reflect invoke object method cl define class new  object name code new  primitive int offset new  primitive code length len  interpreter null  call stack null  simple node null catch  exception e e print stack trace throw new  interpreter error  unable to define class e absolute non classes remove name may have been axed previously return clas 
protected void class loader changed 
 annotate the  no class def found error with some info about the class we were trying to load protected static  error no class def found  string class name  error e return new  no class def found error a class required by class class name could not be loaded n e to string 
protected static  util eval error cm unavailable return new  capabilities  unavailable  class loading features unavailable 
 signature key  class clas  string method name  class types this clas clas this method name method name this types types 
public int hash code if hash code hash code clas hash code method name hash code if types null no args method return hash code for int i i types length i int hc types i null types i hash code hash code hash code i hc return hash code 
public boolean equals  object o  signature key target  signature key o if types null return target types null if clas target clas return false if method name equals target method name return false if types length target types length return false for int i i types length i if types i null if target types i null return false else if types i equals target types i return false return true 
public  bsh class path  string name this name name reset 
public  bsh class path  string name url urls this name add urls 
public void set path url urls reset add urls 
 add the specified  bsh class path as a component of our path  changes in the bcp will be reflected through us public void add component  bsh class path bcp if comp paths null comp paths new  array list comp paths add bcp bcp add listener this 
public void add url urls path add all  arrays as list urls if maps initialized map urls 
public void add url url throws io exception path add url if maps initialized map url 
 get the path components including any component paths public url get path components return url get full path to array new url 
 return the set of class names in the specified package including all component paths synchronized public  set get classes for package  string pack insure initialized  set set new  hash set  collection c  collection package map get pack if c null set add all c if comp paths null for int i i comp paths size i c  bsh class path comp paths get i get classes for package pack if c null set add all c return set 
 return the source of the specified class which may lie in component path synchronized public  class source get class source  string class name  before triggering classpath mapping initialization check for explicitly set class sources e g generated classes  these would take priority over any found in the classpath anyway  class source cs  class source class source get class name if cs null return cs insure initialized trigger possible mapping cs  class source class source get class name if cs null comp paths null for int i i comp paths size cs null i cs  bsh class path comp paths get i get class source class name return cs 
 explicitly set a class source  this is used for generated classes but could potentially be used to allow a user to override which version of a class from the classpath is located synchronized public void set class source  string class name  class source cs class source put class name cs 
 if the claspath map is not initialized do it now  if component maps are not do them as well  random note  should this be insure or ensure i know i ve seen ensure used in the jdk source  here s what  webster has to say  main  entry ensure  pronunciation in shur  function transitive verb  inflected  form s ensured ensuring to make sure certain or safe guarantee synonyms ensure insure assure secure mean to make a thing or person sure ensure insure and assure are interchangeable in many contexts where they indicate the making certain or inevitable of an outcome but insure sometimes stresses the taking of necessary measures beforehand and assure distinctively implies the removal of doubt and suspense from a person s mind secure implies action taken to guard against attack or loss public void insure initialized insure initialized true 
param top path indicates that this is the top level classpath component and it should send the start class mapping message protected synchronized void insure initialized boolean top path  if we are the top path and haven t been initialized before inform the listeners we are going to do expensive map if top path maps initialized start class mapping initialize components if comp paths null for int i i comp paths size i  bsh class path comp paths get i insure initialized false initialize ourself if maps initialized map url path to array new url if top path maps initialized end class mapping maps initialized true 
 get the full path including component paths component paths listed first in order  duplicate path components are removed protected  list get full path  list list new  array list if comp paths null for int i i comp paths size i  list l  bsh class path comp paths get i get full path take care to remove dups wish we had an ordered set collection  iterator it l iterator while it has next  object o it next if list contains o list add o list add all path return list 
 support for super import  get the full name associated with the unqualified name in this classpath  returns either the  string name or an  ambiguous name object encapsulating the various names public  string get class name by unq name  string name throws  class path exception insure initialized  unqualified name table unq name table get unqualified name table  object obj unq name table get name if obj instanceof  ambiguous name throw new  class path exception  ambigous class names  ambiguous name obj get return  string obj 
private  unqualified name table get unqualified name table if unq name table null unq name table build unqualified name table return unq name table 
private  unqualified name table build unqualified name table  unqualified name table unq name table new  unqualified name table add component names if comp paths null for int i i comp paths size i  set s  bsh class path comp paths get i class source key set  iterator it s iterator while it has next unq name table add  string it next add ours  iterator it class source key set iterator while it has next unq name table add  string it next return unq name table 
public  string get all names insure initialized  list names new  array list  iterator it get packages set iterator while it has next  string pack  string it next names add all remove inner class names get classes for package pack if name completion includes unq names names add all get unqualified name table key set return  string names to array new  string 
call map url for each url in the array synchronized void map url urls for int i i urls length i try map urls i catch io exception e  string s  error constructing classpath urls i e error while mapping s 
synchronized void map url url throws io exception  string name url get file  file f new  file name if f is directory class mapping  directory f to string map traverse dir for classes f new  dir class source f else if is archive file name name class mapping  archive url map search jar for classes url new  jar class source url else if is class file name name map loose class name url else  string s  not a classpath component name error while mapping s 
private void map  string classes  object source for int i i classes length i  system out println classes i source map class classes i source 
private void map class  string class name  object source add to package map  string sa split classname class name  string pack sa  string clas sa  set set  set package map get pack if set null set new  hash set package map put pack set set add class name  add to class source map  object obj class source get class name don t replace previously set found earlier in classpath or explicitly set via set class source if obj null class source put class name source 
 clear everything and reset the path to empty synchronized private void reset path new  array list comp paths null clear cached structures 
 clear anything cached  all will be reconstructed as necessary synchronized private void clear cached structures maps initialized false package map new  hash map class source new  hash map unq name table null name space changed 
public void class path changed clear cached structures notify listeners 
static  string traverse dir for classes  file dir throws io exception  list list traverse dir for classes aux dir dir return  string list to array new  string 
static  list traverse dir for classes aux  file top dir  file dir throws io exception  list list new  array list  string top top dir get absolute path  file children dir list files for int i i children length i  file child children i if child is directory list add all traverse dir for classes aux top dir child else  string name child get absolute path if is class file name name  remove absolute topdir portion of path and leave package class part if name starts with top name name substring top length else throw new io exception problem parsing paths name canonicalize class name name list add name return list 
 get the class file entries from the  jar static  string search jar for classes url jar throws io exception  vector v new  vector  input stream in jar open stream  zip input stream zin new  zip input stream in  zip entry ze while ze zin get next entry null  string name ze get name if is class file name name v add element canonicalize class name name zin close  string sa new  string v size v copy into sa return sa 
public static boolean is class file name  string name return name to lower case ends with class name index of 
public static boolean is archive file name  string name name name to lower case return name ends with jar name ends with zip 
 create a proper class name from a messy thing  turn or into remove leading class and trailing class  note this makes lots of strings could be faster public static  string canonicalize class name  string name  string classname name replace classname classname replace if classname starts with class classname classname substring if classname ends with class classname classname substring classname length return classname 
 split class name into package and name public static  string split classname  string classname classname canonicalize class name classname int i classname last index of  string classn packn if i top level class classn classname packn unpackaged else packn classname substring i classn classname substring i return new  string packn classn 
 return a new collection without any inner class names public static  collection remove inner class names  collection col  list list new  array list list add all col  iterator it list iterator while it has next  string name  string it next if name index of it remove return list 
public static url get user class path components throws  class path exception if user class path comp null return user class path comp  string cp  system get property java class path  string paths  string util split cp  file path separator url urls new url paths length try for int i i paths length i  we take care to get the canonical path first  java deals with relative paths for it s bootstrap loader but jar class loader doesn t urls i new  file new  file paths i get canonical path to url catch io exception e throw new  class path exception can t parse class path e user class path comp urls return urls 
 get a list of all of the known packages public  set get packages set insure initialized  set set new  hash set set add all package map key set if comp paths null for int i i comp paths size i set add all  bsh class path comp paths get i package map key set return set 
public void add listener  class path listener l listeners add element new  weak reference l 
public void remove listener  class path listener l listeners remove element l 
void notify listeners for  enumeration e listeners elements e has more elements  weak reference wr  weak reference e next element  class path listener l  class path listener wr get if l null garbage collected listeners remove element wr else l class path changed 
a  bsh class path initialized to the user path from java class path public static  bsh class path get user class path throws  class path exception if user class path null user class path new  bsh class path  user  class  path get user class path components return user class path 
 get the boot path including the lib rt jar if possible public static  bsh class path get boot class path throws  class path exception if boot class path null try  string rtjar  system get property java home lib rt jar  string rtjar get rt jar path url url new  file rtjar to url boot class path new  bsh class path  boot  class  path new url url catch  malformed url exception e throw new  class path exception can t find boot jar e return boot class path 
private static  string get rt jar path  string url string  class class get resource java lang  string class to external form if url string starts with jar file return null int i url string index of if i return null return url string substring jar file length i 
 jar class source url url source url 
public url get url return url source 
public byte get code  string class name throw new  error  unimplemented 
public  string to string return  jar source 
 dir class source  file dir source dir 
public  file get dir return  file source 
public  string to string return  dir source 
public byte get code  string class name return read bytes from file get dir class name 
public static byte read bytes from file  file base  string class name  string n class name replace  file separator char class  file file new  file base n if file null file exists return null byte bytes try  file input stream fis new  file input stream file  data input stream dis new  data input stream fis bytes new byte int file length dis read fully bytes dis close catch io exception ie throw new  runtime exception  couldn t load file file return bytes 
 generated class source byte bytecode source bytecode 
public byte get code  string class name return byte source 
public static void main  string args throws  exception url urls new url args length for int i i args length i urls i new  file args i to url  bsh class path bcp new  bsh class path  test urls 
public  string to string return  bsh class path name super to string path path n comp paths comp paths 
void add  string fullname  string name split classname fullname  object have super get name if have null super put name fullname else if have instanceof  ambiguous name  ambiguous name have add fullname else  string  ambiguous name an new  ambiguous name an add  string have an add fullname super put name an 
public void add  string name list add name 
public  list get return  string list to array new  string return list 
 fire the  name source listeners void name space changed if name source listeners null return for int i i name source listeners size i  name source  listener name source listeners get i name source changed this 
 implements  name source  add a listener who is notified upon changes to names in this space public void add name source listener  name source  listener listener if name source listeners null name source listeners new  array list name source listeners add listener 
public static void add mapping feedback  mapping feedback mf if mapping feedback listener null throw new  runtime exception  unimplemented already a listener mapping feedback listener mf 
void start class mapping if mapping feedback listener null mapping feedback listener start class mapping else  system err println  start  class path  mapping 
void class mapping  string msg if mapping feedback listener null mapping feedback listener class mapping msg else  system err println  mapping msg 
void error while mapping  string s if mapping feedback listener null mapping feedback listener error while mapping s else  system err println s 
void end class mapping if mapping feedback listener null mapping feedback listener end class mapping else  system err println  end  class path  mapping 
bsh enhanced for statement int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error  class element type null  simple node expression statement null  name space enclosing name space callstack top  simple node first node  simple node jjt get child int node count jjt get num children if first node instanceof bsh type element type bsh type first node get type callstack interpreter expression  simple node jjt get child if node count statement  simple node jjt get child else expression first node if node count statement  simple node jjt get child  block name space each name space new  block name space enclosing name space callstack swap each name space final  object iteratee expression eval callstack interpreter if iteratee  primitive null throw new  eval error  the collection array map iterator or enumeration portion of a for statement cannot be null this callstack  collection manager cm  collection manager get collection manager if cm is bsh iterable iteratee throw new  eval error  can t iterate over type iteratee get class this callstack  bsh iterator iterator cm get bsh iterator iteratee  object return control  primitive void while iterator has next try if element type null each name space set typed variable var name name element type type iterator next value new  modifiers none else each name space set variable var name iterator next false catch  util eval error e throw e to eval error for loop iterator variable var name this callstack boolean breakout false switch eats a multi level break here if statement null not empty statement  object ret statement eval callstack interpreter if ret instanceof  return control switch  return control ret kind case return return control ret breakout true break case continue break case break breakout true break if breakout break callstack swap enclosing name space return return control 
public bsh formal comment int id super id 
bsh formal parameter int id super id 
public  string get type descriptor  call stack callstack  interpreter interpreter  string default package if jjt get num children return bsh type jjt get child get type descriptor callstack interpreter default package else this will probably not get used return  ljava lang  object  object type 
 evaluate the type public  object eval  call stack callstack  interpreter interpreter throws  eval error if jjt get num children type bsh type jjt get child get type callstack interpreter else type untyped return type 
bsh formal parameters int id super id 
void insure parsed if param names null return this num args jjt get num children  string param names new  string num args for int i i num args i bsh formal parameter param bsh formal parameter jjt get child i param names i param name this param names param names 
public  string get param names insure parsed return param names 
public  string get type descriptors  call stack callstack  interpreter interpreter  string default package if type descriptors null return type descriptors insure parsed  string type desc new  string num args for int i i num args i bsh formal parameter param bsh formal parameter jjt get child i type desc i param get type descriptor callstack interpreter default package this type descriptors type desc return type desc 
 evaluate the types  note that type resolution does not require the interpreter instance public  object eval  call stack callstack  interpreter interpreter throws  eval error if param types null return param types insure parsed  class param types new  class num args for int i i num args i bsh formal parameter param bsh formal parameter jjt get child i param types i  class param eval callstack interpreter this param types param types return param types 
bsh for statement int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error int i if has for init for init  simple node jjt get child i if has expression expression  simple node jjt get child i if has for update for update  simple node jjt get child i if i jjt get num children should normally be statement  simple node jjt get child i  name space enclosing name space callstack top  block name space for name space new  block name space enclosing name space  note some interesting things are going on here  we swap instead of push  the primary mode of operation acts like we are in the enclosing namespace super must be preserved etc  we do not call the body block eval with the namespace override  instead we allow it to create a second subordinate  block name space child of the for name space  variable propogation still works through the chain but the block s child cleans the state between iteration which is correct  java behavior see forscope bsh put for name space it on the top of the stack  note it s important that there is only one exit point from this method so that we can swap back the namespace callstack swap for name space  do the for init if has for init for init eval callstack interpreter  object return control  primitive void while true if has expression boolean cond bsh if statement evaluate condition expression callstack interpreter if cond break boolean breakout false switch eats a multi level break here if statement null not empty statement do not invoke special override for block see above  object ret statement eval callstack interpreter if ret instanceof  return control switch  return control ret kind case return return control ret breakout true break case continue break case break breakout true break if breakout break if has for update for update eval callstack interpreter callstack swap enclosing name space put it back return return control 
bsh if statement int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error  object ret null if evaluate condition  simple node jjt get child callstack interpreter ret  simple node jjt get child eval callstack interpreter else if jjt get num children ret  simple node jjt get child eval callstack interpreter if ret instanceof  return control return ret else return  primitive void 
public static boolean evaluate condition  simple node cond exp  call stack callstack  interpreter interpreter throws  eval error  object obj cond exp eval callstack interpreter if obj instanceof  primitive if obj  primitive void throw new  eval error  condition evaluates to void type cond exp callstack obj  primitive obj get value if obj instanceof  boolean return  boolean obj boolean value else throw new  eval error  condition must evaluate to a  boolean or boolean cond exp callstack 
bsh import declaration int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error  name space namespace callstack top if super import try namespace do super import catch  util eval error e throw e to eval error this callstack else if static import if import package  class clas bsh ambiguous name jjt get child to class callstack interpreter namespace import static clas else throw new  eval error static field imports not supported yet this callstack else  string name bsh ambiguous name jjt get child text if import package namespace import package name else namespace import class name return  primitive void 
bsh literal int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error if value null throw new  interpreter error  null in bsh literal value return value 
private char get escape char char ch switch ch case b ch b break case t ch t break case n ch n break case f ch f break case r ch r break do nothing ch already contains correct character case case case break return ch 
public void char setup  string str char ch str char at if ch get next character ch str char at if  character is digit ch ch char  integer parse int str substring else ch get escape char ch value new  primitive new  character ch char value 
void string setup  string str  string builder buffer new  string builder for int i i str length i char ch str char at i if ch get next character ch str char at i if  character is digit ch int end pos i check the next two characters while end pos i if  character is digit str char at end pos end pos else break ch char  integer parse int str substring i end pos i end pos else ch get escape char ch buffer append ch value buffer to string intern 
 bsh method bsh method declaration method  name space declaring name space  modifiers modifiers this method name method return type method params node get param names method params node param types method block node declaring name space modifiers 
 bsh method  string name  class return type  string param names  class param types bsh block method body  name space declaring name space  modifiers modifiers this name name this creturn type return type this param names param names if param names null this num args param names length this cparam types param types this method body method body this declaring name space declaring name space this modifiers modifiers 
 bsh method  method method  object object this method get name method get return type null param names method get parameter types null method block null declaring name space null modifiers this java method method this java object object 
 get the argument types of this method loosely typed untyped arguments will be represented by null argument types  note bshmethod needs to re evaluate arg types here  this is broken public  class get parameter types return cparam types 
public  string get parameter names return param names 
 get the return type of the method return  returns null for a loosely typed return value  void type for a void return type or the  class of the type  note bshmethod needs to re evaluate the method return type here  this is broken public  class get return type return creturn type 
public  modifiers get modifiers return modifiers 
public  string get name return name 
 invoke the declared method with the specified arguments and interpreter reference  this is the simplest form of invoke for  bsh method intended to be used in reflective style access to bsh scripts public  object invoke  object arg values  interpreter interpreter throws  eval error return invoke arg values interpreter null null false 
 invoke the bsh method with the specified args interpreter ref and callstack caller info is the node representing the method invocation  it is used primarily for debugging in order to provide access to the text of the construct that invoked the method through the namespace param caller info is the  bean shell ast node representing the method invocation  it is used to print the line number and text of errors in  eval error exceptions  if the node is null here error messages may not be able to point to the precise location and text of the error param callstack is the callstack  if callstack is null a new one will be created with the declaring namespace of the method on top of the stack i e it will look for purposes of the method invocation like the method call occurred in the declaring enclosing namespace in which the method is defined public  object invoke  object arg values  interpreter interpreter  call stack callstack  simple node caller info throws  eval error return invoke arg values interpreter callstack caller info false 
 invoke the bsh method with the specified args interpreter ref and callstack caller info is the node representing the method invocation  it is used primarily for debugging in order to provide access to the text of the construct that invoked the method through the namespace param caller info is the  bean shell ast node representing the method invocation  it is used to print the line number and text of errors in  eval error exceptions  if the node is null here error messages may not be able to point to the precise location and text of the error param callstack is the callstack  if callstack is null a new one will be created with the declaring namespace of the method on top of the stack i e it will look for purposes of the method invocation like the method call occurred in the declaring enclosing namespace in which the method is defined param override name space  when true the method is executed in the namespace on the top of the stack instead of creating its own local namespace  this allows it to be used in constructors  object invoke  object arg values  interpreter interpreter  call stack callstack  simple node caller info boolean override name space throws  eval error if arg values null for int i i arg values length i if arg values i null throw new  error here if java method null try return  reflect invoke method java method java object arg values catch  reflect error e throw new  eval error  error invoking  java method e caller info callstack catch  invocation target exception e throw new  target error  exception invoking imported object method e caller info callstack true is native is this a syncrhonized method if modifiers null modifiers has modifier synchronized  the lock is our declaring namespace s  this reference the method s super  or in the case of a class it s the class instance  object lock if declaring name space is class try lock declaring name space get class instance catch  util eval error e throw new  interpreter error  can t get class instance for synchronized method else lock declaring name space get this interpreter synchronized lock return invoke impl arg values interpreter callstack caller info override name space else return invoke impl arg values interpreter callstack caller info override name space 
private  object invoke impl  object arg values  interpreter interpreter  call stack callstack  simple node caller info boolean override name space throws  eval error  class return type get return type  class param types get parameter types  if null callstack if callstack null callstack new  call stack declaring name space if arg values null arg values new  object  cardinality number of args mismatch if arg values length num args look for help string try should check for null namespace here  string help  string declaring name space get bsh help name interpreter interpreter println help return  primitive void catch  exception e throw eval error throw new  eval error  wrong number of arguments for local method name caller info callstack  make the local namespace for the method invocation  name space local name space if override name space local name space callstack top else local name space new  name space declaring name space name local name space is method true should we do this for both cases above local name space set node caller info set the method parameters in the local namespace for int i i num args i  set typed variable if param types i null try arg values i  types get assignable form arg values i param types i  types cast object arg values i param types i  types assignment catch  util eval error e throw new  eval error  invalid argument param names i for method name e get message caller info callstack try local name space set typed variable param names i param types i arg values i null modifiers catch  util eval error e throw e to eval error  typed method parameter assignment caller info callstack  set untyped variable else untyped param get assignable would catch this for typed param if arg values i  primitive void throw new  eval error  undefined variable or class name parameter param names i to method name caller info callstack else try local name space set local variable param names i arg values i interpreter get strict java catch  util eval error e throw e to eval error caller info callstack  push the new namespace on the call stack if override name space callstack push local name space  invoke the block overriding namespace with local name space  object ret method body eval callstack interpreter true override save the callstack including the called method just for error mess  call stack return stack callstack copy  get back to caller namespace if override name space callstack pop  return control ret control null if ret instanceof  return control ret control  return control ret  method body can only use return statment type return control if ret control kind ret control return ret  return control ret value else ret control return point is the  node of the return statement throw new  eval error continue or break in method body ret control return point return stack  check for explicit return of value from void method type ret control return point is the  node of the return statement if return type  void type ret  primitive void throw new  eval error  cannot return value from void method ret control return point return stack if return type null  if return type void return void as the value if return type  void type return  primitive void return type is a class try ret  types get assignable form ret  class return type  types cast object ret return type  types assignment catch  util eval error e  point to return statement point if we had one else it was implicit return  what s the case here  simple node node caller info if ret control null node ret control return point throw e to eval error  incorrect type returned from method name e get message node callstack return ret 
public boolean has modifier  string name return modifiers null modifiers has modifier name 
public  string to string return  scripted  method  string util method string name get parameter types 
bsh method declaration int id super id 
 set the return type node params node and block node based on child node structure  no evaluation is done here synchronized void insure nodes parsed if params node null there is always a params node return  object first node jjt get child first throws clause if first node instanceof bsh return type return type node bsh return type first node params node bsh formal parameters jjt get child if jjt get num children num throws block node bsh block jjt get child num throws skip throws first throws clause else params node bsh formal parameters jjt get child block node bsh block jjt get child num throws skip throws 
 evaluate the return type node return the type or null indicating loosely typed return  class eval return type  call stack callstack  interpreter interpreter throws  eval error insure nodes parsed if return type node null return return type node eval return type callstack interpreter else return null 
 string get return type descriptor  call stack callstack  interpreter interpreter  string default package insure nodes parsed if return type node null return null else return return type node get type descriptor callstack interpreter default package 
bsh return type get return type node insure nodes parsed return return type node 
 evaluate the declaration of the method  that is determine the structure of the method and install it into the caller s namespace public  object eval  call stack callstack  interpreter interpreter throws  eval error return type eval return type callstack interpreter eval nodes callstack interpreter  install an instance of this method in the namespace  see notes in  bsh method  this is not good need a way to update eval without re installing so that we can re eval params etc when classloader changes look into this  name space namespace callstack top  bsh method bsh method new  bsh method this namespace modifiers try namespace set method name bsh method catch  util eval error e throw e to eval error this callstack return  primitive void 
private void eval nodes  call stack callstack  interpreter interpreter throws  eval error insure nodes parsed validate that the throws names are class names for int i first throws clause i num throws first throws clause i bsh ambiguous name jjt get child i to class callstack interpreter params node eval callstack interpreter if strict java mode check for loose parameters and return type if interpreter get strict java for int i i params node param types length i if params node param types i null  warning  null callstack here  don t think we need a stack trace to indicate how we sourced the method throw new  eval error  strict  java  mode  undeclared argument type parameter params node get param names i in method name this null if return type null  warning  null callstack here  don t think we need a stack trace to indicate how we sourced the method throw new  eval error  strict  java  mode  undeclared return type for method name this null 
public  string to string return  method declaration name 
bsh method invocation int id super id 
bsh ambiguous name get name node return bsh ambiguous name jjt get child 
bsh arguments get args node return bsh arguments jjt get child 
 evaluate the method invocation with the specified callstack and interpreter public  object eval  call stack callstack  interpreter interpreter throws  eval error  name space namespace callstack top bsh ambiguous name name node get name node  do not evaluate methods this or super in class instance space i e inside a constructor if namespace get parent null namespace get parent is class name node text equals super name node text equals this return  primitive void  name name name node get name namespace  object args get args node get arguments callstack interpreter  this try catch block is replicated is bsh primary suffix need to factor out common functionality  move to  reflect try return name invoke method interpreter args callstack this catch  reflect error e throw new  eval error  error in method invocation e get message this callstack catch  invocation target exception e  string msg  method  invocation name  throwable te e get target exception  try to squeltch the native code stack trace if the exception was caused by a reflective call back into the bsh interpreter e g eval or source boolean is native true if te instanceof  eval error if te instanceof  target error is native  target error te in native code else is native false throw new  target error msg te this callstack is native catch  util eval error e throw e to eval error this callstack 
public bsh package declaration int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error bsh ambiguous name name bsh ambiguous name jjt get child  name space namespace callstack top namespace set package name text import the package we re in by default namespace import package name text return  primitive void 
bsh primary expression int id super id 
 evaluate to a value object public  object eval  call stack callstack  interpreter interpreter throws  eval error return eval false callstack interpreter 
 evaluate to a value object public lhs to lhs  call stack callstack  interpreter interpreter throws  eval error  object obj eval true callstack interpreter if obj instanceof lhs throw new  eval error  can t assign to this callstack else return lhs obj 
private  object eval boolean to lhs  call stack callstack  interpreter interpreter throws  eval error  object obj jjt get child int num children jjt get num children for int i i num children i obj bsh primary suffix jjt get child i do suffix obj to lhs callstack interpreter  if the result is a  node eval it to an object or lhs as determined by to lhs if obj instanceof  simple node if obj instanceof bsh ambiguous name if to lhs obj bsh ambiguous name obj to lhs callstack interpreter else obj bsh ambiguous name obj to object callstack interpreter else  some arbitrary kind of node if to lhs is this right throw new  eval error  can t assign to prefix this callstack else obj  simple node obj eval callstack interpreter return lhs or value object as determined by to lhs if obj instanceof lhs if to lhs return obj else try return lhs obj get value catch  util eval error e throw e to eval error this callstack else return obj 
bsh primary suffix int id super id 
public  object do suffix  object obj boolean to lhs  call stack callstack  interpreter interpreter throws  eval error  handle class suffix operation  prefix must be a bsh type if operation class if obj instanceof bsh type if to lhs throw new  eval error  can t assign class this callstack  name space namespace callstack top return bsh type obj get type callstack interpreter else throw new  eval error  attempt to use class suffix on non class this callstack  evaluate our prefix if it needs evaluating first  if this is the first evaluation our prefix mayb be a  node directly from the  primary prefix eval it to an object  if it s an lhs resolve to a value  note  the ambiguous name construct is now necessary where the node may be an ambiguous name  if this becomes common we might want to make a static method node to object or something  the point is that we can t just eval we need to direct the evaluation to the context sensitive type of result namely object class etc if obj instanceof  simple node if obj instanceof bsh ambiguous name obj bsh ambiguous name obj to object callstack interpreter else obj  simple node obj eval callstack interpreter else if obj instanceof lhs try obj lhs obj get value catch  util eval error e throw e to eval error this callstack try switch operation case index return do index obj to lhs callstack interpreter case name return do name obj to lhs callstack interpreter case property return do property to lhs obj callstack interpreter default throw new  interpreter error  unknown suffix type catch  reflect error e throw new  eval error reflection error e this callstack catch  invocation target exception e throw new  target error target exception e get target exception this callstack true 
private  object do name  object obj boolean to lhs  call stack callstack  interpreter interpreter throws  eval error  reflect error  invocation target exception try length on array if field equals length obj get class is array if to lhs throw new  eval error  can t assign array length this callstack else return new  primitive  array get length obj field access if jjt get num children if to lhs return  reflect get lhs object field obj field else return  reflect get object field value obj field  method invocation lhs or non lhs evaluation can both encounter method calls  object oa bsh arguments jjt get child get arguments callstack interpreter todo  note this try catch block is copied from bsh method invocation we need to factor out this common functionality and make sure we handle all cases e g property style access etc maybe move this to  reflect try return  reflect invoke object method obj field oa interpreter callstack this catch  reflect error e throw new  eval error  error in method invocation e get message this callstack catch  invocation target exception e  string msg  method  invocation field  throwable te e get target exception  try to squeltch the native code stack trace if the exception was caused by a reflective call back into the bsh interpreter e g eval or source boolean is native true if te instanceof  eval error if te instanceof  target error is native  target error te in native code else is native false throw new  target error msg te this callstack is native catch  util eval error e throw e to eval error this callstack 
static int get index aux  object obj  call stack callstack  interpreter interpreter  simple node caller info throws  eval error if obj get class is array throw new  eval error  not an array caller info callstack int index try  object index val  simple node caller info jjt get child eval callstack interpreter if index val instanceof  primitive index val  types cast object index val  integer type  types assignment index  primitive index val int value catch  util eval error e  interpreter debug do index e throw e to eval error  arrays may only be indexed by integer types caller info callstack return index 
array index  must handle to lhs case private  object do index  object obj boolean to lhs  call stack callstack  interpreter interpreter throws  eval error  reflect error int index get index aux obj callstack interpreter this if to lhs return new lhs obj index else try return  reflect get index obj index catch  util eval error e throw e to eval error this callstack 
 property access  must handle to lhs case private  object do property boolean to lhs  object obj  call stack callstack  interpreter interpreter throws  eval error if obj  primitive void throw new  eval error  attempt to access property on undefined variable or class name this callstack if obj instanceof  primitive throw new  eval error  attempt to access property on a primitive this callstack  object value  simple node jjt get child eval callstack interpreter if value instanceof  string throw new  eval error  property expression must be a  string or identifier this callstack if to lhs return new lhs obj  string value  property style access to  hashtable or  map  collection manager cm  collection manager get collection manager if cm is map obj  object val cm get from map obj value key return val null val  primitive null val try return  reflect get object property obj  string value catch  util eval error e throw e to eval error  property value this callstack catch  reflect error e throw new  eval error  no such property value this callstack 
bsh primitive type int id super id 
public  class get type return type 
bsh return statement int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error  object value if jjt get num children value  simple node jjt get child eval callstack interpreter else value  primitive void return new  return control kind value this 
bsh return type int id super id 
bsh type get type node return bsh type jjt get child 
public  string get type descriptor  call stack callstack  interpreter interpreter  string default package if is void return v else return get type node get type descriptor callstack interpreter default package 
public  class eval return type  call stack callstack  interpreter interpreter throws  eval error if is void return  void type else return get type node get type callstack interpreter 
bsh statement expression list int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error int n jjt get num children for int i i n i  simple node node  simple node jjt get child i node eval callstack interpreter return  primitive void 
public bsh switch label int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error if is default return null should probably error  simple node label  simple node jjt get child return label eval callstack interpreter 
public bsh switch statement int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error int numchild jjt get num children int child  simple node switch exp  simple node jjt get child child  object switch val switch exp eval callstack interpreter  note this could be made clearer by adding an inner class for the cases and an object context for the child traversal first label bsh switch label label  object node  return control return control null get the first label if child numchild throw new  eval error  empty switch statement this callstack label bsh switch label jjt get child child while more labels or blocks and haven t hit return control while child numchild return control null if label is default or equals switch val if label is default primitive equals switch val label eval callstack interpreter callstack switch exp execute nodes skipping labels until a break or return while child numchild node jjt get child child if node instanceof bsh switch label continue eval it  object value  simple node node eval callstack interpreter should check to disallow continue here if value instanceof  return control return control  return control value break else skip nodes until next label while child numchild node jjt get child child if node instanceof bsh switch label label bsh switch label node break if return control null return control kind return return return control else return  primitive void 
 helper method for testing equals on two primitive or boxable objects yuck factor this out into  primitive java private boolean primitive equals  object switch val  object target val  call stack callstack  simple node switch exp throws  eval error if switch val instanceof  primitive target val instanceof  primitive try binary operation can return  primitive or wrapper type  object result  primitive binary operation switch val target val  parser constants eq result  primitive unwrap result return result equals  boolean true catch  util eval error e throw e to eval error  switch value switch exp get text this callstack else return switch val equals target val 
bsh ternary expression int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error  simple node cond  simple node jjt get child eval true  simple node jjt get child eval false  simple node jjt get child if bsh if statement evaluate condition cond callstack interpreter return eval true eval callstack interpreter else return eval false eval callstack interpreter 
bsh throw statement int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error  object obj  simple node jjt get child eval callstack interpreter need to loosen this to any throwable do we need to handle that in interpreter somewhere check first if obj instanceof  exception throw new  eval error  expression in throw must be  exception type this callstack wrap the exception in a  target exception to propogate it up throw new  target error  exception obj this callstack 
bsh try statement int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error bsh block try block bsh block jjt get child  vector catch params new  vector  vector catch blocks new  vector int nchild jjt get num children  node node null int i while i nchild node jjt get child i instanceof bsh formal parameter catch params add element node catch blocks add element jjt get child i node null finaly block bsh block finally block null if node null finally block bsh block node  why both of these  target error target null  throwable thrown null  object ret null  evaluate the contents of the try block and catch any resulting  target errors generated by the script  we save the callstack depth and if an exception is thrown we pop back to that depth before contiuing  the exception short circuited any intervening method context pops  note we the stack info what do we do with it append to exception message int callstack depth callstack depth try ret try block eval callstack interpreter catch  target error e target e  string stack info  bsh  stack while callstack depth callstack depth stack info t callstack pop n unwrap the target error if target null thrown target get target  if we have an exception find a catch if thrown null int n catch params size for i i n i  get catch block bsh formal parameter fp bsh formal parameter catch params element at i  should cache this subject to classloader change message  evaluation of the formal parameter simply resolves its type via the specified namespace it doesn t modify the namespace fp eval callstack interpreter if fp type null interpreter get strict java throw new  eval error  strict  java  untyped catch block this callstack  if the param is typed check assignability if fp type null try thrown  throwable  types cast object thrown rsh fp type lhs type  types assignment catch  util eval error e  catch the mismatch and continue to try the next  note this is innefficient should have an is assignable from that doesn t throw todo we do now have a way to test assignment in cast object use it continue  found match execute catch block bsh block cb bsh block catch blocks element at i  prepare to execute the block  we must create a new  block name space to hold the catch parameter and swap it on the stack after initializing it  name space enclosing name space callstack top  block name space cb name space new  block name space enclosing name space try if fp type bsh formal parameter untyped set an untyped variable directly in the block cb name space set block variable fp name thrown else set a typed variable directly in the block  modifiers modifiers new  modifiers cb name space set typed variable fp name fp type thrown new  modifiers none catch  util eval error e throw new  interpreter error  unable to set var in catch block namespace put cb name space on the top of the stack callstack swap cb name space try ret cb eval callstack interpreter finally put it back callstack swap enclosing name space target null handled target break evaluate finally block if finally block null ret finally block eval callstack interpreter exception fell through throw it upward if target null throw target if ret instanceof  return control return ret else return  primitive void 
bsh type int id super id 
 used by the grammar to indicate dimensions of array types during parsing public void add array dimension array dims 
 simple node get type node return  simple node jjt get child 
 returns a class descriptor for this type  if the type is an ambiguous name object type evaluation is attempted through the namespace in order to resolve imports  if it is not found and the name is non compound we assume the default package for the name public  string get type descriptor  call stack callstack  interpreter interpreter  string default package return cached type if available if descriptor null return descriptor  string descriptor first node will either be  primitive type or  ambiguous name  simple node node get type node if node instanceof bsh primitive type descriptor get type descriptor bsh primitive type node type else  string clas name bsh ambiguous name node text  bsh class manager bcm interpreter get class manager  note incorrect here we are using the hack in bsh class manager that allows lookup by base name  we need to eliminate this limitation by working through imports  see notes in class manager  string defining class bcm get class being defined clas name  class clas null if defining class null try clas bsh ambiguous name node to class callstack interpreter catch  eval error e throw new  interpreter error unable to resolve type e ignore and try default package  system out println bsh type node class not found else clas name defining class if clas null  system out println found clas clas descriptor get type descriptor clas else if default package null  name is compound clas name descriptor l clas name replace else descriptor l default package replace clas name for int i i array dims i descriptor descriptor this descriptor descriptor  system out println bsh type returning descriptor descriptor return descriptor 
public  class get type  call stack callstack  interpreter interpreter throws  eval error return cached type if available if type null return type first node will either be  primitive type or  ambiguous name  simple node node get type node if node instanceof bsh primitive type base type bsh primitive type node get type else base type bsh ambiguous name node to class callstack interpreter if array dims try  get the type by constructing a prototype array with arbitrary zero length in each dimension int dims new int array dims int array default zeros  object obj  array new instance base type dims type obj get class catch  exception e throw new  eval error  couldn t construct array type this callstack else type base type hack sticking to first interpreter that resolves this see comments on type instance variable interpreter get class manager add listener this return type 
base type is used during evaluation of full type and retained for the case where we are an array type  in the case where we are not an array this will be the same as type public  class get base type return base type 
 if we are an array type this will be non zero and indicate the dimensionality of the array e g for  string public int get array dims return array dims 
public void class loader changed type null base type null 
public static  string get type descriptor  class clas if clas  boolean type return z if clas  character type return c if clas  byte type return b if clas  short type return s if clas  integer type return i if clas  long type return j if clas  float type return f if clas  double type return d if clas  void type return v  is get name ok test with  string name clas get name replace if name starts with name ends with return name else return l name replace 
bsh typed variable declaration int id super id 
private bsh type get type node return bsh type jjt get child 
 class eval type  call stack callstack  interpreter interpreter throws  eval error bsh type type node get type node return type node get type callstack interpreter 
bsh variable declarator get declarators int n jjt get num children int start bsh variable declarator bvda new bsh variable declarator n start for int i start i n i bvda i start bsh variable declarator jjt get child i return bvda 
evaluate the type and one or more variable declarators e g int a b c public  object eval  call stack callstack  interpreter interpreter throws  eval error try  name space namespace callstack top bsh type type node get type node  class type type node get type callstack interpreter bsh variable declarator bvda get declarators for int i i bvda length i bsh variable declarator dec bvda i  type node is passed down the chain for array initializers which need it under some circumstances  object value dec eval type node callstack interpreter try namespace set typed variable dec name type value modifiers catch  util eval error e throw e to eval error this callstack catch  eval error e e re throw  typed variable declaration return  primitive void 
public  string get type descriptor  call stack callstack  interpreter interpreter  string default package return get type node get type descriptor callstack interpreter default package 
bsh unary expression int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error  simple node node  simple node jjt get child  if this is a unary increment of decrement either pre or postfix then we need an lhs to which to assign the result  otherwise just do the unary operation for the value try if kind incr kind decr lhs lhs bsh primary expression node to lhs callstack interpreter return lhs unary operation lhs interpreter get strict java else return unary operation node eval callstack interpreter kind catch  util eval error e throw e to eval error this callstack 
private  object lhs unary operation lhs lhs boolean strict java throws  util eval error if  interpreter debug  interpreter debug lhs unary operation  object prevalue postvalue prevalue lhs get value postvalue unary operation prevalue kind  object ret val if postfix ret val prevalue else ret val postvalue lhs assign postvalue strict java return ret val 
private  object unary operation  object op int kind throws  util eval error if op instanceof  boolean op instanceof  character op instanceof  number return primitive wrapper unary operation op kind if op instanceof  primitive throw new  util eval error  unary operation token image kind inappropriate for object return  primitive unary operation  primitive op kind 
private  object primitive wrapper unary operation  object val int kind throws  util eval error  class operand type val get class  object operand  primitive promote to integer val if operand instanceof  boolean return new  boolean  primitive boolean unary operation  boolean operand kind else if operand instanceof  integer int result  primitive int unary operation  integer operand kind and must be cast back the original type if kind incr kind decr if operand type  byte type return new  byte byte result if operand type  short type return new  short short result if operand type  character type return new  character char result return new  integer result else if operand instanceof  long return new  long  primitive long unary operation  long operand kind else if operand instanceof  float return new  float  primitive float unary operation  float operand kind else if operand instanceof  double return new  double  primitive double unary operation  double operand kind else throw new  interpreter error  an error occurred  please call technical support 
bsh variable declarator int id super id 
 evaluate the optional initializer value  the name was set at parse time a variable declarator can be evaluated with or without preceding type information  currently the type info is only used by array initializers in the case where there is no explicitly declared type param type node is the bsh type node  its info is passed through to any variable intializer children for the case where the array initializer does not declare the type explicitly e g int a type node may be null to indicate no type information available public  object eval bsh type type node  call stack callstack  interpreter interpreter throws  eval error null value means no value  object value null if jjt get num children  simple node initializer  simple node jjt get child  if we have type info and the child is an array initializer pass it along  else use the default eval style  this allows array initializer to handle the problem allowing for future enhancements in loosening types there if type node null initializer instanceof bsh array initializer value bsh array initializer initializer eval type node get base type type node get array dims callstack interpreter else value initializer eval callstack interpreter if value  primitive void throw new  eval error  void initializer this callstack return value 
public  string to string return bsh variable declarator name 
bsh while statement int id super id 
public  object eval  call stack callstack  interpreter interpreter throws  eval error int num child jjt get num children  order of body and condition is swapped for do while  simple node cond exp body null if is do statement cond exp  simple node jjt get child body  simple node jjt get child else cond exp  simple node jjt get child if num child has body else just for side effects body  simple node jjt get child boolean do once flag is do statement while do once flag bsh if statement evaluate condition cond exp callstack interpreter if body null no body continue  object ret body eval callstack interpreter boolean breakout false if ret instanceof  return control switch  return control ret kind case return return ret case continue continue case break breakout true break if breakout break do once flag false return  primitive void 
 reloads the buffer from disk asking for confirmation if the buffer has unsaved changes param view  the view since j edit pre public void reload  view view if get flag untitled return if is dirty  string args path int result gui utilities confirm view changedreload args j option pane yes no option j option pane warning message if result j option pane yes option return view visit new  save caret info visitor load view true 
 loads the buffer from disk param view  the view param reload  if true user will not be asked to recover autosave file if any since pre public boolean load final  view view final boolean reload if is performing io gui utilities error view buffer multiple io null return false set boolean property  buffer io request error occurred false set loading true view text areas temporarily blank out while a buffer is being loaded to indicate to the user that there is no data available yet if get flag temporary  edit bus send new  buffer update this view  buffer update load started final boolean load autosave if reload get flag new file if file null mod time file last modified  only on initial load if reload autosave file null autosave file exists load autosave recover autosave view else if autosave file null autosave file delete load autosave false if load autosave vfs vfs vfs manager get vfs for path path if check file for load view vfs path set loading false return false have to check again since above might set new file flag if reload get flag new file if vfs load view this path set loading false return false else load autosave false  do some stuff once loading is finished  runnable runnable new  runnable public void run  string new path get string property  buffer io request new path  segment seg  segment get property  buffer io request load data  integer array end offsets  integer array get property  buffer io request end offsets load text seg end offsets unset property  buffer io request load data unset property  buffer io request end offsets unset property  buffer io request new path undo mgr clear undo mgr set limit j edit get integer property buffer undo count if get flag temporary finish loading set loading false if reloading a file clear dirty flag if reload set dirty false if load autosave new path null set path new path if load autosave is false we loaded an autosave file so we set dirty to true note that we don t use set dirty because a that would send an unnecessary message b it would also set the autosave dirty flag which will make the autosave thread write out a redundant autosave file if load autosave  buffer super set dirty true send some  edit bus messages if get flag temporary fire buffer loaded  edit bus send new  buffer update  buffer this view  buffer update loaded  edit bus send new  buffer update  buffer this view  buffer update markers changed if get flag temporary runnable run else vfs manager run in awt thread runnable return true 
 loads a file from disk and inserts it into this buffer param view  the view param path the path of the file to insert since pre public boolean insert file  view view  string path if is performing io gui utilities error view buffer multiple io null return false set boolean property  buffer io request error occurred false path  misc utilities construct path this path path  buffer buffer j edit get buffer path if buffer null view get text area set selected text buffer get text buffer get length return true vfs vfs vfs manager get vfs for path path this returns false if initial sanity checks if the file is a directory etc fail return vfs insert view this path 
 autosaves this buffer public void autosave if autosave file null get flag autosave dirty is dirty is performing io autosave file get parent file exists return set flag autosave dirty false vfs manager run in work thread new  buffer autosave request null this null vfs manager get file vfs autosave file get path 
 prompts the user for a file to save this buffer to param view  the view param rename  true if the buffer s path should be changed false if only a copy should be saved to the specified filename since j edit pre public boolean save as  view view boolean rename  string files gui utilities show vfs file dialog view path vfs browser save dialog false files should have length since the dialog type is save dialog if files null return false return save view files rename 
 saves this buffer to the specified path name or the current path name if it s null param view  the view param path  the path name to save the buffer to or null to use the existing path public boolean save  view view  string path return save view path true false 
 saves this buffer to the specified path name or the current path name if it s null param view  the view param path  the path name to save the buffer to or null to use the existing path param rename  true if the buffer s path should be changed false if only a copy should be saved to the specified filename since j edit pre public boolean save  view view  string path boolean rename return save view path rename false 
 saves this buffer to the specified path name or the current path name if it s null param view  the view param path  the path name to save the buffer to or null to use the existing path param rename  true if the buffer s path should be changed false if only a copy should be saved to the specified filename param disable file status check  disables file status checking regardless of the state of the check file status property public boolean save final  view view  string path final boolean rename boolean disable file status check if is performing io gui utilities error view buffer multiple io null return false set boolean property  buffer io request error occurred false if path null get flag new file return save as view rename if path null file null long new mod time file last modified if new mod time mod time j edit get boolean property view check mod status  object args this path int result gui utilities confirm view filechanged save args j option pane yes no option j option pane warning message if result j option pane yes option return false  edit bus send new  buffer update this view  buffer update saving set performing io true final  string old path this path final  string old symlink path symlink path final  string new path path null this path path vfs vfs vfs manager get vfs for path new path if check file for save view vfs new path set performing io false return false  object session vfs create vfs session new path view if session null set performing io false return false unset property overwrite readonly unset property forbid two stage save try vfs file file vfs  get file session new path view if file null boolean vfs rename cap vfs get capabilities vfs rename cap if file is writeable  log log  log warning this  buffer saving  file file is read only if vfs rename cap  log log  log debug this  buffer saving vfs can rename files  string save path vfs  canon path session new path view if  misc utilities is url save path save path  misc utilities resolve symlinks save path save path vfs get two stage save name save path if save path null  log log  log debug this  buffer saving two stage save impossible because path is null vfs manager error view new path ioerror save readonly twostagefail null set performing io false return false else int result gui utilities confirm view vfs overwrite readonly new  object new path j option pane yes no option j option pane warning message if result j option pane yes option  log log  log warning this  buffer saving two stage save will be used to save buffer set boolean property overwrite readonly true else  log log  log debug this  buffer not saved set performing io false return false else  log log  log warning this  buffer saving file is readonly and vfs cannot do two stage save vfs manager error view new path ioerror write error readonly null set performing io false return false else  string save path vfs  canon path session new path view if  misc utilities is url save path save path  misc utilities resolve symlinks save path save path vfs get two stage save name save path if j edit get boolean property two stage save vfs rename cap save path null the file is writeable but the vfs cannot do two stage  we must overwrite readonly flag int result gui utilities confirm view vfs twostageimpossible new  object new path j option pane yes no option j option pane warning message if result j option pane yes option  log log  log warning this  buffer saving two stage save cannot be used set boolean property forbid two stage save true else  log log  log debug this  buffer not saved set performing io false return false catch io exception io vfs manager error view new path ioerror new  string io to string set performing io false return false finally try vfs  end vfs session session view catch io exception io vfs manager error view new path ioerror new  string io to string set performing io false return false if vfs save view this new path set performing io false return false  once save is complete do a few other things vfs manager run in awt thread new  runnable public void run set performing io false set property overwrite readonly null finish saving view old path old symlink path new path rename get boolean property  buffer io request error occurred update markers file view int check j edit get integer property check file status if disable file status check check  general option pane check file status all check  general option pane check file status operations j edit check buffer status view false return true 
 check if the buffer has changed on disk return  one of code not changed code code changed code or code deleted code since j edit pre public int check file status  view view don t do these checks while a save is in progress because for a moment new mod time will be greater than old mod time due to the multithreading only supported on local file system if is performing io file null get flag new file boolean new read only file exists file can write if new read only is file read only set file read only new read only  edit bus send new  buffer update this null  buffer update dirty changed long old mod time mod time long new mod time file last modified if new mod time old mod time mod time new mod time if file exists set flag new file true set dirty true return file deleted else return file changed return file not changed 
 returns the last time j edit modified the file on disk  this method is thread safe public long get last modified return mod time 
 sets the last time j edit modified the file on disk param mod time  the new modification time public void set last modified long mod time this mod time mod time 
 returns the status of the autoreload flag  if true reload changed files automatically public boolean get auto reload return get flag autoreload 
 sets the status of the autoreload flag param value  if true reload changed files automatically public void set auto reload boolean value set flag autoreload value 
 returns the status of the autoreload dialog flag  if true prompt for reloading or notify user when the file has changed on disk public boolean get auto reload dialog return get flag autoreload dialog 
 sets the status of the autoreload dialog flag param value  if true prompt for reloading or notify user when the file has changed on disk public void set auto reload dialog boolean value set flag autoreload dialog value 
 returns the virtual filesystem responsible for loading and saving this buffer  this method is thread safe public vfs get vfs return vfs manager get vfs for path path 
 returns the autosave file for this buffer  this may be null if the file is non local public  file get autosave file return autosave file 
 remove the autosave file since j edit pre public void remove autosave file if autosave file null autosave file delete set flag autosave dirty true 
 returns the name of this buffer  this method is thread safe public  string get name return name 
 returns the path name of this buffer  this method is thread safe public  string get path return path 
param short version if true replaces home path with on unix public  string get path  boolean short version return short version  misc utilities abbreviate path get path 
 if this file is a symbolic link returns the link destination  otherwise returns the file s path  this method is thread safe since j edit pre public  string get symlink path return symlink path 
 returns the directory containing this buffer since j edit pre public  string get directory return directory 
 returns true if this buffer has been closed with link org gjt sp jedit j edit close buffer  view  buffer  this method is thread safe public boolean is closed return get flag closed 
 returns true if the buffer is loaded  this method is thread safe public boolean is loaded return is loading 
 returns whether this buffer lacks a corresponding version on disk  this method is thread safe public boolean is new file return get flag new file 
 sets the new file flag param new file  the new file flag public void set new file boolean new file set flag new file new file if new file set flag untitled false 
 returns true if this file is untitled  this method is thread safe public boolean is untitled return get flag untitled 
 sets the dirty changed since last save flag of this buffer  override public void set dirty boolean d boolean old d is dirty if is untitled j edit get boolean property suppress not saved confirm untitled d false if d get length initial length if j edit get boolean property use md for dirty calculation d  arrays equals calculate hash md hash super set dirty d boolean editable is editable if d if editable set flag autosave dirty true else set flag autosave dirty false if autosave file null autosave file delete if d old d editable  edit bus send new  buffer update this null  buffer update dirty changed 
 returns if this is a temporary buffer  this method is thread safe see j edit open temporary  view  string  string boolean see j edit commit temporary  buffer since j edit pre public boolean is temporary return get flag temporary 
 returns this buffer s icon since j edit pre public  icon get icon if is dirty return gui utilities load icon dirty gif else if is read only return gui utilities load icon readonly gif else if get flag new file return gui utilities load icon new gif else return gui utilities load icon normal gif 
deprecated  call link j edit buffer add buffer listener  buffer listener int  deprecated public void add buffer change listener  buffer change listener listener int priority add buffer listener new  buffer change listener  adapter listener priority 
deprecated  call link j edit buffer add buffer listener  buffer listener  deprecated public void add buffer change listener  buffer change listener listener add buffer listener new  buffer change listener  adapter listener normal priority 
deprecated  call link j edit buffer remove buffer listener  buffer listener  deprecated public void remove buffer change listener  buffer change listener listener  buffer listener listeners get buffer listeners for int i i listeners length i  buffer listener l listeners i if l instanceof  buffer change listener  adapter if  buffer change listener  adapter l get delegate listener remove buffer listener l return 
 reloads settings from the properties  this should be called after the code syntax code or code folding code buffer local properties are changed  override public void properties changed super properties changed set auto reload dialog j edit get boolean property auto reload dialog set auto reload j edit get boolean property auto reload  edit bus send new  buffer update this null  buffer update properties changed 
 override public  object get default property  string name  object ret val if mode null ret val mode get property name if ret val null return null set default property name ret val return ret val  now try buffer property  string value j edit get property buffer name if value null return null  try returning it as an integer first try ret val new  integer value catch  number format exception nf ret val value return ret val 
 toggles word wrap between the three available modes  this is used by the status bar param view  we show a message in the view s status bar since j edit pre public void toggle word wrap  view view  string wrap get string property wrap if wrap equals none wrap soft else if wrap equals soft wrap hard else if wrap equals hard wrap none view get status set message and clear j edit get property view status wrap changed new  string wrap set property wrap wrap properties changed 
 toggles the line separator between the three available settings  this is used by the status bar param view  we show a message in the view s status bar since j edit pre public void toggle line separator  view view  string status null  string line sep get string property linesep if n equals line sep status windows line sep r n else if r n equals line sep status mac line sep r else if r equals line sep status unix line sep n view get status set message and clear j edit get property view status linesep changed new  string j edit get property line sep status set property linesep line sep set dirty true properties changed 
 some settings like comment start and end strings can vary between different parts of a buffer html text and inline  java script for example param offset  the offset param name  the property name since j edit pre  override public  string get context sensitive property int offset  string name  object value super get context sensitive property offset name if value null  parser rule set rules get rule set at offset offset value j edit get mode rules get mode name get property name if value null value mode get property name if value null return null else return  string value of value 
 sets this buffer s edit mode by calling the accept method of each registered edit mode public void set mode  string user mode get string property mode if user mode null unset property mode  mode m  mode provider instance get mode user mode if m null set mode m return  string first line get line text  mode mode  mode provider instance get mode for file name first line if mode null set mode mode return  mode default mode j edit get mode j edit get property buffer default mode if default mode null default mode j edit get mode text if default mode null set mode default mode 
deprecated  call code set property code instead  deprecated public void put property  object name  object value for backwards compatibility if name instanceof  string return set property  string name value 
deprecated  call code set boolean property code instead  deprecated public void put boolean property  string name boolean value set boolean property name value 
public  token get first token return get tokens 
deprecated  use the other form of code mark tokens code instead  deprecated public  token list mark tokens int line index  token list list new  token list mark tokens line index list return list 
 insert a string into the buffer param offset  the offset param str  the string param attr ignored deprecated  call code insert code instead  deprecated public void insert string int offset  string str  attribute set attr insert offset str 
deprecated  do not call this method use link get path instead  deprecated public  file get file return file 
 returns a vector of markers since j edit pre public  vector  marker get markers return markers 
 returns the status prompt for the given marker action  only intended to be called from code actions xml code since j edit pre public  string get marker status prompt  string action return j edit get property view status action new  string get marker name string 
 returns a string of all set markers used by the status bar eg a b since j edit pre public  string get marker name string  string builder buf new  string builder for int i i markers size i  marker marker markers get i if marker get shortcut if buf length buf append buf append marker get shortcut if buf length return j edit get property view status no markers else return buf to string 
 if a marker is set on the line of the position it is removed  otherwise a new marker with the specified shortcut is added param pos  the position of the marker param shortcut  the shortcut if none since j edit pre public void add or remove marker char shortcut int pos int line get line of offset pos if get marker at line line null remove marker line else add marker shortcut pos 
 adds a marker to this buffer param pos  the position of the marker param shortcut  the shortcut if none since j edit pre public void add marker char shortcut int pos  marker marker n new  marker this shortcut pos boolean added false don t sort markers while buffer is being loaded if is loaded set flag markers changed true marker n create position for int i i markers size i  marker marker markers get i if shortcut marker get shortcut shortcut marker set shortcut if marker get position pos markers remove element at i i for int i i markers size i  marker marker markers get i if marker get position pos markers insert element at marker n i added true break if added markers add element marker n if is loaded get flag temporary  edit bus send new  buffer update this null  buffer update markers changed 
 returns the first marker within the specified range param start  the start offset param end  the end offset since j edit pre public  marker get marker in range int start int end for int i i markers size i  marker marker markers get i int pos marker get position if pos start pos end return marker return null 
 returns the first marker at the specified line or code null code if there is none param line  the line number since j edit pre public  marker get marker at line int line for int i i markers size i  marker marker markers get i if get line of offset marker get position line return marker return null 
 removes all markers at the specified line param line  the line number since j edit pre public void remove marker int line for int i i markers size i  marker marker markers get i if get line of offset marker get position line set flag markers changed true marker remove position markers remove element at i i  edit bus send new  buffer update this null  buffer update markers changed 
 removes all defined markers since j edit pre public void remove all markers set flag markers changed true for int i i markers size i markers get i remove position markers remove all elements if is loaded  edit bus send new  buffer update this null  buffer update markers changed 
 returns the marker with the specified shortcut param shortcut  the shortcut since j edit pre public  marker get marker char shortcut for  marker marker markers if marker get shortcut shortcut return marker return null 
 returns the path for this buffer s markers file param vfs  the appropriate vfs since j edit pre deprecated it will fail if you save to another vfs use link get markers path vfs  string  deprecated public  string get markers path vfs vfs return get markers path vfs path 
 returns the path for this buffer s markers file param vfs  the appropriate vfs param path the path of the buffer it can be different from the field when using save as since j edit pre public static  string get markers path vfs vfs  string path return vfs get parent of path path vfs get file name path marks 
 save the markers file or delete it when there are mo markers left  handling markers is now independent from saving the buffer  changing markers will not set the buffer dirty any longer param view  the current view since j edit pre public boolean update markers file  view view if markers changed return true adapted from vfs save vfs vfs vfs manager get vfs for path get path if vfs get capabilities vfs write cap vfs is markers file supported vfs manager error view path vfs not supported save new  string markers file return false  object session vfs create vfs session path view if session null return false vfs manager run in work thread new  markers save request view this session vfs path return true 
 return true when markers have changed and the markers file needs to be updated since j edit pre public boolean markers changed return get flag markers changed 
 sets unsets the markers changed flag since j edit pre public void set markers changed boolean changed set flag markers changed changed 
 this socket is closed when the buffer is closed public void set wait socket  socket wait socket this wait socket wait socket 
 returns the next buffer in the list public  buffer get next return next 
 returns the previous buffer in the list public  buffer get prev return prev 
 returns the position of this buffer in the buffer list public int get index int count  buffer buffer prev while true if buffer null break count buffer buffer prev return count 
 returns a string representation of this buffer  this simply returns the path name  override public  string to string return name  misc utilities abbreviate directory 
 buffer  string path boolean new file boolean temp  map props super props markers new  vector  marker set flag temporary temp this must be called before any  edit bus messages are sent set path path  magic untitled is only set if new file param to constructor is set new file is also set if file doesn t exist on disk  this is so that we can tell apart files created with j edit new file and those that just don t exist on disk  why do we need to tell the difference between the two j edit add buffer to list checks if the only opened buffer is an untitled buffer and if so replaces it with the buffer to add  we don t want this behavior to occur with files that don t exist on disk only untitled ones set flag untitled new file set flag new file new file set flag autoreload j edit get boolean property auto reload set flag autoreload dialog j edit get boolean property auto reload dialog 
void commit temporary set flag temporary false finish loading 
void close set flag closed true if autosave file null autosave file delete notify clients with wait if wait socket null try wait socket get output stream write wait socket get output stream flush wait socket get input stream close wait socket get output stream close wait socket close catch io exception io  log log  log error this io 
private void set flag int flag boolean value if value flags flag else flags flag 
private boolean get flag int flag int mask flag return flags mask mask 
private void set path final  string path j edit visit new j edit visitor adapter  override public void visit  edit pane edit pane edit pane buffer renamed  buffer this path path this path path vfs vfs vfs manager get vfs for path path if vfs get capabilities vfs write cap set file read only true name vfs get file name path directory vfs get parent of path path if vfs instanceof  file vfs file new  file path symlink path  misc utilities resolve symlinks path if we don t do this the autosave file won t be deleted after a save as if autosave file null autosave file delete autosave file new  file file get parent name else i wonder if the lack of this broke anything in the past file null autosave file null symlink path path 
private boolean recover autosave final  view view if autosave file can read return false this method might get called at startup gui utilities hide splash screen final  object args autosave file get path int result gui utilities confirm view autosave found args j option pane yes no option j option pane warning message if result j option pane yes option vfs manager get file vfs load view this autosave file get path show this message when all i o requests are complete vfs manager run in awt thread new  runnable public void run gui utilities message view autosave loaded args return true else return false 
private boolean check file for load  view view vfs vfs  string path if vfs get capabilities vfs low latency cap  object session vfs create vfs session path view if session null return false try vfs file file vfs  get file session path view if file null set new file true return true if file is readable vfs manager error view path ioerror no read null set new file false return false set file read only file is writeable if file get type vfs file file vfs manager error view path ioerror open directory null set new file false return false catch io exception io vfs manager error view path ioerror new  string io to string return false finally try vfs  end vfs session session view catch io exception io vfs manager error view path ioerror new  string io to string return false return true 
private static boolean check file for save  view view vfs vfs  string path if vfs get capabilities vfs low latency cap  object session vfs create vfs session path view if session null return false try vfs file file vfs  get file session path view if file null return true if file get type vfs file file vfs manager error view path ioerror save directory null return false catch io exception io vfs manager error view path ioerror new  string io to string return false finally try vfs  end vfs session session view catch io exception io vfs manager error view path ioerror new  string io to string return false return true 
return an md hash of the contents of the buffer private byte calculate hash final byte dummy new byte if j edit get boolean property use md for dirty calculation return dummy  byte buffer bb null read lock try  log log  log notice this calculate hash int length get length bb  byte buffer allocate length  chars are bytes  char buffer cb bb as char buffer cb append get segment length finally read unlock try  message digest digest java security  message digest get instance md digest update bb return digest digest catch  no such algorithm exception nsae  log log  log error this  can t  calculate md hash nsae return dummy 
 update the buffer s members with the current hash and length for later comparison private void update hash initial length get length md hash calculate hash 
private void finish loading update hash parse buffer local properties aha this is probably the only way to fix this  fold handler old fold handler get fold handler set mode if get fold handler old fold handler on a reload the fold handler doesn t change but we still need to re collapse folds don t do this on initial fold handler creation invalidate fold levels fire fold handler changed  create marker positions for int i i markers size i  marker marker markers get i marker remove position int pos marker get position if pos get length marker set position get length else if pos marker set position marker create position 
private void finish saving  view view  string old path  string old symlink path  string path boolean rename boolean error  set the buffer s path  caveat won t work if save called with a relative path  but i don t think anyone calls it like that anyway if error path equals old path  buffer buffer j edit get buffer path if rename if we save a file with the same name as one that s already open we presume that we can close the existing file since the user would have confirmed the overwrite in the save as dialog box anyway if buffer null can t happen buffer get path equals old path buffer set dirty false j edit close buffer view buffer set path path final  hash set  buffer set buffer sets new  hash set  buffer set final  hash set  edit pane edit panes current new  hash set  edit pane j edit visit new j edit visitor adapter  override public void visit  edit pane edit pane  buffer set buffer set edit pane get buffer set if buffer set index of  buffer this buffer sets add buffer set if edit pane get buffer  buffer this edit panes current add edit pane j edit get buffer set manager remove buffer this for  buffer set buffer set buffer sets j edit get buffer set manager add buffer buffer set this for  edit pane edit pane edit panes current edit pane set buffer this else if we saved over an already open file using save a copy as then reload the existing buffer if buffer null can t happen buffer get path equals old path buffer load view true  update this buffer for the new path if rename if file null mod time file last modified if error we do a write lock so that the autosave which grabs a read lock is not executed between the deletion of the autosave file and clearing of the dirty flag try write lock if autosave file null autosave file delete set flag autosave dirty false set file read only false set flag new file false set flag untitled false super set dirty false if j edit get boolean property reset undo on save undo mgr clear finally write unlock parse buffer local properties if get path equals old path if is temporary j edit update position old symlink path this set mode else if user adds mode buffer local property  string new mode get string property mode if new mode null new mode equals get mode get name set mode else properties changed update hash if is temporary  edit bus send new  buffer update this view  buffer update dirty changed new message type introduced in pre  edit bus send new  buffer update this view  buffer update saved 
 edit the syntax style of the token under the caret param text area the textarea where your caret is since j edit pre public void edit syntax style j edit text area text area int line num text area get caret line int start get line start offset line num int position text area get caret position  default token handler token handler new  default token handler mark tokens line num token handler  token token token handler get tokens while token id  token end int next start token length if start position next position break start next token token next if token id  token end token id  token null j option pane show message dialog j edit get active view j edit get property syntax style no token message j edit get property syntax style no token title j option pane plain message return  string type name  token token to string token id  string property view style type name to lower case  syntax style current style gui utilities parse style j edit get property property  dialog  syntax style style new  style editor j edit get active view current style type name get style if style null j edit set property property gui utilities get style string style j edit properties changed 
 called when line fold levels change param buffer  the buffer in question param start  the start line number param end  the end line number since j edit pre public void fold level changed j edit buffer buffer int start int end 
 called when text is inserted into the buffer param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines inserted param length  the number of characters inserted since j edit pre public void content inserted j edit buffer buffer int start line int offset int num lines int length 
 called when text is about to be inserted in the buffer param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines inserted param length  the number of characters inserted since j edit pre public void pre content inserted j edit buffer buffer int start line int offset int num lines int length 
 called when text is about to be removed from the buffer but is still present param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines to be removed param length  the number of characters to be removed since j edit pre public void pre content removed j edit buffer buffer int start line int offset int num lines int length 
 called when text is removed from the buffer param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines removed param length  the number of characters removed since j edit pre public void content removed j edit buffer buffer int start line int offset int num lines int length 
 called after an undo or compound edit has finished  the text area uses this event to queue up and collapse cleanup operations so they are only run once during a long transaction such as a  replace  all operation param buffer  the buffer in question since j edit pre public void transaction complete j edit buffer buffer 
 called to notify the text area that folds need to be collapsed if the collapse folds property is set  this method is called after the buffer has been loaded and also if the user changes the fold handler param buffer  the buffer in question since j edit pre public void fold handler changed j edit buffer buffer 
 called to notify the text area that the buffer has been reloaded param buffer  the buffer in question since j edit pre public void buffer loaded j edit buffer buffer 
 creates a new buffer i o request param view  the view param buffer  the buffer param session  the vfs session param vfs  the vfs param path  the path public  buffer autosave request  view view  buffer buffer  object session vfs vfs  string path super view buffer session vfs path 
public void run  output stream out null try  string args vfs get file name path set status j edit get property vfs status autosave args the entire save operation can be aborted set abortable true try buffer read lock if buffer is dirty buffer has been saved while we were waiting return out vfs  create output stream session path view if out null return write buffer out catch  exception e  log log  log error this e  string pp e to string vfs manager error view path ioerror write error pp  incomplete autosave file should not exist if out null try out close out null vfs  delete session path view catch io exception ioe  log log  log error this ioe finally buffer read unlock catch  work thread  abort a finally io utilities close quietly out 
 called when line fold levels change param buffer  the buffer in question param start  the start line number param end  the end line number since j edit pre public void fold level changed  buffer buffer int start int end 
 called when text is inserted into the buffer param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines inserted param length  the number of characters inserted since j edit pre public void content inserted  buffer buffer int start line int offset int num lines int length 
 called when text is about to be removed from the buffer but is still present param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines to be removed param length  the number of characters to be removed since j edit pre public void pre content removed  buffer buffer int start line int offset int num lines int length 
 called when text is removed from the buffer param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines removed param length  the number of characters removed since j edit pre public void content removed  buffer buffer int start line int offset int num lines int length 
 called after an undo or compound edit has finished  the text area uses this event to queue up and collapse cleanup operations so they are only run once during a long transaction such as a  replace  all operation param buffer  the buffer in question since j edit pre public void transaction complete  buffer buffer 
 called to notify the text area that folds need to be collapsed if the collapse folds property is set  this method is called after the buffer has been loaded and also if the user changes the fold handler param buffer  the buffer in question since j edit pre public void fold handler changed  buffer buffer 
 called to notify the text area that the buffer has been reloaded param buffer  the buffer in question since j edit pre public void buffer loaded  buffer buffer 
public  adapter  buffer change listener delegate this delegate delegate 
public  buffer change listener get delegate return delegate 
 called when line fold levels change param buffer  the buffer in question param start line  the start line number param end line  the end line number since j edit pre public void fold level changed j edit buffer buffer int start line int end line delegate fold level changed  buffer buffer start line end line 
 called when text is inserted into the buffer param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines inserted param length  the number of characters inserted since j edit pre public void content inserted j edit buffer buffer int start line int offset int num lines int length delegate content inserted  buffer buffer start line offset num lines length 
 called when text is removed from the buffer param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines removed param length  the number of characters removed since j edit pre public void content removed j edit buffer buffer int start line int offset int num lines int length delegate content removed  buffer buffer start line offset num lines length 
 called when text is about to be inserted in the buffer param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines inserted param length  the number of characters inserted since j edit pre public void pre content inserted j edit buffer buffer int start line int offset int num lines int length 
 called when text is about to be removed from the buffer but is still present param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines to be removed param length  the number of characters to be removed since j edit pre public void pre content removed j edit buffer buffer int start line int offset int num lines int length delegate pre content removed  buffer buffer start line offset num lines length 
 called after an undo or compound edit has finished  the text area uses this event to queue up and collapse cleanup operations so they are only run once during a long transaction such as a  replace  all operation param buffer  the buffer in question since j edit pre public void transaction complete j edit buffer buffer delegate transaction complete  buffer buffer 
 called to notify the text area that folds need to be collapsed if the collapse folds property is set  this method is called after the buffer has been loaded and also if the user changes the fold handler param buffer  the buffer in question since j edit pre public void fold handler changed j edit buffer buffer delegate fold handler changed  buffer buffer 
 called to notify the text area that the buffer has been reloaded param buffer  the buffer in question since j edit pre public void buffer loaded j edit buffer buffer delegate buffer loaded  buffer buffer 
param edit pane the edit pane that sent the message param new buffer the buffer that will soon be displayed public  buffer changing  edit pane edit pane  buffer new buffer super edit pane  edit pane update buffer changing if new buffer null  string s  arrays to string  thread current thread get stack trace  log log  log error this  buffer changing to null  buffer  emit  position changing instead s m buffer new buffer 
return the new buffer that is about to be displayed public  buffer get buffer return m buffer 
 buffer handler  display manager display manager  text area text area j edit buffer buffer this display manager display manager this text area text area this buffer buffer 
public void buffer loaded j edit buffer buffer display manager buffer loaded 
public void fold handler changed j edit buffer buffer display manager fold handler changed 
public void fold level changed j edit buffer buffer int start int end  system err println fold level changed start to text area get last physical line end if text area get display manager display manager end buffer is loading text area invalidate line range start text area get last physical line 
public void content inserted j edit buffer buffer int start line int offset int num lines int length if buffer is loading return display manager screen line mgr content inserted start line num lines int end line start line num lines if num lines delayed multiline update true display manager folds content inserted start line num lines  first line first line display manager first line  scroll line count scroll line count display manager scroll line count if text area get display manager display manager if num lines first line content inserted start line num lines scroll line count content inserted start line num lines if delayed update end start line delayed update end num lines delay update start line end line resize selections if necessary  iterator  selection iter text area get selection iterator while iter has next  selection s iter next if s content inserted buffer start line offset num lines length delay update s start line s end line int caret text area get caret position if caret offset int scroll mode text area caret auto scroll  text area electric scroll  text area no scroll text area move caret position caret length scroll mode else int scroll mode text area caret auto scroll  text area normal scroll  text area no scroll text area move caret position caret scroll mode else first line call reset true scroll line count call reset true 
 called when text is about to be inserted in the buffer param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines inserted param length  the number of characters inserted since j edit pre public void pre content inserted j edit buffer buffer int start line int offset int num lines int length if text area get display manager display manager get ready to break fold start line 
 called when text is about to be removed from the buffer but is still present param buffer  the buffer in question param start line  the first line param offset  the start offset from the beginning of the buffer param num lines  the number of lines to be removed param length  the number of characters to be removed since j edit pre public void pre content removed j edit buffer buffer int start line int offset int num lines int length if buffer is loading return  first line first line display manager first line  scroll line count scroll line count display manager scroll line count if text area get display manager display manager if num lines get ready to break fold start line else int last line start line num lines if display manager is line visible start line display manager is line visible last line offset buffer get line start offset start line offset length buffer get line start offset last line get ready to break fold start line get ready to break fold last line else  the removal will not touch inside of folds and wll not modify any remaining lines if num lines first line pre content removed start line offset num lines scroll line count pre content removed start line offset num lines if delayed update end start line delayed update end num lines delay update start line start line else first line call reset true scroll line count call reset true display manager screen line mgr content removed start line num lines if num lines return delayed multiline update true if display manager folds pre content removed start line num lines display manager folds reset buffer get line count first line call reset true scroll line count call reset true if first line physical line display manager get last visible line first line physical line display manager get first visible line will be handled later see comments at the end of transaction complete very subtle if we leave this for ensure physical line is visible an extra line will be added to the scroll line count else if display manager is line visible first line physical line first line physical line display manager get next visible line first line physical line 
public void content removed j edit buffer buffer int start line int start int num lines int length if buffer is loading return if text area get display manager display manager resize selections if necessary int n sel text area get selection count  iterator  selection iter text area get selection iterator while iter has next  selection s iter next if s content removed buffer start line start num lines length delay update s start line s end line if n sel s start s end iter remove int caret text area get caret position if caret start length int scroll mode text area caret auto scroll  text area electric scroll  text area no scroll text area move caret position caret length scroll mode else if caret start int scroll mode text area caret auto scroll  text area electric scroll  text area no scroll text area move caret position start scroll mode else int scroll mode text area caret auto scroll  text area normal scroll  text area no scroll text area move caret position caret scroll mode 
public void transaction complete j edit buffer buffer if text area get display manager display manager delayed update false return if delayed update do delayed update text area  finish caret update delayed update false  debug code if  debug scroll verify int line delayed update start if display manager is line visible line line display manager get next visible line line  system err println delayed update start delayed update end text area get line count int scroll line count while line line delayed update end scroll line count display manager get screen line count line line display manager get next visible line line if scroll line count display manager get scroll line count throw new  internal error scroll line count display manager get scroll line count 
private void do delayed update must update screen line counts before we call notify screen line changes since that calls update scroll bar which needs valid info int line delayed update start if display manager is line visible line line display manager get next visible line line while line line delayed update end display manager update screen line count line line display manager get next visible line line must be before the below call so that the chunk cache is not updated with an invisible first line see above display manager notify screen line changes if delayed multiline update text area invalidate screen line range text area chunk cache get screen line of offset delayed update start text area get visible lines delayed multiline update false else text area invalidate line range delayed update start delayed update end update visible lines int visible lines text area get visible lines if visible lines text area chunk cache get line info visible lines force the fold levels to be updated when painting the last line of a buffer  buffer is fold start doesn t call get fold level hence the fold level changed event might not be sent for the previous line buffer get fold level delayed update end 
private void delay update int start line int end line text area chunk cache invalidate chunks from phys start line if delayed update delayed update start start line delayed update end end line delayed update true else delayed update start  math min delayed update start start line delayed update end  math max delayed update end end line 
private void get ready to break fold int line display manager expand fold line false 
public  selection get selection return string to selection selection 
public  entry  string path int caret  string selection  string encoding  string mode this path path this caret caret this selection selection this encoding encoding this mode mode 
public  string to string return path caret 
public static  entry get entry  string path history lock read lock lock try for  entry entry history if  misc utilities paths equal entry path path return entry finally history lock read lock unlock return null 
public static void set entry  string path int caret  selection selection  string encoding  string mode  entry entry new  entry path caret selection to string selection encoding mode history lock write lock lock try remove entry path add entry entry finally history lock write lock unlock notify change 
 clear the  buffer history since pre public static void clear history lock write lock lock try history clear finally history lock write lock unlock notify change 
 returns the  buffer list return the buffer history list since j edit pre public static  list  entry get history  returns a snapshot to avoid concurrent access to the history  this requires o n time but it should be ok because this method should be used only by external o n operation history lock read lock lock try return  list  entry history clone finally history lock read lock unlock 
public static void load if recent xml null return if recent xml file exists return  log log  log message  buffer history class  loading recent xml  recent handler handler new  recent handler try recent xml load handler catch io exception e  log log  log error  buffer history class e trim to limit handler result history handler result 
public static void save if recent xml null return if recent xml has changed on disk  log log  log warning  buffer history class recent xml changed on disk will not save recent files return  log log  log message  buffer history class  saving recent xml  string line sep  system get property line separator  settings xml  saver out null try out recent xml open saver out write xml declaration out write doctype recent system recent dtd out write line sep out write recent out write line sep  make a snapshot to avoid long locking period which may be required by file i o  list  entry snapshot get history for  entry entry snapshot out write entry out write line sep out write path out write xml utilities chars to entities entry path false out write path out write line sep out write caret out write  string value of entry caret out write caret out write line sep if entry selection null entry selection length out write selection out write entry selection out write selection out write line sep if entry encoding null out write encoding out write entry encoding out write encoding out write line sep if entry mode null out write mode out write entry mode out write mode out write line sep out write entry out write line sep out write recent out write line sep out finish catch  exception e  log log  log error  buffer history class e finally io utilities close quietly out 
private static void add entry  entry entry history lock write lock lock try history add first entry trim to limit history finally history lock write lock unlock 
private static void remove entry  string path history lock write lock lock try  iterator  entry iter history iterator while iter has next  entry entry iter next if  misc utilities paths equal path entry path iter remove return finally history lock write lock unlock 
private static  string selection to string  selection s if s null return null  string builder buf new  string builder for int i i s length i if i buf append  selection sel s i if sel instanceof  selection  range buf append range else if sel instanceof  selection  rect buf append rect buf append sel get start buf append buf append sel get end return buf to string 
private static  selection string to selection  string s if s null return null  list  selection selection new  array list  selection  string tokenizer st new  string tokenizer s while st has more tokens  string type st next token int start  integer parse int st next token int end  integer parse int st next token if end start i m not sure when this can happen but it does sometimes witness the j edit bug tracker continue  selection sel if type equals range sel new  selection  range start end else if type equals rect sel new  selection  rect start end selection add sel  selection return value new  selection selection size return value selection to array return value return return value 
private static void trim to limit  linked list  entry list int max j edit get integer property recent files while list size max list remove last 
private static void notify change  edit bus send new  dynamic menu changed recent files 
public  input source resolve entity  string public id  string system id return xml utilities find entity system id recent dtd get class 
public void end element  string uri  string local name  string name if name equals entry result add last new  entry path caret selection encoding mode path null caret selection null encoding null mode null else if name equals path path char data to string else if name equals caret caret  integer parse int char data to string else if name equals selection selection char data to string else if name equals encoding encoding char data to string else if name equals mode mode char data to string char data set length 
public void characters char ch int start int length char data append ch start length 
 creates a new buffer i o request param view  the view param buffer  the buffer param session  the vfs session param vfs  the vfs param path  the path public  buffer insert request  view view  buffer buffer  object session vfs vfs  string path super view buffer session vfs path 
public void run  input stream in null try  string args vfs get file name path set status j edit get property vfs status load args set abortable true path vfs  canon path session path view vfs file entry vfs  get file session path view long length if entry null length entry get length else length l in vfs  create input stream session path false view if in null return final  segment buffer seg read autodetect in length true we don t do this in  buffer insert so that we can insert multiple files at once vfs manager run in awt thread new  runnable public void run view get text area set selected text seg to string catch  exception e  log log  log error this e  string pp e to string vfs manager error view path ioerror read error pp buffer set boolean property error occurred true catch  work thread  abort a buffer set boolean property error occurred true finally io utilities close quietly in try vfs  end vfs session session view catch  exception e  log log  log error this e  string pp e to string vfs manager error view path ioerror read error pp buffer set boolean property error occurred true catch  work thread  abort a buffer set boolean property error occurred true 
 creates a new buffer i o request param view  the view param buffer  the buffer param session  the vfs session param vfs  the vfs param path  the path protected  buffer io request  view view  buffer buffer  object session vfs vfs  string path this view view this buffer buffer this session session this vfs vfs this path path markers path  buffer get markers path vfs path 
public  string to string return get class get name buffer 
 size of character i o buffers public static int get char io buffer size return iobufsize 
 size of byte i o buffers public static int get byte io buffer size is sizeof char in byte return iobufsize 
 tries to detect if the stream is gzipped and if it has an encoding specified with an xml pi protected  reader autodetect  input stream in throws io exception return  misc utilities autodetect in buffer 
protected  segment buffer read  reader in long length boolean insert throws io exception we guess an initial size for the array  integer array end offsets new  integer array  math max int length only true if the file size is known boolean track progress buffer is temporary length if track progress set maximum length set value if the file size is not known start with a resonable default buffer size if length length iobufsize  segment buffer seg new  segment buffer int length char buf new char iobufsize  number of characters in buf array  input stream read doesn t always fill the array eg the file size is not a multiple of iobufsize or it is a g zipped file etc int len  true if a n was read after a r  usually means this is a dos  windows file boolean crlf false a r was read hence a  mac os file boolean cr only false  was the previous read character a r  if we read a n and this is true we assume we have a dos  windows file boolean last was cr false  number of lines read  every lines we update the progress bar int line count while len in read buf buf length  offset of previous line relative to the start of the i o buffer not relative to the start of the document int last line for int i i len i  look for line endings switch buf i case r  if we read a r and last was cr is also true it is probably a  mac file r r in stream if last was cr cr only true crlf false  otherwise set a flag so that n knows that last was a r else last was cr true  insert a line seg append buf last line i last line seg append n end offsets add seg count if track progress line count progress interval set value seg count  this is i to take the trailing n into account last line i break case n  if last was cr is true we just read a r followed by a n  we specify that this is a  windows file but take no further action and just ignore the r if last was cr cr only false crlf true last was cr false  bump last line so that the next line doesn t erronously pick up the r last line i  otherwise we found a n that follows some other character hence we have a  unix file else cr only false crlf false seg append buf last line i last line seg append n end offsets add seg count if track progress line count progress interval set value seg count last line i break default  if we find some other character that follows a r so it is not a  windows file and probably a  mac file if last was cr cr only true crlf false last was cr false break if track progress set value seg count  add remaining stuff from buffer seg append buf last line len last line set abortable false  string line separator if seg count fix for byte files should open using the default line seperator line separator j edit get property buffer line separator  system get property line separator else if crlf line separator r n else if cr only line separator r else line separator n  chop trailing newline and or z if any int buffer length seg count if buffer length char ch seg array buffer length if ch x a dos z seg count buffer set boolean property  buffer trailing eol false if buffer length j edit get boolean property strip trailing eol char ch seg array buffer length if ch n buffer set boolean property  buffer trailing eol true seg count end offsets set size end offsets get size add a line marker at the end for proper offset manager operation end offsets add seg count to avoid having to deal with read write locks and such we insert the loaded data into the buffer in the post load cleanup runnable which runs in the awt thread if insert buffer set property load data seg buffer set property end offsets end offsets buffer set property new path path if line separator null buffer set property j edit buffer linesep line separator used in insert return seg 
protected void write  buffer buffer  output stream out throws io exception  string encoding name buffer get string property j edit buffer encoding  encoding encoding  encoding server get encoding encoding name  writer writer encoding get text writer new  buffered output stream out get byte io buffer size  segment line segment new  segment  string newline buffer get string property j edit buffer linesep if newline null newline  system get property line separator final int buffer line count buffer get line count set maximum buffer line count progress interval set value int i while i buffer line count buffer get line text i line segment try writer write line segment array line segment offset line segment count if i buffer line count j edit get boolean property strip trailing eol buffer get boolean property  buffer trailing eol writer write newline catch  character coding exception e  string message get write encoding error message encoding name encoding line segment i io exception wrapping new  char conversion exception message wrapping init cause e throw wrapping if i progress interval set value i progress interval writer flush 
private static  string get write encoding error message  string encoding name  encoding encoding  segment line int line index  string args encoding name  integer to string line index unknown column unknown the character try int char index get first guilty character index encoding line if char index char index line count char c line array line offset char index args  integer to string char index args c u  integer to hex string c to upper case catch  exception e  ignore return j edit get property ioerror write encoding error args 
private static int get first guilty character index  encoding encoding  segment line throws io exception if line count return else if line count return  writer tester encoding get text writer new  output stream public void write int b for int i i line count i try tester write line array line offset i catch  character coding exception e return i return 
public synchronized  string get first file  view view if files null files  get files view if files null files length return null else return files 
public synchronized  string get next file  view view  string path if files null files  get files view if files null files length return null if path null path view get buffer get symlink path vfs vfs vfs manager get vfs for path path boolean ignore case vfs get capabilities vfs case insensitive cap for int i i files length i if  standard utilities compare strings files i path ignore case return path return get first file view else so that the last isn t checked vfs vfs vfs manager get vfs for path path boolean ignore case vfs get capabilities vfs case insensitive cap for int i i files length i if  standard utilities compare strings files i path ignore case return files i return null 
public synchronized  string get files  view view if files null files  get files view if files null files length return null else return files 
public synchronized int get file count  view view if files null files  get files view if files null return else return files length 
public  string get code not supported for arbitriary filesets return null 
public void invalidate cached list files null 
 creates a new buffer i o request param view  the view param buffer  the buffer param session  the vfs session param vfs  the vfs param path  the path public  buffer load request  view view  buffer buffer  object session vfs vfs  string path super view buffer session vfs path 
public void run try set abortable true if buffer is temporary  string args vfs get file name path set status j edit get property vfs status load args set value l path vfs  canon path session path view read contents buffer set new file false if j edit get boolean property persistent markers vfs is markers file supported  input stream markers null try  string args vfs get file name path if buffer is temporary set status j edit get property vfs status load markers args set abortable true markers vfs  create input stream session markers path true view if markers null read markers buffer markers catch  exception e ignore finally io utilities close quietly markers catch  exception e  log log  log error this e  object pp e to string vfs manager error view path ioerror read error pp buffer set boolean property error occurred true catch  out of memory error oom  log log  log error this oom vfs manager error view path out of memory error null buffer set boolean property error occurred true catch  work thread  abort a buffer set boolean property error occurred true finally try vfs  end vfs session session view catch  exception e  log log  log error this e  string pp e to string vfs manager error view path ioerror read error pp buffer set boolean property error occurred true catch  work thread  abort a buffer set boolean property error occurred true 
 returns the raw contents stream for this load request  this stream is not buffered or unzipped private  input stream get naked stream throws io exception  input stream in vfs  create input stream session path false view if in null return in throw new io exception  unable to get a  stream for path 
 returns content length of this load request private long get content length throws io exception vfs file entry vfs  get file session path view if entry null return entry get length else return l 
 returns rewinded contents stream  this method assumes the marked stream was made by get marked stream method  the stream may be reopened if reset failed private  buffered input stream rewind contents stream  buffered input stream marked stream boolean gzipped throws io exception try marked stream reset return marked stream catch io exception e  log log  log notice this path  reopening to rewind the stream  reopen the stream because the mark has been invalidated while previous reading marked stream close  input stream in get naked stream try if gzipped in new gzip input stream in  buffered input stream result  auto detection get marked stream in in null return result finally io utilities close quietly in 
 read the contents of this load request  some auto detection is performed if enabled gzi ped file  the encoding  if fallback encodings are specified they are used on encoding errors private void read contents throws io exception long length get content length  buffered input stream marked stream  auto detection get marked stream get naked stream try boolean gzipped false encoding providers is consist of given encodings as  string or contents aware detectors as  encoding detector  list  object encoding providers new  array list  object boolean autodetect buffer get boolean property  buffer encoding autodetect if autodetect gzipped  auto detection is gzipped marked stream marked stream reset encoding providers add all  auto detection get encoding detectors  if the detected encoding fail fallback to the original encoding encoding providers add buffer get string property  buffer encoding  string fallback encodings j edit get property fallback encodings if fallback encodings null fallback encodings length for  string encoding fallback encodings split s encoding providers add encoding else gzipped buffer get boolean property  buffer gzipped encoding providers add buffer get string property  buffer encoding if gzipped  log log  log debug this path  stream is gzipped marked stream  auto detection get marked stream new gzip input stream marked stream  set  string failed encodings new  hash set  string  exception encoding error null for  object encoding provider encoding providers  string encoding null if encoding provider instanceof  string encoding  string encoding provider else if encoding provider instanceof  encoding detector marked stream rewind contents stream marked stream gzipped encoding  encoding detector encoding provider detect encoding new  buffered input stream marked stream else  log log  log debug this  strange encoding provider encoding provider if encoding null encoding length failed encodings contains encoding continue marked stream rewind contents stream marked stream gzipped try read  encoding server get text reader marked stream encoding length false if autodetect  store the successful properties if gzipped buffer set boolean property  buffer gzipped true buffer set property  buffer encoding encoding return catch  char conversion exception e encoding error e catch  character coding exception e encoding error e catch  unsupported encoding exception e encoding error e catch  unsupported charset exception e encoding error e  log log  log notice this path encoding encoding error failed encodings add encoding  all possible detectors and encodings failed  object pp  text utilities join failed encodings if failed encodings size pp encoding error to string else pp  see details in  activity  log vfs manager error view path ioerror encoding error pp marked stream rewind contents stream marked stream gzipped read  encoding server get encoding buffer get string property  buffer encoding get permissive text reader marked stream length false if autodetect gzipped buffer set boolean property  buffer gzipped true finally marked stream close 
private static void read markers  buffer buffer  input stream  in throws io exception  for reload command buffer remove all markers  buffered reader in new  buffered reader new  input stream reader  in try  string line while line in read line null malformed marks file if line length continue compatibility kludge for j edit and earlier if line char at continue char shortcut line char at int start line index of int end line index of start int position  integer parse int line substring start end buffer add marker shortcut position buffer set markers changed false finally in close 
public  buffer option pane super  buffer  options init 
 override protected void  init buffer j edit get active view get buffer  string filename buffer get name set name  buffer filename add component gui utilities create multiline label j edit get property buffer options caption add separator buffer options loading saving  line separator  string line seps j edit get property line sep unix j edit get property line sep windows j edit get property line sep mac line separator new j combo box line seps  string line sep buffer get string property j edit buffer linesep if line sep null line sep  system get property line separator if n equals line sep line separator set selected index else if r n equals line sep line separator set selected index else if r equals line sep line separator set selected index add component j edit get property buffer options line separator line separator  encoding  string encodings  misc utilities get encodings true  arrays sort encodings new  standard utilities  string compare  string true encoding new j combo box encodings encoding set editable true encoding set selected item buffer get string property j edit buffer encoding add component j edit get property buffer options encoding encoding g zipped setting gzipped new j check box j edit get property buffer options gzipped gzipped set selected buffer get boolean property  buffer gzipped add component gzipped  autoreload settings  check mod status on focus  string mod check options j edit get property options general check mod status nothing j edit get property options general check mod status prompt j edit get property options general check mod status reload j edit get property options general check mod status silent reload check mod status new j combo box mod check options if buffer get auto reload if buffer get auto reload dialog reload and notify check mod status set selected index else reload silently check mod status set selected index else if buffer get auto reload dialog prompt check mod status set selected index else do nothing check mod status set selected index add component j edit get property options general check mod status check mod status add separator buffer options editing  edit mode modes j edit get modes  arrays sort modes new  standard utilities  string compare  mode true mode new j combo box modes mode set selected item buffer get mode  action handler action listener new  action handler mode add action listener action listener add component j edit get property buffer options mode mode  fold mode  string fold modes  fold handler get fold modes folding new j combo box fold modes folding set selected item buffer get string property folding add component j edit get property options editing folding folding  wrap mode  string wrap modes none soft hard wrap new j combo box wrap modes wrap set selected item buffer get string property wrap add component j edit get property options editing wrap wrap  max line length  string line lengths max line len new j combo box line lengths max line len set editable true max line len set selected item buffer get string property max line len add component j edit get property options editing max line len max line len  tab size  string tab sizes tab size new j combo box tab sizes tab size set editable true tab size set selected item buffer get string property tab size add component j edit get property options editing tab size tab size  indent size indent size new j combo box tab sizes indent size set editable true indent size set selected item buffer get string property indent size add component j edit get property options editing indent size indent size  soft tabs no tabs new j check box j edit get property options editing no tabs no tabs set selected buffer get boolean property no tabs add component no tabs 
 override protected void  save int index line separator get selected index  string line sep if index line sep n else if index line sep r n else if index line sep r else throw new  internal error  string old line sep buffer get string property j edit buffer linesep if old line sep null old line sep  system get property line separator if old line sep equals line sep buffer set string property j edit buffer linesep line sep buffer set dirty true  string encoding  string this encoding get selected item  string old encoding buffer get string property j edit buffer encoding if old encoding equals encoding buffer set string property j edit buffer encoding encoding buffer set dirty true  disable auto detect because user explicitly specify an encoding buffer set boolean property  buffer encoding autodetect false boolean gzipped value gzipped is selected boolean old gzipped buffer get boolean property  buffer gzipped if gzipped value old gzipped buffer set boolean property  buffer gzipped gzipped value buffer set dirty true buffer set string property folding  string folding get selected item buffer set string property wrap  string wrap get selected item try buffer set property max line len new  integer max line len get selected item to string catch  number format exception nf try buffer set property tab size new  integer tab size get selected item to string catch  number format exception nf try buffer set property indent size new  integer indent size get selected item to string catch  number format exception nf buffer set boolean property no tabs no tabs is selected index mode get selected index buffer set mode modes index switch check mod status get selected index case buffer set auto reload dialog false buffer set auto reload false break case buffer set auto reload dialog true buffer set auto reload false break case buffer set auto reload dialog true buffer set auto reload true break case buffer set auto reload dialog false buffer set auto reload true break 
public void action performed  action event evt  object source evt get source if source mode  mode  mode  mode mode get selected item folding set selected item  mode get property folding wrap set selected item  mode get property wrap max line len set selected item  mode get property max line len tab size set selected item  mode get property tab size indent size set selected item  mode get property indent size no tabs set selected  mode get boolean property no tabs 
public  buffer options  view view  buffer buffer super view j edit get property buffer options title true this view view this buffer buffer j panel content new j panel new  border layout content set border new  empty border set content pane content  action handler action listener new  action handler panel new  buffer option pane content add  border layout north panel  buttons j panel buttons new j panel buttons set layout new  box layout buttons  box layout x axis buttons set border new  empty border buttons add  box create glue ok new j button j edit get property common ok ok add action listener action listener get root pane set default button ok buttons add ok buttons add  box create horizontal strut cancel new j button j edit get property common cancel cancel add action listener action listener buttons add cancel buttons add  box create glue content add  border layout south buttons pack set location relative to view set visible true 
public void ok panel save dispose 
public void cancel dispose 
public void action performed  action event evt  object source evt get source if source ok ok else if source cancel cancel 
 buffer printable  printer job job  object format  view view  buffer buffer  font font boolean header boolean footer boolean line numbers boolean color this job job this format format this view view this buffer buffer this font font this header header this footer footer this line numbers line numbers styles org gjt sp util  syntax utilities load styles j edit get property print font j edit get integer property print fontsize color styles  token null new  syntax style text color null font  change any white text to black for int i i styles length i  syntax style s styles i if s get foreground color equals  color white s get background color null styles i new  syntax style  color black styles i get background color styles i get font line list new  array list  chunk token handler new  display token handler 
public void print try buffer read lock if format null job print else  method method  printer job class get method print new  class  class for name javax print attribute  print request attribute set method invoke job new  object format catch  printer abort exception ae  log log  log debug this ae catch  exception e  log log  log error this e final  string args e to string  swing utilities invoke later new  runnable public void run gui utilities error view print error args finally buffer read unlock 
public int print  graphics  gfx  page format page format int page index throws  printer exception we keep the first non null frc we get since sometimes we get invalid ones on subsequent pages on  windows if frc null frc  graphics d  gfx get font render context  log log  log debug this  font render context is frc  log log  log debug this  asked to print page page index  log log  log debug this  current page is current page if page index current page for int i current page i page index i  log log  log debug this  current physical line is now current page start current physical line current page start print page  gfx page format i true current page page index  log log  log debug this  current page is now current page if page index current page if end  log log  log debug this  the end return no such page current page start current physical line  log log  log debug this  current physical line is now current page start current page page index  log log  log debug this  current page is now current page else if page index current page current physical line current page start  log log  log debug this  current physical line is now current page start print page  gfx page format page index true return page exists 
private void print page  graphics  gfx  page format page format int page index boolean actually paint  log log  log debug this print page page index actually paint  graphics d gfx  graphics d  gfx gfx set font font double page x page format get imageable x double page y page format get imageable y double page width page format get imageable width double page height page format get imageable height  log log  log debug this  page dimensions page width x page height if header double header height paint header gfx page x page y page width actually paint page y header height page height header height if footer double footer height paint footer gfx page x page y page width page height page index actually paint page height footer height boolean glyph vector j edit get boolean property print glyph vector double line number width determine line number width if line numbers the s ensure that gets digits gets digits and so on int line number digits int  math ceil  math log buffer get line count  math log now that we know how many chars there are get the width char chars new char line number digits for int i i chars length i chars i line number width font get string bounds chars line number digits frc get width else line number width  log log  log debug this  page dimensions page width line number width x page height calculate tab size int tab size j edit get integer property print tab size char chars new char tab size for int i i chars length i chars i double tab width font get string bounds chars tab size frc get width  print tab expander e new  print tab expander tab width lm font get line metrics g gy yx frc  log log  log debug this  line height is lm get height double y print loop for if current physical line buffer get line count  log log  log debug this  finished buffer end true break print loop if j edit get boolean property print folds true view get text area get display manager is line visible current physical line  log log  log debug this  skipping invisible line current physical line continue line list clear token handler init styles frc e line list float page width line number width buffer mark tokens current physical line token handler if line list is empty line list add null if y lm get height line list size page height  log log  log debug this  finished page before line current physical line break print loop if line numbers actually paint gfx set font font gfx set color line number color gfx draw string  string value of current physical line float page x float page y y lm get height for int i i line list size i y lm get height  chunk chunks line list get i if chunks null actually paint  chunk paint chunk backgrounds chunks gfx float page x line number width float page y y  chunk paint chunk list chunks gfx float page x line number width float page y y glyph vector current physical line 
private double paint header  graphics d gfx double page x double page y double page width boolean actually paint  string header text j edit get property print header text new  string buffer get name  font render context frc gfx get font render context lm font get line metrics header text frc  rectangle d bounds font get string bounds header text frc  rectangle d header bounds new  rectangle d  double page x page y page width bounds get height if actually paint gfx set color header color gfx fill header bounds gfx set color header text color gfx draw string header text float page x page width bounds get width float page y lm get ascent return header bounds get height 
private double paint footer  graphics d gfx double page x double page y double page width double page height int page index boolean actually paint  string footer text j edit get property print footer text new  object new  date  integer value of page index  font render context frc gfx get font render context lm font get line metrics footer text frc  rectangle d bounds font get string bounds footer text frc  rectangle d footer bounds new  rectangle d  double page x page y page height bounds get height page width bounds get height if actually paint gfx set color footer color gfx fill footer bounds gfx set color footer text color gfx draw string footer text float page x page width bounds get width float page y page height bounds get height lm get ascent return footer bounds get height 
 print tab expander double tab width this tab width tab width 
public float next tab stop float x int tab offset int ntabs int x tab width return float ntabs tab width 
private static  printer job get print job job  printer job get printer job int orientation j edit get integer property print orientation  page format portrait double width j edit get double property print width double height j edit get double property print height double x j edit get double property print x double y j edit get double property print y double pagewidth j edit get double property print pagewidth double pageheight j edit get double property print pageheight format job default page format set orientation  page format portrait if width height  paper pap format get paper pap set imageable area x y width height pap set size pagewidth pageheight format set paper pap format set orientation orientation return job 
public static void page setup  view view job get print job  page format new format job page dialog format if new format null format new format j edit set integer property print orientation format get orientation  paper paper format get paper j edit set double property print width paper get imageable width j edit set double property print height paper get imageable height j edit set double property print x paper get imageable x j edit set double property print y paper get imageable y j edit set double property print pagewidth paper get width j edit set double property print pageheight paper get height 
public static void print final  view view final  buffer buffer boolean selection job get print job job set job name buffer get path boolean header j edit get boolean property print header boolean footer j edit get boolean property print footer boolean line numbers j edit get boolean property print line numbers boolean color j edit get boolean property print color  font font j edit get font property print font  buffer printable printable new  buffer printable job null view buffer font header footer line numbers color job set printable printable format if job print dialog return printable print 
public static  page format get page format return format 
private static  printer job get print job  string job name job  printer job get printer job format new  hash print request attribute set  string settings j edit get settings directory if settings null  string print spec path  misc utilities construct path settings printspec  file file print spec new  file print spec path if file print spec exists try  file input stream file in new  file input stream file print spec  object input stream ob in new  object input stream file in format  hash print request attribute set ob in read object catch  exception e  log log  log error  buffer printer   class e for backwards compatibility the color variable is stored also as a property if j edit get boolean property print color format add  chromaticity color else format add  chromaticity monochrome no need to always keep the same job name for every printout format add new  job name job name null return job 
public static void page setup  view view  printer job prn job get print job  page setup only if prn job page dialog format null save print spec 
public static void print final  view view final  buffer buffer boolean selection job get print job buffer get path boolean header j edit get boolean property print header boolean footer j edit get boolean property print footer boolean line numbers j edit get boolean property print line numbers boolean color j edit get boolean property print color  font font j edit get font property print font  buffer printable printable new  buffer printable job format view buffer font header footer line numbers color job set printable printable if job print dialog format return save print spec printable print 
public static  page format get page format convert from  print request attribute set to the page format  printer job prn job get print job  page format pf prn job default page  paper pap pf get paper  media size name media  media size name format get  media class  media size ms  media size get media size for name media  media printable area mediaarea  media printable area format get  media printable area class if mediaarea null pap set imageable area mediaarea get x  media printable area inch mediaarea get y  media printable area inch mediaarea get width  media printable area inch mediaarea get height  media printable area inch if ms null pap set size ms get x  media size inch ms get y  media size inch pf set paper pap  orientation requested orientation  orientation requested format get  orientation requested class if orientation null if orientation get value  orientation requested landscape get value pf set orientation  page format landscape else if orientation get value  orientation requested reverse landscape get value pf set orientation  page format reverse landscape else if orientation get value  orientation requested portrait get value pf set orientation  page format portrait else if orientation get value  orientation requested reverse portrait get value doesnt exist pf set orientation  page format reverse portrait then just do the next best thing pf set orientation  page format portrait return pf 
private static void save print spec  string settings j edit get settings directory if settings null return  string print spec path  misc utilities construct path settings printspec  file file print spec new  file print spec path try  file output stream file out new  file output stream file print spec  object output stream ob out new  object output stream file out ob out write object format for backwards compatibility the color variable is stored also as a property  chromaticity cc  chromaticity format get  chromaticity class if cc null j edit set boolean property print color cc get value  chromaticity color get value catch  exception e e print stack trace 
 creates a new buffer i o request param view  the view param buffer  the buffer param session  the vfs session param vfs  the vfs param path  the path public  buffer save request  view view  buffer buffer  object session vfs vfs  string path super view buffer session vfs path 
public void run if the vfs supports renaming files we first save to filename save then rename that to filename so that if the save fails data will not be lost as of pre we now call vfs get two stage save name instead of constructing the path directly since some vfs s might not allow in filenames boolean vfs rename cap vfs get capabilities vfs rename cap boolean want two stage want two stage save buffer boolean two stage save vfs rename cap want two stage try  string args vfs get file name path set status j edit get property vfs status save args the entire save operation can be aborted set abortable true path vfs  canon path session path view if  misc utilities is url path path  misc utilities resolve symlinks path  string save path if two stage save save path vfs get two stage save name path if save path null throw new io exception  can t get a temporary path for two stage save path else make backup save path path  output stream out vfs  create output stream session save path view if out null buffer set boolean property error occurred true return try this must be after the stream is created or we deadlock with ssh tools buffer read lock try  can t use buffer get name here because it is not changed until the save is complete if path ends with gz buffer set boolean property  buffer gzipped true else if buffer get name ends with gz  the path do not ends with gz  the buffer name was gz  so it means it s blabla txt gz blabla txt i remove the gz property buffer set boolean property  buffer gzipped false if buffer get boolean property  buffer gzipped out new gzip output stream out write buffer out finally buffer read unlock finally io utilities close quietly out if two stage save make backup if vfs  rename session save path path view throw new io exception  rename failed save path if two stage save vfs manager send vfs update vfs path true catch  unsupported charset exception e  log log  log error this e e  string pp e get charset name vfs manager error view path ioerror unsupported encoding error pp buffer set boolean property error occurred true catch  exception e  log log  log error this e  string pp e to string vfs manager error view path ioerror write error pp buffer set boolean property error occurred true catch  work thread  abort a buffer set boolean property error occurred true finally try vfs  save complete session buffer path view if two stage save vfs  finish two stage save session buffer path view clean up left over markers file if j edit get boolean property persistent markers vfs  delete session  buffer get markers path vfs path view vfs  end vfs session session view catch  exception e  log log  log error this e  string pp e to string vfs manager error view path ioerror write error pp buffer set boolean property error occurred true catch  work thread  abort a buffer set boolean property error occurred true 
 make the backup private void make backup throws io exception  only backup once per session if buffer get property  buffer backed up null j edit get boolean property backup every save vfs  backup session path view buffer set boolean property  buffer backed up true 
private static boolean want two stage save  buffer buffer return buffer get boolean property forbid two stage save buffer get boolean property overwrite readonly j edit get boolean property two stage save 
public  buffer segment char data int offset int len this data offset len null 
public  buffer segment char data int offset int len  buffer segment next this data data this offset offset this len len this next next 
public char char at int index if index len return data offset index else if next null return next char at index len else throw new  array index out of bounds exception index 
public int length return len next null next length 
public  char sequence sub sequence int start int end return sub segment start end 
public  string to string  string builder sb new  string builder to string sb return sb to string 
private void to string  string builder sb sb append data offset len if next null next to string sb 
private  buffer segment sub segment int start int end if start start end if end len return new  buffer segment data offset start end start else if next null if start len return new  buffer segment data offset start len start next sub segment end len else return next sub segment start len end len else throw new  array index out of bounds exception else throw new  array index out of bounds exception 
public static  scope from string  string s  scope scopes values for  scope scope scopes if scope to string equals s return scope return global 
 create a new  buffer set public  buffer set buffers  collections synchronized list new  array list  buffer listeners new  event listener list if j edit get boolean property sort buffers if j edit get boolean property sort by name sorter name sorter else sorter path sorter 
public void add buffer at  buffer buffer int position  log log  log debug this hash code add buffer at buffer position  buffer untitled buffer null synchronized buffers if buffers size  buffer buf buffers get if buf is untitled buf is dirty untitled buffer buf if sorter null if buffers contains buffer return buffers add buffer  collections sort buffers sorter position buffers index of buffer else int old pos buffers index of buffer if old pos if position return move buffer old pos position return int size buffers size if position position size position size buffers add position buffer  buffer set listener listeners this listeners get listeners  buffer set listener class  log log  log debug this hash code  buffer added buffer at position for  buffer set listener listener listeners listener buffer added buffer position i don t like this reverse control if untitled buffer null j edit get buffer set manager remove buffer this untitled buffer 
 returns the  buffer at the given index param index the index  the index must exists return the buffer at the index public  buffer get buffer int index return buffers get index 
public  buffer get previous buffer int index if buffers is empty return null if buffers size return buffers get if index return buffers get buffers size return buffers get index 
public  buffer get next buffer int index if buffers is empty return null if buffers size return buffers get buffers size if index buffers size return buffers get return buffers get index 
public int index of  buffer buffer return buffers index of buffer 
public int size return buffers size 
public void get all buffers  buffer set listener listener synchronized buffers for int i i buffers size i  buffer buffer buffers get i  log log  log debug this hash code  buffer added buffer at i listener buffer added buffer i 
 returns an array of all buffers in this buffer set return an array of all  buffers public  buffer get all buffers  buffer buffers new  buffer this buffers size return this buffers to array buffers 
 add a  buffer set listener param listener the new  buffer set listener public void add buffer set listener  buffer set listener listener  log log  log debug this hash code add buffer set listener listener listeners add  buffer set listener class listener 
 remove a  buffer set listener  if there are no listeners anymore remove all buffers from the buffer set param listener the removed  buffer set listener public void remove buffer set listener  buffer set listener listener  log log  log debug this hash code remove buffer set listener listener listeners remove  buffer set listener class listener if has listeners must empty the buffer set  buffer buffers get all buffers  buffer set manager buffer set manager j edit get buffer set manager for  buffer buffer buffers buffer set manager remove buffer this buffer 
 check if the  buffer set has listeners return true if the buffer set has listeners public boolean has listeners return listeners get listener count 
 override public  string to string return  buffer set nb buffers size 
void add buffer  buffer buffer add buffer at buffer 
 this method is called by  buffer set manager to signal that this  buffer set needs to react to a change in the sorting properties void handle message if j edit get boolean property sort buffers set the appropriate sorter if j edit get boolean property sort by name sorter name sorter else sorter path sorter do the sort  collections sort buffers sorter notify the listeners so they can repaint themselves  buffer set listener listeners this listeners get listeners  buffer set listener class for  buffer set listener listener listeners listener buffer set sorted else user has elected not to sort  buffer sets sorter null 
void move buffer int old position int new position if sorter null  buffers are sorted do nothing return  buffer buffer synchronized buffers buffer buffers remove old position int size buffers size if new position new position size new position size buffers add new position buffer  buffer set listener listeners this listeners get listeners  buffer set listener class  log log  log debug this hash code  buffer moved buffer from old position to new position for  buffer set listener listener listeners listener buffer moved buffer old position new position 
void remove buffer  buffer buffer int index synchronized buffers index buffers index of buffer if index return buffers remove index  buffer set listener listeners this listeners get listeners  buffer set listener class  log log  log debug this hash code  buffer removed buffer for  buffer set listener listener listeners listener buffer removed buffer index 
public int compare  buffer o  buffer o int ret  standard utilities compare strings o get name o get name true if ret ret  standard utilities compare strings o get path o get path true return ret 
public int compare  buffer o  buffer o return  standard utilities compare strings o get path o get path true 
public void buffer added  buffer buffer int index 
public void buffer removed  buffer buffer int index 
public void buffer moved  buffer buffer int old index int new index 
public void buffer set sorted 
public static  new buffer set action from string  string s  new buffer set action new buffer set actions values for  new buffer set action new buffer set action new buffer set actions if new buffer set action get name equals s return new buffer set action return currentbuffer 
public  string get name return super to string 
 override public  string to string return j edit get property options editpane bufferset newbufferset get name 
public  buffer set manager  edit bus add to bus this 
public void handle message eb message message if message instanceof  view update  view update view update  view update message if view update get what  view update closed  view view view update get view  unlink the buffer from this buffer set  buffer set view buffer set view get local buffer set view buffer set get all buffers new  buffer set closed view buffer set else if message instanceof  edit pane update  edit pane update edit pane update  edit pane update message if edit pane update get what  edit pane update destroyed  edit pane edit pane edit pane update get edit pane  if the edit pane has own  buffer set unlink the buffer from this buffer set if edit pane get buffer set scope  buffer set  scope editpane  buffer set edit pane buffer set edit pane get buffer set edit pane buffer set get all buffers new  buffer set closed edit pane buffer set else if message instanceof  properties changed pass on  properties changed message to  buffer sets so they can resort themselves as needed visit new  buffer set visitor public void visit  buffer set buffer set buffer set handle message 
 merge the content of the source buffer set into the target buffer set param target the target buffer set param source the source buffer set see org gjt sp jedit  edit pane set buffer org gjt sp jedit  buffer public void merge buffer set  buffer set target  buffer set source  buffer buffers source get all buffers for  buffer buffer buffers add buffer target buffer 
 count the buffer sets in which the buffer is param buffer the buffer return the number of buffersets in which buffer is see org gjt sp jedit j edit close buffer org gjt sp jedit  edit pane org gjt sp jedit  buffer public int count buffer sets  buffer buffer return get owners buffer size 
 add a buffer into the current edit pane of the given view  if the view is null it will be added to the global buffer set param view a view or null param buffer the buffer to add public void add buffer  view view  buffer buffer  edit pane edit pane view null null view get edit pane add buffer edit pane buffer 
 add a buffer into the current edit pane of the given edit pane  if the edit pane is null it will be added to the global buffer set param edit pane an  edit pane or null param buffer the buffer to add public void add buffer  edit pane edit pane  buffer buffer if edit pane null add buffer j edit get global buffer set buffer else  buffer set buffer set edit pane get buffer set add buffer buffer set buffer 
 add a buffer in the given buffer set param buffer set the buffer set param buffer the buffer to add public void add buffer  buffer set buffer set  buffer buffer buffer set add buffer buffer 
 add all buffers to the buffer set param buffer set the buffer set public void add all buffers  buffer set buffer set  buffer buffers j edit get buffers for  buffer buffer buffers if buffer is closed add buffer buffer set buffer 
 moves a buffer from a old position to a new position in the  buffer set used in an  edit pane public void move buffer  edit pane edit pane int old position int new position edit pane get buffer set move buffer old position new position 
 remove a buffer from the  edit pane s buffer set param edit pane the edit pane  it cannot be null param buffer the buffer public void remove buffer  edit pane edit pane  buffer buffer  buffer set buffer set edit pane get buffer set remove buffer buffer set buffer 
 remove a buffer from a  view s  buffer set param buffer set the buffer set param buffer the buffer that will be removed void remove buffer  buffer set buffer set  buffer buffer  log log  log debug this remove buffer buffer set buffer  set  buffer set owners get owners buffer owners remove buffer set buffer set remove buffer buffer if owners is empty  log log  log debug this  buffer buffer is in no buffer set anymore closing it j edit  close buffer null buffer if buffer set size buffer set has listeners int untitled count j edit get next untitled buffer id  buffer new empty buffer j edit open temporary j edit get active view null  untitled untitled count true null j edit commit temporary new empty buffer j edit get buffer set manager add buffer buffer set new empty buffer 
remove a buffer from all buffer sets param buffer the buffer that must be removed public void remove buffer  buffer buffer for  buffer set buffer set get owners buffer buffer set remove buffer buffer if buffer set size buffer set has listeners int untitled count j edit get next untitled buffer id  buffer new empty buffer j edit open temporary j edit get active view null  untitled untitled count true null j edit commit temporary new empty buffer j edit get buffer set manager add buffer buffer set new empty buffer 
 this method will visit all buffersets param visitor the bufferset visitor public void visit  buffer set visitor visitor  buffer set global j edit get global buffer set visitor visit j edit get global buffer set for  view view j edit get views  buffer set view local view get local buffer set if view local null visitor visit view local for  edit pane edit pane view get edit panes  buffer set used edit pane get buffer set if used global used view local visitor visit used 
return set of  buffer sets that contain buffer private  set  buffer set get owners  buffer buffer final  set  buffer set candidates new  hash set  buffer set  collect all  buffer sets visit new  buffer set visitor public void visit  buffer set buffer set candidates add buffer set  remove all that doesn t contain the buffer  iterator  buffer set i candidates iterator while i has next if i next index of buffer i remove  remaining are the result return candidates 
private  buffer set closed  buffer set closed buffer set this closed buffer set closed buffer set 
 override public void buffer added  buffer buffer int index  set  buffer set owners get owners buffer owners remove closed buffer set if owners is empty  log log  log message this  the buffer buffer was removed from a  buffer set closing it j edit  close buffer null buffer 
public  widget get widget  view view  widget buffer set widget new  buffer set widget view return buffer set widget 
 buffer set widget final  view view buffer set label new  tool tip label  override public void add notify super add notify  edit bus add to bus  buffer set widget this  override public void remove notify super remove notify  edit bus remove from bus  buffer set widget this this view view update buffer set label add mouse listener new  mouse adapter  override public void mouse clicked  mouse event evt if evt get click count  edit pane edit pane view get edit pane  buffer set  scope scope edit pane get buffer set scope switch scope case global scope  buffer set  scope view break case view scope  buffer set  scope editpane break case editpane scope  buffer set  scope global break edit pane set buffer set scope scope 
public j component get component return buffer set label 
public void update  buffer set  scope scope view get edit pane get buffer set scope if current scope null current scope equals scope buffer set label set text scope to string substring to upper case buffer set label set tool tip text j edit get property view status bufferset tooltip new  object scope current scope scope 
public void properties changed retarded gtk look and feel  font font new j label get font ui manager get font  label font  font metrics fm buffer set label get font metrics font  dimension dim new  dimension  math max fm char width e  math max fm char width v fm char width g fm get height buffer set label set preferred size dim buffer set label set maximum size dim 
public void handle message eb message message if message instanceof  view update  view update view update  view update message if view update get what  view update edit pane changed update else if message instanceof  edit pane update  edit pane update edit pane update  edit pane update message if edit pane update get edit pane view get edit pane edit pane update get what  edit pane update bufferset changed update 
public  buffer switcher final  edit pane edit pane this edit pane edit pane set font new  font  dialog  font bold set renderer new  buffer cell renderer set maximum row count j edit get integer property buffer switcher max row count add action listener new  action handler add popup menu listener new  popup menu listener public void popup menu will become visible  popup menu event e public void popup menu will become invisible  popup menu event e edit pane get text area request focus public void popup menu canceled  popup menu event e edit pane get text area request focus 
public void update buffer list if the buffer count becomes then it is guaranteed to become very soon so don t do anything in that case  buffer set buffer set edit pane get buffer set if buffer set size return updating true set maximum row count j edit get integer property buffer switcher max row count set model new  default combo box model buffer set get all buffers set selected item edit pane get buffer set tool tip text edit pane get buffer get path true updating false 
public void action performed  action event evt if updating  buffer buffer  buffer get selected item if buffer null edit pane set buffer buffer 
public  component get list cell renderer component j list list  object value int index boolean is selected boolean cell has focus super get list cell renderer component list value index is selected cell has focus  buffer buffer  buffer value if buffer null set icon null else set icon buffer get icon set tool tip text buffer get path return this 
 creates a new buffer update message param buffer  the buffer param what  what happened public  buffer update  buffer buffer  view view  object what super buffer this view view if what null throw new  null pointer exception  what must be non null this what what 
 returns what caused this buffer update public  object get what return what 
 returns the buffer involved public  buffer get buffer return  buffer get source 
 returns the view involved which may be null public  view get view return view 
public  string param string return what what view view super param string 
 constructs a new link  byte vector  byte vector with a default initial size public  byte vector data new byte 
 constructs a new link  byte vector  byte vector with the given initial size param initial size the initial size of the byte vector to be constructed public  byte vector final int initial size data new byte initial size 
 puts a byte into this byte vector  the byte vector is automatically enlarged if necessary param b a byte return this byte vector public  byte vector put final int b int length this length if length data length enlarge data length byte b this length length return this 
 puts two bytes into this byte vector  the byte vector is automatically enlarged if necessary param b a byte param b another byte return this byte vector public  byte vector put final int b final int b int length this length if length data length enlarge byte data this data data length byte b data length byte b this length length return this 
 puts a short into this byte vector  the byte vector is automatically enlarged if necessary param s a short return this byte vector public  byte vector put final int s int length this length if length data length enlarge byte data this data data length byte s data length byte s this length length return this 
 puts a byte and a short into this byte vector  the byte vector is automatically enlarged if necessary param b a byte param s a short return this byte vector public  byte vector put final int b final int s int length this length if length data length enlarge byte data this data data length byte b data length byte s data length byte s this length length return this 
 puts an int into this byte vector  the byte vector is automatically enlarged if necessary param i an int return this byte vector public  byte vector put final int i int length this length if length data length enlarge byte data this data data length byte i data length byte i data length byte i data length byte i this length length return this 
 puts a long into this byte vector  the byte vector is automatically enlarged if necessary param l a long return this byte vector public  byte vector put final long l int length this length if length data length enlarge byte data this data int i int l data length byte i data length byte i data length byte i data length byte i i int l data length byte i data length byte i data length byte i data length byte i this length length return this 
 puts a  string in utf format into this byte vector  the byte vector is automatically enlarged if necessary param s a  string return this byte vector public  byte vector put utf final  string s int char length s length int byte length for int i i char length i char c s char at i if c c byte length else if c u ff byte length else byte length if byte length throw new  illegal argument exception int length this length if length byte length data length enlarge byte length byte data this data data length byte byte length data length byte byte length for int i i char length i char c s char at i if c c data length byte c else if c u ff data length byte x e c x f data length byte x c x f data length byte x c x f else data length byte x c c x f data length byte x c x f this length length return this 
 puts an array of bytes into this byte vector  the byte vector is automatically enlarged if necessary param b an array of bytes  may be tt null tt to put tt len tt null bytes into this byte vector param off index of the fist byte of b that must be copied param len number of bytes of b that must be copied return this byte vector public  byte vector put byte array final byte b final int off final int len if length len data length enlarge len if b null  system arraycopy b off data length len length len return this 
 enlarge this byte vector so that it can receive n more bytes param size number of additional bytes that this byte vector should be able to receive private void enlarge final int size byte new data new byte  math max data length length size  system arraycopy data new data length data new data 
public  call stack 
public  call stack  name space namespace push namespace 
public void clear stack remove all elements 
public void push  name space ns stack insert element at ns 
public  name space top return get 
zero based public  name space get int depth if depth depth return  name space javacode else return  name space stack element at depth 
 this is kind of crazy but used by the set name space command zero based public void set int depth  name space ns stack set element at ns depth 
public  name space pop if depth throw new  interpreter error pop on empty  call stack  name space top top stack remove element at return top 
 swap in the value as the new top of the stack and return the old value public  name space swap  name space new top  name space old top  name space stack element at stack set element at new top return old top 
public int depth return stack size 
public  name space to array  name space nsa new  name space depth stack copy into nsa return nsa 
public  string to string  string builder sb new  string builder sb append  call stack n  name space nsa to array for int i i nsa length i sb append t nsa i n return sb to string 
 occasionally we need to freeze the callstack for error reporting purposes etc  suppress warnings unchecked public  call stack copy  call stack cs new  call stack cs stack  vector  name space stack clone return cs 
public static boolean have swing class exists caches info for us return class exists javax swing j button 
public static boolean can generate interfaces class exists caches info for us return class exists java lang reflect  proxy 
 if accessibility is enabled determine if the accessibility mechanism exists and if we have the optional bsh package to use it  note that even if both are true it does not necessarily mean that we have runtime permission to access the fields  java security has a say in it see org gjt sp jedit bsh  reflect manager public static boolean have accessibility return accessibility 
public static void set accessibility boolean b throws  unavailable if b false accessibility false return if class exists java lang reflect  accessible object class exists org gjt sp jedit bsh reflect  reflect manager impl throw new  unavailable  accessibility unavailable test basic access try  string class get declared methods catch  security exception e throw new  unavailable  accessibility unavailable e accessibility true 
 use direct  class for name to test for the existence of a class  we should not use  bsh class manager here because a the systems using these tests would probably not load the classes through it anyway b bshclassmanager is heavy and touches other class files this capabilities code must be light enough to be used by any system including the remote applet public static boolean class exists  string name  object c classes get name if c null try  note do not change this to  bsh class manager plain class for name or equivalent  this class must not touch any other bsh classes c  class for name name catch  class not found exception e if c null classes put c unused return c null 
public  unavailable  string s super s 
public  charset encoding  string name body  charset for name name 
public  reader get text reader  input stream in throws io exception  pass the decoder explicitly to report a decode error as an exception instead of replacing with u fffd  the form  input stream reader in encoding seemed to use  coding error action replace internally return new  input stream reader in body new decoder 
public  writer get text writer  output stream out throws io exception  pass the encoder explicitly because of same reason in get text reader return new  output stream writer out body new encoder 
public  reader get permissive text reader  input stream in throws io exception  use replace action to indicate where the coding error happened by the replacement character u fffd  charset decoder permissive body new decoder permissive on malformed input  coding error action replace permissive on unmappable character  coding error action replace return new  input stream reader in permissive 
 paints a chunk list param chunks  the chunk list param gfx  the graphics context param x  the x co ordinate param y  the y co ordinate param glyph vector true if we want to use glyph vector false if we want to use draw string return  the width of the painted text since j edit pre public static float paint chunk list  chunk chunks  graphics d gfx float x float y boolean glyph vector  rectangle clip rect gfx get clip bounds float  x f while chunks null only paint visible chunks if x  x chunks width clip rect x x  x clip rect x clip rect width  useful for debugging purposes if  debug chunk paint debug gfx draw new  rectangle d  float x  x y chunks width if chunks accessable chunks visible gfx set font chunks style get font gfx set color chunks style get foreground color if glyph vector chunks gv null gfx draw glyph vector chunks gv x  x y else if chunks str null gfx draw string chunks str int x  x int y  x chunks width chunks  chunk chunks next return  x 
 paints the background highlights of a chunk list param chunks  the chunk list param gfx  the graphics context param x  the x co ordinate param y  the y co ordinate return  the width of the painted backgrounds since j edit pre public static float paint chunk backgrounds  chunk chunks  graphics d gfx float x float y  rectangle clip rect gfx get clip bounds float  x f  font metrics for background gfx get font metrics int ascent for background get ascent int height for background get height while chunks null only paint visible chunks if x  x chunks width clip rect x x  x clip rect x clip rect width if chunks accessable  paint token background color if necessary  color bg color chunks background if bg color null gfx set color bg color gfx fill new  rectangle d  float x  x y ascent  x chunks width  x height  x chunks width chunks  chunk chunks next return  x 
 converts an offset in a chunk list into an x co ordinate param chunks  the chunk list param offset  the offset since j edit pre public static float offset to x  chunk chunks int offset if chunks null offset chunks offset throw new  array index out of bounds exception offset chunks offset float x f while chunks null if chunks accessable offset chunks offset chunks length return x chunks offset to x offset chunks offset x chunks width chunks  chunk chunks next return x 
 converts an x co ordinate in a chunk list into an offset param chunks  the chunk list param x  the x co ordinate param round  round up to next letter if past the middle of a letter return  the offset within the line or if the x co ordinate is too far to the right since j edit pre public static int x to offset  chunk chunks float x boolean round float  x f while chunks null if chunks accessable x  x chunks width return chunks x to offset x  x round  x chunks width chunks  chunk chunks next return 
public  chunk float width int offset  parser rule set rules super  token null offset rules this width width 
public  chunk byte id int offset int length  parser rule set rules  syntax style styles byte default id super id offset length rules accessable true style styles id background style get background color if background null background styles default id get background color 
public final float get positions if gv null return null if positions null positions gv get glyph positions length null return positions 
public final float offset to x int offset if visible return f else return get positions offset 
public final int x to offset float x boolean round if visible if round width x x return offset length else return offset float pos get positions for int i i length i float glyph x pos i float next x i length width pos i if next x x if round next x x x glyph x return offset i else return offset i wtf return 
public void init  segment seg  tab expander expander float x  font render context font render context initialized true if accessable do nothing else if length seg array seg offset offset t visible false float new x expander next tab stop x offset length width new x x else visible true str new  string seg array seg offset offset length char text array seg array int text start seg offset offset  workaround for a bug in  sun  java http bugs sun com bugdatabase view bug do bug id if sun java  text limit is used as a text count in layout glyph vector  so it works only the case text start is char copy new char length  system arraycopy text array text start copy length text array copy text start int text limit text start length fixme  need  bi di support int layout flags  font layout left to right  font layout no start context  font layout no limit context gv style get font layout glyph vector font render context text array text start text limit layout flags  rectangle d logical bounds gv get logical bounds width float logical bounds get width 
 chunk cache  text area text area this text area text area out new  array list  chunk token handler new  display token handler 
 returns the max line width of the textarea  it will check all lines the first invalid line return the max line width int get max horizontal scroll width int max for int i i first invalid line i  line info info line info i if info width max max info width return max 
param line physical line number of document param offset number of characters from the left of the line return returns the screen line number where the line and offset are  it returns if this position is not currently visible int get screen line of offset int line int offset if line info length return if line text area get first physical line return if line text area get first physical line offset get line info offset return if line text area get last physical line return if line last screen line p  line info last get line info last screen line if offset last offset offset last offset last length return last screen line int screen line  find the screen line containing this offset for int i i text area get visible lines i  line info info get line info i if info physical line line line is invisible return i return if info physical line line if offset info offset offset info offset info length screen line i break if screen line return last screen line p line last screen line screen line return screen line 
 recalculate visible lines  this is called when the  text area geometry is changed or when the font is changed void recalculate visible lines  line info new line info new  line info text area get visible lines int start if line info null start else start  math min line info length new line info length  system arraycopy line info new line info start for int i start i new line info length i new line info i new  line info line info new line info last screen line last screen line p 
void set buffer j edit buffer buffer this buffer buffer last screen line last screen line p 
void scroll down int amount int visible lines text area get visible lines  system arraycopy line info amount line info visible lines amount for int i visible lines amount i visible lines i line info i new  line info first invalid line amount if first invalid line first invalid line if  debug chunk cache debug  system err println f t f only amount need updates last screen line last screen line p 
void scroll up int amount  system arraycopy line info line info amount text area get visible lines amount for int i i amount i line info i new  line info don t try this at home int old first invalid line first invalid line first invalid line update chunks up to amount first invalid line old first invalid line amount if first invalid line text area get visible lines first invalid line text area get visible lines if  debug chunk cache debug  log log  log debug this f t f only amount need updates last screen line last screen line p 
void invalidate all first invalid line last screen line last screen line p 
void invalidate chunks from phys int physical line for int i i first invalid line i  line info info line info i if info physical line info physical line physical line first invalid line i if i last screen line last screen line last screen line p break 
 returns the line informations for a given screen line param screen line the screen line return the  line info for the screen line  line info get line info int screen line update chunks up to screen line return line info screen line 
 returns the number of subregions of a physical line param physical line a physical line return the number of subregions of this physical line int get line subregion count int physical line if text area soft wrap return out clear line to chunk list physical line out int size out size if size return else return size 
 returns the subregion containing the specified offset a subregion is a subset of a physical line  each screen line corresponds to one subregion  unlike the link get screen line of offset int int method this method works with non visible lines too param offset the offset param line infos a line infos array  usualy the array is the result of link get line infos for physical line int call return the subregion of the offset or if the offset was not in one of the given line infos static int get subregion of offset int offset  line info line infos for int i i line infos length i  line info info line infos i if offset info offset offset info offset info length return i return 
 converts an x co ordinate within a subregion into an offset from the start of that subregion param physical line  the physical line number param subregion  the subregion if then this is the last subregion param x  the x co ordinate param round  round up to next character if x is past the middle of a character return the offset from the start of the subregion int x to subregion offset int physical line int subregion int x boolean round  line info infos get line infos for physical line physical line if subregion subregion infos length return x to subregion offset infos subregion x round 
 converts an x co ordinate within a subregion into an offset from the start of that subregion param info  the line info object param x  the x co ordinate param round  round up to next character if x is past the middle of a character return the offset from the start of the subregion static int x to subregion offset  line info info int x boolean round int offset  chunk x to offset info chunks x round if offset offset info offset info length offset info offset info length return offset 
 converts an offset within a subregion into an x co ordinate param physical line  the physical line param offset  the offset return the x co ordinate of the offset within a subregion int subregion offset to x int physical line int offset  line info infos get line infos for physical line physical line  line info info infos get subregion of offset offset infos return subregion offset to x info offset 
 converts an offset within a subregion into an x co ordinate param info  the line info object param offset  the offset return the x co ordinate of the offset within a subregion static int subregion offset to x  line info info int offset return int  chunk offset to x info chunks offset 
 returns the start offset of the specified subregion of the specified physical line param line  the physical line number param offset  an offset return the start offset of the subregion of the line int get subregion start offset int line int offset  line info line infos get line infos for physical line line  line info info line infos get subregion of offset offset line infos return text area get line start offset info physical line info offset 
 returns the end offset of the specified subregion of the specified physical line param line  the physical line number param offset  an offset return the end offset of the subregion of the line int get subregion end offset int line int offset  line info line infos get line infos for physical line line  line info info line infos get subregion of offset offset line infos return text area get line start offset info physical line info offset info length 
param physical line  the physical line number param offset  the offset param x  the location param ignore wrap  if true behave as if soft wrap is off even if it is on int get below position int physical line int offset int x boolean ignore wrap  line info line infos get line infos for physical line physical line int subregion get subregion of offset offset line infos if subregion line infos length ignore wrap return text area get line start offset physical line x to subregion offset line infos subregion x true else int next line text area display manager get next visible line physical line if next line return else return text area get line start offset next line x to subregion offset next line x true 
param physical line  the physical line number param offset  the offset param x  the location param ignore wrap  if true behave as if soft wrap is off even if it is on int get above position int physical line int offset int x boolean ignore wrap  line info line infos get line infos for physical line physical line int subregion get subregion of offset offset line infos if subregion ignore wrap return text area get line start offset physical line x to subregion offset line infos subregion x true else int prev line text area display manager get prev visible line physical line if prev line return else return text area get line start offset prev line x to subregion offset prev line x true 
 the need full repaint variable becomes true when the number of screen lines in a physical line changes return true if the  text area needs full repaint boolean need full repaint boolean ret val need full repaint need full repaint false return ret val 
 line info get line infos for physical line int physical line out clear if buffer is loading line to chunk list physical line out if out is empty out add null  list  line info return value new  array list  line info out size get line infos for physical line physical line return value return return value to array new  line info out size 
private void get line infos for physical line int physical line  list  line info list for int i i out size i  chunk chunks out get i  line info info new  line info info physical line physical line if i info first subregion true info offset else info offset chunks offset if i out size info last subregion true info length text area get line length physical line info offset else info length out get i offset info offset info chunks chunks list add info 
 find a valid line closest to the last screen line private int get first screen line for int i first invalid line i i if line info i last subregion return i return 
 return a physical line number private int get update start line int first screen line for the first line displayed take its physical line to be the text area s first physical line if first screen line return text area get first physical line otherwise determine the next visible line else int prev phys line line info first screen line physical line if the empty space at the end of the text area when the buffer has less lines than are visible if prev phys line return else return text area display manager get next visible line prev phys line 
private void update chunks up to int last screen line this method is a nightmare if last screen line line info length throw new  array index out of bounds exception last screen line if one line s chunks are invalid remaining lines are also invalid if last screen line first invalid line return int first screen line get first screen line int physical line get update start line first screen line if  debug chunk cache debug  log log  log debug this  updating chunks from first screen line to last screen line  note that we rely on the fact that when a physical line is invalidated all screen lines subregions of that line are invalidated as well  see below comment for code that tries to uphold this assumption out clear int offset int length for int i first screen line i last screen line i  line info info line info i  chunk chunks get another line of chunks if out is empty unless this is the first time increment the line number if physical line i first screen line physical line text area display manager get next visible line physical line empty space if physical line info chunks null info physical line fix the bug where the horiz scroll bar was not updated after creating a new file info width continue chunk the line line to chunk list physical line out info first subregion true if the line has no text out size if out is empty if i if text area display manager first line skew  log log  log error this bug skew text area display manager first line skew out size out size text area display manager first line skew need full repaint true last screen line line info length chunks null offset length otherwise the number of subregions else if i int skew text area display manager first line skew if skew out size  the skew cannot be greater than the chunk count of the line we need at least one chunk per subregion in a line  log log  log error this bug skew skew out size out size need full repaint true last screen line line info length else if skew info first subregion false for int j j skew j out remove chunks out remove offset chunks offset if out is empty length out get offset offset else length text area get line length physical line offset else info first subregion false chunks out remove offset chunks offset if out is empty length out get offset offset else length text area get line length physical line offset boolean last subregion out is empty if i last screen line last screen line line info length if the user changes the syntax token at the end of a line need to do a full repaint if token handler get line context info line context last screen line need full repaint true  if this line has become longer or shorter in which case the new physical line number is different from the cached one we need to continue updating past the last line advise the text area to repaint  on the other hand if the line wraps beyond last screen line we need to keep updating the chunk list to ensure proper alignment of invalidation flags see start of method else if info physical line physical line info last subregion last subregion last screen line need full repaint true  we only cache entire physical lines at once don t want to split a physical line into screen lines and only have some valid else if out is empty last screen line info physical line physical line info last subregion last subregion info offset offset info length length info chunks chunks info line context token handler get line context first invalid line  math max last screen line first invalid line 
private void line to chunk list int physical line  list  chunk out  text area painter painter text area get painter token handler init painter get styles painter get font render context painter out text area soft wrap text area wrap margin f buffer mark tokens physical line token handler 
 override public  string to string return  line info physical line offset length first subregion last subregion 
 override protected void paint fold shape  graphics d gfx int top int bottom gfx draw arc top bottom top 
public static  class generator get class generator throws  util eval error if cg null try  class clas  class for name org gjt sp jedit bsh  class generator impl cg  class generator clas new instance catch  exception e throw new  unavailable  class generator unavailable e return cg 
public  class generate class  string name  modifiers modifiers  class interfaces  class super class bsh block block boolean is interface  call stack callstack  interpreter interpreter throws  eval error  delegate to the static method return generate class impl name modifiers interfaces super class block is interface callstack interpreter 
public  object invoke superclass method  bsh class manager bcm  object instance  string method name  object args throws  util eval error  reflect error  invocation target exception  delegate to the static method return invoke superclass method impl bcm instance method name args 
 change the parent of the class instance namespace  this is currently used for inner class support  note  this method will likely be removed in the future  this could be static public void set instance name space parent  object instance  string class name  name space parent  this ithis  class generator util get class instance this instance class name ithis get name space set parent parent 
 parse the bsh block for for the class definition and generate the class using  class generator public static  class generate class impl  string name  modifiers modifiers  class interfaces  class super class bsh block block boolean is interface  call stack callstack  interpreter interpreter throws  eval error  scripting classes currently requires accessibility  this can be eliminated with a bit more work try  capabilities set accessibility true catch  capabilities  unavailable e throw new  eval error  defining classes currently requires reflective  accessibility block callstack  name space enclosing name space callstack top  string package name enclosing name space get package  string class name enclosing name space is class enclosing name space get name name name  string fq class name package name null class name package name class name  bsh class manager bcm interpreter get class manager  race condition here bcm defining class fq class name  create the class static namespace  name space class static name space new  name space enclosing name space class name class static name space is class true callstack push class static name space  evaluate any inner class class definitions in the block effectively recursively call this method for contained classes first block eval block callstack interpreter true override  class node filter classclasses  generate the type for our class  variable variables get declared variables block callstack interpreter package name  delayed eval bsh method methods get declared methods block callstack interpreter package name  class generator util class generator new  class generator util modifiers class name package name super class interfaces variables methods class static name space is interface byte code class generator generate class if debug write out the class file to debug classes directory  string dir  system get property debug classes if dir null try  file output stream out new  file output stream dir class name class out write code out close catch io exception e  define the new class in the classloader  class gen class bcm define class fq class name code import the unq name into parent enclosing name space import class fq class name replace try class static name space set local variable  class generator util bshinit block false strict java catch  util eval error e throw new  interpreter error unable to init static e  give the static space its class static import important to do this after all classes are defined class static name space set class static gen class evaluate the static portion of the block in the static space block eval block callstack interpreter true override  class node filter classstatic callstack pop if gen class is interface  set the static bsh  this callback  string bsh static field name  class generator util bshstatic class name try lhs lhs  reflect get lhs static field gen class bsh static field name lhs assign class static name space get this interpreter false strict catch  exception e throw new  interpreter error  error in class gen setup e bcm done defining class fq class name return gen class 
static  variable get declared variables bsh block body  call stack callstack  interpreter interpreter  string default package  list vars new  array list for int child child body jjt get num children child  simple node node  simple node body jjt get child child if node instanceof bsh typed variable declaration bsh typed variable declaration tvd bsh typed variable declaration node  modifiers modifiers tvd modifiers  string type tvd get type descriptor callstack interpreter default package bsh variable declarator vardec tvd get declarators for int i i vardec length i  string name vardec i name try  variable var new  variable name type null value modifiers vars add var catch  util eval error e value error shouldn t happen return  variable vars to array new  variable 
static  delayed eval bsh method get declared methods bsh block body  call stack callstack  interpreter interpreter  string default package throws  eval error  list methods new  array list for int child child body jjt get num children child  simple node node  simple node body jjt get child child if node instanceof bsh method declaration bsh method declaration md bsh method declaration node md insure nodes parsed  modifiers modifiers md modifiers  string name md name  string return type md get return type descriptor callstack interpreter default package bsh return type return type node md get return type node bsh formal parameters param types node md params node  string param types param types node get type descriptors callstack interpreter default package  delayed eval bsh method bm new  delayed eval bsh method name return type return type node md params node get param names param types param types node md block node null declaring name space modifiers callstack interpreter methods add bm return  delayed eval bsh method methods to array new  delayed eval bsh method 
private  class node filter int context this context context 
public boolean is visible  simple node node if context classes return node instanceof bsh class declaration  only show class decs in classes if node instanceof bsh class declaration return false if context static return is static node if context instance return is static node all return true 
boolean is static  simple node node if node instanceof bsh typed variable declaration return bsh typed variable declaration node modifiers null bsh typed variable declaration node modifiers has modifier static if node instanceof bsh method declaration return bsh method declaration node modifiers null bsh method declaration node modifiers has modifier static need to add static block here if node instanceof bsh block return false return false 
public static  object invoke superclass method impl  bsh class manager bcm  object instance  string method name  object args throws  util eval error  reflect error  invocation target exception  string super name  class generator util bshsuper method name look for the specially named super delegate method  class clas instance get class  method super method  reflect resolve java method bcm clas super name  types get types args false only static if super method null return  reflect invoke method super method instance args  no super method try to invoke regular method could be a superfluous super which is legal  class super class clas get superclass super method  reflect resolve expected java method bcm super class instance method name args false only static return  reflect invoke method super method instance args 
param package name e g com foo bar public  class generator util  modifiers class modifiers  string class name  string package name  class super class  class interfaces  variable vars  delayed eval bsh method bshmethods  name space class static name space boolean is interface this class modifiers class modifiers this class name class name if package name null this fq class name package name replace class name else this fq class name class name if super class null super class  object class this super class super class this super class name  type get internal name super class if interfaces null interfaces new  class this interfaces interfaces this vars vars this class static name space class static name space this super constructors super class get declared constructors  split the methods into constructors and regular method lists  list consl new  array list  list methodsl new  array list  string class base name get base name class name for inner classes for int i i bshmethods length i if bshmethods i get name equals class base name consl add bshmethods i else methodsl add bshmethods i this constructors  delayed eval bsh method consl to array new  delayed eval bsh method this methods  delayed eval bsh method methodsl to array new  delayed eval bsh method try class static name space set local variable bshconstructors constructors false strict catch  util eval error e throw new  interpreter error can t set cons var this is interface is interface 
 generate the class bytecode for this class public byte generate class  force the class public for now int class mods get asm modifiers class modifiers acc public if is interface class mods acc interface  string interface names new  string interfaces length for int i i interfaces length i interface names i  type get internal name interfaces i  string source file  bean shell  generated via asm www objectweb org  class writer cw new  class writer false cw visit class mods fq class name super class name interface names source file if is interface  generate the bsh instance  this reference holder field generate field bshthis class name  lorg gjt sp jedit bsh  this acc public cw  generate the static bsh static reference holder field generate field bshstatic class name  lorg gjt sp jedit bsh  this acc public acc static cw  generate the fields for int i i vars length i  string type vars i get type descriptor  don t generate private or loosely typed fields  note loose types aren t currently parsed anyway if vars i has modifier private type null continue int modifiers if is interface modifiers acc public acc static acc final else modifiers get asm modifiers vars i get modifiers generate field vars i get name type modifiers cw  generate the constructors boolean has constructor false for int i i constructors length i  don t generate private constructors if constructors i has modifier private continue int modifiers get asm modifiers constructors i get modifiers generate constructor i constructors i get param type descriptors modifiers cw has constructor true  if no other constructors generate a default constructor if is interface has constructor generate constructor defaultconstructor index new  string acc public cw  generate the delegate methods for int i i methods length i  string return type methods i get return type descriptor  don t generate private or loosely return typed methods if methods i has modifier private return type null continue int modifiers get asm modifiers methods i get modifiers if is interface modifiers acc public acc abstract generate method class name fq class name methods i get name return type methods i get param type descriptors modifiers cw boolean is static modifiers acc static boolean overridden class contains method super class methods i get name methods i get param type descriptors if is static overridden generate super delegate method super class name methods i get name return type methods i get param type descriptors modifiers cw return cw to byte array 
 translate bsh  modifiers into asm modifier bitflags static int get asm modifiers  modifiers modifiers int mods if modifiers null return mods if modifiers has modifier public mods acc public if modifiers has modifier protected mods acc protected if modifiers has modifier static mods acc static if modifiers has modifier synchronized mods acc synchronized if modifiers has modifier abstract mods acc abstract return mods 
 generate a field static or instance static void generate field  string field name  string type int modifiers  class writer cw cw visit field modifiers field name type null value 
 generate a delegate method static or instance  the generated code packs the method arguments into an object array wrapping primitive types in bsh  primitive invokes the static or instance namespace invoke method method and then unwraps returns the result static void generate method  string class name  string fq class name  string method name  string return type  string param types int modifiers  class writer cw  string exceptions null boolean is static modifiers acc static if return type null map loose return type to  object return type object  string method descriptor get method descriptor return type param types  generate method body  code visitor cv cw visit method modifiers method name method descriptor exceptions if modifiers acc abstract return  generate code to push the bshthis or bshstatic field if is static cv visit field insn getstatic fq class name bshstatic class name  lorg gjt sp jedit bsh  this else  push this cv visit var insn aload  get the instance field cv visit field insn getfield fq class name bshthis class name  lorg gjt sp jedit bsh  this  push the name of the method as a constant cv visit ldc insn method name  generate code to push arguments as an object array generate parameter reifier code param types is static cv  push nulls for various args of invoke method cv visit insn aconst null interpreter cv visit insn aconst null callstack cv visit insn aconst null callerinfo  push the boolean constant true for declared only cv visit insn iconst   invoke the method  this invoke method name  class sig boolean cv visit method insn invokevirtual org gjt sp jedit bsh  this invoke method  type get method descriptor  type get type  object class new  type  type get type  string class  type get type  object class  type get type  interpreter class  type get type  call stack class  type get type  simple node class  type get type  boolean type  generate code to unwrap bsh  primitive types cv visit method insn invokestatic org gjt sp jedit bsh  primitive unwrap  ljava lang  object  ljava lang  object  generate code to return the value generate return code return type cv  need to calculate this just fudging here for now cv visit maxs 
 generate a constructor void generate constructor int index  string param types int modifiers  class writer cw offset after params of the args object var final int args var param types length offset after params of the  constructor args var final int cons args var param types length  string exceptions null  string method descriptor get method descriptor v param types  create this constructor method  code visitor cv cw visit method modifiers init method descriptor exceptions  generate code to push arguments as an object array generate parameter reifier code param types false is static cv cv visit var insn astore args var  generate the code implementing the alternate constructor switch generate constructor switch index args var cons args var cv  generate code to invoke the  class generator util init instance method push this cv visit var insn aload  push the class constructor name as a constant cv visit ldc insn class name  push arguments as an object array cv visit var insn aload args var invoke the init instance method cv visit method insn invokestatic org gjt sp jedit bsh  class generator util init instance  ljava lang  object  ljava lang  string  ljava lang  object v cv visit insn return  need to calculate this just fudging here for now cv visit maxs 
 generate a switch with a branch for each possible alternate constructor  this includes all superclass constructors and all constructors of this class  the default branch of this switch is the default superclass constructor p  this method also generates the code to call the static  class generator util get constructor args method which inspects the scripted constructor to find the alternate constructor signature if any and evalute the arguments at runtime  the get constructor args method returns the actual arguments as well as the index of the constructor to call void generate constructor switch int cons index int args var int cons args var  code visitor cv  label default label new  label  label end label new  label int cases super constructors length constructors length  label labels new  label cases for int i i cases i labels i new  label  generate code to call  class generator util to get our switch index and give us args push super class name cv visit ldc insn super class get name use super class name var push class static  this object cv visit field insn getstatic fq class name bshstatic class name  lorg gjt sp jedit bsh  this push args cv visit var insn aload args var push this constructor index number onto stack cv visit int insn bipush cons index invoke the  class generator util get constructors args method cv visit method insn invokestatic org gjt sp jedit bsh  class generator util get constructor args  ljava lang  string  lorg gjt sp jedit bsh  this  ljava lang  object i  lorg gjt sp jedit bsh  class generator util  constructor args store  constructor args in cons args var cv visit var insn astore cons args var  get the  constructor args selector field from  constructor args push  constructor args cv visit var insn aload cons args var cv visit field insn getfield org gjt sp jedit bsh  class generator util  constructor args selector i start switch cv visit table switch insn min cases max default label labels generate switch body int index for int i i super constructors length i index do switch branch index super class name get type descriptors super constructors i get parameter types end label labels cons args var cv for int i i constructors length i index do switch branch index fq class name constructors i get param type descriptors end label labels cons args var cv generate the default branch of switch cv visit label default label default branch always invokes no args super cv visit var insn aload push this cv visit method insn invokespecial super class name init v done with switch cv visit label end label 
static void do switch branch int index  string target class name  string param types  label end label  label labels int cons args var  code visitor cv cv visit label labels index cv visit line number index labels index cv visit var insn aload push this before args  unload the arguments from the  constructor args object for int i i param types length i  string type param types i  string method null if type equals z method get boolean else if type equals b method get byte else if type equals c method get char else if type equals s method get short else if type equals i method get int else if type equals j method get long else if type equals d method get double else if type equals f method get float else method get object invoke the iterator method on the  constructor args cv visit var insn aload cons args var push the  constructor args  string class name org gjt sp jedit bsh  class generator util  constructor args  string ret type if method equals get object ret type object else ret type type cv visit method insn invokevirtual class name method ret type if it s an object type we must do a check cast if method equals get object cv visit type insn checkcast descriptor to class name type invoke the constructor for this branch  string descriptor get method descriptor v param types cv visit method insn invokespecial target class name init descriptor cv visit jump insn goto end label 
static  string get method descriptor  string return type  string param types  string builder sb new  string builder for int i i param types length i sb append param types i sb append return type return sb to string 
 generate a superclass method delegate accessor method  these methods are specially named methods which allow access to overridden methods of the superclass which the  java reflection api normally does not allow  maybe combine this with generate method static void generate super delegate method  string super class name  string method name  string return type  string param types int modifiers  class writer cw  string exceptions null if return type null map loose return to  object return type object  string method descriptor get method descriptor return type param types  add method body  code visitor cv cw visit method modifiers  bsh super method name method descriptor exceptions cv visit var insn aload  push vars int local var index for int i i param types length i if is primitive param types i cv visit var insn iload local var index else cv visit var insn aload local var index local var index param types i equals d param types i equals j cv visit method insn invokespecial super class name method name method descriptor generate plain return code return type cv  need to calculate this just fudging here for now cv visit maxs 
boolean class contains method  class clas  string method name  string param types while clas null  method methods clas get declared methods for int i i methods length i if methods i get name equals method name  string method param types get type descriptors methods i get parameter types boolean found true for int j j method param types length j if param types j equals method param types j found false break if found return true clas clas get superclass return false 
 generate return code for a normal bytecode static void generate plain return code  string return type  code visitor cv if return type equals v cv visit insn return else if is primitive return type int opcode ireturn if return type equals d opcode dreturn else if return type equals f opcode freturn else if return type equals j long opcode lreturn cv visit insn opcode else cv visit type insn checkcast descriptor to class name return type cv visit insn areturn 
 generates the code to reify the arguments of the given method  for a method int m int i  string s this code is the bytecode corresponding to the new  object new bsh  primitive i s expression author  eric  bruneton author  pat  niemeyer param cv the code visitor to be used to generate the bytecode param is static the enclosing methods is static public static void generate parameter reifier code  string param types boolean is static final  code visitor cv cv visit int insn sipush param types length cv visit type insn anewarray java lang  object int local var index is static for int i i param types length i  string param param types i cv visit insn dup cv visit int insn sipush i if is primitive param int opcode if param equals f opcode fload else if param equals d opcode dload else if param equals j opcode lload else opcode iload  string type org gjt sp jedit bsh  primitive cv visit type insn new type cv visit insn dup cv visit var insn opcode local var index  string desc param ok cv visit method insn invokespecial type init desc v else  technically incorrect here we need to wrap null values as bsh  primitive null  however the  this invoke method will do that much for us  we need to generate a conditional here to test for null and return  primitive null cv visit var insn aload local var index cv visit insn aastore local var index param equals d param equals j 
 generates the code to unreify the result of the given method  for a method int m int i  string s this code is the bytecode corresponding to the  integer int value expression param cv the code visitor to be used to generate the bytecode author  eric  bruneton author  pat  niemeyer public static void generate return code  string return type  code visitor cv if return type equals v cv visit insn pop cv visit insn return else if is primitive return type int opcode ireturn  string type  string meth if return type equals b type java lang  byte meth byte value else if return type equals i type java lang  integer meth int value else if return type equals z type java lang  boolean meth boolean value else if return type equals d opcode dreturn type java lang  double meth double value else if return type equals f opcode freturn type java lang  float meth float value else if return type equals j opcode lreturn type java lang  long meth long value else if return type equals c type java lang  character meth char value else if return type equals s type java lang  short meth short value  string desc return type cv visit type insn checkcast type type is correct here cv visit method insn invokevirtual type meth desc cv visit insn opcode else cv visit type insn checkcast descriptor to class name return type cv visit insn areturn 
 evaluate the arguments if any for the constructor specified by the constructor index  return the  constructor args object which contains the actual arguments to the alternate constructor and also the index of that constructor for the constructor switch param cons args the arguments to the constructor  these are necessary in the evaluation of the alt constructor args e g  foo a super a return the  constructor args object containing a constructor selector and evaluated arguments for the alternate constructor public static  constructor args get constructor args  string super class name  this class static this  object cons args int index  delayed eval bsh method constructors try constructors  delayed eval bsh method class static this get name space get variable bshconstructors catch  exception e throw new  interpreter error unable to get instance initializer e if index defaultconstructor auto gen default constructor return  constructor args default use default super constructor  delayed eval bsh method constructor constructors index if constructor method body jjt get num children return  constructor args default use default super constructor  determine if the constructor calls this or super  string alt constructor null bsh arguments args node null  simple node first statement  simple node constructor method body jjt get child if first statement instanceof bsh primary expression first statement  simple node first statement jjt get child if first statement instanceof bsh method invocation bsh method invocation method node bsh method invocation first statement bsh ambiguous name method name method node get name node if method name text equals super method name text equals this alt constructor method name text args node method node get args node if alt constructor null return  constructor args default use default super constructor  make a tmp namespace to hold the original constructor args for use in eval of the parameters node  name space cons args name space new  name space class static this get name space cons args  string cons arg names constructor get parameter names  class cons arg types constructor get parameter types for int i i cons args length i try cons args name space set typed variable cons arg names i cons arg types i cons args i null modifiers catch  util eval error e throw new  interpreter error err setting local cons arg e evaluate the args  call stack callstack new  call stack callstack push cons args name space  object args null  interpreter interpreter class static this declaring interpreter try args args node get arguments callstack interpreter catch  eval error e throw new  interpreter error  error evaluating constructor args e  class arg types  types get types args args  primitive unwrap args  class super class interpreter get class manager class for name super class name if super class null throw new  interpreter error can t find superclass super class name  constructor super cons super class get declared constructors find the matching super constructor for the args if alt constructor equals super int i  reflect find most specific constructor index arg types super cons if i throw new  interpreter error can t find constructor for args return new  constructor args i args find the matching this constructor for the args  class candidates new  class constructors length for int i i candidates length i candidates i constructors i get parameter types int i  reflect find most specific signature arg types candidates if i throw new  interpreter error can t find constructor for args this constructors come after super constructors in the table int selector i super cons length int our selector index super cons length  are we choosing ourselves recursively through a this reference if selector our selector throw new  interpreter error  recusive constructor call return new  constructor args selector args 
 initialize an instance of the class  this method is called from the generated class constructor to evaluate the instance initializer and scripted constructor in the instance namespace public static void init instance  object instance  string class name  object args  class sig  types get types args  call stack callstack new  call stack  interpreter interpreter  name space instance name space check to see if the instance has already been initialized the case if using a this alternate constuctor  this instance this get class instance this instance class name xxx clean up this conditional if instance this null  create the instance  this namespace set it on the object instance and invoke the instance initializer  get the static  this reference from the proto instance  this class static this get class static this instance get class class name interpreter class static this declaring interpreter  get the instance initializer block from the static  this bsh block instance init block try instance init block bsh block class static this get name space get variable bshinit catch  exception e throw new  interpreter error unable to get instance initializer e  create the instance namespace instance name space new  name space class static this get name space class name instance name space is class true  set the instance  this reference on the instance instance this instance name space get this interpreter try lhs lhs  reflect get lhs object field instance bshthis class name lhs assign instance this false strict catch  exception e throw new  interpreter error  error in class gen setup e  give the instance space its object import instance name space set class instance instance should use try finally here to pop ns callstack push instance name space evaluate the instance portion of the block in it try  evaluate the initializer block instance init block eval block callstack interpreter true override  class generator impl  class node filter classinstance catch  exception e throw new  interpreter error  error in class initialization e callstack pop else  the object instance has already been initialzed by another constructor  fall through to invoke the constructor body below interpreter instance this declaring interpreter instance name space instance this get name space invoke the constructor method from the instance this  string constructor name get base name class name try  find the constructor now in the instance namespace  bsh method constructor instance name space get method constructor name sig true declared only if args we must have constructor if args length constructor null throw new  interpreter error  can t find constructor class name  evaluate the constructor if constructor null constructor invoke args interpreter callstack null caller info false override name space catch  exception e if e instanceof  target error e  exception  target error e get target if e instanceof  invocation target exception e  exception  invocation target exception e get target exception e print stack trace  system err throw new  interpreter error  error in class initialization e 
 get the static bsh namespace field from the class param class name may be the name of clas itself or a superclass of clas static  this get class static this  class clas  string class name try return  this  reflect get static field value clas bshstatic class name catch  exception e throw new  interpreter error  unable to get class static space e 
 get the instance bsh namespace field from the object instance return the class instance  this object or null if the object has not been initialized static  this get class instance this  object instance  string class name try  object o  reflect get object field value instance bshthis class name return  this  primitive unwrap o unwrap  primitive  null to null catch  exception e throw new  interpreter error  generated class  error getting  this e 
 does the type descriptor string describe a primitive type private static boolean is primitive  string type descriptor return type descriptor length right 
static  string get type descriptors  class cparams  string sa new  string cparams length for int i i sa length i sa i bsh type get type descriptor cparams i return sa 
 if a non array object type remove the prefix l and suffix  can this be factored out  should be be adding the l here instead private static  string descriptor to class name  string s if s starts with s starts with l return s return s substring s length 
private static  string get base name  string class name int i class name index of if i return class name return class name substring i 
 the index of the constructor to call  constructor args 
 constructor args int selector  object args this selector selector this args args 
 object next return args arg 
public boolean get boolean return  boolean next boolean value 
public byte get byte return  byte next byte value 
public char get char return  character next char value 
public short get short return  short next short value 
public int get int return  integer next int value 
public long get long return  long next long value 
public double get double return  double next double value 
public float get float return  float next float value 
public  object get object return next 
public  class identifier  class clas this clas clas 
public  class get target class return clas 
public  string to string return  class  identifier clas get name 
 used by  bsh class manager singleton constructor public  class manager impl reset 
return the class or null public  class class for name  string name check positive cache  class c  class absolute class cache get name if c null return c check negative cache if absolute non classes get name null if  interpreter debug  interpreter debug absolute non class list hit name return null if  interpreter debug  interpreter debug  trying to load class name  check explicitly mapped reloaded class  class loader overlay loader get loader for class name if overlay loader null try c overlay loader load class name catch  exception e used to squeltch this changed for see  bsh class manager catch  no class def found error e throw no class def found name e  should be there since it was explicitly mapped throw an error insure that core classes are loaded from the same loader if c null if name starts with bsh package try c  interpreter class get class loader load class name catch  class not found exception e  check classpath extension reloaded classes if c null if base loader null try c base loader load class name catch  class not found exception e  optionally try external classloader if c null if external class loader null try c external class loader load class name catch  class not found exception e  optionally try context classloader  note that this might be a security violation is catching the  security exception sufficient for all environments or do we need a way to turn this off completely if c null try  class loader context class loader  thread current thread get context class loader if context class loader null c  class for name name true context class loader catch  class not found exception e fall through catch  security exception e fall through try plain class for name if c null try c plain class for name name catch  class not found exception e  try scripted class if c null c load source class name  cache result or null for not found  note plain class for name already caches so it will be redundant in that case however this process only happens once cache class info name c return c 
 get a resource url using the  bean shell classpath param path should be an absolute path public url get resource  string path url url null if base loader null classloader wants no leading slash url base loader get resource path substring if url null url super get resource path return url 
 get a resource stream using the  bean shell classpath param path should be an absolute path public  input stream get resource as stream  string path  input stream in null if base loader null classloader wants no leading slash in base loader get resource as stream path substring if in null in super get resource as stream path return in 
 class loader get loader for class  string name return  class loader loader map get name 
public void add class path url path throws io exception if base loader null set class path new url path else opportunity here for listener in classpath base loader add url path base class path add path class loader changed 
 clear all classloading behavior and class caches and reset to initial state public void reset base class path new  bsh class path base class path base loader null loader map new  hash map class loader changed calls clear caches for us 
 set a new base classpath and create a new base classloader  this means all types change public void set class path url cp base class path set path cp init base loader loader map new  hash map class loader changed 
 overlay the entire path with a new class loader  set the base path to the user path base path  no point in including the boot class path can t reload thos public void reload all classes throws  class path exception  bsh class path bcp new  bsh class path temp bcp add component base class path bcp add component  bsh class path get user class path set class path bcp get path components 
init the base loader from the base class path private void init base loader base loader new  bsh class loader this base class path 
 reloading classes means creating a new classloader and using it whenever we are asked for classes in the appropriate space  for this we use a  discrete files class loader public void reload classes  string class names throws  class path exception validate that it is a class here init base class loader if there is none if base loader null init base loader  discrete files class loader  class source map map new  discrete files class loader  class source map for int i i class names length i  string name class names i look in base loader class path  class source class source base class path get class source name look in user class path if class source null  bsh class path get user class path insure initialized class source  bsh class path get user class path get class source name  no point in checking boot class path can t reload those else we could have used full class path above if class source null throw new  class path exception  nothing known about class name  jar class source is not working just need to implement it s get code method or if we decide to allow the  bsh class manager to handle it since it is a url class loader and can handle ja rs if class source instanceof  jar class source throw new  class path exception  cannot reload class name from source class source map put name class source  create classloader for the set of classes  class loader cl new  discrete files class loader this map map those classes the loader in the overlay map  iterator it map key set iterator while it has next loader map put  string it next cl class loader changed 
 reload all classes in the specified package e g com sun tools  the special package name unpackaged can be used to refer to unpackaged classes public void reload package  string pack throws  class path exception  collection classes base class path get classes for package pack if classes null classes  bsh class path get user class path get classes for package pack no point in checking boot class path can t reload those if classes null throw new  class path exception  no classes found for package pack reload classes  string classes to array new  string 
 get the full blown classpath public  bsh class path get class path throws  class path exception if full class path null return full class path full class path new  bsh class path  bean shell  full  class  path full class path add component  bsh class path get user class path try full class path add component  bsh class path get boot class path catch  class path exception e  system err println  warning can t get boot class path full class path add component base class path return full class path 
 support for import  hide details in here as opposed to  name space public void do super import throws  util eval error  should we prevent it from happening twice try get class path insure initialized prime the lookup table get class name by unq name always true now get class path set name completion include unq names true catch  class path exception e throw new  util eval error  error importing classpath e super import true 
protected boolean has super import return super import 
 return the name or null if none is found  throw an  class path exception containing detail if name is ambigous public  string get class name by unq name  string name throws  class path exception return get class path get class name by unq name name 
public void add listener  listener l listeners add element new  weak reference l ref queue clean up old listeners  reference deadref while deadref ref queue poll null boolean ok listeners remove element deadref if ok  system err println cleaned up weak ref deadref else if  interpreter debug  interpreter debug tried to remove non existent weak ref deadref 
public void remove listener  listener l throw new  error unimplemented 
public  class loader get base loader return base loader 
 get the  bean shell classloader public  class loader get class loader  impl  notes  we add the bytecode source and the reload the class which causes the  bsh class loader to be initialized and create a  discrete files class loader for the bytecode exception  class path exception can be thrown by reload classes public  class define class  string name byte code base class path set class source name new  generated class source code try reload classes new  string name catch  class path exception e throw new org gjt sp jedit bsh  interpreter error define class e return class for name name 
 clear global class cache and notify namespaces to clear their class caches  the listener list is implemented with weak references so that we will not keep every namespace in existence forever protected void class loader changed clear the static caches in  bsh class manager clear caches  vector to remove new  vector safely remove for  enumeration e listeners elements e has more elements  weak reference wr  weak reference e next element  listener l  listener wr get if l null garbage collected to remove add wr else l class loader changed for  enumeration e to remove elements e has more elements listeners remove element e next element 
public void dump  print writer i i println  bsh  class  manager  dump i println i println base loader base loader i println loader map loader map i println i println base class path base class path 
public  class path exception  string msg super msg 
 constructs a new link  class writer  class writer object param compute maxs tt true tt if the maximum stack size and the maximum number of local variables must be automatically computed  if this flag is tt true tt then the arguments of the link  code visitor visit maxs visit maxs method of the link  code visitor  code visitor returned by the link visit method visit method method will be ignored and computed automatically from the signature and the bytecode of each method public  class writer final boolean compute maxs index pool new  byte vector table new  item threshold int d table length key new  item key new  item key new  item this compute maxs compute maxs 
public void visit final int access final  string name final  string super name final  string interfaces final  string source file this access access this name new class name index this super name super name null new class super name index if interfaces null interfaces length interface count interfaces length this interfaces new int interface count for int i i interface count i this interfaces i new class interfaces i index if source file null new utf  source file this source file new utf source file if access  constants acc deprecated new utf  deprecated 
public void visit inner class final  string name final  string outer name final  string inner name final int access if inner classes null new utf  inner classes inner classes new  byte vector inner classes count inner classes put name null new class name index inner classes put outer name null new class outer name index inner classes put inner name null new utf inner name index inner classes put access 
public void visit field final int access final  string name final  string desc final  object value field count if fields null fields new  byte vector fields put access put new utf name index put new utf desc index int attribute count if value null attribute count if access  constants acc synthetic attribute count if access  constants acc deprecated attribute count fields put attribute count if value null fields put new utf  constant value index fields put put new cst value index if access  constants acc synthetic fields put new utf  synthetic index put if access  constants acc deprecated fields put new utf  deprecated index put 
public  code visitor visit method final int access final  string name final  string desc final  string exceptions  code writer cw new  code writer this compute maxs cw init access name desc exceptions return cw 
public void visit end 
 returns the bytecode of the class that was build with this class writer return the bytecode of the class that was build with this class writer public byte to byte array computes the real size of the bytecode of this class int size interface count if fields null size fields length int nb methods  code writer cb first method while cb null nb methods size cb get size cb cb next size pool length int attribute count if source file null attribute count size if access  constants acc deprecated attribute count size if inner classes null attribute count size inner classes length allocates a byte vector of this size in order to avoid unnecessary arraycopy operations in the  byte vector enlarge method  byte vector out new  byte vector size out put x cafebabe put put out put index put byte array pool data pool length out put access put name put super name out put interface count for int i i interface count i out put interfaces i out put field count if fields null out put byte array fields data fields length out put nb methods cb first method while cb null cb put out cb cb next out put attribute count if source file null out put new utf  source file index put put source file index if access  constants acc deprecated out put new utf  deprecated index put if inner classes null out put new utf  inner classes index out put inner classes length put inner classes count out put byte array inner classes data inner classes length return out data 
 adds a number or string constant to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param cst the value of the constant to be added to the constant pool  this parameter must be an link java lang  integer  integer a link java lang  float  float a link java lang  long  long a link java lang  double  double or a link  string  string return a new or already existing constant item with the given value  item new cst final  object cst if cst instanceof  integer int val  integer cst int value return new integer val else if cst instanceof  float float val  float cst float value return new float val else if cst instanceof  long long val  long cst long value return new long val else if cst instanceof  double double val  double cst double value return new double val else if cst instanceof  string return new string  string cst else throw new  illegal argument exception value cst 
 adds an utf string to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param value the  string value return a new or already existing utf item  item new utf final  string value key set utf value null null  item result get key if result null pool put utf put utf value result new  item index key put result return result 
 adds a class reference to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param value the internal name of the class return a new or already existing class reference item  item new class final  string value key set class value null null  item result get key if result null pool put class new utf value index result new  item index key put result return result 
 adds a field reference to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param owner the internal name of the field s owner class param name the field s name param desc the field s descriptor return a new or already existing field reference item  item new field final  string owner final  string name final  string desc key set field owner name desc  item result get key if result null put field new class owner index new name type name desc index result new  item index key put result return result 
 adds a method reference to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param owner the internal name of the method s owner class param name the method s name param desc the method s descriptor return a new or already existing method reference item  item new method final  string owner final  string name final  string desc key set meth owner name desc  item result get key if result null put meth new class owner index new name type name desc index result new  item index key put result return result 
 adds an interface method reference to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param owner itf the internal name of the method s owner interface param name the method s name param desc the method s descriptor return a new or already existing interface method reference item  item new itf method final  string owner itf final  string name final  string desc key set imeth owner itf name desc  item result get key if result null put imeth new class owner itf index new name type name desc index result new  item index key put result return result 
 adds an integer to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param value the int value return a new or already existing int item private  item new integer final int value key set value  item result get key if result null pool put int put value result new  item index key put result return result 
 adds a float to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param value the float value return a new or already existing float item private  item new float final float value key set value  item result get key if result null pool put float put  float float to int bits value result new  item index key put result return result 
 adds a long to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param value the long value return a new or already existing long item private  item new long final long value key set value  item result get key if result null pool put long put value result new  item index key put result index return result 
 adds a double to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param value the double value return a new or already existing double item private  item new double final double value key set value  item result get key if result null pool put double put  double double to long bits value result new  item index key put result index return result 
 adds a string to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param value the  string value return a new or already existing string item private  item new string final  string value key set str value null null  item result get key if result null pool put str new utf value index result new  item index key put result return result 
 adds a name and type to the constant pool of the class being build  does nothing if the constant pool already contains a similar item param name a name param desc a type descriptor return a new or already existing name and type item private  item new name type final  string name final  string desc key set name type name desc null  item result get key if result null put name type new utf name index new utf desc index result new  item index key put result return result 
 returns the constant pool s hash table item which is equal to the given item param key a constant pool item return the constant pool s hash table item which is equal to the given item or tt null tt if there is no such item private  item get final  item key  item tab table int hash code key hash code int index hash code x fffffff tab length for  item i tab index i null i i next if i hash code hash code key is equal to i return i return null 
 puts the given item in the constant pool s hash table  the hash table i must i not already contains this item param i the item to be added to the constant pool s hash table private void put final  item i if index threshold int old capacity table length  item old map table int new capacity old capacity  item new map new  item new capacity threshold int new capacity table new map for int j old capacity j for  item old old map j old null  item e old old old next int index e hash code x fffffff new capacity e next new map index new map index e int index i hash code x fffffff table length i next table index table index i 
 puts one byte and two shorts into the constant pool param b a byte param s a short param s another short private void put final int b final int s final int s pool put b s put s 
public  widget get widget  view view  widget clock new  clock widget return clock 
 clock widget clock new  clock 
public j component get component return clock 
public void update 
public void properties changed 
 clock set foreground j edit get color property view status foreground set background j edit get color property view status background 
 override public void add notify super add notify update int milliseconds per minute timer new  timer milliseconds per minute this timer set initial delay int milliseconds per minute  system current time millis milliseconds per minute timer start  tool tip manager shared instance register component this 
 override public void remove notify timer stop  tool tip manager shared instance unregister component this super remove notify 
 override public  string get tool tip text return new  date to string 
 override public  point get tool tip location  mouse event event return new  point event get x 
public void action performed  action event e update 
private static  string get time return  date format get time instance  date format short format new  date 
private void update set text get time 
public  close bracket indent rule char close bracket boolean aligned super  text utilities get complementary bracket close bracket null close bracket this aligned aligned 
public void apply j edit buffer buffer int this line index int prev line index int prev prev line index  list  indent action indent actions int index if aligned index this line index else index prev line index if index return  char sequence line text buffer get line segment index int offset for offset line text length offset offset if line text char at offset close bracket break if offset return int close count get brackets buffer index close count if close count  align bracket align bracket new  align bracket buffer index offset  consider the following  common  lisp code with one more opening bracket than closing defun emit push long arg cond eql arg emit lconst  eql arg emit lconst  even though we have a closing bracket match on line the next line must be indented relative to the corresponding opening bracket from line int open line align bracket get open bracket line if open line int column align bracket get open bracket column align bracket set extra indent get brackets buffer open line column open count indent actions add align bracket 
deprecated  this method calls  bracket indent rule get brackets  string which has been deprecated  deprecated public boolean is match  string line return get brackets line close count 
public  align bracket j edit buffer buffer int line int offset this line line this offset offset int open bracket index  text utilities find matching bracket buffer this line this offset if open bracket index open bracket line else open bracket line buffer get line of offset open bracket index open bracket column open bracket index buffer get line start offset open bracket line open bracket line text buffer get line segment open bracket line 
public int get extra indent return extra indent 
public void set extra indent int extra indent this extra indent extra indent 
public int get open bracket column return open bracket column 
public int get open bracket line return open bracket line 
public int calculate indent j edit buffer buffer int line int old indent int new indent if open bracket line text null return new indent else return  standard utilities get leading white space width open bracket line text buffer get tab size extra indent buffer get indent size 
public boolean keep checking return false 
public  close dialog  view view this view  arrays as list j edit get buffers 
public  close dialog  view view  collection  buffer buffers super view j edit get property close title true this view view j panel content new j panel new  border layout content set border new  empty border set content pane content  box icon box new  box  box layout y axis icon box add new j label ui manager get icon  option pane warning icon icon box add  box create glue content add  border layout west icon box j panel center panel new j panel new  border layout j label label new j label j edit get property close caption label set border new  empty border center panel add  border layout north label buffer list new j list buffer model new  default list model buffer list set visible row count buffer list add list selection listener new  list handler for  buffer buffer buffers if buffer is dirty buffer model add element buffer get path center panel add  border layout center new j scroll pane buffer list content add  border layout center center panel  action handler action listener new  action handler  box buttons new  box  box layout x axis buttons add  box create glue buttons add select all new j button j edit get property close select all select all set mnemonic j edit get property close select all mnemonic char at select all add action listener action listener buttons add  box create horizontal strut buttons add save new j button j edit get property close save save set mnemonic j edit get property close save mnemonic char at save add action listener action listener buttons add  box create horizontal strut buttons add discard new j button j edit get property close discard discard set mnemonic j edit get property close discard mnemonic char at discard add action listener action listener buttons add  box create horizontal strut buttons add cancel new j button j edit get property common cancel cancel add action listener action listener buttons add  box create glue buffer list set selected index content add  border layout south buttons content get root pane set default button cancel gui utilities request focus this buffer list pack set location relative to view set visible true 
public boolean is ok return ok 
 override public void ok do nothing 
 override public void cancel dispose 
private void update buttons int index buffer list get selected index save get model set enabled index discard get model set enabled index 
public void action performed  action event evt  object source evt get source if source select all i m too tired to think of a better way to handle this right now try select all flag true buffer list set selection interval buffer model get size finally select all flag false buffer list request focus else if source save  object paths buffer list get selected values for int i i paths length i  string path  string paths i  buffer buffer j edit get buffer path if buffer save view null true true return vfs manager wait for requests if buffer get boolean property  buffer io request error occurred return j edit  close buffer view buffer buffer model remove element path if buffer model get size ok true dispose else buffer list set selected index buffer list request focus else if source discard  object paths buffer list get selected values for int i i paths length i  string path  string paths i  buffer buffer j edit get buffer path j edit  close buffer view buffer buffer model remove element path if buffer model get size ok true dispose else buffer list set selected index buffer list request focus else if source cancel cancel 
public void value changed  list selection event evt if select all flag return int index buffer list get selected index if index  string path  string buffer model get element at index  buffer buffer j edit get buffer path if buffer null it seems this buffer was already closed  log log  log debug this  buffer path is already closed buffer model remove element at index else view show buffer buffer update buttons 
 constructs a  code writer param cw the class writer in which the method must be added param compute maxs tt true tt if the maximum stack size and number of local variables must be automatically computed protected  code writer final  class writer cw final boolean compute maxs if cw first method null cw first method this cw last method this else cw last method next this cw last method this this cw cw this compute maxs compute maxs if compute maxs pushes the first block onto the stack of blocks to be visited current block new  label current block pushed true block stack current block 
 initializes this  code writer to define the bytecode of the specified method param access the method s access flags see link  constants param name the method s name param desc the method s descriptor see link  type  type param exceptions the internal names of the method s exceptions  may be tt null tt protected void init final int access final  string name final  string desc final  string exceptions this access access this name cw new utf name this desc cw new utf desc if exceptions null exceptions length exception count exceptions length this exceptions new int exception count for int i i exception count i this exceptions i cw new class exceptions i index if compute maxs updates max locals int size get arguments and return sizes desc if access  constants acc static size if size max locals max locals size 
public void visit insn final int opcode if compute maxs updates current and max stack sizes int size stack size size opcode if size max stack size max stack size size stack size size if opcode athrow or x return ends current block no successor if opcode  constants ireturn opcode  constants return opcode  constants athrow if current block null current block max stack size max stack size current block null adds the instruction to the bytecode of the method code put opcode 
public void visit int insn final int opcode final int operand if compute maxs opcode  constants newarray updates current and max stack sizes only if opcode newarray stack size variation for bipush or sipush int size stack size if size max stack size max stack size size stack size size adds the instruction to the bytecode of the method if opcode  constants sipush code put opcode operand else bipush or newarray code put opcode operand 
public void visit var insn final int opcode final int var if compute maxs updates current and max stack sizes if opcode  constants ret no stack change but end of current block no successor if current block null current block max stack size max stack size current block null else x load or x store int size stack size size opcode if size max stack size max stack size size stack size size updates max locals int n if opcode  constants lload opcode  constants dload opcode  constants lstore opcode  constants dstore n var else n var if n max locals max locals n adds the instruction to the bytecode of the method if var opcode  constants ret int opt if opcode  constants istore opt iload  opcode  constants iload var else opt istore  opcode  constants istore var code put opt else if var code put wide put opcode var else code put opcode var 
public void visit type insn final int opcode final  string desc if compute maxs opcode  constants new updates current and max stack sizes only if opcode new stack size variation for anewarray checkcast instanceof int size stack size if size max stack size max stack size size stack size size adds the instruction to the bytecode of the method code put opcode cw new class desc index 
public void visit field insn final int opcode final  string owner final  string name final  string desc if compute maxs int size computes the stack size variation char c desc char at switch opcode case  constants getstatic size stack size c d c j break case  constants putstatic size stack size c d c j break case  constants getfield size stack size c d c j break case  constants putfield default size stack size c d c j break updates current and max stack sizes if size max stack size max stack size size stack size size adds the instruction to the bytecode of the method code put opcode cw new field owner name desc index 
public void visit method insn final int opcode final  string owner final  string name final  string desc  item i if opcode  constants invokeinterface i cw new itf method owner name desc else i cw new method owner name desc int arg size i int val if compute maxs computes the stack size variation  in order not to recompute several times this variation for the same  item we use the int val field of this item to store this variation once it has been computed  more precisely this int val field stores the sizes of the arguments and of the return value corresponding to desc if arg size the above sizes have not been computed yet so we compute them arg size get arguments and return sizes desc and we save them in order not to recompute them in the future i int val arg size int size if opcode  constants invokestatic size stack size arg size arg size x else size stack size arg size arg size x updates current and max stack sizes if size max stack size max stack size size stack size size adds the instruction to the bytecode of the method if opcode  constants invokeinterface if compute maxs if arg size arg size get arguments and return sizes desc i int val arg size code put  constants invokeinterface i index put arg size else code put opcode i index 
public void visit jump insn final int opcode final  label label if check if label owner null label owner this else if label owner this throw new  illegal argument exception if compute maxs if opcode  constants goto no stack change but end of current block with one new successor if current block null current block max stack size max stack size add successor stack size label current block null else if opcode  constants jsr if current block null add successor stack size label else updates current stack size max stack size unchanged because stack size variation always negative in this case stack size size opcode if current block null add successor stack size label adds the instruction to the bytecode of the method if label resolved label position code length  short min value case of a backward jump with an offset  in this case we automatically replace goto with goto w jsr with jsr w and i fxxx l with ifno txxx l goto w l where ifno txxx is the opposite opcode of i fxxx i e ifne for ifeq and where l designates the instruction just after the goto w if opcode  constants goto code put goto w else if opcode  constants jsr code put jsr w else code put opcode opcode opcode code put jump offset code put goto w label put this code code length true else case of a backward jump with an offset or of a forward jump with of course an unknown offset  in these cases we store the offset in bytes which will be increased in resize instructions if needed code put opcode label put this code code length false 
public void visit label final  label label if check if label owner null label owner this else if label owner this throw new  illegal argument exception if compute maxs if current block null ends current block with one new successor current block max stack size max stack size add successor stack size label begins a new current block resets the relative current and max stack sizes current block label stack size max stack size resolves previous forward references to label if any resize label resolve this code length code data 
public void visit ldc insn final  object cst  item i cw new cst cst if compute maxs int size computes the stack size variation if i type  class writer long i type  class writer double size stack size else size stack size updates current and max stack sizes if size max stack size max stack size size stack size size adds the instruction to the bytecode of the method int index i index if i type  class writer long i type  class writer double code put ldc  w index else if index code put ldc w index else code put  constants ldc index 
public void visit iinc insn final int var final int increment if compute maxs updates max locals only no stack change int n var if n max locals max locals n adds the instruction to the bytecode of the method if var increment increment code put wide put  constants iinc var put increment else code put  constants iinc put var increment 
public void visit table switch insn final int min final int max final  label dflt final  label labels if compute maxs updates current stack size max stack size unchanged stack size ends current block with many new successors if current block null current block max stack size max stack size add successor stack size dflt for int i i labels length i add successor stack size labels i current block null adds the instruction to the bytecode of the method int source code length code put  constants tableswitch while code length code put dflt put this code source true code put min put max for int i i labels length i labels i put this code source true 
public void visit lookup switch insn final  label dflt final int keys final  label labels if compute maxs updates current stack size max stack size unchanged stack size ends current block with many new successors if current block null current block max stack size max stack size add successor stack size dflt for int i i labels length i add successor stack size labels i current block null adds the instruction to the bytecode of the method int source code length code put  constants lookupswitch while code length code put dflt put this code source true code put labels length for int i i labels length i code put keys i labels i put this code source true 
public void visit multi a new array insn final  string desc final int dims if compute maxs updates current stack size max stack size unchanged because stack size variation always negative or null stack size dims adds the instruction to the bytecode of the method  item class item cw new class desc code put  constants multianewarray class item index put dims 
public void visit try catch block final  label start final  label end final  label handler final  string type if check if start owner this end owner this handler owner this throw new  illegal argument exception if start resolved end resolved handler resolved throw new  illegal argument exception if compute maxs pushes handler block onto the stack of blocks to be visited if handler pushed handler begin stack size handler pushed true handler next block stack block stack handler catch count if catch table null catch table new  byte vector catch table put start position catch table put end position catch table put handler position catch table put type null cw new class type index 
public void visit maxs final int max stack final int max locals if compute maxs true non relative max stack size int max control flow analysis algorithm while the block stack is not empty pop a block from this stack update the max stack size compute the true non relative begin stack size of the successors of this block and push these successors onto the stack unless they have already been pushed onto the stack  note by hypothesis the link  label begin stack size of the blocks in the block stack are the true non relative beginning stack sizes of these blocks  label stack block stack while stack null pops a block from the stack  label l stack stack stack next computes the true non relative max stack size of this block int start l begin stack size int block max start l max stack size updates the global max stack size if block max max max block max analyses the successors of the block  edge b l successors while b null l b successor if this successor has not already been pushed onto the stack if l pushed computes the true beginning stack size of this successor block l begin stack size start b stack size pushes this successor onto the stack l pushed true l next stack stack l b b next this max stack max releases all the  edge objects used by this  code writer synchronized size appends the head tail list at the beginning of the pool list if tail null tail pool next pool pool head else this max stack max stack this max locals max locals 
public void visit local variable final  string name final  string desc final  label start final  label end final int index if check if start owner this start resolved throw new  illegal argument exception if end owner this end resolved throw new  illegal argument exception if local var null cw new utf  local variable table local var new  byte vector local var count local var put start position local var put end position start position local var put cw new utf name index local var put cw new utf desc index local var put index 
public void visit line number final int line final  label start if check if start owner this start resolved throw new  illegal argument exception if line number null cw new utf  line number table line number new  byte vector line number count line number put start position line number put line 
 computes the size of the arguments and of the return value of a method param desc the descriptor of a method return the size of the arguments of the method plus one for the implicit this argument arg size and the size of its return value ret size packed into a single int i tt arg size ret size tt arg size is therefore equal to tt i tt and ret size to tt i x tt private static int get arguments and return sizes final  string desc int n int c while true char car desc char at c if car car desc char at c return n car v car d car j else if car l while desc char at c n else if car while car desc char at c c if car d car j n else if car d car j n else n 
 adds a successor to the link current block current block block param stack size the current relative stack size in the current block param successor the successor block to be added to the current block private void add successor final int stack size final  label successor  edge b creates a new  edge object or reuses one from the shared pool synchronized size if pool null b new  edge else b pool removes b from the pool pool pool pool next adds the previous  edge to the list of  edges used by this  code writer if tail null tail b b pool next head head b initializes the previous  edge object b stack size stack size b successor successor and adds it to the successor list of the current block block b next current block successors current block successors b 
 returns the size of the bytecode of this method return the size of the bytecode of this method final int get size if resize replaces the temporary jump opcodes introduced by  label resolve resize instructions new int new int int size if code length cw new utf  code size code length catch count if local var null size local var length if line number null size line number length if exception count cw new utf  exceptions size exception count if access  constants acc synthetic cw new utf  synthetic size if access  constants acc deprecated cw new utf  deprecated size return size 
 puts the bytecode of this method in the given byte vector param out the byte vector into which the bytecode of this method must be copied final void put final  byte vector out out put access put name index put desc index int attribute count if code length attribute count if exception count attribute count if access  constants acc synthetic attribute count if access  constants acc deprecated attribute count out put attribute count if code length int size code length catch count if local var null size local var length if line number null size line number length out put cw new utf  code index put size out put max stack put max locals out put code length put byte array code data code length out put catch count if catch count out put byte array catch table data catch table length attribute count if local var null attribute count if line number null attribute count out put attribute count if local var null out put cw new utf  local variable table index out put local var length put local var count out put byte array local var data local var length if line number null out put cw new utf  line number table index out put line number length put line number count out put byte array line number data line number length if exception count out put cw new utf  exceptions index put exception count out put exception count for int i i exception count i out put exceptions i if access  constants acc synthetic out put cw new utf  synthetic index put if access  constants acc deprecated out put cw new utf  deprecated index put 
 resizes the designated instructions while keeping jump offsets and instruction addresses consistent  this may require to resize other existing instructions or even to introduce new instructions for example increasing the size of an instruction by at the middle of a method can increases the offset of an ifeq instruction from to in which case ifeq must be replaced with ifneq goto w  this in turn may require to increase the size of another jump instruction and so on  all these operations are handled automatically by this method p i  this method must be called after all the method that is being built has been visited i  in particular the link  label  label objects used to construct the method are no longer valid after this method has been called param indexes current positions of the instructions to be resized  each instruction must be designated by the index of its i last i byte plus one or in other words by the index of the i first i byte of the i next i instruction param sizes the number of bytes to be i added i to the above instructions  more precisely for each i lt tt len tt tt sizes tt i bytes will be added at the end of the instruction designated by tt indexes tt i or if tt sizes tt i is negative the i last i tt sizes i tt bytes of the instruction will be removed the instruction size i must not i become negative or null  the gaps introduced by this method must be filled in manually in the array returned by the link get code get code method param len the number of instruction to be resized  must be smaller than or equal to tt indexes tt length and tt sizes tt length return the tt indexes tt array which now contains the new positions of the resized instructions designated as above protected int resize instructions final int indexes final int sizes final int len byte b code data bytecode of the method int u v label indexes in b int i j loop indexes st step  as explained above resizing an instruction may require to resize another one which may require to resize yet another one and so on  the first step of the algorithm consists in finding all the instructions that need to be resized without modifying the code  this is done by the following fix point algorithm parse the code to find the jump instructions whose offset will need more than bytes to be stored the future offset is computed from the current offset and from the number of bytes that will be inserted or removed between the source and target instructions  for each such instruction adds an entry in a copy of the indexes and sizes arrays if this has not already been done in a previous iteration if at least one entry has been added during the previous step go back to the beginning otherwise stop  in fact the real algorithm is complicated by the fact that the size of tableswitch and lookupswitch instructions depends on their position in the bytecode because of padding  in order to ensure the convergence of the algorithm the number of bytes to be added or removed from these instructions is over estimated during the previous loop and computed exactly only after the loop is finished this requires another pass to parse the bytecode of the method int all indexes new int len copy of indexes int all sizes new int len copy of sizes boolean resize instructions to be resized int new offset future offset of a jump instruction  system arraycopy indexes all indexes len  system arraycopy sizes all sizes len resize new boolean code length int state loop again loop ended last pass done do if state state u while u b length int opcode b u x ff opcode of current instruction int insert bytes to be added after this instruction switch  class writer type opcode case  class writer noarg insn case  class writer implvar insn u break case  class writer label insn if opcode converts temporary opcodes to inclusive and to ifeq jsr inclusive ifnull and ifnonnull opcode opcode opcode opcode label u read unsigned short b u else label u read short b u new offset get new offset all indexes all sizes u label if new offset  short min value new offset  short max value if resize u if opcode  constants goto opcode  constants jsr two additional bytes will be required to replace this goto or jsr instruction with a goto w or a jsr w insert else five additional bytes will be required to replace this i fxxx l instruction with ifno txxx l goto w l where ifno txxx is the opposite opcode of i fxxx i e ifne for ifeq and where l designates the instruction just after the goto w insert resize u true u break case  class writer labelw insn u break case  class writer tabl insn if state true number of bytes to be added or removed from this instruction future number of padding bytes current number of padding byte previously over estimated variation new offset u u new offset u u new offset new offset get new offset all indexes all sizes u insert new offset else if resize u over estimation of the number of bytes to be added to this instruction current number of padding bytes u u u insert u resize u true skips instruction u u u u read int b u read int b u break case  class writer look insn if state like tabl insn new offset get new offset all indexes all sizes u insert new offset else if resize u like tabl insn insert u resize u true skips instruction u u u u read int b u break case  class writer wide insn opcode b u x ff if opcode  constants iinc u else u break case  class writer var insn case  class writer sbyte insn case  class writer ldc insn u break case  class writer short insn case  class writer ldcw insn case  class writer fieldormeth insn case  class writer type insn case  class writer iinc insn u break case  class writer itfmeth insn u break case  class writer mana insn default u break if insert adds a new u insert entry in the all indexes and all sizes arrays int new indexes new int all indexes length int new sizes new int all sizes length  system arraycopy all indexes new indexes all indexes length  system arraycopy all sizes new sizes all sizes length new indexes all indexes length u new sizes all sizes length insert all indexes new indexes all sizes new sizes if insert state if state state while state nd step copies the bytecode of the method into a new bytevector updates the offsets and inserts or removes bytes as requested  byte vector new code new  byte vector code length u while u code length for i all indexes length i i if all indexes i u if i len if sizes i new code put byte array null sizes i else new code length sizes i indexes i new code length int opcode b u x ff switch  class writer type opcode case  class writer noarg insn case  class writer implvar insn new code put opcode u break case  class writer label insn if opcode changes temporary opcodes to inclusive and to ifeq jsr inclusive ifnull and ifnonnull opcode opcode opcode opcode label u read unsigned short b u else label u read short b u new offset get new offset all indexes all sizes u label if new offset  short min value new offset  short max value replaces goto with goto w jsr with jsr w and i fxxx l with ifno txxx l goto w l where ifno txxx is the opposite opcode of i fxxx i e ifne for ifeq and where l designates the instruction just after the goto w if opcode  constants goto new code put goto w else if opcode  constants jsr new code put jsr w else new code put opcode opcode opcode new code put jump offset new code put goto w new offset new offset now computed from start of goto w new code put new offset else new code put opcode new code put new offset u break case  class writer labelw insn label u read int b u new offset get new offset all indexes all sizes u label new code put opcode new code put new offset u break case  class writer tabl insn skips to padding bytes v u u u v reads and copies instruction int source new code length new code put  constants tableswitch while new code length new code put label v read int b u u new offset get new offset all indexes all sizes v label new code put new offset j read int b u u new code put j j read int b u j u new code put read int b u for j j label v read int b u u new offset get new offset all indexes all sizes v label new code put new offset break case  class writer look insn skips to padding bytes v u u u v reads and copies instruction source new code length new code put  constants lookupswitch while new code length new code put label v read int b u u new offset get new offset all indexes all sizes v label new code put new offset j read int b u u new code put j for j j new code put read int b u u label v read int b u u new offset get new offset all indexes all sizes v label new code put new offset break case  class writer wide insn opcode b u x ff if opcode  constants iinc new code put byte array b u u else new code put byte array b u u break case  class writer var insn case  class writer sbyte insn case  class writer ldc insn new code put byte array b u u break case  class writer short insn case  class writer ldcw insn case  class writer fieldormeth insn case  class writer type insn case  class writer iinc insn new code put byte array b u u break case  class writer itfmeth insn new code put byte array b u u break case mana insn default new code put byte array b u u break updates the instructions addresses in the catch local var and line number tables if catch table null b catch table data u while u catch table length write short b u get new offset all indexes all sizes read unsigned short b u write short b u get new offset all indexes all sizes read unsigned short b u write short b u get new offset all indexes all sizes read unsigned short b u u if local var null b local var data u while u local var length label read unsigned short b u new offset get new offset all indexes all sizes label write short b u new offset label read unsigned short b u new offset get new offset all indexes all sizes label new offset write short b u new offset u if line number null b line number data u while u line number length write short b u get new offset all indexes all sizes read unsigned short b u u replaces old bytecodes with new ones code new code returns the positions of the resized instructions return indexes 
 reads an unsigned short value in the given byte array param b a byte array param index the start index of the value to be read return the read value static int read unsigned short final byte b final int index return b index x ff b index x ff 
 reads a signed short value in the given byte array param b a byte array param index the start index of the value to be read return the read value static short read short final byte b final int index return short b index x ff b index x ff 
 reads a signed int value in the given byte array param b a byte array param index the start index of the value to be read return the read value static int read int final byte b final int index return b index x ff b index x ff b index x ff b index x ff 
 writes a short value in the given byte array param b a byte array param index where the first byte of the short value must be written param s the value to be written in the given byte array static void write short final byte b final int index final int s b index byte s b index byte s 
 computes the future value of a bytecode offset p  note it is possible to have several entries for the same instruction in the tt indexes tt and tt sizes tt two entries index a size b and index a size b are equivalent to a single entry index a size b b param indexes current positions of the instructions to be resized  each instruction must be designated by the index of its i last i byte plus one or in other words by the index of the i first i byte of the i next i instruction param sizes the number of bytes to be i added i to the above instructions  more precisely for each i tt len tt tt sizes tt i bytes will be added at the end of the instruction designated by tt indexes tt i or if tt sizes tt i is negative the i last i tt sizes i tt bytes of the instruction will be removed the instruction size i must not i become negative or null param begin index of the first byte of the source instruction param end index of the first byte of the target instruction return the future value of the given bytecode offset static int get new offset final int indexes final int sizes final int begin final int end int offset end begin for int i i indexes length i if begin indexes i indexes i end forward jump offset sizes i else if end indexes i indexes i begin backward jump offset sizes i return offset 
 returns the current size of the bytecode of this method  this size just includes the size of the bytecode instructions it does not include the size of the  exceptions  local variable table  line number table  synthetic and  deprecated attributes if present return the current size of the bytecode of this method protected int get code size return code length 
 returns the current bytecode of this method  this bytecode only contains the instructions it does not include the  exceptions  local variable table  line number table  synthetic and  deprecated attributes if present return the current bytecode of this method  the bytecode is contained between the index inclusive and the index link get code size get code size exclusive protected byte get code return code data 
 construct a basic  collection iterator param iterate over me  the object over which we are iterating throws java lang  illegal argument exception  if the argument is not a supported i e iterable type throws java lang  null pointer exception  if the argument is null public  collection iterator  object iterate over me iterator create iterator iterate over me 
 create an iterator over the given object param iterate over me  object of type  iterator  collection or types supported by  collection manager  basic bsh iterator return an  iterator throws java lang  illegal argument exception  if the argument is not a supported i e iterable type throws java lang  null pointer exception  if the argument is null protected  iterator create iterator  object iterate over me if iterate over me null throw new  null pointer exception  object arguments passed to the  collection iterator constructor cannot be null if iterate over me instanceof  iterator return  iterator iterate over me if iterate over me instanceof  collection return  collection iterate over me iterator  should we be able to iterate over maps if iterate over me instanceof  map return  map iterate over me entry set iterator throw new  illegal argument exception  cannot enumerate object of type iterate over me get class 
 fetch the next object in the iteration return  the next object public  object next return iterator next 
 returns true if and only if there are more objects available via the code next code method return  the next object public boolean has next return iterator has next 
public synchronized static  collection manager get collection manager if manager null  capabilities class exists java util  collection  class clas try clas  class for name org gjt sp jedit bsh collection  collection manager impl manager  collection manager clas new instance catch  exception e  interpreter debug unable to load  collection manager impl e if manager null manager new  collection manager default impl return manager 
public boolean is bsh iterable  object obj  this could be smarter try get bsh iterator obj return true catch  illegal argument exception e return false 
public  bsh iterator get bsh iterator  object obj throws  illegal argument exception return new  basic bsh iterator obj 
public boolean is map  object obj return obj instanceof  hashtable 
public  object get from map  object map  object key return  hashtable map get key 
public  object put in map  object map  object key  object value return  hashtable map put key value 
 construct a basic  basic bsh iterator param iterate over me  the object over which we are iterating throws java lang  illegal argument exception  if the argument is not a supported i e iterable type throws java lang  null pointer exception  if the argument is null public  basic bsh iterator  object iterate over me enumeration create enumeration iterate over me 
 create an enumeration over the given object param iterate over me  object of type  enumeration  vector  string  string buffer or an array return an enumeration throws java lang  illegal argument exception  if the argument is not a supported i e iterable type throws java lang  null pointer exception  if the argument is null protected  enumeration create enumeration  object iterate over me if iterate over me null throw new  null pointer exception  object arguments passed to the  basic bsh iterator constructor cannot be null if iterate over me instanceof  enumeration return  enumeration iterate over me if iterate over me instanceof  vector return  vector iterate over me elements if iterate over me get class is array final  object array iterate over me return new  enumeration int index length  array get length array public  object next element return  array get array index public boolean has more elements return index length if iterate over me instanceof  string return create enumeration  string iterate over me to char array if iterate over me instanceof  string buffer return create enumeration iterate over me to string to char array if iterate over me instanceof  string builder return create enumeration iterate over me to string to char array throw new  illegal argument exception  cannot enumerate object of type iterate over me get class 
 fetch the next object in the iteration return  the next object public  object next return enumeration next element 
 returns true if and only if there are more objects available via the code next code method return  the next object public boolean has next return enumeration has more elements 
public  bsh iterator get bsh iterator  object obj throws  illegal argument exception if obj instanceof  collection obj instanceof  iterator return new  collection iterator obj else return new org gjt sp jedit bsh  collection manager  basic bsh iterator obj 
public boolean is map  object obj if obj instanceof  map return true else return super is map obj 
public  object get from map  object map  object key  hashtable implements  map return  map map get key 
public  object put in map  object map  object key  object value  hashtable implements  map return  map map put key value 
public  color well button  color color set icon new  color well color set margin new  insets add action listener new  action handler according to krisk this looks better on os x if  operating system is mac oslf put client property j button button type toolbar 
public  color get selected color return  color well get icon color 
public void set selected color  color color  color well get icon color color repaint 
 color well  color color this color color 
public int get icon width return 
public int get icon height return 
public void paint icon  component c  graphics g int x int y if color null return g set color color g fill rect x y get icon width get icon height g set color color darker g draw rect x y get icon width get icon height 
public void action performed  action event evt j dialog parent gui utilities get parent dialog  color well button this j dialog dialog if parent null dialog new  color picker dialog parent j edit get property color chooser title true else dialog new  color picker dialog j option pane get frame for component  color well button this j edit get property color chooser title true dialog pack dialog set visible true 
public  color picker dialog  frame parent  string title boolean modal super parent title modal init 
public  color picker dialog  dialog parent  string title boolean modal super parent title modal get content pane set layout new  border layout init 
public void ok  color c chooser get color if c null set selected color c set visible false 
public void cancel set visible false 
public void action performed  action event evt if evt get source ok ok else cancel 
private void init  color c get selected color if c null chooser new j color chooser else chooser new j color chooser c get content pane add  border layout center chooser  box buttons new  box  box layout x axis buttons add  box create glue ok new j button j edit get property common ok ok add action listener this buttons add ok buttons add  box create horizontal strut get root pane set default button ok cancel new j button j edit get property common cancel cancel add action listener this buttons add cancel buttons add  box create glue get content pane add  border layout south buttons pack set location relative to get parent 
public  command line reader  reader in super in 
public int read throws io exception int b if state sent semi state last char nl return n skip cr while b in read r if b n if state last char nl b state sent semi else state last char nl else state normal return b 
 this is a degenerate implementation i don t know how to keep this from blocking if we try to read more than one char  there is no available for  readers public int read char buff int off int len throws io exception int b read if b return eof not zero read apparently else buff off char b return 
public static void main  string args throws  exception  reader in new  command line reader new  input stream reader  system in while true  system out println in read 
public static void complete word  view view j edit text area text area view get text area  buffer buffer view get buffer int caret line text area get caret line int caret text area get caret position if buffer is editable text area get toolkit beep return  keyword map keyword map buffer get keyword map at offset caret  string no word sep get non alpha numeric word chars buffer keyword map  string word get word to complete buffer caret line caret no word sep if word null text area get toolkit beep return  completion completions get completions buffer word caret if completions length text area get toolkit beep if there is only one competion insert in buffer else if completions length  completion c completions if c text equals word text area get toolkit beep else text area replace selection c text substring word length show popup if else  string longest prefix  misc utilities get longest prefix completions keyword map null keyword map get ignore case false if word length longest prefix length buffer insert caret longest prefix substring word length text area scroll to caret false  point location text area offset to xy caret word length location y text area get painter get font metrics get height  swing utilities convert point to screen location text area get painter new  complete word view longest prefix completions location no word sep 
public  complete word  view view  string word  completion completions  point location  string no word sep super view location this no word sep no word sep this view view this text area view get text area this buffer view get buffer this word word reset new  words completions true 
private static  string get non alpha numeric word chars  buffer buffer  keyword map keyword map figure out what constitutes a word character and what doesn t  string no word sep buffer get string property no word sep if no word sep null no word sep if keyword map null  string keyword no word sep keyword map get non alpha numeric chars if keyword no word sep null no word sep keyword no word sep return no word sep 
private static  string get word to complete  buffer buffer int caret line int caret  string no word sep  char sequence line buffer get line segment caret line int dot caret buffer get line start offset caret line if dot return null char ch line char at dot if  character is letter or digit ch no word sep index of ch attempting to expand non word char return null int word start  text utilities find word start line dot no word sep  char sequence word line sub sequence word start dot if word length return null return word to string 
private static  collection  buffer get visible buffers final  set  buffer buffers new  hash set  buffer j edit visit new j edit visitor adapter  override public void visit  edit pane edit pane buffers add edit pane get buffer return buffers 
private static  completion get completions final  buffer buffer final  string word final int caret build a list of unique words in all buffers or visible buffers depending on complete from all buffers final  set  completion completions new  tree set  completion new  standard utilities  string compare  completion only complete current buffer s keyword map final  keyword map keyword map buffer get keyword map at offset caret final  string no word sep get non alpha numeric word chars buffer keyword map final  collection  buffer source buffers j edit get boolean property complete from all buffers  arrays as list j edit get buffers get visible buffers for  buffer b source buffers only complete current buffer s keyword map  keyword map  keyword map if b buffer  keyword map keyword map else  keyword map null int offset b buffer caret get completions b word keyword map no word sep offset completions  completion completion array completions to array new  completion completions size return completion array 
private static void get completions  buffer buffer  string word  keyword map keyword map  string no word sep int caret  set  completion completions int word len word length try to find matching keywords if keyword map null  string keywords keyword map get keywords for int i i keywords length i  string  keyword keywords i if  keyword region matches keyword map get ignore case word word len  completion keyword new  completion  keyword true if completions contains keyword completions add keyword loop through all lines of current buffer for int i i buffer get line count i  char sequence line buffer get line segment i int start buffer get line start offset i check for match at start of line if  standard utilities starts with line word caret start word length  string  word complete word line no word sep  completion comp new  completion  word false remove duplicates if completions contains comp completions add comp check for match inside line int len line length word length for int j j len j char c line char at j if  character is letter or digit c no word sep index of c if  standard utilities region matches line j word word len caret start j word length  string  word complete word line j no word sep  completion comp new  completion  word false remove duplicates if completions contains comp completions add comp 
private static  string complete word  char sequence line int offset  string no word sep so that find word end doesn t pick up the space at the start int word end  text utilities find word end line offset no word sep return line sub sequence offset word end to string 
 completion  string text boolean keyword this text text this keyword keyword 
public  string to string return text 
public int hash code return text hash code 
public boolean equals  object obj if obj instanceof  completion return  completion obj text equals text else return false 
public  words  completion completions this renderer new  default list cell renderer this completions completions 
public int get size return completions length 
public boolean is valid return true 
public void complete int index  string insertion completions index to string substring word length text area replace selection insertion 
public  component get cell renderer j list list int index boolean is selected boolean cell has focus renderer get list cell renderer component list null index is selected cell has focus  completion comp completions index  string text comp text  font font list get font if index text index text else if index text text if comp keyword font font derive font  font bold renderer set text text renderer set font font return renderer 
public  string get description int index return null 
private void reset words  string new word int caret text area get caret position  completion completions get completions buffer new word caret if completions length word new word reset new  words completions true else dispose 
protected void key pressed  key event e if e get key code  key event vk back space text area backspace e consume if word length dispose else reset words word substring word length 
protected void key typed  key event e char ch e get key char if  character is digit ch int index ch if index index else index if index get candidates get size set selected index index if do selected completion e consume dispose return else fall through t handled above if ch b ch t eg foo c b will insert foobar if  character is letter or digit ch no word sep index of ch do selected completion text area user input ch e consume dispose return text area user input ch e consume reset words word ch 
 create a completion popup  it is not shown until reset method is called with valid candidates  all key events for the view are intercepted by this popup untill end of completion since j edit pre public  completion popup  view view super view this view view this key handler new  key handler this candidates null this list new j list list set selection mode  list selection model single selection list set cell renderer new  cell renderer list add key listener key handler list add mouse listener new  mouse handler j panel content new j panel new  border layout content set focus traversal keys enabled false stupid scrollbar policy is an attempt to work around bugs people have been seeing with ibm s jdk  sep j scroll pane scroller new j scroll pane list  scroll pane constants vertical scrollbar always  scroll pane constants horizontal scrollbar never content add scroller  border layout center set content pane content add window focus listener new  window focus handler 
public  completion popup  view view  point location this view if location null set location location 
 quit completion public void dispose if is displayable if view get key event interceptor key handler view set key event interceptor null super dispose  this is a workaround to ensure setting the focus back to the text area  without this the focus gets lost after closing the popup in some environments  it seems to be a bug in j se or  probably it relates to the following one  frame does not receives focus after closing of the owned window http bugs sun com bugdatabase view bug do bug id  swing utilities invoke later new  runnable public void run view get text area request focus 
 start completion param candidates  the candidates of this completion param active  set focus to the popup public void reset  candidates candidates boolean active if candidates null candidates is valid candidates get size dispose return this candidates candidates list set model new  candidate list model list set visible row count  math min candidates get size pack set location fit in screen get location null this view get text area get painter get font metrics get height if active set selected index gui utilities request focus this list set visible true view set key event interceptor key handler 
 current candidates of completion public  candidates get candidates return candidates 
 returns index of current selection  returns if nothing is selected public int get selected index return list get selected index 
 set selection public void set selected index int index if candidates null index index candidates get size list set selected index index list ensure index is visible index  string description candidates get description index if description null view get status set message and clear description 
 do completion with current selection and quit public boolean do selected completion int selected list get selected index if candidates null selected selected candidates get size candidates complete selected dispose return true return false 
 handle key pressed events  override this method to make additional key handing protected void key pressed  key event e 
 handle key typed events  override this method to make additional key handing protected void key typed  key event e 
private static  point fit in screen  point p  window w int line height  rectangle screen size w get graphics configuration get bounds if p y w get height screen size height p y p y w get height line height return p 
private void move relative int n int selected list get selected index int new select selected n if new select new select else int num items list get model get size if num items return if new select num items new select num items if new select selected set selected index new select 
private void move relative pages int n int page size list get visible row count move relative page size n 
private void pass key event to view  key event e  remove intercepter to avoid infinite recursion assert view get key event interceptor key handler view set key event interceptor null  here depends on an implementation detail  use action bar to force processing key typed event in the implementation of gui  input handler process key event view get input handler process key event e  view action bar false  restore key handler only if this popup is still alive  the key event might trigger dispose of this popup if this is displayable view set key event interceptor key handler 
public int get size return candidates get size 
public  object get element at int index  this value is not used  the list is only rendered by components returned by get cell renderer return candidates 
public  component get list cell renderer component j list list  object value int index boolean is selected boolean cell has focus return candidates get cell renderer list index is selected cell has focus 
public void key pressed  key event e  completion popup this key pressed e if candidates null candidates is valid dispose else if e is consumed switch e get key code case  key event vk tab case  key event vk enter if do selected completion e consume else dispose break case  key event vk escape dispose e consume break case  key event vk up move relative e consume break case  key event vk down move relative e consume break case  key event vk page up move relative pages e consume break case  key event vk page down move relative pages e consume break default if e is action key e is control down e is alt down e is meta down dispose break if e is consumed pass key event to view e 
public void key typed  key event e  completion popup this key typed e if candidates null candidates is valid dispose if e is consumed pass key event to view e 
public void mouse clicked  mouse event e if do selected completion e consume else dispose 
public void window gained focus  window event e 
public void window lost focus  window event e dispose 
public final int get length return length 
public  string get text int start int len if start gap start return new  string text start gap end gap start len else if start len gap start return new  string text start len else return new  string text start gap start start concat new  string text gap end start len gap start 
 returns the specified text range in a code  segment code p  using a classname  segment classname is generally more efficient than using a classname  string classname because it results in less memory allocation and array copying p param start  the start offset param len  the number of characters to get param seg  the segment to copy the text to see j edit buffer get text int int  segment public void get text int start int len  segment seg if start gap start seg array text seg offset start gap end gap start seg count len else if start len gap start seg array text seg offset start seg count len else seg array new char len copy text before gap  system arraycopy text start seg array gap start start copy text after gap  system arraycopy text gap end seg array gap start start len start gap start seg offset seg count len 
 returns a read only segment of the buffer since j edit pre public  char sequence get segment int start int len if start gap start return new  buffer segment text start gap end gap start len else if start len gap start return new  buffer segment text start len else return new  buffer segment text start gap start start new  buffer segment text gap end start len gap start 
public void insert int start  string str int len str length move gap start start if gap end gap start len ensure capacity length len move gap end start len str get chars len text start gap start len length len 
 inserts the given data into the buffer since j edit pre public void insert int start  char sequence str int len str length move gap start start if gap end gap start len ensure capacity length len move gap end start len for int i i len i text start i str char at i gap start len length len 
public void insert int start  segment seg move gap start start if gap end gap start seg count ensure capacity length seg count move gap end start seg count  system arraycopy seg array seg offset text start seg count gap start seg count length seg count 
public void  set content char text int length this text text this gap start this gap end this length length 
public void remove int start int len move gap start start gap end len length len 
private void move gap start int new start int new end gap end new start gap start if new start gap start nothing to do else if new start gap start  system arraycopy text gap end text gap start new start gap start else if new start gap start  system arraycopy text new start text new end gap start new start gap start new start gap end new end 
private void move gap end int new end  system arraycopy text gap end text new end length gap start gap end new end 
private void ensure capacity int capacity if capacity text length char text n new char capacity  system arraycopy text text n length gap end gap start text text n 
public  context add dialog  component comp super gui utilities get parent dialog comp j edit get property options context add title true j panel content new j panel new  border layout content set border new  empty border set content pane content  action handler action handler new  action handler  button group grp new  button group j panel type panel new j panel new  grid layout type panel set border new  empty border type panel add new j label j edit get property options context add caption separator new j radio button j edit get property options context add separator separator add action listener action handler grp add separator type panel add separator action new j radio button j edit get property options context add action action add action listener action handler grp add action action set selected true type panel add action content add  border layout north type panel j panel action panel new j panel new  border layout  action set actions list j edit get action sets  tree set  action set action sets new  tree set  action set for int i i actions list length i  action set action set actions list i if action set get action count action sets add action set combo new j combo box action sets to array combo set selected index j edit get integer property context add dialog last selection combo add action listener action handler action panel add  border layout north combo list new j list list set visible row count list set selection mode  list selection model single selection action panel add  border layout center new j scroll pane list content add  border layout center action panel j panel south panel new j panel south panel set layout new  box layout south panel  box layout x axis south panel set border new  empty border south panel add  box create glue ok new j button j edit get property common ok ok add action listener action handler get root pane set default button ok south panel add ok south panel add  box create horizontal strut cancel new j button j edit get property common cancel cancel add action listener action handler south panel add cancel south panel add  box create glue content add  border layout south south panel update list pack set location relative to gui utilities get parent dialog comp set visible true 
public void ok is ok true dispose 
public void cancel dispose 
public  string get selection if is ok return null if separator is selected return else if action is selected return  abstract context option pane  menu item list get selected value action name else throw new  internal error 
private void update list  action set action set  action set combo get selected item j edit set integer property context add dialog last selection combo get selected index  edit action actions action set get actions  vector list model new  vector actions length for int i i actions length i  edit action action actions i  string label action get label if label null continue list model add element new  abstract context option pane  menu item action get name label  collections sort list model new  abstract context option pane  menu item compare list set list data list model 
public void action performed  action event evt  object source evt get source if source instanceof j radio button combo set enabled action is selected list set enabled action is selected if source ok ok else if source cancel cancel else if source combo update list 
public  context option pane super context j edit get property options context caption 
 returns j edit s context menu configuration since j edit pre protected  string get context menu return j edit get property view context 
 saves j edit s context menu configuration since j edit pre protected void save context menu  string menu j edit set property view context menu 
param comp the component that will be used as parent in case of error param source the source vfs param target the target vfs public  copy file worker  component comp  string source  string target if source null target null throw new  null pointer exception  the source and target cannot be null this comp comp this source source this target target 
public void run try vfs copy this source target comp false catch io exception e  log log  log error this e e 
public  string get first file  view view return view get buffer get path 
public  string get next file  view view  string file if file null return view get buffer get path else return null 
public  string get files  view view return new  string view get buffer get path 
public int get file count  view view return 
public  string get code return new  current buffer set 
public  deep indent rule char open char char close char this open char open char this close char close char 
public void apply j edit buffer buffer int this line index int prev line index int prev prev line index  list  indent action indent actions if prev line index return int line index prev line index int old line index line index  char sequence line text buffer get line segment line index int search pos while true if line index old line index line text buffer get line segment line index old line index line index  parens parens new  parens buffer line index search pos  no unmatched parens on prev line if parens open offset parens close offset  try prev prev line if present if prev prev line index search pos line index prev prev line index prev prev line index continue return  there s an unmatched open parenthesis we want to align according to its position if parens close offset recalculate column when using tabs instead of spaces int indent parens open offset get indent line text buffer get tab size line text length indent actions clear indent actions add new  indent action  align parameter indent return  there s an unmatched closed parenthesis find the matching parenthesis and start looking from there again int open paren offset  text utilities find matching bracket buffer line index parens close offset if open paren offset  avoid falling back to the prev prev line in this case prev prev line index line index buffer get line of offset open paren offset search pos open paren offset buffer get line start offset line index if search pos break else break 
 returns the length of the string as if it were indented with spaces instead of tabs private int get indent  char sequence line int tab size int cnt for int i i line length i if line char at i t cnt tab size else if  character is whitespace line char at i cnt line length i break cnt return cnt 
 parens j edit buffer b int line int pos this search pos pos this open new  stack  integer this close new  stack  integer b mark tokens line this open offset open is empty open pop close offset close is empty close pop 
public void handle token  segment seg byte id int offset int length  token marker  line context context if length search pos search pos offset return if search pos offset length search pos length search pos offset switch id case  token comment case  token comment case  token comment case  token comment case  token literal case  token literal case  token literal case  token literal  ignore comments and literals break default for int i offset i offset length i if seg array seg offset i open char if open is empty close is empty close pop else open push i else if seg array seg offset i close char if close is empty open is empty open pop else close push i break 
public void set line context  token marker  line context line context  do nothing 
 override public  string to string return  parens open offset close offset 
 returns the fold handler with the specified name or null if there is no registered handler with that name param name  the name of the desired fold handler return the  fold handler or null if it doesn t exist since j edit pre public  fold handler get fold handler  string name return folds get name 
 returns an array containing the names of all registered fold handlers since j edit pre public  string get fold modes return folds key set to array new  string folds size 
 add a new  fold hander param fold handler the new fold handler since j edit pre public void add fold handler  fold handler fold handler folds put fold handler get name fold handler 
 creates a new input handler with no key bindings defined param view  the view param bindings  an explicitly specified set of key bindings must not be null since j edit pre public  default input handler  view view  hashtable bindings super view if bindings null throw new  null pointer exception this bindings this current bindings bindings 
 creates a new input handler with no key bindings defined param view  the view public  default input handler  view view this view new  hashtable 
 creates a new input handler with the same set of key bindings as the one specified  note that both input handlers share a pointer to exactly the same key binding table so adding a key binding in one will also add it to the other param copy  the input handler to copy key bindings from param view  the view public  default input handler  view view  default input handler copy this view copy bindings 
 returns if a prefix key has been pressed  override public boolean is prefix active return bindings current bindings super is prefix active 
 override public void set current bindings  hashtable bindings view get status set message  string bindings get prefix str current bindings bindings 
 handles the given keystroke param key stroke  the key stroke param dry run only calculate the return value do not have any other effect since j edit pre public boolean handle key  key event translator  key key stroke boolean dry run char input if key stroke modifiers null key stroke modifiers equals s switch key stroke key case n case t input char key stroke key break default input key stroke input break if read next char null if input if dry run set current bindings bindings invoke read next char input repeat count return true else if dry run read next char null view get status set message null  object o current bindings get key stroke if o null if dry run  don t beep if the user presses some key we don t know about unless a prefix is active  otherwise it will beep when caps lock is pressed etc if current bindings bindings  toolkit get default toolkit beep f should be passed on but c e f shouldn t repeat count set current bindings bindings else if input if key stroke is from global context let user input be only local user input input else this is retarded excuse me while i drool and make stupid noises if  key event workaround is numeric keypad key stroke key  key event workaround numeric keypad key send shortcut prefix off else if o instanceof  hashtable if dry run set current bindings  hashtable o  shortcut prefix active event fire prefix state change current bindings true shortcut on true return true else if o instanceof  string if dry run set current bindings bindings send shortcut prefix off invoke action  string o return true else if o instanceof  edit action if dry run set current bindings bindings send shortcut prefix off invoke action  edit action o return true if dry run send shortcut prefix off return false 
 returns a the symbolic modifier name for the specified  java modifier flag param mod a modifier constant from code  input event code since j edit pre public static char get symbolic modifier name int mod return  key event translator get symbolic modifier name mod 
 returns a string containing symbolic modifier names set in the specified event param evt  the event since j edit pre public static  string get modifier string  input event evt return  key event translator get modifier string evt 
public  default input handler provider  abstract input handler input handler this input handler input handler 
public  abstract input handler get input handler return input handler 
 clears the list of tokens public void init last token first token null 
 returns the first syntax token since j edit pre public  token get tokens return first token 
 called by the token marker when a syntax token has been parsed param seg  the segment containing the text param id  the token type one of the constants in the link  token class param offset  the start offset of the token param length  the number of characters in the token param context  the line context since j edit pre public void handle token  segment seg byte id int offset int length  token marker  line context context  token token create token id offset length context if token null add token token context 
 the token handler can compare this object with the object previously given for this line to see if the token type at the end of the line has changed meaning subsequent lines might need to be retokenized since j edit pre public  token marker  line context get line context return line context 
 the token handler can compare this object with the object previously given for this line to see if the token type at the end of the line has changed meaning subsequent lines might need to be retokenized since j edit pre public void set line context  token marker  line context line context this line context line context 
protected  parser rule set get parser rule set  token marker  line context context while context null if context rules is built in return context rules context context parent return null 
protected  token create token byte id int offset int length  token marker  line context context return new  token id offset length get parser rule set context 
protected void add token  token token  token marker  line context context if first token null first token last token token else last token next token last token last token next 
 this constructor is used in class generation  it supplies  string type descriptors for return and parameter class types and allows delay of the evaluation of those types until they are requested  it does this by holding bsh type nodes as well as an evaluation callstack and interpreter which are called when the class types are requested  note technically i think we could get by passing in only the current namespace or perhaps  bsh class manager here instead of  call stack and  interpreter  however let s just play it safe in case of future changes anywhere you eval a node you need these  delayed eval bsh method  string name  string return type descriptor bsh return type return type node  string param names  string param type descriptors bsh formal parameters param types node bsh block method body  name space declaring name space  modifiers modifiers  call stack callstack  interpreter interpreter super name null return type param names null param types method body declaring name space modifiers this return type descriptor return type descriptor this return type node return type node this param type descriptors param type descriptors this param types node param types node this callstack callstack this interpreter interpreter 
public  string get return type descriptor return return type descriptor 
public  class get return type if return type node null return null bsh type will cache the type for us try return return type node eval return type callstack interpreter catch  eval error e throw new  interpreter error can t eval return type e 
public  string get param type descriptors return param type descriptors 
public  class get parameter types bsh formal parameters will cache the type for us try return  class param types node eval callstack interpreter catch  eval error e throw new  interpreter error can t eval param types e 
public static  string usage return usage dir  string dir n dir 
 implement dir command public static void invoke  interpreter env  call stack callstack  string dir invoke env callstack dir 
 implement dir  string directory command public static void invoke  interpreter env  call stack callstack  string dir  file file try file env path to file dir catch io exception e env println error reading path e return if file exists file can read env println  can t read file return if file is directory env println dir is not a directory  string files file list files  string util bubble sort files for int i i files length i  file f new  file dir  file separator files i  string builder sb new  string builder sb append f can read r sb append f can write w sb append   sb append  date d new  date f last modified  gregorian calendar c new  gregorian calendar c set time d int day c get  calendar day of month sb append months c get  calendar month day if day sb append sb append hack to get fixed length length field int fieldlen  string builder len new  string builder for int j j fieldlen j len append len insert f length len set length fieldlen hack to move the spaces to the front int si len to string index of if si  string pad len to string substring si len set length si len insert pad sb append len to string sb append f get name if f is directory sb append env println sb to string 
public  directory list set  string directory  string glob boolean recurse this directory directory this glob glob this recurse recurse this skip binary j edit get boolean property search skip binary toggle this skip hidden j edit get boolean property search skip hidden toggle 
public  string get directory return directory 
since j edit pre public void set directory  string directory this directory directory invalidate cached list 
public  string get file filter return glob 
since j edit pre public void set file filter  string glob this glob glob invalidate cached list 
public boolean is recursive return recurse 
since j edit pre public void set recursive boolean recurse this recurse recurse invalidate cached list 
 override public  string get code return new  directory list set  standard utilities chars to escapes directory  standard utilities chars to escapes glob recurse 
 override protected  string  get files final  component comp skip binary j edit get boolean property search skip binary toggle skip hidden j edit get boolean property search skip hidden toggle final vfs vfs vfs manager get vfs for path directory  object session if  swing utilities is event dispatch thread session vfs create vfs session directory comp else final  object return value new  object try  swing utilities invoke and wait new  runnable public void run return value vfs create vfs session directory comp catch  exception e  log log  log error this e session return value if session null return null try try return vfs  list directory session directory glob recurse comp skip binary skip hidden finally vfs  end vfs session session comp catch io exception io vfs manager error comp directory ioerror new  string io to string return null 
public  directory provider  string dir this dir dir 
public boolean update every time return true 
public void update j menu menu final  view view gui utilities get view menu  string path if dir null path view get buffer get directory else path dir j menu item mi new j menu item path mi set action command path mi set icon  file cell renderer open dir icon  action listeners  action listener file listener new  action listener public void action performed  action event evt j edit open file view evt get action command  action listener dir listener new  action listener public void action performed  action event evt vfs browser browse directory view evt get action command mi add action listener dir listener menu add mi menu add separator if dir null view get buffer get vfs instanceof  file vfs mi new j menu item j edit get property directory not local mi set enabled false menu add mi return  file directory new  file path j menu current menu for filtering out backups  string backup prefix j edit get property backup prefix  string backup suffix j edit get property backup suffix  file list directory list files if list null list length mi new j menu item j edit get property directory no files mi set enabled false menu add mi else int max items j edit get integer property menu spillover  arrays sort list new  standard utilities  string compare  file true for int i i list length i  file file list i  string name file get name skip marker files if name ends with marks continue skip autosave files if name starts with name ends with continue skip backup files if backup prefix length name starts with backup prefix backup suffix length name ends with backup suffix continue skip directories if file is directory continue mi new j menu item name mi set action command file get path mi add action listener file is directory dir listener file listener mi set icon file is directory  file cell renderer dir icon  file cell renderer file icon if current get item count max items i list length current add separator j menu new current new j menu j edit get property common more current add new current current new current current add mi 
public void put  string name  class source source super put name source 
public  class source get  string name return  class source super get name 
public  discrete files class loader  bsh class manager class manager  class source map map super class manager this map map 
public  class find class  string name throws  class not found exception  load it if it s one of our classes  class source source map get name if source null byte code source get code name return define class name code code length else  let superclass  bsh class loader url class loader find class try to find the class return super find class name 
public  string to string return super to string for files map 
static  display manager get display manager j edit buffer buffer  text area text area  list  display manager l buffer map get buffer if l null l new  linked list  display manager buffer map put buffer l  an existing display manager s fold visibility map that a new display manager will inherit  display manager copy null  iterator  display manager liter l iterator  display manager dmgr while liter has next dmgr liter next copy dmgr if dmgr in use dmgr text area text area dmgr in use true return dmgr if we got here no unused display manager in list dmgr new  display manager buffer text area copy dmgr in use true l add dmgr return dmgr 
void release in use false 
public static void buffer closed j edit buffer buffer buffer map remove buffer 
static void text area disposed  text area text area for  list  display manager l buffer map values  iterator  display manager liter l iterator while liter has next  display manager dmgr liter next if dmgr text area text area dmgr dispose liter remove 
since j edit pre public j edit buffer get buffer return buffer 
 returns if the specified line is visible param line a physical line index since j edit pre public final boolean is line visible int line return folds search line 
 returns the physical line number of the first visible line since j edit pre public int get first visible line return folds first 
 returns the physical line number of the last visible line since j edit pre public int get last visible line return folds last 
 returns the next visible line after the specified line index or if there is no next visible line param line a physical line index since j edit pre public int get next visible line int line if line line buffer get line count throw new  array index out of bounds exception line return folds next line 
 returns the previous visible line before the specified line index param line a physical line index return the previous visible physical line or if there is no visible line since j edit pre public int get prev visible line int line if line line buffer get line count throw new  array index out of bounds exception line return folds prev line 
 returns how many screen lines contains the given physical line  it can be greater than when using soft wrap param line the physical line return the screen line count public final int get screen line count int line update screen line count line return screen line mgr get screen line count line 
 returns the number of displayable lines  it can be greater than the number of lines of the buffer when using soft wrap a line can count for n lines or when using folding if the foldings are collapsed return the number of displayable lines public final int get scroll line count return scroll line count scroll line 
 collapses the fold at the specified physical line index param line a physical line index since j edit pre public void collapse fold int line int line count buffer get line count int end line count if the caret is on a collapsed fold collapse the parent fold if line line buffer get line count buffer is fold start line is line visible line line int initial fold level buffer get fold level line  find fold start and end int start if line line count buffer get fold level line initial fold level this line is the start of a fold start line for int i line i line count i if buffer get fold level i initial fold level end i break else boolean ok false scan backwards looking for the start for int i line i i if buffer get fold level i initial fold level start i ok true break if ok no folds in buffer return for int i line i line count i if buffer get fold level i initial fold level end i break  collapse the fold hide line range start end notify screen line changes text area fold structure changed 
 expands the fold at the specified physical line index param line a physical line index param fully  if true all subfolds will also be expanded since j edit pre public int expand fold int line boolean fully the first sub fold used by j edit text area expand fold int return value int line count buffer get line count int end line count if line line count return while is line visible line int prev line folds lookup folds search line if is line visible prev line return expand fold prev line fully if is line visible prev line return if is line visible line fully return  find fold start and fold end int start int initial fold level buffer get fold level line if buffer get fold level line initial fold level this line is the start of a fold start line if is line visible line folds search line folds count int index folds search line end folds lookup index else for int i line i line count i if buffer get fold level i initial fold level end i break else if fully return start line while start buffer get fold level start initial fold level start initial fold level buffer get fold level start for int i line i line count i if buffer get fold level i initial fold level end i break  expand the fold if fully show line range start end else for int i start i end if return value buffer is fold start i return value i show line range i i int fold buffer get fold level i i while i end buffer get fold level i fold i notify screen line changes text area fold structure changed return return value 
 expands all folds since j edit pre public void expand all folds show line range buffer get line count notify screen line changes text area fold structure changed 
 this method should only be called from code actions xml code since j edit pre public void expand folds char digit if digit digit  toolkit get default toolkit beep else expand folds digit 
 expands all folds with the specified fold level param fold level  the fold level since j edit pre public void expand folds int fold level if buffer get fold handler instanceof  indent fold handler fold level fold level buffer get indent size show line range buffer get line count this ensures that the first line is always visible boolean seen visible line false int first invisible for int i i buffer get line count i if seen visible line buffer get fold level i fold level if first invisible i hide line range first invisible i first invisible i seen visible line true if first invisible buffer get line count hide line range first invisible buffer get line count notify screen line changes if text area get display manager this text area fold structure changed 
 narrows the visible portion of the buffer to the specified line range param start  the first line param end  the last line since j edit pre public void narrow int start int end if start end start end buffer get line count throw new  array index out of bounds exception start end if start get first visible line end get last visible line expand all folds if start hide line range start if end buffer get line count hide line range end buffer get line count if we narrowed to a single collapsed fold if start buffer get line count is line visible start expand fold start false text area fire narrow active notify screen line changes text area fold structure changed 
void init if initialized if buffer is loading reset anchors else initialized true folds new  range map if buffer is loading folds reset buffer get line count else buffer handler fold handler changed buffer notify screen line changes 
void notify screen line changes if  debug scroll debug  log log  log debug this notify screen line changes when the text area switches to us it will do a reset anyway if text area get display manager this return try if first line call reset first line reset else if first line call changed first line changed if scroll line count call reset scroll line count reset first line ensure physical line is visible else if scroll line count call changed scroll line count changed if first line call changed scroll line count call reset scroll line count call changed text area update scroll bar text area recalculate last physical line finally first line call reset first line call changed false scroll line count call reset scroll line count call changed false 
void set first line int old first line int first line int visible lines text area get visible lines if first line old first line visible lines this first line scroll down first line old first line text area chunk cache invalidate all else if first line old first line visible lines this first line scroll up old first line first line text area chunk cache invalidate all else if first line old first line this first line scroll down first line old first line text area chunk cache scroll down first line old first line else if first line old first line this first line scroll up old first line first line text area chunk cache scroll up old first line first line notify screen line changes 
 scroll from a given amount of lines param amount the amount of lines that must be scrolled param skew a skew within the given line void set first physical line int amount int skew int old first line text area get first line if amount skew this first line skew j edit text area scroll to needs this to simplify its code if skew this first line scroll up skew else if skew this first line scroll down skew else nothing to do return else if amount this first line phys down amount skew else if amount this first line phys up amount skew int first line text area get first line int visible lines text area get visible lines if first line old first line do nothing else if first line old first line visible lines first line old first line visible lines text area chunk cache invalidate all else if first line old first line text area chunk cache scroll down first line old first line else if first line old first line text area chunk cache scroll up old first line first line we have to be careful notify screen line changes 
void invalidate screen line counts screen line mgr invalidate screen line counts first line call reset true scroll line count call reset true 
void update screen line count int line if screen line mgr is screen line count valid line int new count text area chunk cache get line subregion count line set screen line count line new count 
void buffer loaded folds reset buffer get line count screen line mgr reset if text area get display manager this text area properties changed init int collapse folds buffer get integer property collapse folds if collapse folds expand folds collapse folds 
void fold handler changed if buffer is loading return folds reset buffer get line count reset anchors int collapse folds buffer get integer property collapse folds if collapse folds expand folds collapse folds 
private  display manager j edit buffer buffer  text area text area  display manager copy this buffer buffer this screen line mgr new  screen line manager buffer this text area text area scroll line count new  scroll line count this text area first line new  first line this text area buffer handler new  buffer handler this text area buffer this listener priority thing is a bad hack buffer add buffer listener buffer handler j edit buffer high priority if copy null folds new  range map copy folds initialized true 
private void reset anchors first line call reset true scroll line count call reset true notify screen line changes 
private void dispose buffer remove buffer listener buffer handler 
private void show line range int start int end if  debug fold vis debug  log log  log debug this show line range start end for int i start i end i xxx if is line visible i important not screen line mgr get screen line count int screen lines get screen line count i if first line physical line i first line scroll line screen lines first line call changed true scroll line count scroll line screen lines scroll line count call changed true update fold visibility map folds show start end 
private void hide line range int start int end if  debug fold vis debug  log log  log debug this hide line range start end int i start if is line visible i i get next visible line i while i i end int screen lines get screen line count i if i first line physical line first line scroll line screen lines first line skew first line call changed true scroll line count scroll line screen lines scroll line count call changed true i get next visible line i update fold visibility map folds hide start end if is line visible first line physical line int first visible get first visible line if first line physical line first visible first line physical line first visible first line scroll line else first line physical line get prev visible line first line physical line first line scroll line get screen line count first line physical line first line call changed true 
 sets the number of screen lines that the specified physical line is split into param line the line number param count the line count if no wrap since j edit pre private void set screen line count int line int count int old count screen line mgr get screen line count line old one so that the screen line manager sets the validity flag screen line mgr set screen line count line count if count old count return if is line visible line return if first line physical line line if first line physical line line first line call changed true else first line scroll line count old count first line call changed true scroll line count scroll line count old count scroll line count call changed true 
 init some variables that will be used when marking tokens  this is called before link j edit buffer mark tokens int  token handler to store some data that will be required and that we don t want to put in the parameters param styles param font render context param expander param out param wrap margin public void init  syntax style styles  font render context font render context  tab expander expander  list  chunk out float wrap margin super init x f this styles styles this font render context font render context this expander expander silly allow for anti aliased characters fuzz if wrap margin f this wrap margin wrap margin f else this wrap margin f this out out seen non whitespace false end x end of whitespace f end null 
 returns the list of chunks since j edit pre public  list  chunk get chunk list return out 
 called by the token marker when a syntax token has been parsed param seg  the segment containing the text param id  the token type one of the constants in the link  token class param offset  the start offset of the token param length  the number of characters in the token param context  the line context since j edit pre public void handle token  segment seg byte id int offset int length  token marker  line context context if id  token end if first token null out add merge  chunk first token seg return for int split offset split offset length split offset max chunk len int split length  math min length split offset max chunk len  chunk chunk create chunk id offset split offset split length context add token chunk context if wrap margin f init chunk chunk seg x chunk width if  character is whitespace seg array seg offset chunk offset if seen non whitespace end last token end x x else end of whitespace x else if x wrap margin end null seen non whitespace  chunk next line new  chunk end of whitespace end offset end length get parser rule set context init chunk next line seg next line next end next end next null if first token null out add merge  chunk first token seg first token next line x x end x end of whitespace end null end x x seen non whitespace true 
private  chunk create chunk byte id int offset int length  token marker  line context context return new  chunk id offset length get parser rule set context styles context rules get default 
protected void init chunk  chunk chunk  segment seg chunk init seg expander x font render context 
private  chunk merge  chunk first  segment seg if first null return null  chunk chunk first while chunk next null  chunk next  chunk chunk next if can merge chunk next seg in case already initialized un initialize it chunk initialized false chunk length next length chunk width next width chunk next next next else if chunk initialized init chunk chunk seg if wrap margin f x chunk width chunk next if chunk initialized init chunk chunk seg return first 
private static boolean can merge  chunk c  chunk c  segment seg if c accessable c accessable return false char ch seg array seg offset c offset char ch seg array seg offset c offset return c style c style ch t ch t c length c length max chunk len 
deprecated use is alternate layout  deprecated public boolean set alternate layout return is alternate layout 
j edit  view option wide horizontal docking areas versus tall vertical docking areas return true if using the alternate layout public boolean is alternate layout return alternate layout 
public void set alternate layout boolean alternate layout this alternate layout alternate layout 
public void add layout component  string name  component comp add layout component comp name 
public void add layout component  component comp  object cons if cons null center equals cons center comp else if  dockable window manager top equals cons top  dockable panel comp else if  dockable window manager left equals cons left  dockable panel comp else if  dockable window manager bottom equals cons bottom  dockable panel comp else if  dockable window manager right equals cons right  dockable panel comp else if top buttons equals cons top buttons comp else if left buttons equals cons left buttons comp else if bottom buttons equals cons bottom buttons comp else if right buttons equals cons right buttons comp 
public void remove layout component  component comp if center comp center null else if comp top top null else if comp left left null else if comp bottom bottom null else if comp right right null 
public  dimension preferred layout size  container parent  dimension pref size new  dimension  dimension  top top get preferred size  dimension  left left get preferred size  dimension  bottom bottom get preferred size  dimension  right right get preferred size  dimension  top buttons top buttons get preferred size  dimension  left buttons left buttons get preferred size  dimension  bottom buttons bottom buttons get preferred size  dimension  right buttons right buttons get preferred size  dimension  center center null new  dimension center get preferred size  dimension  top toolbars new  dimension  dimension  bottom toolbars new  dimension pref size height  top height  bottom height  center height  top buttons height  bottom buttons height  top toolbars height  bottom toolbars height pref size width  left width  right width  math max  center width  math max  top toolbars width  bottom toolbars width  left buttons width  right buttons width return pref size 
public  dimension minimum layout size  container parent i m lazy return preferred layout size parent 
public  dimension maximum layout size  container parent return new  dimension  integer max value  integer max value 
public void layout container  container parent  dimension size parent get size  dimension  top toolbars new  dimension  dimension  bottom toolbars new  dimension int top button height int bottom button height int left button width int right button width  dimension  top top get preferred size  dimension  left left get preferred size  dimension  bottom bottom get preferred size  dimension  right right get preferred size int top height  top height int bottom height  bottom height int left width  left width int right width  right width boolean top empty  container top buttons get component count boolean left empty  container left buttons get component count boolean bottom empty  container bottom buttons get component count boolean right empty  container right buttons get component count  dimension close box size if  container top buttons get component count close box size new  dimension else close box size  container top buttons get component get preferred size int close box width  math max close box size width close box size height if alternate layout  lay out independent buttons int  width size width int padding left empty right empty close box width top button height top get window container get wrapped dimension  width close box width top buttons set bounds padding size width padding top button height bottom button height bottom get window container get wrapped dimension  width bottom buttons set bounds padding size height bottom button height size width padding bottom button height int  height size height top button height bottom button height  lay out dependent buttons left button width left get window container get wrapped dimension  height left buttons set bounds top height top button height left button width  height top height bottom height right button width right get window container get wrapped dimension  height right buttons set bounds size width right button width top height top button height right button width  height top height bottom height int dimensions adjust docking areas to fit size top height left width bottom height right width top button height left button width bottom button height right button width  top toolbars  bottom toolbars top height dimensions left width dimensions bottom height dimensions right width dimensions  lay out docking areas top set bounds top button height size width top height bottom set bounds size height bottom height bottom button height size width bottom height left set bounds left button width top button height top height left width  height top height bottom height right set bounds  width right button width right width top button height top height right width  height top height bottom height else  lay out independent buttons int  height size height int padding top empty bottom empty close box width left button width left get window container get wrapped dimension  height close box width left buttons set bounds padding left button width  height padding right button width right get window container get wrapped dimension  height right buttons set bounds size width right button width padding right button width  height padding int  width size width left button width right button width  lay out dependent buttons top button height top get window container get wrapped dimension  width top buttons set bounds left button width left width  width left width right width top button height bottom button height bottom get window container get wrapped dimension  width bottom buttons set bounds left button width left width  height bottom button height  width left width right width bottom button height int dimensions adjust docking areas to fit size top height left width bottom height right width top button height left button width bottom button height right button width  top toolbars  bottom toolbars top height dimensions left width dimensions bottom height dimensions right width dimensions  lay out docking areas top set bounds left button width left width top button height  width left width right width top height bottom set bounds left button width left width size height bottom height bottom button height  width left width right width bottom height left set bounds left button width left width  height right set bounds size width right width right button width right width  height  position center edit pane or split pane if center null center set bounds left button width left width top button height top height  top toolbars height size width left width right width left button width right button width size height top height top button height bottom height bottom button height  top toolbars height  bottom toolbars height 
private int adjust docking areas to fit  dimension size int top height int left width int bottom height int right width int top button height int left button width int bottom button height int right button width  dimension  top toolbars  dimension  bottom toolbars int max top height size height bottom height top button height bottom button height  top toolbars height  bottom toolbars height top height  math min  math max max top height top height left width  math min  math max size width left button width right button width right width left width int max bottom height size height top height top button height bottom button height  top toolbars height  bottom toolbars height bottom height  math min  math max max bottom height bottom height right width  math min  math max size width left button width right button width left width right width top get window container set dimension top height left get window container set dimension left width bottom get window container set dimension bottom height right get window container set dimension right width return new int top height left width bottom height right width 
public float get layout alignment x  container target return f 
public float get layout alignment y  container target return f 
public void invalidate layout  container target 
 dockable panel  panel window container panel super new  card layout this panel panel this wm panel get dockable window manager  resize mouse handler resize mouse handler new  resize mouse handler add mouse listener resize mouse handler add mouse motion listener resize mouse handler 
 panel window container get window container return panel 
void show dockable  string name  card layout get layout show this name 
public  dimension get minimum size return new  dimension 
public  dimension get preferred size final  string position panel get position final int dimension panel get dimension if panel get current null return new  dimension else if position equals  dockable window manager top position equals  dockable window manager bottom if dimension int height super get preferred size height panel set dimension height return new  dimension dimension  panel window container splitter width else if dimension int width super get preferred size width panel set dimension width return new  dimension dimension  panel window container splitter width 
public void set bounds int x int y int width int height final  string position panel get position final int dimension panel get dimension if position equals  dockable window manager top position equals  dockable window manager bottom if dimension height  panel window container splitter width panel show  dockable window manager impl  entry null else panel set dimension height else if dimension width  panel window container splitter width panel show  dockable window manager impl  entry null else panel set dimension width super set bounds x y width height 
public void mouse pressed  mouse event evt if can drag continuous layout j edit get boolean property appearance continuous layout wm set resize pos panel get dimension panel drag start evt get point 
public void mouse released  mouse event evt if can drag if continuous layout panel set dimension wm resize pos  panel window container splitter width wm finish resizing drag start null wm revalidate 
public void mouse moved  mouse event evt  border border get border if border null collapsed return  string position panel get position  insets insets border get border insets  dockable panel this can drag false  top if position equals  dockable window manager top if evt get y get height insets bottom can drag true  left else if position equals  dockable window manager left if evt get x get width insets right can drag true  bottom else if position equals  dockable window manager bottom if evt get y insets top can drag true  right else if position equals  dockable window manager right if evt get x insets left can drag true if drag start null if can drag wm set cursor  cursor get predefined cursor get appropriate cursor else wm set cursor  cursor get predefined cursor  cursor default cursor 
public void mouse dragged  mouse event evt if can drag return if drag start null can t happen return int dimension panel get dimension  string position panel get position int new size  top if position equals  dockable window manager top new size evt get y wm set resize pos evt get y drag start y dimension panel  left else if position equals  dockable window manager left new size evt get x wm set resize pos evt get x drag start x dimension panel  bottom else if position equals  dockable window manager bottom new size dimension evt get y wm set resize pos dimension evt get y drag start y panel  right else if position equals  dockable window manager right new size dimension evt get x wm set resize pos dimension evt get x drag start x panel if continuous layout panel set dimension new size  panel window container splitter width wm revalidate 
public void mouse exited  mouse event evt if drag start null wm set cursor  cursor get predefined cursor  cursor default cursor 
private int get appropriate cursor  string position panel get position if position equals  dockable window manager top return  cursor n resize cursor else if position equals  dockable window manager left return  cursor w resize cursor else if position equals  dockable window manager bottom return  cursor s resize cursor else if position equals  dockable window manager right return  cursor e resize cursor else throw new  internal error 
public static synchronized  dockable window factory get instance if instance null instance new  dockable window factory return instance 
public  dockable window factory dockable window factories new  hash map  string  window 
 plugins shouldn t need to call this method since j edit pre public void load dockable windows  plugin jar plugin url uri  plugin jar  plugin cache entry cache try  log log  log debug  dockable window manager class  loading dockables from uri  dockable list handler dh new  dockable list handler plugin uri boolean failure xml utilities parse xml uri open stream dh if failure cache null cache cached dockable names dh get cached dockable names cache cached dockable action flags dh get cached dockable action flags cache cached dockable movable flags dh get cached dockable movable flags catch io exception e  log log  log error  dockable window manager class e 
 plugins shouldn t need to call this method since j edit pre public void unload dockable windows  plugin jar plugin  iterator entries dockable window factories entry set iterator while entries has next  map  entry entry  map  entry entries next  window factory  window entry get value if factory plugin plugin entries remove 
since j edit pre public void cache dockable windows  plugin jar plugin  string name boolean actions boolean movable for int i i name length i  window factory new  window plugin name i null actions i movable i dockable window factories put name i factory 
public void register dockable window  plugin jar plugin  string name  string code boolean actions boolean movable  window factory dockable window factories get name if factory null factory code code factory loaded true else factory new  window plugin name code actions movable dockable window factories put name factory 
public  string get registered dockable windows  string ret val new  string dockable window factories size  iterator  window entries dockable window factories values iterator int i while entries has next  window factory entries next ret val i factory name return ret val 
public  window get dockable window factory  string name return dockable window factories get name 
public  string get dockable window plugin class  string name  window w get dockable window factory name if w null w plugin null w plugin get plugin null return null return w plugin get plugin get class name 
 iterator  window get dockable window iterator return dockable window factories values iterator 
param plugin the plugin jar for which we are loading the dockables xml param uri the uri of the dockables xml file  dockable list handler  plugin jar plugin url uri this plugin plugin this uri uri state stack new  stack  string actions true movable movable default code new  string builder cached dockable names new  linked list  string cached dockable action flags new  linked list  boolean cached dockable movable flags new  linked list  boolean 
 override public  input source resolve entity  string public id  string system id return xml utilities find entity system id dockables dtd  misc utilities class 
 override public void characters char c int off int len  string tag peek element if tag equals dockable code append c off len 
 override public void start element  string uri  string local name  string q name  attributes attrs  string tag push element q name if tag equals dockable dockable name attrs get value name actions false equals attrs get value no actions  string movable attr attrs get value movable if movable attr null movable movable attr equals ignore case true 
 override public void end element  string uri  string local name  string name if name null return  string tag peek element if name equals tag if tag equals dockable register dockable window plugin dockable name code to string actions movable cached dockable names add dockable name cached dockable action flags add  boolean value of actions cached dockable movable flags add  boolean value of movable make default be true for the next action actions true movable movable default code set length pop element else can t happen throw new  internal error 
 override public void start document try push element null catch  exception e  log log  log error this e 
public  string get cached dockable names return cached dockable names to array new  string cached dockable names size 
public boolean get cached dockable action flags return boolean list to array cached dockable action flags 
public boolean get cached dockable movable flags return boolean list to array cached dockable movable flags 
 this method transforms a  list  boolean into the corresponding boolean array param list the  list  boolean you want to convert return a boolean array private boolean boolean list to array java util  list  boolean list boolean return value new boolean list size int i for  boolean value list return value i value boolean value return return value 
private  string push element  string name name name null null name intern state stack push name return name 
private  string peek element return state stack peek 
private  string pop element return state stack pop 
 window  plugin jar plugin  string name  string code boolean actions boolean movable this plugin plugin this name name this code code this movable movable if code null loaded true if actions  action set action set plugin null j edit get built in action set plugin get action set action set add action new  open action name action set add action new  toggle action name action set add action new  float action name  string label j edit get property name label if label null label no label property name  string args label j edit set temporary property name label label j edit set temporary property name toggle label j edit get property view docking toggle label args j edit set temporary property name toggle toggle true j edit set temporary property name float label j edit get property view docking float label args 
void load if loaded return load dockable windows plugin plugin get dockables uri null 
j component create dockable window  view view  string position  avoid infinite recursion synchronized this if is being created return null is being created true load if loaded  log log  log warning this  outdated cache return null  name space name space new  name space  bean shell get name space  dockable window manager  factory create dockable window try name space set variable position position catch  util eval error e  log log  log error this e j component win j component  bean shell eval view name space code synchronized this is being created false return win 
 open action  string name super name this dockable name 
public void invoke  view view view get dockable window manager show dockable window dockable 
 override public  string get code return view get dockable window manager show dockable window dockable 
 toggle action  string name super name toggle this dockable name 
public void invoke  view view view get dockable window manager toggle dockable window dockable 
public boolean is selected  view view return view get dockable window manager is dockable window visible dockable 
 override public  string get code return view get dockable window manager toggle dockable window dockable 
 float action  string name super name float this dockable name 
public void invoke  view view view get dockable window manager float dockable window dockable 
 override public  string get code return view get dockable window manager float dockable window dockable 
public  dockable window manager  view view  dockable window factory instance  view config config this view view this factory instance alternate layout j edit get boolean property alternate layout prop 
public void init  edit bus add to bus this  iterator  dockable window factory  window entries factory get dockable window iterator while entries has next  dockable window factory  window window entries next  string dockable window name positions put dockable get dockable position dockable add plugin dockable window plugin dockable 
public void close  edit bus remove from bus this 
public void apply docking layout  docking layout docking  by default use the docking positions specified by the j edit properties  iterator  entry  string  string iterator positions entry set iterator while iterator has next  entry  string  string entry iterator next  string dockable entry get key  string position entry get value if position equals floating show dockable window dockable 
 opens the specified dockable window  as of j edit pre has the same effect as calling show dockable window param name  the dockable window name since j edit pre public void add dockable window  string name show dockable window name 
 hides the specified dockable window  as of j edit pre has the same effect as calling hide dockable window param name  the dockable window name since j edit pre public void remove dockable window  string name hide dockable window name 
 toggles the visibility of the specified dockable window param name  the dockable window name public void toggle dockable window  string name if is dockable window visible name remove dockable window name else add dockable window name 
 returns the specified dockable window  note that this method will return null if the dockable has not been added yet  make sure you call link add dockable window  string first param name  the name of the dockable window since j edit pre public j component get dockable window  string name return get dockable name 
 hides all visible dock areas or shows them again if the last time it was a hide since j edit pre public void toggle dock areas if close toggle t top get top docking area get current null t left get left docking area get current null t right get right docking area get current null t bottom get bottom docking area get current null get bottom docking area show null get top docking area show null get right docking area show null get left docking area show null else if t bottom get bottom docking area show most recent if t left get left docking area show most recent if t right get right docking area show most recent if t top get top docking area show most recent close toggle close toggle view get text area request focus 
public void dockable title changed  string dockable  string new title 
 the action event close docking area by default only works on windows that are docked  if you want your floatable plugins to also respond to this event you need to add key listeners to each component in your plugin that usually has keyboard focus  this function returns a key listener which does exactly that  you should not need to call this method it is used by  floating window container param dockable name the name of your dockable return a  key listener you can add to that plugin s component since j edit pre public  key listener close listener  string dockable name return new  key handler dockable name 
 returns this dockable window manager s view since j edit pre public  view get view return view 
since j edit pre public j component get dockable  string name return windows get name 
 returns the title of the specified dockable window param name  the name of the dockable window since j edit pre public  string get dockable title  string name return long title name 
 changes the longtitle property of a dockable window which corresponds to the title shown when it is floating not docked  fires a change event that makes sure all floating dockables change their title param dockable the name of the dockable as specified in the dockables xml param title the new longtitle you want to see above it since pre public void set dockable title  string dockable  string title  string prop name get long title property name dockable  string old title j edit get property prop name j edit set property prop name title fire property change prop name old title title dockable title changed dockable title 
public static  string get registered dockable windows return  dockable window factory get instance get registered dockable windows 
public static  string get dockable window plugin name  string name  string plugin class  dockable window factory get instance get dockable window plugin class name if plugin class null return null return j edit get property plugin plugin class name 
public void set docking layout  docking layout docking apply docking layout docking apply alternate layout alternate layout 
private void add plugin dockable  plugin jar plugin  string name  set  string dockables plugins get plugin if dockables null dockables new  hash set  string plugins put plugin dockables dockables add name 
public void handle message eb message msg if msg instanceof  dockable window update if  dockable window update msg get what  dockable window update properties changed properties changed else if msg instanceof  properties changed properties changed else if msg instanceof  plugin update  plugin update pmsg  plugin update msg if pmsg get what  plugin update loaded  iterator  dockable window factory  window iter factory get dockable window iterator while iter has next  dockable window factory  window w iter next if w plugin pmsg get plugin jar  string position get dockable position w name positions put w name position add plugin dockable w plugin w name dockable loaded w name position properties changed else if pmsg is exiting we don t care else if pmsg get what  plugin update deactivated pmsg get what  plugin update unloaded  set  string dockables plugins remove pmsg get plugin jar if dockables null for  string dockable dockables dispose dockable window dockable windows remove dockable 
public  string long title  string name  string title j edit get property get long title property name name if title null return short title name return title 
public  string short title  string name  string title j edit get property name title if title null return no title property name return title 
protected void apply alternate layout boolean alternate layout 
protected void dockable loaded  string dockable name  string position 
protected void docking position changed  string dockable name  string old position  string new position 
protected boolean get alternate layout prop return alternate layout 
protected void properties changed if view is plain view return boolean new alternate layout j edit get boolean property alternate layout prop if new alternate layout alternate layout alternate layout new alternate layout apply alternate layout new alternate layout  string dockables factory get registered dockable windows for int i i dockables length i  string dockable dockables i  string old position positions get dockable  string new position get dockable position dockable if old position null new position equals old position positions put dockable new position docking position changed dockable old position new position 
protected j component create dockable  string name  dockable window factory  window wf factory get dockable window factory name if wf null  log log  log error this  unknown dockable window name return null  string position get dockable position name j component window wf create dockable window view position if window null windows put name window return window 
protected  string get dockable position  string name return j edit get property name dock position floating 
protected void focus dockable  string name j component c get dockable name if c null return if c instanceof  default focus component  default focus component c focus on default component else c request focus 
protected  string get long title property name  string dockable name return dockable name longtitle 
public  key handler  string dockable name  string shortcut j edit get property action shortcut  string shortcut j edit get property action shortcut if shortcut null b parse shortcut shortcut if shortcut null b parse shortcut shortcut name dockable name match match 
 override public void key typed  key event e if b null match match e b match if b null match match e b match if match match b size match match b size hide dockable window name match match 
private int match  key event e  vector  key shortcut int index char c e get key char if shortcut null c shortcut get index key return index return 
private  vector  key parse shortcut  string shortcut  vector  key keys new  vector  key  string parts shortcut split s for  string part parts if part length keys add  key event translator parse key part return keys 
public void set plain view boolean plain 
public  string get saved layouts  string layout dir get layout directory if layout dir null return null  file dir new  file layout dir  file files dir list files new  filename filter public boolean accept  file dir  string name return name ends with xml  string layouts new  string files length for int i i files length i layouts i file to layout files i get name return layouts 
private static  string file to layout  string filename return filename replace first xml 
private static  string layout to file  string base name int view index  string builder name new  string builder base name if view index no view index name append view append view index name append xml return name to string 
public  string get layout filename  string base name int view index  string dir get layout directory if dir null return null return dir  file separator layout to file base name view index 
private  string get layout directory  string name get name if name null return null  string dir j edit get settings directory if dir null return null dir dir  file separator name  file d new  file dir if d exists d mkdir return dir 
public void start element  string uri  string local name  string q name  attributes attrs for int i i attrs get length i attribute attrs get q name i attrs get value i 
private void attribute  string aname  string value if aname equals top top value else if aname equals left left value else if aname equals bottom bottom value else if aname equals right right value else if aname equals top pos top pos  integer parse int value else if aname equals left pos left pos  integer parse int value else if aname equals bottom pos bottom pos  integer parse int value else if aname equals right pos right pos  integer parse int value 
public  default handler get perspective handler return new  perspective handler 
public boolean save layout  string base name int view index  string line sep  system get property line separator  string filename get layout filename base name view index  buffered writer out null try out new  buffered writer new  file writer filename out write docking left out write left null left out write top out write top null top out write right out write right null right out write bottom out write bottom null bottom out write left pos out write  string value of left pos out write top pos out write  string value of top pos out write right pos out write  string value of right pos out write bottom pos out write  string value of bottom pos out write out write line sep catch io exception e  log log  log error this e e return false finally io utilities close quietly out return true 
 override public boolean load layout  string base name int view index  string filename get layout filename base name view index  default handler handler get perspective handler try no need to close the stream it is closed by xml utilities parse xml method xml utilities parse xml new  file input stream filename handler catch  file not found exception e return false catch io exception e return false return true 
 override public  string get name return  dockable window manager 
public void set docking layout  docking layout docking  dockable window config config  dockable window config docking if config null return if config top null config top length show dockable window config top if config left null config left length show dockable window config left if config bottom null config bottom length show dockable window config bottom if config right null config right length show dockable window config right 
 override public  docking layout get docking layout  view config config  dockable window config docking new  dockable window config docking top get top docking area get current docking left get left docking area get current docking bottom get bottom docking area get current docking right get right docking area get current docking top pos get top docking area get dimension docking left pos get left docking area get dimension docking bottom pos get bottom docking area get dimension docking right pos get right docking area get dimension return docking 
 creates a new dockable window manager param view  the view param factory a link  dockable window factory usually code  dockable window factory get instance code param config a docking configuration since j edit pre public  dockable window manager impl  view view  dockable window factory factory  view  view config config super view factory config set layout new  dockable layout windows new  hash map  string  entry clones new  array list  entry  dockable window config docking  dockable window config config docking if docking null docking new  dockable window config top new  panel window container this top docking top pos left new  panel window container this left docking left pos bottom new  panel window container this bottom docking bottom pos right new  panel window container this right docking right pos add  dockable layout top buttons top button panel add  dockable layout left buttons left button panel add  dockable layout bottom buttons bottom button panel add  dockable layout right buttons right button panel add top top dockable panel add left left dockable panel add bottom bottom dockable panel add right right dockable panel 
public void set main panel j panel panel add panel 
 initialises dockable window manager  do not call this method directly public void init super init  iterator  dockable window factory  window entries factory get dockable window iterator while entries has next add entry entries next properties changed 
 opens a new instance of the specified dockable window in a floating container param name  the dockable window name return  the new dockable window instance since j edit pre public j component float dockable window  string name  entry entry windows get name if entry null  log log  log error this  unknown dockable window name return null create a copy of this dockable window and float it  entry new entry new  entry entry factory floating new entry win new entry factory create dockable window view floating if new entry win null  floating window container fwc new  floating window container this true new entry container fwc new entry container register new entry new entry container show new entry clones add new entry return new entry win 
 opens the specified dockable window param name  the dockable window name since j edit pre public void show dockable window  string name last entry windows get name if last entry null  log log  log error this  unknown dockable window name return if last entry win null last entry win last entry factory create dockable window view last entry position if last entry win null if last entry position equals floating last entry container null  floating window container fwc new  floating window container this view is plain view last entry container fwc last entry container register last entry show stack push name last entry container show last entry  object reason  dockable window update activated  edit bus send new  dockable window update this reason name else an error occurred 
 hides the specified dockable window param name  the dockable window name since j edit pre public void hide dockable window  string name  entry entry windows get name if entry null  log log  log error this  unknown dockable window name return if entry win null return entry container show null 
 returns the specified dockable window  note that this method will return null if the dockable has not been added yet  make sure you call link add dockable window  string first  for historical reasons this does the same thing as link get dockable window  string param name  the name of the dockable window since j edit pre public j component get dockable  string name  entry entry windows get name if entry null entry win null return null else return entry win 
 returns if the specified dockable window is visible param name  the dockable window name public boolean is dockable window visible  string name  entry entry windows get name if entry null entry win null return false else return entry container is visible entry 
 returns if the specified dockable window is docked into the view param name  the dockable s name since j edit pre public boolean is dockable window docked  string name  entry entry windows get name if entry null return false else return entry position equals floating 
 closes the most recently focused dockable since j edit pre public void close current area i don t know of any other way to fix this since invoking this command from a menu results in the focus owner being the menu until the menu goes away  swing utilities invoke later new  runnable public void run  try to hide the last entry that was shown try  string dockable name show stack pop hide dockable window dockable name return catch  exception e  component comp view get focus owner while comp null  system err println comp get class if comp instanceof  dockable panel  dockable panel panel  dockable panel comp  panel window container container panel get window container container show  dockable window manager impl  entry null return comp comp get parent get toolkit beep 
 called when the view is being closed since j edit pre public void close super close for  entry entry windows values if entry win null entry container unregister entry for  entry clone clones if clone win null clone container unregister clone 
public  panel window container get top docking area return top 
public  panel window container get left docking area return left 
public  panel window container get bottom docking area return bottom 
public  panel window container get right docking area return right 
public j popup menu create popup menu final  dockable window container container final  string dockable final boolean clone j popup menu popup new j popup menu if dockable null container instanceof  panel window container  action listener listener new  action listener public void action performed  action event evt show dockable window evt get action command  string dockables  panel window container container get dockables  map  string  string dockable map new  tree map  string  string for int i i dockables length i  string action dockables i dockable map put get dockable title action action for  map  entry  string  string entry dockable map entry set j menu item item new j menu item entry get key item set action command entry get value item add action listener listener popup add item else j menu item caption new j menu item get dockable title dockable caption set enabled false popup add caption popup add separator  string current pos j edit get property dockable dock position floating if clone  string positions floating top left bottom right for int i i positions length i final  string pos positions i if pos equals current pos continue j menu item move menu item new j menu item j edit get property view docking menu pos move menu item add action listener new  action listener public void action performed  action event evt j edit set property dockable dock position pos  edit bus send new  dockable window update  dockable window manager impl this  dockable window update properties changed dockable show dockable window dockable popup add move menu item popup add separator j menu item clone menu item new j menu item j edit get property view docking menu clone clone menu item add action listener new  action listener public void action performed  action event evt float dockable window dockable popup add clone menu item popup add separator j menu item close menu item new j menu item j edit get property view docking menu close close menu item add action listener new  action listener public void action performed  action event evt if clone  floating window container container dispose else remove dockable window dockable popup add close menu item if clone current pos equals floating j menu item undock menu item new j menu item j edit get property view docking menu undock undock menu item add action listener new  action listener public void action performed  action event evt j edit set property dockable dock position floating  edit bus send new  dockable window update  dockable window manager impl this  dockable window update properties changed dockable  reset the window properties changed doesn t reset it for movable windows  entry entry windows get dockable if entry null  log log  log error this  unknown dockable window dockable else entry win null popup add undock menu item return popup 
public void paint children  graphics g super paint children g if resize rect null g set color  color dark gray g fill rect resize rect x resize rect y resize rect width resize rect height 
public void handle message eb message msg if msg instanceof  dockable window update if  dockable window update msg get what  dockable window update properties changed properties changed else if msg instanceof  properties changed properties changed else if msg instanceof  plugin update  plugin update pmsg  plugin update msg if pmsg get what  plugin update loaded  iterator  dockable window factory  window iter factory get dockable window iterator while iter has next  dockable window factory  window w iter next if w plugin pmsg get plugin jar add entry w properties changed else if pmsg is exiting we don t care else if pmsg get what  plugin update deactivated  iterator  entry iter get all plugin entries pmsg get plugin jar false while iter has next  entry entry iter next if entry container null entry container remove entry else if pmsg get what  plugin update unloaded  iterator  entry iter get all plugin entries pmsg get plugin jar true while iter has next  entry entry iter next if entry container null entry container unregister entry entry win null entry container null 
void set resize pos int resize pos  panel window container resizing this resize pos resize pos if resize pos resize pos if continuous layout return  rectangle new resize rect new  rectangle  panel window container splitter width  panel window container splitter width if resizing top resize pos  math min resize pos get height top button panel get height bottom dockable panel get height bottom button panel get height  panel window container splitter width new resize rect x top dockable panel get x new resize rect y resize pos top button panel get height new resize rect width top dockable panel get width else if resizing left resize pos  math min resize pos get width left button panel get width right dockable panel get width right button panel get width  panel window container splitter width new resize rect x resize pos left button panel get width new resize rect y left dockable panel get y new resize rect height left dockable panel get height else if resizing bottom resize pos  math min resize pos get height bottom button panel get height top dockable panel get height top button panel get height  panel window container splitter width new resize rect x bottom dockable panel get x new resize rect y get height bottom button panel get height resize pos  panel window container splitter width new resize rect width bottom dockable panel get width else if resizing right resize pos  math min resize pos get width right button panel get width left dockable panel get width left button panel get width  panel window container splitter width new resize rect x get width right button panel get width resize pos  panel window container splitter width new resize rect y right dockable panel get y new resize rect height right dockable panel get height  rectangle to repaint if resize rect null to repaint new resize rect else to repaint resize rect union new resize rect resize rect new resize rect repaint to repaint 
void finish resizing resize rect null repaint 
protected void properties changed if view is plain view return  dockable layout get layout set alternate layout j edit get boolean property view docking alternate layout  string window list factory get registered dockable windows for int i i window list length i  string dockable window list i  entry entry windows get dockable  string new position j edit get property dockable dock position floating if new position equals entry position continue entry position new position if entry container null entry container unregister entry entry container null if entry factory movable new position equals floating if entry win instanceof  dockable window  dockable window entry win move new position else entry win null if new position equals floating else if new position equals top entry container top else if new position equals left entry container left else if new position equals bottom entry container bottom else if new position equals right entry container right else  log log  log warning this  unknown position new position continue entry container register entry top sort dockables left sort dockables bottom sort dockables right sort dockables continuous layout j edit get boolean property appearance continuous layout revalidate repaint 
private void add entry  dockable window factory  window factory  entry e if view is plain view don t show menu items to dock into a plain view e new  entry factory floating else e new  entry factory if e position equals floating nothing to do else if e position equals top e container top else if e position equals left e container left else if e position equals bottom e container bottom else if e position equals right e container right else  log log  log warning this  unknown position e position if e container null e container register e windows put factory name e 
 if remove is false only remove from clones list otherwise remove from both entries and clones private  iterator  entry get all plugin entries  plugin jar plugin boolean remove  list  entry return value new  linked list  entry  iterator  entry iter windows values iterator while iter has next  entry entry iter next if entry factory plugin plugin return value add entry if remove iter remove iter clones iterator while iter has next  entry entry iter next if entry factory plugin plugin return value add entry iter remove return return value iterator 
 entry  dockable window factory  window factory this factory j edit get property factory name dock position floating 
return the long title for the dockable floating window public  string long title  string title j edit get property factory name longtitle if title null return short title else return title 
return  the short title for the dockable button text public  string short title  string title j edit get property factory name title if title null return no title property factory name else return title 
return a label appropriate for the title on the dock buttons public  string label  string retval j edit get property factory name label retval retval replace all return retval 
 entry  dockable window factory  window factory  string position this factory factory this position position get the title here not in the factory constructor since the factory might be created before a plugin s props are loaded 
 override public void dispose dockable window  string name  nothing to do here called as a response to plugin unloading handled differently by this implementation 
public  dockable window manager create  view view  dockable window factory instance  view config config return new  dockable window manager impl view instance config 
public  docking layout create docking layout return new  dockable window manager impl  dockable window config 
 creates a new dockable window update message param wm  the dockable window manager param what  what happened param dockable  the dockable window in question public  dockable window update  dockable window manager wm  object what  string dockable super wm if what null throw new  null pointer exception  what must be non null this what what this dockable dockable 
 returns what caused this dockable update public  object get what return what 
 returns the dockable in question or null if the message type is code properties changed code public  string get dockable return dockable 
public  string param string return what what dockable dockable super param string 
private  docking layout manager current mode new  hash map  view  string 
private static boolean save  view view  string layout name  docking layout docking view get view config docking if docking null boolean ret docking save layout layout name  docking layout no view index if ret return false add action layout name return true 
public static void save as  view view if j edit get settings directory null j option pane show message dialog view j edit get property no settings message return  string layout name j option pane show input dialog view j edit get property save layout message j edit get property save layout title j option pane question message if layout name null return if save view layout name j option pane show message dialog view j edit get property save layout failed 
private static void load  view view  string layout name  docking layout docking  view get docking framework provider create docking layout if docking load layout layout name  docking layout no view index view get dockable window manager set docking layout docking 
public static void load  view view if j edit get settings directory null j option pane show message dialog view j edit get property no settings message return  string layout name  string j option pane show input dialog view j edit get property load layout message j edit get property load layout title j option pane question message null get saved layouts null if layout name null return load view layout name 
private static  string get saved layouts  docking layout docking  view get docking framework provider create docking layout  string layouts null if docking null layouts docking get saved layouts if layouts null return new  string return layouts 
private static void add action  string layout name if actions null actions contains layout name actions add action new  load perspective action layout name 
public static void init create actions instance new  docking layout manager  edit bus add to bus instance 
private static void create actions actions new  action set  docking  layouts  string layouts get saved layouts for  string layout layouts add action layout j edit add action set actions actions init key bindings 
public static void remove actions j edit remove action set actions 
public  load perspective action  string layout name super load prefix layout name new  string layout name j edit set temporary property load prefix layout name label load prefix layout name 
 override public void invoke  view view  docking layout manager load view  string args 
private boolean can change edit mode eb message message if message instanceof  buffer update  buffer update bu  buffer update message  object what bu get what if what  buffer update closed what  buffer update created what  buffer update properties changed return true else if message instanceof  edit pane update  edit pane update ep  edit pane update message  object what ep get what if what  edit pane update buffer changed what  edit pane update created return true return false 
public void handle message eb message message boolean auto load mode layout j edit get boolean property  docking option pane auto load mode layout prop false if auto load mode layout return if message instanceof  view update  view update vu  view update message if vu get what  view update closed  view view j edit get active view  string mode current mode get view save mode layout view mode return  check for a change in the edit mode  view view j edit get active view if view null return if can change edit mode message return  string new mode get current edit mode view  string mode current mode get view boolean same mode mode null new mode null mode null mode equals new mode if same mode boolean auto save mode layout j edit get boolean property  docking option pane auto save mode layout prop false if auto save mode layout save mode layout view mode current mode put view new mode load mode layout view new mode 
private  string get current edit mode  view view  buffer buffer view get buffer if buffer null return null  mode buffer mode buffer get mode if buffer mode null return null return buffer mode get name 
private void save mode layout  view view  string mode  string mode layout get mode perspective mode if mode layout null return save view mode layout 
private void load mode layout  view view  string mode  string mode layout get mode perspective mode if mode layout null return load view mode layout 
public static void load current mode layout  view view if view null return  string mode instance get current edit mode view instance load mode layout view mode 
public static void save current mode layout  view view if view null return  string mode instance get current edit mode view instance save mode layout view mode 
private  string get mode perspective  string mode if mode null mode global mode return mode mode 
public  docking option pane super docking 
public void  init set layout new  border layout add  border layout north create docking options panel add  border layout center create window table scroller dockable set selection set model new  default combo box model window model get dockable sets 
public void  save j edit set boolean property auto load mode layout prop auto load mode layout is selected j edit set boolean property auto save mode layout prop auto save mode layout is selected window model save 
private j panel create docking options panel j panel p new j panel p set layout new  grid layout boolean auto load mode layout prop j edit get boolean property auto load mode layout prop false auto load mode layout new j check box j edit get property auto load mode layout label auto load mode layout prop p add auto load mode layout auto save mode layout new j check box j edit get property auto save mode layout label j edit get boolean property auto save mode layout prop false p add auto save mode layout auto save mode layout set enabled auto load mode layout prop auto load mode layout add action listener new  action listener public void action performed  action event e auto save mode layout set enabled auto load mode layout is selected  box v set selection  box create vertical box p add v set selection  box set selection  box create horizontal box v set selection add set selection set selection add  box create horizontal strut set selection add new j label j edit get property options docking select set label set selection add  box create horizontal strut dockable set selection new j combo box set selection add dockable set selection dockable set selection add item listener new  item listener public void item state changed  item event e window model show set  string dockable set selection get selected item set selection add  box create horizontal strut v set selection add  box create vertical strut return p 
private j scroll pane create window table scroller window model create window model window table new j table window model window table get table header set reordering allowed false window table set column selection allowed false window table set row selection allowed false window table set cell selection enabled false  dock position cell renderer combo box new  dock position cell renderer window table set row height combo box get preferred size height  table column column window table get column model get column column set cell renderer combo box column set cell editor new  default cell editor new  dock position cell renderer  dimension d window table get preferred size d height  math min d height j scroll pane scroller new j scroll pane window table scroller set preferred size d return scroller 
private static  window table model create window model return new  window table model 
 dock position cell renderer super new  string  dockable window manager floating  dockable window manager top  dockable window manager left  dockable window manager bottom  dockable window manager right  dock position cell renderer this set request focus enabled false 
public  component get table cell renderer component j table table  object value boolean is selected boolean has focus int row int column set selected item value return this 
 window table model dockable sets new  hash map  string  vector  entry  vector  entry all new  vector  entry dockable sets put all dockable set all windows new  vector  entry  string dockables  dockable window manager get registered dockable windows for  string dockable dockables  string plugin  dockable window manager get dockable window plugin name dockable  string set if plugin null set plugin set prefix plugin else set core dockable set  vector  entry current set dockables dockable sets get set if current set dockables null current set dockables new  vector  entry dockable sets put set current set dockables  entry entry new  entry dockable current set dockables add entry all add entry show set all dockable set 
public  vector  string get dockable sets  vector  string sets new  vector  string for  string set dockable sets key set sets add set sets remove all dockable set sets remove core dockable set  collections sort sets sets insert element at core dockable set sets insert element at all dockable set return sets 
public void show set  string set windows dockable sets get set  collections sort windows new  window compare fire table data changed 
public int get column count return 
public int get row count return windows size 
public  class get column class int col switch col case case return  string class default throw new  internal error 
public  object get value at int row int col  entry window  entry windows element at row switch col case return window title case return window dock position default throw new  internal error 
public boolean is cell editable int row int col return col 
public void set value at  object value int row int col if col return  entry window  entry windows element at row switch col case window dock position  string value break default throw new  internal error fire table rows updated row row 
public  string get column name int index switch index case return j edit get property options docking title case return j edit get property options docking dock position default throw new  internal error 
public void save for int i i windows size i  entry windows element at i save 
 entry  string name this name name title j edit get property name title if title null title name dock position j edit get property name dock position if dock position null dock position  dockable window manager floating 
void save j edit set property name dock position dock position 
public int compare  object obj  object obj  entry e  entry obj  entry e  entry obj return  standard utilities compare strings e title e title true 
public  dummy fold handler super none 
 returns the fold level of the specified line param buffer  the buffer in question param line index  the line index param seg a segment the fold handler can use to obtain any text from the buffer if necessary return  the fold level of the specified line since j edit pre public int get fold level j edit buffer buffer int line index  segment seg return 
 called by the token marker when a syntax token has been parsed param seg  the segment containing the text param id  the token type one of the constants in the link  token class param offset  the start offset of the token param length  the number of characters in the token param context  the line context since j edit pre public void handle token  segment seg byte id int offset int length  token marker  line context context 
 the token handler can compare this object with the object previously given for this line to see if the token type at the end of the line has changed meaning subsequent lines might need to be retokenized since j edit pre public void set line context  token marker  line context line context 
 creates a new dynamic menu changed message param name  the menu name  all dynamic menus with this name will be recreated next time they are displayed public  dynamic menu changed  string name super null this name name 
 returns the name of the menu in question public  string get menu name return name 
public  string param string return menu name super param string 
 creates a new message param source  the message source since j edit pre protected eb message  object source this source source 
 creates a new message param source  the message source protected eb message eb component source this source source 
 returns the sender of this message since j edit pre public  object get source return source 
 returns a string representation of this message  override public  string to string  string class name get class get name int index class name last index of return class name substring index param string 
 returns a string representation of this message s parameters public  string param string return source source 
 handles a message sent on the  edit bus next version remove this public void handle message eb message message  edit bus remove from bus this if seen warning return seen warning true  log log  log warning this get class name should extend  edit plugin not eb plugin since it has an empty handle message 
protected eb plugin 
since j edit pre public  edit abbrev dialog  frame frame  string abbrev  string expansion  map abbrevs super frame j edit get property edit abbrev title true init abbrev expansion abbrevs 
public  edit abbrev dialog  dialog dialog  string abbrev  string expansion  map abbrevs super dialog j edit get property edit abbrev title true init abbrev expansion abbrevs 
public  string get abbrev if is ok return null return editor get abbrev 
public  string get expansion if is ok return null return editor get expansion 
private void init  string abbrev  string expansion  map abbrevs this abbrevs abbrevs this original abbrev abbrev j panel content new j panel new  border layout content set border new  empty border set content pane content editor new  abbrev editor editor set abbrev abbrev editor set expansion expansion editor set border new  empty border content add  border layout center editor  box box new  box  box layout x axis box add  box create glue ok new j button j edit get property common ok ok add action listener new  action handler get root pane set default button ok box add ok box add  box create horizontal strut cancel new j button j edit get property common cancel cancel add action listener new  action handler box add cancel box add  box create glue content add  border layout south box  key listener listener new  key handler add key listener listener editor get before caret text area add key listener listener editor get after caret text area add key listener listener set default close operation dispose on close pack set location relative to get parent set visible true 
private boolean check for existing abbrev  string abbrev editor get abbrev if abbrevs get abbrev null if abbrev equals original abbrev return true int result gui utilities confirm this edit abbrev duplicate null j option pane yes no option j option pane warning message return result j option pane yes option return true 
public void action performed  action event evt if evt get source ok if editor get abbrev null editor get abbrev length get toolkit beep return if check for existing abbrev return is ok true dispose 
public void key pressed  key event evt if evt get key code  key event vk escape dispose 
 creates a new edit action with the specified name param name  the action name public  edit action  string name super name 
public  edit action  string name  object new args super name new args 
 returns the action s label  this returns the value of the property named by link get name suffixed with code label code public  string get label if args null return j edit get property name label args return j edit get property name label 
 returns the action s mouse over message  this returns the value of the property named by link get name suffixed with code mouse over code public final  string get mouse over text return j edit get property name mouse over 
deprecated  call code gui utilities get view code instead public static  view get view  component comp moved to gui utilities as it makes no sense being here return gui utilities get view comp 
 returns if this edit action should be displayed as a check box in menus  this returns the value of the property named by link get name suffixed with code toggle code since j edit pre public final boolean is toggle return j edit get boolean property name toggle 
 if this edit action is a toggle returns if it is selected or not param comp  the component since j edit pre public boolean is selected  component comp return false 
 returns if this edit action should not be repeated  returns false by default since j edit pre public boolean no repeat return false 
 returns if this edit action should not be recorded  returns false by default since j edit pre public boolean no record return false 
 returns if this edit action should not be remembered as the most recently invoked action since j edit pre public boolean no remember last return false 
 returns the  bean shell code that will replay this action  bean shell action get code returns something more interesting for  actions that were loaded from the actions xml file  you do not need to override this method if your action name is unique this  edit action was added to an  action set and that to an  action context of j edit concrete since j edit pre since j edit pre public  string get code return j edit get action name invoke view 
 creates a new action listener wrapper since j edit pre public  wrapper  action context context  string action name this context context this action name action name 
 called when the user selects this action from a menu  it passes the action through the link org gjt sp jedit gui  input handler invoke action  edit action method which performs any recording or repeating param evt  the action event public void action performed  action event evt  edit action action context get action action name if action null  log log  log warning this  unknown action action name else context invoke action evt action 
 adds a component to the bus  it will receive all messages sent on the bus param comp  the component to add public static void add to bus eb component comp add to bus  object comp 
 adds a component to the bus  methods annotated with the link eb handler annotation found in the component will be used as  edit bus message handlers if a message of a matching type is sent on the bus p  if the component implements link eb component then the link eb component handle message eb message method will be called for every message sent on the bus param comp  the component to add since j edit pre public static void add to bus  object comp components add component comp 
 removes a component from the bus param comp  the component to remove public static void remove from bus eb component comp remove from bus  object comp 
 removes a component from the bus param comp  the component to remove since pre public static void remove from bus  object comp components remove component comp 
 returns an array of all components connected to the bus deprecated  don t use this method  it now returns an empty array  deprecated public static eb component get components return new eb component 
 sends a message to all components on the bus in turn param message  the message public static void send eb message message  log log  log debug  edit bus class message to string components lock try send impl message finally components unlock 
private  edit bus 
private static void dispatch eb message handler emh eb message msg throws  exception if emh handler null emh handler invoke emh comp msg else assert emh comp instanceof eb component eb component emh comp handle message msg 
private static void send impl eb message message boolean is exact true  class type message get class while type equals  object class  list eb message handler handlers components get type if handlers null try for eb message handler emh handlers if is exact emh source null emh source exact continue if  debug eb timer long start  system nano time dispatch emh message long time  system nano time start if time  log log  log debug  edit bus class emh comp time ns else dispatch emh message catch  throwable t  log log  log error  edit bus class  exception while sending message on  edit bus  log log  log error  edit bus class t type type get superclass is exact false 
eb message handler  object comp  method handler eb handler source this comp comp this handler handler this source source 
public  list eb message handler safe get  class type  list eb message handler lst super get type if lst null lst new  linked list eb message handler super put type lst return lst 
public synchronized void lock lock 
public synchronized void unlock lock if lock for  object comp add add component comp for  object comp remove remove component comp add clear remove clear 
public synchronized void remove component  object comp if lock remove add comp return for  class msg key set  list eb message handler handlers get msg if handlers null continue for  iterator eb message handler it handlers iterator it has next eb message handler emh it next if emh comp comp it remove 
public synchronized void add component  object comp if lock add add comp return for  method m comp get class get methods eb handler source m get annotation eb handler class if source null continue  class params m get parameter types if params length  log log  log error  edit bus class  invalid eb handler method m get name in class comp get class get name too many parameters continue if eb message class is assignable from params  log log  log error  edit bus class  invalid parameter params get name in method m get name of class comp get class get name continue synchronized components safe get params add new eb message handler comp m source  if the component implements eb component then add the default handler for backwards compatibility if comp instanceof eb component safe get eb message class add new eb message handler comp null null 
public  editing option pane super editing 
 override protected void  init  mode modes j edit get modes  arrays sort modes new  standard utilities  string compare  mode true global new  mode properties mode props new  mode properties modes length  string mode names new  string modes length mode names j edit get property options editing global for int i i modes length i mode props i new  mode properties modes i mode names i modes i get name mode new j combo box mode names mode add action listener new  action handler caption box new  box  box layout x axis add component caption box add component j edit get property options editing mode mode use defaults new j check box j edit get property options editing use defaults use defaults add action listener new  action handler add component use defaults add component j edit get property options editing no word sep no word sep new j text field add component camel cased words new j check box j edit get property options editing camel cased words  string fold modes  fold handler get fold modes add component j edit get property options editing folding folding new j combo box fold modes add component j edit get property options editing collapse folds collapse folds new j text field  string wrap modes none soft hard add component j edit get property options editing wrap wrap new j combo box wrap modes  string line lens max line len new j combo box line lens max line len set tool tip text j edit get property options editing max line len tooltip add component j edit get property options editing max line len max line len max line len set editable true  string tab sizes add component j edit get property options editing tab size tab size new j combo box tab sizes tab size set editable true add component j edit get property options editing indent size indent size new j combo box tab sizes indent size set editable true add component no tabs new j check box j edit get property options editing no tabs add component deep indent new j check box j edit get property options editing deep indent filename glob new j text field filename glob set tool tip text j edit get property glob tooltip add component j edit get property options editing filename glob filename glob add component j edit get property options editing firstline glob firstline glob new j text field select mode add separator default mode new j combo box modes default mode set selected item j edit get mode j edit get property buffer default mode add component j edit get property options editing default mode default mode undo count new j text field j edit get property buffer undo count add component j edit get property options editing undo count undo count  reset  undo  manager  on  save reset undo on save new j check box j edit get property options general reset undo reset undo on save set selected j edit get boolean property reset undo on save add component reset undo on save 
 override protected void  save j edit set property buffer default mode  mode default mode get selected item get name j edit set property buffer undo count undo count get text j edit set boolean property reset undo on save reset undo on save is selected save mode global save for int i i mode props length i mode props i save 
private void save mode current use defaults use defaults is selected current filename glob filename glob get text current firstline glob firstline glob get text current no word sep no word sep get text current camel cased words camel cased words is selected current folding  string folding get selected item current collapse folds collapse folds get text current wrap  string wrap get selected item current max line len  string max line len get selected item current tab size  string tab size get selected item current indent size  string indent size get selected item current no tabs no tabs is selected current deep indent deep indent is selected 
private void select mode int index mode get selected index current index global mode props index current edited true current load caption box remove all caption box add gui utilities create multiline label j edit get property options editing caption index use defaults set selected current use defaults filename glob set text current filename glob firstline glob set text current firstline glob no word sep set text current no word sep camel cased words set selected current camel cased words folding set selected item current folding collapse folds set text current collapse folds wrap set selected item current wrap max line len set selected item current max line len tab size set selected item current tab size indent size set selected item current indent size no tabs set selected current no tabs deep indent set selected current deep indent update enabled revalidate 
private void update enabled boolean enabled if current global enabled true use defaults set enabled false filename glob set enabled false firstline glob set enabled false else enabled mode props mode get selected index use defaults use defaults set enabled true filename glob set enabled enabled firstline glob set enabled enabled no word sep set enabled enabled camel cased words set enabled enabled folding set enabled enabled collapse folds set enabled enabled wrap set enabled enabled max line len set enabled enabled tab size set enabled enabled indent size set enabled enabled no tabs set enabled enabled deep indent set enabled enabled 
public void action performed  action event evt  object source evt get source if source mode save mode select mode else if source use defaults mode props mode get selected index use defaults use defaults is selected update enabled 
 mode properties 
 mode properties  mode mode this mode mode 
void load if loaded return loaded true if mode null mode load if necessary use defaults j edit get boolean property mode mode get name custom settings filename glob  string mode get property filename glob firstline glob  string mode get property firstline glob no word sep  string mode get property no word sep camel cased words mode get boolean property camel cased words folding mode get property folding to string collapse folds mode get property collapse folds to string wrap mode get property wrap to string max line len mode get property max line len to string tab size mode get property tab size to string indent size mode get property indent size to string no tabs mode get boolean property no tabs deep indent mode get boolean property deep indent else no word sep j edit get property buffer no word sep camel cased words j edit get boolean property buffer camel cased words folding j edit get property buffer folding collapse folds j edit get property buffer collapse folds wrap j edit get property buffer wrap max line len j edit get property buffer max line len tab size j edit get property buffer tab size indent size j edit get property buffer indent size no tabs j edit get boolean property buffer no tabs deep indent j edit get boolean property buffer deep indent 
void save don t do anything if the user didn t change any settings if edited return  string prefix if mode null prefix mode mode get name j edit set boolean property prefix custom settings use defaults need to call  mode init if the file name or first line globs change  string old filename glob  string mode get property filename glob  string old firstline glob  string mode get property firstline glob if use defaults j edit reset property prefix filename glob j edit reset property prefix firstline glob j edit reset property prefix no word sep j edit reset property prefix camel cased words j edit reset property prefix folding j edit reset property prefix collapse folds j edit reset property prefix wrap j edit reset property prefix max line len j edit reset property prefix tab size j edit reset property prefix indent size j edit reset property prefix no tabs j edit reset property prefix deep indent if  standard utilities objects equal old filename glob mode get property filename glob  standard utilities objects equal old firstline glob mode get property firstline glob mode init return else j edit set property prefix filename glob filename glob j edit set property prefix firstline glob firstline glob if  standard utilities objects equal old filename glob filename glob  standard utilities objects equal old firstline glob firstline glob mode init else prefix buffer j edit set property prefix no word sep no word sep j edit set boolean property prefix camel cased words camel cased words j edit set property prefix folding folding j edit set property prefix collapse folds collapse folds j edit set property prefix wrap wrap j edit set property prefix max line len max line len j edit set property prefix tab size tab size j edit set property prefix indent size indent size j edit set boolean property prefix no tabs no tabs j edit set boolean property prefix deep indent deep indent 
 creates a new editor exiting message param source  the message source public  editor exiting eb component source super source 
 creates a new editor exiting started message param view  the view from which this exit was called public  editor exit requested  view view super view 
 returns the view involved public  view get view return  view get source 
 cancels the exit process  if a plugin calls this method j edit will not exit anymore public void cancel exit has been exit cancelled true 
 check if the exit process has been cancelled public boolean has been exit cancelled return has been exit cancelled 
 creates a new editor started message param source  the message source public  editor started eb component source super source 
 returns the view containing this edit pane return the view that contains this  edit pane since j edit pre public  view get view return view 
 returns the  edit pane of a  text area param ta the text area return the  edit pane containing the  text area public static  edit pane get  text area ta if ta null return null return  edit pane  swing utilities get ancestor of class  edit pane class ta 
 returns the current buffer return the current buffer since j edit pre public  buffer get buffer return buffer 
 sets the current buffer param buffer  the buffer to edit since j edit pre public void set buffer  buffer buffer set buffer buffer true 
 sets the current buffer param buffer  the buffer to edit param request focus true if the textarea should request focus false otherwise since j edit pre public void set buffer final  buffer buffer boolean request focus if buffer null throw new  null pointer exception if this buffer buffer return if buffer set index of buffer j edit get buffer set manager add buffer this buffer if buffer inside compound edit buffer end compound edit  edit bus send new  buffer changing this buffer if buffer set index of this buffer when closing the last buffer of a buffer set the current buffer will still be the closed buffer until a new empty buffer is created  so if the current buffer is not anymore in the buffer set do not set the recent buffer recent buffer this buffer if recent buffer null save caret info this buffer buffer text area set buffer buffer if init view update title if buffer switcher null if buffer switcher get selected item buffer buffer switcher set selected item buffer buffer switcher set tool tip text buffer get path  edit bus send new  edit pane update this  edit pane update buffer changed if request focus  swing utilities invoke later new  runnable public void run only do this if we are the current edit pane if view get edit pane  edit pane this buffer switcher null buffer switcher is popup visible text area request focus  only do this after all i o requests are complete  runnable runnable new  runnable public void run avoid a race condition see bug if buffer get buffer load caret info if buffer is performing io vfs manager run in awt thread runnable else runnable run 
 selects the previous buffer since j edit pre public void prev buffer  buffer buffer buffer set get previous buffer buffer set index of this buffer set buffer buffer 
 selects the next buffer since j edit pre public void next buffer  buffer buffer buffer set get next buffer buffer set index of this buffer set buffer buffer 
 selects the most recently edited buffer since j edit pre public void recent buffer if recent buffer null set buffer recent buffer else get toolkit beep 
 sets the focus onto the text area since j edit pre public void focus on text area  swing utilities invoke later new  runnable public void run text area request focus 
 returns the view s text area return the text area of the edit pane since j edit pre public j edit text area get text area return text area 
 returns the buffer switcher combo box instance return the buffer switcher it can be null since j edit pre public  buffer switcher get buffer switcher return buffer switcher 
 pops up and focuses on the buffer switcher combo box since j edit pre previously known as show buffer switcher public void focus buffer switcher if buffer switcher null get toolkit beep else  swing utilities invoke later new  runnable public void run buffer switcher request focus buffer switcher show popup 
 saves the caret information to the current buffer since j edit pre public void save caret info if buffer is loaded return buffer set integer property  buffer caret text area get caret position  caret info caret info carets for path get buffer get path if caret info null caret info new  caret info carets for path put buffer get path caret info caret info caret text area get caret position  selection selection text area get selection for int i i selection length i selection i  selection selection i clone buffer set property  buffer selection selection caret info selection selection caret info rectangular selection text area is rectangular selection enabled caret info multiple selection text area is multiple selection enabled buffer set integer property  buffer scroll vert text area get first physical line caret info scroll vert text area get first physical line buffer set integer property  buffer scroll horiz text area get horizontal offset caret info scroll horiz text area get horizontal offset if buffer is untitled  buffer history set entry buffer get path text area get caret position  selection buffer get property  buffer selection buffer get string property j edit buffer encoding buffer get mode get name 
 loads the caret and selection information from this  edit pane fall back to the information from the current buffer if none is already in this  edit pane since j edit pre public void load caret info get our internal map of buffer  caret info since there might be current info already  caret info caret info carets for path get buffer get path if caret info null caret info new  caret info set the position of the caret itself  caret position could be stored in the internal map already if so use that one first  otherwise fall back to any previously saved caret position that was stored in the buffer properties int caret caret info caret if caret buffer get boolean property  buffer caret positioned  integer i  integer buffer get property  buffer caret caret i null i buffer unset property  buffer caret positioned if caret text area set caret position  math min caret buffer get length set any selections  selection selection caret info selection if selection null selection  selection buffer get property  buffer selection if selection null for int i i selection length i  selection s selection i int max buffer get length if s get start max s get end max selection i null text area set selection selection text area set rectangular selection enabled caret info rectangular selection text area set multiple selection enabled caret info multiple selection set first line value int first line caret info scroll vert if first line  integer i  integer buffer get property  buffer scroll vert first line i null i if first line text area set first physical line first line set horizontal offset int horizontal offset caret info scroll horiz if horizontal offset  integer i  integer buffer get property  buffer scroll horiz horizontal offset i null i if horizontal offset text area set horizontal offset horizontal offset  silly bug workaround  if you look at the above code note that we restore the saved caret position first then scroll to the saved location  however the caret changing can itself result in scrolling to a different location than what was saved and since move caret position calls update bracket highlight the bracket highlight s out of bounds calculation will rely on a different set of physical first last lines than what we will end up with eventually  instead of confusing the user with status messages that appear at random when switching buffers we simply hide the message altogether view get status set message null 
 this method should be called by the  buffer when the path is changing param old path the old path of the buffer param new path the new path of the buffer void buffer renamed  string old path  string new path  caret info caret info carets for path remove old path if caret info null carets for path put new path caret info 
 moves the caret to the next marker since j edit pre public void go to next marker boolean select java util  list  marker markers buffer get markers if markers is empty get toolkit beep return  marker marker null int caret text area get caret position for int i i markers size i  marker  marker markers get i if  marker get position caret marker  marker break the markers list is not empty at this point if marker null marker markers get if select text area extend selection caret marker get position else if text area is multiple selection enabled text area select none text area move caret position marker get position 
 moves the caret to the previous marker since j edit pre public void go to prev marker boolean select java util  list  marker markers buffer get markers if markers is empty get toolkit beep return int caret text area get caret position  marker marker null for int i markers size i i  marker  marker markers get i if  marker get position caret marker  marker break if marker null marker markers get markers size if select text area extend selection caret marker get position else if text area is multiple selection enabled text area select none text area move caret position marker get position 
 moves the caret to the marker with the specified shortcut param shortcut  the shortcut param select  true if the selection should be extended false otherwise since j edit pre public void go to marker char shortcut boolean select  marker marker buffer get marker shortcut if marker null get toolkit beep return int pos marker get position if select text area extend selection text area get caret position pos else if text area is multiple selection enabled text area select none text area move caret position pos 
 adds a marker at the caret position since j edit pre public void add marker int caret line text area get caret line always add markers on selected lines  selection selection text area get selection for int i i selection length i  selection s selection i int start line s get start line if start line s get end line start line caret line buffer add marker s get start if s get end line caret line buffer add marker s get end toggle marker on caret line buffer add or remove marker text area get caret position 
 moves the caret to the marker with the specified shortcut then sets the marker position to the former caret position param shortcut  the shortcut since j edit pre public void swap marker and caret char shortcut  marker marker buffer get marker shortcut if marker null get toolkit beep return int caret text area get caret position text area set caret position marker get position buffer add marker shortcut caret 
public void handle message eb message msg if msg instanceof  properties changed properties changed load buffer switcher else if msg instanceof  buffer update handle buffer update  buffer update msg 
 returns for split pane compatibility  override public final  dimension get minimum size return new  dimension 
 returns the current buffer set  this can be changed by set buffer set scope return the buffer set which is currently used by this  edit pane since j edit pre public  buffer set get buffer set return buffer set 
 get the current scope of buffer set since j edit pre public  buffer set  scope get buffer set scope return buffer set scope 
 set the scope of buffer set for the  edit pane param scope the new scope since j edit pre public void set buffer set scope  buffer set  scope scope if this buffer set scope scope  buffer set old buffer set this buffer set  buffer set new buffer set switch scope case editpane new buffer set new  buffer set break case view new buffer set view get local buffer set break default scope  buffer set  scope global case global new buffer set j edit get global buffer set break  buffer set manager buffer set manager j edit get buffer set manager if j edit is startup done  ignore new buffersets contain option when loading perspective  string action j edit get property editpane bufferset new  buffer set manager  new buffer set action buffer set action  buffer set manager  new buffer set action from string action  view active view j edit get active view switch buffer set action case copy if old buffer set null  edit pane edit pane view get edit pane if edit pane null if active view null edit pane active view get edit pane if edit pane null buffer set manager add all buffers new buffer set else buffer set manager merge buffer set new buffer set edit pane buffer set else buffer set manager merge buffer set new buffer set old buffer set break case empty break case currentbuffer if active view null break  edit pane edit pane active view get edit pane  buffer buffer edit pane get buffer buffer set manager add buffer new buffer set buffer break if buffer null buffer set manager add buffer new buffer set buffer this buffer set new buffer set this buffer set scope scope if new buffer set size j edit new file this  this must be after updating this buffer set since remove buffer set listener uses  edit pane get buffer set on this  edit pane if old buffer set null old buffer set remove buffer set listener this new buffer set add buffer set listener this if buffer switcher null buffer switcher update buffer list  edit bus send new  edit pane update this  edit pane update bufferset changed if new buffer set index of recent buffer the recent buffer is not in the buffer set recent buffer null if new buffer set index of buffer the current buffer is not contained in the buffer set we must change the current buffer if recent buffer null set buffer recent buffer else set buffer new buffer set get buffer if j edit is startup done  do not mark perspective dirty on startup  perspective manager set perspective dirty true 
a buffer was added in the buffer set param buffer the added buffer param index the position where it was added since j edit pre public void buffer added  buffer buffer int index if buffer null return if buffer switcher null buffer switcher update buffer list if buffer set index of this buffer it happens when having untitled buffer if i open a file  the untitled buffer is closed but the new buffer is not yet opened set buffer buffer 
a buffer was removed from the buffer set param buffer the removed buffer param index the position where it was before being removed since j edit pre public void buffer removed  buffer buffer int index if buffer is untitled the buffer was a new file so i do not need to keep it s informations carets for path remove buffer get path if buffer this buffer  the closed buffer is the current buffer  buffer new buffer recent buffer null recent buffer buffer set get previous buffer index if new buffer null new buffer is closed set buffer new buffer if buffer set size recent buffer buffer set get previous buffer index else if buffer set size set buffer buffer set get buffer recent buffer null if buffer recent buffer recent buffer null if buffer switcher null buffer switcher update buffer list 
a buffer was moved in the  buffer set param buffer the moved buffer param old index the position it was before param new index the new position since j edit pre public void buffer moved  buffer buffer int old index int new index if buffer switcher null buffer switcher update buffer list 
 the buffer set was sorted since j edit pre public void buffer set sorted if buffer switcher null buffer switcher update buffer list 
 override public  string to string return get class get name view get edit pane this active inactive buffer set scope 
 edit pane  view view  buffer buffer  buffer set  scope scope super new  border layout init true this view view text area new j edit text area view text area get painter set anti alias new  anti alias j edit get property view anti alias text area set mouse handler new  mouse handler text area text area set transfer handler new  text area transfer handler marker highlight new  marker highlight  gutter gutter text area get gutter gutter set gutter enabled  gutter option pane is gutter enabled gutter set min line number digit count  gutter option pane get min line number digits gutter set selection area enabled  gutter option pane is selection area enabled gutter add extension marker highlight gutter set selection popup handler new  gutter popup handler public void handle popup int x int y int line  buffer buffer get buffer buffer add or remove marker buffer get line start offset line text area add status listener new  status handler add  border layout center text area properties changed this buffer buffer set buffer set scope scope this buffer null if buffer null set buffer j edit get first buffer else set buffer buffer load buffer switcher init false  edit bus add to bus this 
void close save caret info  edit bus send new  edit pane update this  edit pane update destroyed  edit bus remove from bus this text area dispose 
private void properties changed  text area painter painter text area get painter init painter painter  gutter gutter text area get gutter gutter set expanded j edit get boolean property view gutter line numbers int interval j edit get integer property view gutter highlight interval gutter set highlight interval interval gutter set current line highlight enabled j edit get boolean property view gutter highlight current line gutter set structure highlight enabled j edit get boolean property view gutter structure highlight gutter set structure highlight color j edit get color property view gutter structure highlight color gutter set background j edit get color property view gutter bg color gutter set foreground j edit get color property view gutter fg color gutter set highlighted foreground j edit get color property view gutter highlight color gutter set fold color j edit get color property view gutter fold color marker highlight set marker highlight color j edit get color property view gutter marker color marker highlight set marker highlight enabled j edit get boolean property view gutter marker highlight gutter set current line foreground j edit get color property view gutter current line color  string alignment j edit get property view gutter number alignment if right equals alignment gutter set line number alignment  gutter right else if center equals alignment gutter set line number alignment  gutter center else left default case gutter set line number alignment  gutter left gutter set font j edit get font property view gutter font gutter set gutter enabled  gutter option pane is gutter enabled gutter set min line number digit count  gutter option pane get min line number digits gutter set selection area enabled  gutter option pane is selection area enabled gutter set selection area background  gutter option pane get selection area background gutter set selection area width  gutter option pane get selection area width int width j edit get integer property view gutter border width gutter set border width j edit get color property view gutter focus border color j edit get color property view gutter no focus border color text area get painter get background gutter set fold painter text area get fold painter text area set caret blink enabled j edit get boolean property view caret blink text area set electric scroll j edit get integer property view electric borders  set up the right click popup menu text area create popup menu null use old property name for backwards compatibility text area set quick copy enabled j edit get boolean property view middle mouse paste text area set drag enabled j edit get boolean property view drag and drop text area set join non word chars j edit get boolean property view join non word chars text area set ctrl for rectangular selection j edit get boolean property view ctrl for rectangular selection text area properties changed if buffer switcher null buffer switcher set maximum row count j edit get integer property buffer switcher max row count 
 init the painter of a textarea param painter the painter of a textarea since j edit pre public static void init painter  text area painter painter painter set font j edit get font property view font painter set structure highlight enabled j edit get boolean property view structure highlight painter set structure highlight color j edit get color property view structure highlight color painter set eol markers painted j edit get boolean property view eol markers painter set eol marker color j edit get color property view eol marker color painter set wrap guide painted j edit get boolean property view wrap guide painter set wrap guide color j edit get color property view wrap guide color painter set caret color j edit get color property view caret color painter set selection color j edit get color property view selection color painter set multiple selection color j edit get color property view multiple selection color painter set background j edit get color property view bg color painter set foreground j edit get color property view fg color painter set block caret enabled j edit get boolean property view block caret painter set thick caret enabled j edit get boolean property view thick caret painter set line highlight enabled j edit get boolean property view line highlight painter set line highlight color j edit get color property view line highlight color painter set anti alias new  anti alias j edit get property view anti alias painter set fractional font metrics enabled j edit get boolean property view frac font metrics  string default font j edit get property view font int default font size j edit get integer property view fontsize painter set styles  syntax utilities load styles default font default font size  syntax style fold line style new  syntax style for int i i i fold line style i gui utilities parse style j edit get property view style fold line i default font default font size painter set fold line style fold line style 
void load buffer switcher if j edit get boolean property view show buffer switcher if buffer switcher null buffer switcher new  buffer switcher this add  border layout north buffer switcher buffer switcher update buffer list revalidate else if buffer switcher null remove buffer switcher revalidate buffer switcher null 
private void handle buffer update  buffer update msg  buffer  buffer msg get buffer if msg get what  buffer update created if buffer switcher null buffer switcher update buffer list  when closing the last buffer the  buffer update closed handler doesn t call set buffer because null buffers are not supported  instead it waits for the subsequent  untitled file creation if buffer is closed since recent buffer will be set to the one that was closed recent buffer null else if msg get what  buffer update closed if buffer switcher null buffer switcher update buffer list if  buffer buffer  the closed buffer is the current buffer  buffer new buffer recent buffer null recent buffer  buffer get prev if new buffer null new buffer is closed set buffer new buffer recent buffer new buffer get prev else if  buffer recent buffer recent buffer null  buffer closed buffer msg get buffer if closed buffer is untitled the buffer was a new file so i do not need to keep it s informations carets for path remove closed buffer get path else if msg get what  buffer update load started if  buffer buffer text area set caret position text area get painter repaint else if msg get what  buffer update loaded if  buffer buffer text area repaint if buffer switcher null buffer switcher update buffer list if view get edit pane this  status bar status view get status status update caret status status update buffer status status update misc status load caret info else if msg get what  buffer update dirty changed if  buffer buffer buffer switcher null if buffer is dirty buffer switcher repaint else buffer switcher update buffer list else if msg get what  buffer update markers changed if  buffer buffer text area get gutter repaint else if msg get what  buffer update properties changed if  buffer buffer buffer is loaded text area properties changed if view get edit pane this view get status update buffer status else if msg get what  buffer update saved  buffer buffer text area properties changed 
public void status changed org gjt sp jedit textarea  text area text area int flag boolean value  status bar status view get status if status null return switch flag case overwrite changed status set message and clear j edit get property view status overwrite changed new  integer value break case multi select changed status set message and clear j edit get property view status multi changed new  integer value break case rect select changed status set message and clear j edit get property view status rect select changed new  integer value break status update misc status 
public void bracket selected org gjt sp jedit textarea  text area text area int line  string text  status bar status view get status if status null return status set message and clear j edit get property view status bracket new  object line text 
public void narrow active org gjt sp jedit textarea  text area text area  status bar status view get status if status null return status set message and clear j edit get property view status narrow 
public  color get marker highlight color return marker highlight color 
public void set marker highlight color  color marker highlight color this marker highlight color marker highlight color 
public boolean is marker highlight enabled return marker highlight 
public void set marker highlight enabled boolean marker highlight this marker highlight marker highlight 
 override public void paint valid line  graphics d gfx int screen line int physical line int start int end int y if is marker highlight enabled  buffer buffer  buffer text area get buffer if buffer get marker in range start end null gfx set color get marker highlight color  font metrics fm text area get painter get font metrics gfx fill rect y text area get gutter get width fm get height 
 override public  string get tool tip text int x int y if is marker highlight enabled int line height text area get painter get font metrics get height if line height return null int line y line height int start text area get screen line start offset line int end text area get screen line end offset line if start end return null  buffer buffer  buffer text area get buffer  marker marker buffer get marker in range start end if marker null char shortcut marker get shortcut if shortcut return j edit get property view gutter marker no name else  string args  string value of shortcut return j edit get property view gutter marker args return null 
 creates a new edit pane update message param edit pane  the edit pane param what  what happened public  edit pane update  edit pane edit pane  object what super edit pane if what null throw new  null pointer exception  what must be non null this what what 
 returns what caused this edit pane update public  object get what return what 
 returns the edit pane involved public  edit pane get edit pane return  edit pane get source 
public  string param string return what what super param string 
j edit calls this method when the plugin is being activated either during startup or at any other time a plugin can get activated for a number of reasons ul li  the plugin is written for j edit or older in which case it will always be loaded at startup li li  the plugin has its code activate code property set to code startup code in which case it will always be loaded at startup li li  one of the properties listed in the plugin s code activate code property is set to code true code in which case it will always be loaded at startup li li  one of the plugin s classes is being accessed by another plugin a macro or a  bean shell snippet in a plugin api xml file li ul  note that this method is always called from the event dispatch thread even if the activation resulted from a class being loaded from another thread a side effect of this is that some of your plugin s code might get executed before this method finishes running p  when this method is being called for plugins written for j edit and below no views or buffers are open  however this is not the case for plugins using the new api  for example if your plugin adds tool bars to views make sure you correctly handle the case where views are already open when the plugin is loaded p  if your plugin must be loaded on startup take care to have this method return as quickly as possible p  the default implementation of this method does nothing since j edit pre public void start 
j edit calls this method when the plugin is being unloaded  this can be when the program is exiting or at any other time p  if a plugin uses state information or other persistent data that should be stored in a special format this would be a good place to write the data to storage  if the plugin uses j edit s properties api to hold settings no special processing is needed for them on exit since they will be saved automatically p  with plugins written for j edit and below this method is only called when the program is exiting  however this is not the case for plugins using the new api  for example if your plugin adds tool bars to views make sure you correctly handle the case where views are still open when the plugin is unloaded p  to avoid memory leaks this method should ensure that no references to any objects created by this plugin remain in the heap  in the case of actions dockable windows and services j edit ensures this automatically  for other objects your plugin must clean up maually p  the default implementation of this method does nothing since j edit pre public void stop 
 returns the home of your plugin return the plugin home  it can be null if there is no settings directory since pre see get resource as stream see get resource as output stream see get resource path public  file get plugin home return get plugin home get class name 
p  returns the home of the specified plugin p p  since the first parameter is a reference to the code  class instance for the plugin this method requires the plugin to be activated p p  see link get plugin home  edit plugin method as an alternate for when the plugin doesn t need to be activated or when you do not have the code  class instance available p param clazz the class of the plugin return the plugin home  it can be null if there is no settings directory since pre see get plugin home  edit plugin see get resource as stream see get resource as output stream see get resource path public static  file get plugin home  class extends  edit plugin clazz return get plugin home clazz get name 
p  returns the home of the specified plugin p p  this method doesn t need the plugin to be activated  you can pass an code  edit plugin  deferred instance that you get from code j edit get plugin  string or code j edit get plugins if the plugin in question is not activated yet and this method doesn t cause the plugin to get activated  if you have a reference to the plugins code  class instance available consider using the code  class method p param plugin the plugin return the plugin home  it can be null if there is no settings directory since pre see get plugin home  class see get resource as stream see get resource as output stream see get resource path public static  file get plugin home  edit plugin plugin return get plugin home plugin get class name 
 returns the home of the specified plugin param plugin class name the plugin class name fully qualified return the plugin home  it can be null if there is no settings directory since pre see get resource as stream see get resource as output stream see get resource path private static  file get plugin home  string plugin class name  string settings directory j edit get settings directory if settings directory null return null  file file new  file settings directory plugins if file is directory if file mkdir  log log  log error  edit plugin class  can t create directory file get absolute path return new  file file plugin class name 
p  returns an input stream to the specified resource or code null if none is found p p  since the first parameter is a reference to the code  class instance for the plugin this method requires the plugin to be activated p p  see link get resource as stream  edit plugin  string method as an alternate for when the plugin doesn t need to be activated or when you do not have the code  class instance available p param clazz the plugin class param path  the path to the resource to be returned relative to the plugin s resource path return  an input stream for the resource or code null code since pre see get plugin home see get resource as stream  edit plugin  string see get resource as output stream see get resource path public static  input stream get resource as stream  class extends  edit plugin clazz  string path return get resource as stream clazz get name path 
p  returns an input stream to the specified resource or code null code if none is found p p  this method doesn t need the plugin to be activated  you can pass an code  edit plugin  deferred instance that you get from code j edit get plugin  string or code j edit get plugins if the plugin in question is not activated yet and this method doesn t cause the plugin to get activated  if you have a reference to the plugins code  class instance available consider using the code  class method p param plugin the plugin param path  the path to the resource to be returned relative to the plugin s resource path return  an input stream for the resource or code null code since pre see get plugin home see get resource as stream  class  string see get resource as output stream see get resource path public static  input stream get resource as stream  edit plugin plugin  string path return get resource as stream plugin get class name path 
 returns an input stream to the specified resource or code null code if none is found param plugin class name the plugin class name fully qualified param path  the path to the resource to be returned relative to the plugin s resource path return  an input stream for the resource or code null code since pre see get plugin home see get resource as output stream see get resource path private static  input stream get resource as stream  string plugin class name  string path try  file file get resource path plugin class name path if file null file exists return null return new  file input stream file catch io exception e return null 
p  returns an output stream to the specified resource or code null if access to that resource is denied p p  since the first parameter is a reference to the code  class instance for the plugin this method requires the plugin to be activated p p  see link get resource as output stream  edit plugin  string method as an alternate for when the plugin doesn t need to be activated or when you do not have the code  class instance available p param clazz the plugin class param path  the path to the resource to be returned relative to the plugin s resource path return  an output stream for the resource or code null code since pre see get plugin home see get resource as output stream  edit plugin  string see get resource as stream see get resource path public static  output stream get resource as output stream  class extends  edit plugin clazz  string path return get resource as output stream clazz get name path 
p  returns an output stream to the specified resource or code null node if access to that resource is denied p p  this method doesn t need the plugin to be activated  you can pass an code  edit plugin  deferred instance that you get from code j edit get plugin  string or code j edit get plugins if the plugin in question is not activated yet and this method doesn t cause the plugin to get activated  if you have a reference to the plugins code  class instance available consider using the code  class method p param plugin the plugin param path  the path to the resource to be returned relative to the plugin s resource path return  an output stream for the resource or code null code since pre see get plugin home see get resource as output stream  class  string see get resource as stream see get resource path public static  output stream get resource as output stream  edit plugin plugin  string path return get resource as output stream plugin get class name path 
 returns an output stream to the specified resource or code null node if access to that resource is denied param plugin class name the plugin class name fully qualified param path  the path to the resource to be returned relative to the plugin s resource path return  an output stream for the resource or code null code since pre see get plugin home see get resource as stream see get resource path private static  output stream get resource as output stream  string plugin class name  string path try  file file get resource path plugin class name path if file null return null  file parent file file get parent file if parent file exists if parent file mkdirs  log log  log error  edit plugin class  unable to create folder parent file get path return null return new  file output stream file catch io exception e return null 
p  returns the full path of the specified plugin resource p p  since the first parameter is a reference to the code  class instance for the plugin this method requires the plugin to be activated p p  see link get resource path  edit plugin  string method as an alternate for when the plugin doesn t need to be activated or when you do not have the code  class instance available p param clazz the plugin class param path  the relative path to the resource from the plugin s resource path return  the absolute path to the resource or null if there is no plugin home since pre see get plugin home see get resource as output stream see get resource as stream see get resource path  edit plugin  string public static  file get resource path  class extends  edit plugin clazz  string path return get resource path clazz get name path 
p  returns the full path of the specified plugin resource p p  this method doesn t need the plugin to be activated  you can pass an code  edit plugin  deferred instance that you get from code j edit get plugin  string or code j edit get plugins if the plugin in question is not activated yet and this method doesn t cause the plugin to get activated  if you have a reference to the plugins code  class instance available consider using the code  class method p param plugin the plugin param path  the relative path to the resource from the plugin s resource path return  the absolute path to the resource or null if there is no plugin home since pre see get plugin home see get resource as output stream see get resource as stream see get resource path  class  string public static  file get resource path  edit plugin plugin  string path return get resource path plugin get class name path 
 returns the full path of the specified plugin resource param plugin class name the plugin class name fully qualified param path  the relative path to the resource from the plugin s resource path return  the absolute path to the resource or null if there is no plugin home since pre see get plugin home see get resource as output stream see get resource as stream private static  file get resource path  string plugin class name  string path  file home get plugin home plugin class name if home null return null return new  file home path 
 returns the plugin s class name  this might not be the same as the class of the actual code  edit plugin code instance for example if the plugin is not loaded yet since j edit pre public  string get class name return get class get name 
 returns the jar file containing this plugin since j edit pre public  plugin jar get plugin jar return jar 
 called by the view when constructing its b  plugins b menu  see the description of this class for details about how the menu items are constructed from plugin properties since j edit pre public final j menu item create menu items if this instanceof  broken return null  string menu item name j edit get property plugin get class name menu item if menu item name null return gui utilities load menu item menu item name  string menu property plugin get class name menu  string code property plugin get class name menu code if j edit get property menu property null j edit get property code property null  string plugin name j edit get property plugin get class name name return new  enhanced menu menu property plugin name return null 
 called by the filesystem browser when constructing its b  plugins b menu  see the description of this class for details about how the menu items are constructed from plugin properties since j edit pre public final j menu item create browser menu items if this instanceof  broken return null  string menu item name j edit get property plugin get class name browser menu item if menu item name null return gui utilities load menu item vfs browser get action context menu item name false  string menu property plugin get class name browser menu if j edit get property menu property null  string plugin name j edit get property plugin get class name name return new  enhanced menu menu property plugin name vfs browser get action context return null 
deprecated  instead of overriding this method define properties as specified in the description of this class public void create menu items  vector menu items 
deprecated  instead of overriding this method define properties as specified in the description of this class public void create option panes  options dialog options dialog 
public  string get class name return clazz 
 broken  plugin jar jar  string clazz this jar jar this clazz clazz 
public  string get class name return clazz 
 deferred  plugin jar jar  string clazz this jar jar this clazz clazz 
 edit plugin load plugin class return null 
public  string to string return  deferred clazz 
 edit server  string port file super j edit server daemon port file set daemon true this port file port file try  on  unix set permissions of port file to rw so that on broken  unices which give everyone read access to user home dirs people can t see your port file and hence send arbitriary  bean shell code your way  nasty if  operating system is unix new  file port file create new file  file vfs set permissions port file  bind to any port on localhost accept simultaneous connection attempts before rejecting connections socket new  server socket  inet address get by name auth key new  random next int  integer max value int port socket get local port  file writer out new  file writer port file try out write b n out write  string value of port out write n out write  string value of auth key out write n finally out close ok true  log log  log debug this j edit server started on port socket get local port  log log  log debug this  authorization key is auth key catch io exception io on some  windows versions connections to localhost fail if the network is not running  to avoid confusing newbies with weird error messages log errors that occur while starting the server as notice not error  log log  log notice this io 
public void run for if abort return  socket client null try client socket accept  stop script kiddies from opening the edit server port and just leaving it open as a  do s client set so timeout  log log  log message this client connected  data input stream in new  data input stream client get input stream if handle client client in abort true catch  exception e if abort  log log  log error this e abort true finally if client null try client close catch  exception e  log log  log error this e client null 
param restore  ignored unless no views are open param parent  the client s parent directory param args a list of files  null entries are ignored for convinience since j edit pre public static void handle client boolean restore  string parent  string args handle client restore false false parent args 
param restore  ignored unless no views are open param new view  open a new view param new plain view  open a new plain view param parent  the client s parent directory param args a list of files  null entries are ignored for convinience since j edit pre public static  buffer handle client boolean restore boolean new view boolean new plain view  string parent  string args we have to deal with a huge range of possible border cases here if j edit get first view null coming out of background mode no views open no buffers open if args empty  buffer buffer j edit open files null parent args if j edit get buffer count j edit new file  edit pane null boolean restore files restore j edit get boolean property restore buffer null j edit get boolean property restore cli  view view  perspective manager load perspective restore files if view null if buffer null buffer j edit get first buffer view j edit new view null buffer else if buffer null view set buffer buffer false return buffer else if new plain view no background mode and opening a new view  buffer buffer j edit open files null parent args if buffer null buffer j edit get first buffer j edit new view null buffer true return buffer else if new view no background mode and opening a new view  buffer buffer j edit open files null parent args if buffer null buffer j edit get first buffer j edit new view j edit get active view buffer false return buffer else no background mode and reusing existing view  view view j edit get active view  buffer buffer j edit open files view parent args  hack done to fix bringing the window to the front  at least on windows  frame to front doesn t cut it  remove the is windows check if it s broken under other o ses too if j edit get boolean property server broken to front view set state java awt  frame iconified un iconify using jdk api view set state java awt  frame normal view request focus view to front return buffer 
boolean is ok return ok 
public int get port return socket get local port 
void stop server abort true try socket close catch io exception io new  file port file delete 
private boolean handle client final  socket client  data input stream in throws  exception int key in read int if key auth key  log log  log error this client wrong authorization key got key expected auth key in close client close return false else  reset the timeout client set so timeout  log log  log debug this client authenticated successfully final  string script in read utf  log log  log debug this script  swing utilities invoke later new  runnable public void run try  name space ns new  name space  bean shell get name space  edit server namespace ns set variable socket client  bean shell eval null ns script catch org gjt sp jedit bsh  util eval error e  log log  log error this e finally try  bean shell get name space set variable socket null catch org gjt sp jedit bsh  util eval error e  log log  log error this e return true 
 returns an instance of  encoding for specified name  the name is used for search the following domains in the listed order java nio charset  charset j edit  service manager public static  encoding get encoding  string name try return new  charset encoding name catch  illegal charset name exception e just failed catch  unsupported charset exception e just failed  object named service  service manager get service service class name if named service null named service instanceof  encoding return  encoding named service  unsupported charset exception is for java nio charset but throw this here too so that this can be caught as an encoding error by catch clause for general i o code throw new  unsupported charset exception  no such encoding name 
 returns the set of all available encoding names public static  set  string get available names  set  string set new  hash set  string set add all  charset available charsets key set set add all  arrays as list  service manager get service names service class return set 
 returns the set of user selected encoding names public static  set  string get selected names  set  string set get available names  iterator  string i set iterator while i has next  string name i next if j edit get boolean property encoding opt out name false i remove return set 
 returns a  reader object that reads the  input stream with the encoding  this method is same with get encoding encoding get text reader in public static  reader get text reader  input stream in  string encoding throws io exception return get encoding encoding get text reader in 
 returns a  writer object that writes to the  output stream with the encoding  this method is same with get encoding encoding get text writer out public static  writer get text writer  output stream out  string encoding throws io exception return get encoding encoding get text writer out 
 returns if the specified name is supported as a name for an  encoding public static boolean has encoding  string name try if  charset is supported name return true catch  illegal charset name exception e  the name is illegal for java nio charset  charset  but it may be legal for service name return  arrays as list  service manager get service names service class contains name 
public  encodings option pane super encodings 
 override protected void  init  default file encoding  string encodings get encodings true sort encodings new  standard utilities  string compare  string true default encoding new j combo box encodings default encoding set editable true default encoding set selected item j edit get property buffer j edit buffer encoding  system get property file encoding add component j edit get property options general encoding default encoding  auto detect encoding encoding autodetect new j check box j edit get property options general encoding autodetect encoding autodetect set selected j edit get boolean property buffer encoding autodetect add component encoding autodetect both  encoding detectors encoding detectors new j text field j edit get property encoding detectors bom xml pi add component j edit get property options general encoding detectors encoding detectors  fallback  encodings fallback encodings new j text field j edit get property fallback encodings fallback encodings set tool tip text j edit get property options general fallback encodings tooltip add component j edit get property options general fallback encodings fallback encodings  encodings to display encodings get encodings false sort encodings new  standard utilities  string compare  string true  vector  entry encoding entries vector new  vector  entry boolean enable select all false boolean enable select none false for  string encoding encodings boolean selected get boolean property encoding opt out encoding false enable select all enable select all selected enable select none enable select none selected encoding entries vector add new  entry selected encoding encodings list new j check box list encoding entries vector encodings list get model add table model listener new  table model handler j scroll pane encodings scroll pane new j scroll pane encodings list encodings scroll pane set border new  titled border get property options encodings select encodings  dimension d encodings list get preferred size d height  math min d height encodings scroll pane set preferred size d add component encodings scroll pane both  select  all  none  buttons  box buttons box create horizontal box buttons box add create horizontal strut  action handler action handler new  action handler select all button new j button get property options encodings select all select all button add action listener action handler select all button set enabled enable select all buttons box add select all button buttons box add create horizontal strut select none button new j button get property options encodings select none select none button add action listener action handler select none button set enabled enable select none buttons box add select none button buttons box add create horizontal strut add component buttons box 
 override protected void  save j edit set property buffer j edit buffer encoding  string default encoding get selected item j edit set boolean property buffer encoding autodetect encoding autodetect is selected j edit set property encoding detectors encoding detectors get text j edit set property fallback encodings fallback encodings get text for  entry entry encodings list get values if entry is checked unset property encoding opt out entry get value else set boolean property encoding opt out entry get value true 
public void action performed  action event ae  object source ae get source if source select all button encodings list select all else if source select none button for int i c encodings list get row count i c i encodings list set value at false i 
public void table changed  table model event tme int checked amount encodings list get checked values length if checked amount select none button set enabled false else select none button set enabled true if encodings list get values length checked amount select all button set enabled false else select all button set enabled true 
public  widget get widget  view view  encoding widget mode new  encoding widget view return mode 
public  encoding widget final  view view encoding new  tool tip label this view view encoding set tool tip text j edit get property view status mode tooltip encoding add mouse listener new  mouse adapter  override public void mouse clicked  mouse event evt if evt get click count new  buffer options view view get buffer 
public j component get component return encoding 
public void update  buffer buffer view get buffer if buffer is loaded encoding set text buffer get string property encoding 
public void properties changed 
public  encoding with bom  string plain byte bom bom map get plain if bom null throw new  unsupported charset exception plain with bom this plain new  charset encoding plain this bom bom 
public  reader get text reader  input stream in throws io exception byte actual mark new byte bom length int count in read actual mark if count bom length  arrays equals actual mark bom throw new  malformed input exception return plain get text reader in 
public  writer get text writer  output stream out throws io exception out write bom return plain get text writer out 
public  reader get permissive text reader  input stream in throws io exception byte actual mark new byte bom length int count in read actual mark if count bom length  arrays equals actual mark bom  concatenate the non bom bytes and the rest of input so that the non bom bytes are reinterepreted as some characters in new  sequence input stream new  byte array input stream actual mark count in return plain get permissive text reader in 
public  string detect encoding  input stream sample throws io exception byte mark new byte int count sample read mark byte low byte bom xff byte high byte bom xff if count if mark low mark high mark x mark x return x utf le bom else if mark x mark x mark high mark low return x utf be bom if count if mark low mark high return x utf le bom else if mark high mark low x utf be bom does not available  but an encoder for utf actually uses big endian with corresponding bom  it just works as utf be with bom return utf if count utf bom length int i while i utf bom length if mark i utf bom i break i if i utf bom length return utf y return null 
public  enhanced button  icon icon  string tool tip  string action  action context context super icon this action action if action null set the name of this button for instance if the action is vfs browser previous the name will be previous this helps greatly in testing the ui with  fest  swing int i suffix action last index of if i suffix i suffix action length set name action else set name action substring i suffix set enabled true add action listener new  edit action  wrapper context action add mouse listener new  mouse handler else set enabled false set tool tip text tool tip 
public boolean is focus traversable return false 
public void mouse released  mouse event evt if msg set gui utilities get view  component evt get source get status set message null msg set false 
public void mouse entered  mouse event evt  string msg j edit get property action mouse over if msg null gui utilities get view  component evt get source get status set message msg msg set true 
public void mouse exited  mouse event evt if msg set gui utilities get view  component evt get source get status set message null msg set false 
 creates a new menu item  most plugins should call gui utilities load menu item instead param label  the menu item label param action  the edit action param context  an action context since j edit pre public  enhanced check box menu item  string label  string action  action context context this context context this action action this shortcut gui utilities get shortcut label action if  operating system has screen menu bar shortcut null set text label shortcut shortcut null else set text label if action null set enabled true add action listener new  edit action  wrapper context action add mouse listener new  mouse handler else set enabled false set model new  model 
public  dimension get preferred size  dimension d super get preferred size if shortcut null d width get font metrics  enhanced menu item accelerator font string width shortcut return d 
public void paint  graphics g super paint g if shortcut null g set font  enhanced menu item accelerator font g set color get model is armed  enhanced menu item accelerator selection foreground  enhanced menu item accelerator foreground  font metrics fm g get font metrics  insets insets get insets g draw string shortcut get width fm string width shortcut insets right insets left get font get size insets top  operating system is mac oslf xxx magic number 
public boolean is selected if is showing return false  edit action a context get action action if a null  log log  log warning this  unknown action action return false try return a is selected  enhanced check box menu item this catch  throwable t  log log  log error this t return false 
public void set selected boolean b 
public void mouse released  mouse event evt if msg set gui utilities get view  component evt get source get status set message null msg set false 
public void mouse entered  mouse event evt  string msg j edit get property action mouse over if msg null gui utilities get view  component evt get source get status set message msg msg set true 
public void mouse exited  mouse event evt if msg set gui utilities get view  component evt get source get status set message null msg set false 
public  enhanced dialog  frame parent  string title boolean modal super parent title modal  init 
public  enhanced dialog  dialog parent  string title boolean modal super parent title modal  init 
public boolean get enter enabled return enter enabled 
public void set enter enabled boolean enter enabled this enter enabled enter enabled 
private void  init  container get layered pane add container listener new  container handler get content pane add container listener new  container handler key handler new  key handler add key listener key handler add window listener new  window handler set default close operation do nothing on close enter enabled true 
public void component added  container event evt component added evt get child 
public void component removed  container event evt component removed evt get child 
private void component added  component comp comp add key listener key handler if comp instanceof  container  container cont  container comp cont add container listener this  component comps cont get components for int i i comps length i component added comps i 
private void component removed  component comp comp remove key listener key handler if comp instanceof  container  container cont  container comp cont remove container listener this  component comps cont get components for int i i comps length i component removed comps i 
public void key pressed  key event evt if evt is consumed return if evt get key code  key event vk enter enter enabled  component comp get focus owner while comp null if comp instanceof j combo box j combo box combo j combo box comp if combo is editable  object selected combo get editor get item if selected null combo set selected item selected break comp comp get parent ok evt consume else if evt get key code  key event vk escape cancel evt consume 
public void window closing  window event evt cancel 
public  enhanced menu  string name this name j edit get property name concat label j edit get action context 
public  enhanced menu  string name  string label this name label j edit get action context 
public  enhanced menu  string name  string label  action context context this context context if label null label name char mnemonic int index label index of if index label length index mnemonic  character to lower case label char at index label label substring index concat label substring index else mnemonic set text label if  operating system is mac os set mnemonic mnemonic  string menu items j edit get property name if menu items null  string tokenizer st new  string tokenizer menu items while st has more tokens  string menu item name st next token if menu item name equals add separator else add gui utilities load menu item context menu item name true initial component count get menu component count provider code j edit get property name code eb stub new  edit bus stub name eb stub menu out of date true add menu listener this if provider code null  edit bus add to bus eb stub 
public void menu selected  menu event evt init 
public void menu deselected  menu event e 
public void menu canceled  menu event e 
public void init if provider code null return if provider null  object obj  bean shell eval null  bean shell get name space provider code provider  dynamic menu provider obj if provider null error provider code null return if eb stub menu out of date provider update every time eb stub menu out of date false while get menu component count initial component count remove get menu component count if provider null provider update this 
protected void finalize throws  exception if eb stub null  edit bus remove from bus eb stub 
 edit bus stub  string name this name name menu out of date true 
public void handle message eb message msg if msg instanceof  dynamic menu changed name equals  dynamic menu changed msg get menu name menu out of date true else if msg instanceof  properties changed while this might be questionable some menus depend on properties menu out of date true 
 creates a new menu item  most plugins should call gui utilities load menu item instead param label  the menu item label param action  the edit action param context  an action context since j edit pre public  enhanced menu item  string label  string action  action context context this action action this shortcut gui utilities get shortcut label action if  operating system has screen menu bar shortcut null set text label shortcut shortcut null else set text label if action null set enabled true add action listener new  edit action  wrapper context action add mouse listener new  mouse handler else set enabled false 
public  dimension get preferred size  dimension d super get preferred size if shortcut null d width get font metrics accelerator font string width shortcut return d 
public void paint  graphics g super paint g if shortcut null g set font accelerator font g set color get model is armed accelerator selection foreground accelerator foreground  font metrics fm g get font metrics  insets insets get insets g draw string shortcut get width fm string width shortcut insets right insets left get font get size insets top  operating system is mac oslf xxx magic number 
public void mouse released  mouse event evt if msg set gui utilities get view  component evt get source get status set message null msg set false 
public void mouse entered  mouse event evt  string msg j edit get property action mouse over if msg null gui utilities get view  component evt get source get status set message msg msg set true 
public void mouse exited  mouse event evt if msg set gui utilities get view  component evt get source get status set message null msg set false 
public  error entry  string path  string message prop  object args this path path  string message j edit get property message prop args if message null message  undefined property message prop  log log  log error this path  log log  log error this message  vector  string tokenized message new  vector  string int last index for int i i message length i if message char at i n tokenized message add element message substring last index i last index i if last index message length tokenized message add element message substring last index messages new  string tokenized message size tokenized message copy into messages 
public boolean equals  object o if o instanceof  error entry  error entry e  error entry o return e path equals path else return false 
public  string to string return path n  text utilities join java util  arrays as list messages n 
public  error list dialog  frame frame  string title  string caption  vector  error entry messages boolean plugin error super frame title plugin error j panel content new j panel new  border layout content set border new  empty border set content pane content  box icon box new  box  box layout y axis icon box add new j label ui manager get icon  option pane error icon icon box add  box create glue content add  border layout west icon box j panel center panel new j panel new  border layout j label label new j label caption label set border new  empty border center panel add  border layout north label j text pane errors new j text pane errors set editable false errors set foreground j edit get color property view fg color errors set background j edit get color property view bg color errors set caret color j edit get active view get edit pane get text area get painter get caret color errors set selection color j edit get active view get edit pane get text area get painter get selection color  styled document doc errors get styled document  font plain font new j label get font  simple attribute set plain font attr set new  simple attribute set  style constants set font family plain font attr set plain font get family  simple attribute set bold font attr set  simple attribute set plain font attr set clone  style constants set bold bold font attr set true for  error entry entry messages try doc insert string doc get length entry path n bold font attr set for  string s entry messages doc insert string doc get length s n plain font attr set catch  bad location exception e need this bullshit scroll bar policy for the preferred size hack to work j scroll pane scroll pane new j scroll pane errors j scroll pane vertical scrollbar always j scroll pane horizontal scrollbar always  dimension size scroll pane get preferred size size width  math min size width scroll pane set preferred size size center panel add  border layout center scroll pane content add  border layout center center panel  box buttons new  box  box layout x axis buttons add  box create glue ok new j button j edit get property common ok ok add action listener new  action handler if plugin error plugin mgr new j button j edit get property error list plugin manager plugin mgr add action listener new  action handler buttons add plugin mgr buttons add  box create horizontal strut buttons add ok buttons add  box create glue content add  border layout south buttons get root pane set default button ok pack set location relative to frame set visible true 
public void ok dispose 
public void cancel dispose 
public void action performed  action event evt if evt get source ok dispose else if evt get source plugin mgr  plugin manager show plugin manager j option pane get frame for component  error list dialog this 
public  widget get widget  view view  widget error widget new  error widget view return error widget 
 error widget  view view error highlight new  error highlight view 
public j component get component return error highlight 
public void update error highlight update 
public void properties changed 
 error highlight  view view set foreground j edit get color property view status foreground set background j edit get color property view status background add mouse listener new  my mouse adapter view 
 override public void add notify super add notify update int milliseconds per minute timer new  timer milliseconds per minute this timer start  tool tip manager shared instance register component this 
 override public void remove notify timer stop  tool tip manager shared instance unregister component this super remove notify 
 override public  point get tool tip location  mouse event event return new  point event get x 
public void action performed  action event e update 
private void update int size  log throwables size if size current size current size size if size set foreground j edit get color property view status foreground set text null set tool tip text size error else set foreground  color red set text  integer to string size error s set tool tip text size error s 
 my mouse adapter  view view this view view 
 override public void mouse clicked  mouse event e if  log throwables is empty return if gui utilities is right button e get modifiers j popup menu menu gui utilities load popup menu errorwidget popupmenu gui utilities show popup menu menu  error highlight this e get x e get y else if e get click count new  error dialog view 
private  error dialog  frame view super view  errors false byte array output stream new  byte array output stream print stream new  print stream byte array output stream throwables  log throwables to array text area new j text area text area set editable false if throwables length  throwable throwable  throwable throwables set throwable throwable combo new j combo box throwables combo add item listener new  item listener public void item state changed  item event e set throwable  throwable combo get selected item get content pane add combo  border layout north get content pane add new j scroll pane text area  box buttons new  box  box layout x axis buttons add  box create glue buttons add remove this error new j button j edit get property grab key remove buttons add  box create horizontal strut buttons add remove all errors new j button j edit get property common clear all  error dialog  my action listener action listener new  my action listener remove this error add action listener action listener remove all errors add action listener action listener buttons add  box create glue get content pane add buttons  border layout south pack gui utilities load geometry this status error widget set visible true 
private void set throwable  throwable throwable if throwable null text area set text null else throwable print stack trace print stream text area set text byte array output stream to string text area set caret position byte array output stream reset 
 override public void dispose gui utilities save geometry this status error widget super dispose 
 override public void ok dispose 
 override public void cancel dispose 
public void action performed  action event e  object source e get source if source remove this error  throwable throwable  throwable combo get selected item if throwable null  log throwables remove throwable combo remove item throwable if combo get item count dispose else if source remove all errors for  object throwable throwables  log throwables remove throwable dispose 
public  eval error  string s  simple node node  call stack callstack set message s this node node freeze the callstack for the stack trace if callstack null this callstack callstack copy 
 print the error with line number and stack trace public  string to string  string trace if node null trace at  line node get line number in file node get source file node get text else  users should not normally see this trace at unknown location if callstack null trace trace n get script stack trace return get message trace 
 re throw the error prepending the specified message public void re throw  string msg throws  eval error prepend message msg throw this 
 the error has trace info associated with it i e  it has an ast node that can print its location and source text  simple node get node return node 
void set node  simple node node this node node 
public  string get error text if node null return node get text else return unknown error 
public int get error line number if node null return node get line number else return 
public  string get error source file if node null return node get source file else return unknown file 
public  string get script stack trace if callstack null return  unknown  string trace  call stack stack callstack copy while stack depth  name space ns stack pop  simple node node ns get node if ns is method trace trace n called from method ns get name if node null trace at  line node get line number in file node get source file node get text return trace 
see to string for a full display of the information public  string get message return message 
public void set message  string s message s 
 prepend the message if it is non null protected void prepend message  string s if s null return if message null message s else message s message 
public  explicit fold handler super explicit 
 returns the fold level of the specified line param buffer  the buffer in question param line index  the line index param seg a segment the fold handler can use to obtain any text from the buffer if necessary return  the fold level of the specified line since j edit pre public int get fold level j edit buffer buffer int line index  segment seg if line index return else int fold level buffer get fold level line index buffer get line text line index seg int offset seg offset int count seg count int opening brackets closing brackets for int i i count i switch seg array offset i case closing brackets opening brackets if opening brackets fold level opening brackets break case opening brackets closing brackets if closing brackets if fold level fold level closing brackets break default closing brackets opening brackets break return fold level 
 creates an extended grid layout manager with the specified horizontal and vertical gap and the specified distance to the borders of the parent container param hgap  the horizontal space between two columns literal param vgap  the vertical space between two rows literal param distance to borders  the distances to the borders of the parent container throws  illegal argument exception if hgap literal throws  illegal argument exception if vgap literal public  extended grid layout int hgap int vgap  insets distance to borders if hgap throw new  illegal argument exception hgap must be non negative hgap if vgap throw new  illegal argument exception vgap must be non negative vgap this hgap hgap this vgap vgap this distance to borders  insets distance to borders clone comptable new  hashtable  component  extended grid layout constraints 
 creates an extended grid layout manager with zero horizontal and vertical gap and zero distance to the borders of the parent container public  extended grid layout this new  insets 
 if the layout manager uses a per component string adds the component code component code to the layout associating it with the string specified by code name code param name  the string to be associated with the component  has to be code null so that default constraints are used param component  the component to be added throws  illegal argument exception if code name is not code null see add layout component java awt  component java lang  object public void add layout component  string name  component component add layout component component name 
 adds the specified component to the layout using the specified constraints object param component  the component to be added param constraints  where how the component is added to the layout throws  illegal argument exception if code constraints is not an  extended grid layout constraints object throws  illegal argument exception if code constraints is a placeholder throws  illegal argument exception if code constraints is not the right one for the component see  extended grid layout constraints public void add layout component  component component  object constraints if null constraints constraints new  extended grid layout constraints component if constraints instanceof  extended grid layout constraints  extended grid layout constraints egl constraints  extended grid layout constraints constraints if egl constraints is placeholder throw new  illegal argument exception constraints must not be a placeholder else if component egl constraints get component throw new  illegal argument exception constraints is not the right one for this component comptable put component egl constraints else throw new  illegal argument exception constraints must not be an  extended grid layout constraints object 
 retrieves the constraints for the specified code component  if code component is not in the code  extended grid layout a set of default code  extended grid layout constraints are returned param component the code component to be queried return the contraints for the specified code component throws  null pointer exception if code component is code null see  extended grid layout constraints private  extended grid layout constraints lookup constraints  component component if null component throw new  null pointer exception component must not be null  extended grid layout constraints constraints comptable get component if null constraints constraints new  extended grid layout constraints component comptable put component constraints return constraints 
 removes the specified component from the layout param component  the component to be removed public void remove layout component  component component comptable remove component 
 returns the alignment along the x axis  this specifies how the component would like to be aligned relative to other components  the value should be a number between and where represents alignment along the origin is aligned the furthest away from the origin is centered etc param container  the container for which the alignment should be returned return code java awt  component center alignment public float get layout alignment x  container container return center alignment 
 returns the alignment along the y axis  this specifies how the component would like to be aligned relative to other components  the value should be a number between and where represents alignment along the origin is aligned the furthest away from the origin is centered etc param container  the container for which the alignment should be returned return code java awt  component center alignment public float get layout alignment y  container container return center alignment 
 calculates the minimum size dimensions for the specified container given the components it contains param parent  the component to be laid out return  the minimum size for the container see maximum layout size see preferred layout size public  dimension minimum layout size  container parent synchronized parent get tree lock  list  list  extended grid layout constraints grid rows new  array list  list  extended grid layout constraints  set  extended grid layout constraints colspans new  hash set  extended grid layout constraints  set  extended grid layout constraints rowspans new  hash set  extended grid layout constraints  dimension grid size build grid parent grid rows colspans rowspans return get size parent  layout size minimum false grid size grid rows colspans rowspans new int 
 calculates the preferred size dimensions for the specified container given the components it contains param parent  the container to be laid out return  the preferred size for the container see maximum layout size see minimum layout size public  dimension preferred layout size  container parent synchronized parent get tree lock  list  list  extended grid layout constraints grid rows new  array list  list  extended grid layout constraints  set  extended grid layout constraints colspans new  hash set  extended grid layout constraints  set  extended grid layout constraints rowspans new  hash set  extended grid layout constraints  dimension grid size build grid parent grid rows colspans rowspans return get size parent  layout size preferred false grid size grid rows colspans rowspans new int 
 calculates the maximum size dimensions for the specified container given the components it contains param parent  the container to be laid out return  the maximum size for the container see minimum layout size see preferred layout size public  dimension maximum layout size  container parent synchronized parent get tree lock  list  list  extended grid layout constraints grid rows new  array list  list  extended grid layout constraints  set  extended grid layout constraints colspans new  hash set  extended grid layout constraints  set  extended grid layout constraints rowspans new  hash set  extended grid layout constraints  dimension grid size build grid parent grid rows colspans rowspans return get size parent  layout size maximum false grid size grid rows colspans rowspans new int 
 invalidates the layout indicating that if the layout manager has cached information it should be discarded param container  the container for which the cached information should be discarded public void invalidate layout  container container 
 lays out the specified container param parent  the container to be laid out public void layout container  container parent synchronized parent get tree lock  pass build the grid  list  list  extended grid layout constraints grid rows new  array list  list  extended grid layout constraints  set  extended grid layout constraints colspans new  hash set  extended grid layout constraints  set  extended grid layout constraints rowspans new  hash set  extended grid layout constraints  dimension grid size build grid parent grid rows colspans rowspans  pass compute minimum preferred and maximum column widths row heights int layout sizes new int  dimension preferred size get size parent  layout size preferred true grid size grid rows colspans rowspans layout sizes int minimum col widths layout sizes int minimum row heights layout sizes int preferred col widths layout sizes int preferred row heights layout sizes int maximum col widths layout sizes int maximum row heights layout sizes  pass redistribute free space  dimension parent size parent get size  insets insets parent get insets int free width parent size width insets left insets right grid size width hgap distance to borders left distance to borders right int free height parent size height insets top insets bottom grid size height vgap distance to borders top distance to borders bottom redistribute space preferred size width free width grid size width preferred col widths minimum col widths maximum col widths redistribute space preferred size height free height grid size height preferred row heights minimum row heights maximum row heights  pass layout components for int row y insets top distance to borders top row grid size height y preferred row heights row vgap row  list  extended grid layout constraints grid row grid rows get row for int col x insets left distance to borders left col grid size width x preferred col widths col hgap col  extended grid layout constraints cell grid row get col if null cell null cell get component cell is placeholder  component component cell get component  dimension max size component get maximum size int from col cell get col int colspan cell get effective colspan int to col from col colspan int width for int col from col col to col col width preferred col widths col width colspan hgap int from row cell get row int rowspan cell get effective rowspan int to row from row rowspan int height for int row from row row to row row height preferred row heights row height rowspan vgap int x correction int y correction if width max size width x correction int width max size width component get alignment x width max size width if height max size height y correction int height max size height component get alignment y height max size height component set bounds x x correction y y correction width height 
 redistributs free space positive or negative to all available columns or rows while taking elements maximum and minimum sizes into account if possible param total size  the cumulated preferred sizes of the components param free size  the available space for displaying components without any gaps between components or between the grid and the borders of the parent container param start  the start in the arrays of rows or columns inclusive param stop  the stop in the arrays of rows or columns exclusive param preferred element sizes  the preferred sizes of the rows or columns  after invocation of this method this array holds the sizes that should be used param minimum element sizes  the minimum sizes of the rows or columns param maximum element sizes  the maximum sizes of the rows or columns private void redistribute space int total size int free size int start int stop int preferred element sizes int minimum element sizes int maximum element sizes if total size free size boolean grow total size free size calculate the size that is available for redistribution free size free size total size grow while free size calculate the amount of elements that can be resized without violating the minimum and maximum sizes and their current cumulated size int modifyable amount long modify size for int i start i stop i if grow preferred element sizes i maximum element sizes i grow preferred element sizes i minimum element sizes i modifyable amount modify size preferred element sizes i boolean check bounds true if all elements are at their minimum or maximum size resize all elements if modifyable amount for int i start i stop i modify size preferred element sizes i check bounds false modifyable amount stop start to prevent an endless loop if the container gets resized to a very small amount if modify size break resize the elements if free size modifyable amount for int i start i stop i if free size check bounds check bounds grow preferred element sizes i maximum element sizes i grow preferred element sizes i minimum element sizes i preferred element sizes i grow if preferred element sizes i preferred element sizes i free size else long modify size addition double factor double free size modify size double modify size for int i start i stop i long modifyable size check bounds grow maximum element sizes i preferred element sizes i preferred element sizes i minimum element sizes i  integer max value preferred element sizes i long element modify size  math abs  math round factor preferred element sizes i preferred element sizes i if element modify size modifyable size preferred element sizes i grow element modify size element modify size modify size addition grow element modify size element modify size free size element modify size else preferred element sizes i grow modifyable size modifyable size modify size addition grow modifyable size modifyable size free size modifyable size if preferred element sizes i preferred element sizes i modify size modify size addition 
 calculates the minimum preferred or maximum size dimensions for the specified container given the components it contains param parent  the container to be laid out param layout size if code  layout size minimum compute minimum layout size if code  layout size preferred compute preferred layout size if code  layout size maximum compute maximum layout size if code fill raw sizes is code true the layout size is computed without applying gaps between components or between the grid and the borders of the parent container param fill raw sizes  whether to fill the result arrays with the raw row heights and column widths and whether to apply gaps between components or between the grid and the borders of the parent container when computing the layout size param grid size  the amount of rows and columns in the grid param grid rows  the grid holding the constraints for the components param colspans  in this code  set the constraints which are part of a colspan are stored param rowspans  in this code  set the constraints which are part of a rowspan are stored param result arrays  if code fill raw sizes is code true the first six arrays get filled with the raw row heights and column widths result arrays result minimum col widths result arrays result minimum row heights result arrays result preferred col widths result arrays result preferred row heights result arrays result maximum col widths result arrays result maximum row heights return  the minimum preferred or maximum size dimensions for the specified container throws  illegal argument exception  if code fill raw sizes true and code result arrays length private  dimension get size  container parent  layout size layout size boolean fill raw sizes  dimension grid size  list  list  extended grid layout constraints grid rows  set  extended grid layout constraints colspans  set  extended grid layout constraints rowspans int result arrays if fill raw sizes result arrays length throw new  illegal argument exception  if fill raw sizes is true result arrays length must be result arrays length int minimum col widths new int grid size width int minimum row heights new int grid size height int preferred col widths new int grid size width int preferred row heights new int grid size height int maximum col widths new int grid size width int maximum row heights new int grid size height  arrays fill minimum col widths  arrays fill minimum row heights  arrays fill preferred col widths  arrays fill preferred row heights  arrays fill maximum col widths  arrays fill maximum row heights get the maximum of the minimum sizes the maximum of the preferred sizes and the minimum of the maximum sizes of all rows and columns not taking rowspans and colspans into account for int row row grid size height row  list  extended grid layout constraints grid row grid rows get row for int col col grid size width col  extended grid layout constraints cell grid row get col if null cell null cell get component  component component cell get component  dimension minimum size component get minimum size  dimension preferred size component get preferred size  dimension maximum size component get maximum size if colspans contains cell minimum col widths col  math max minimum col widths col minimum size width preferred col widths col  math max preferred col widths col preferred size width maximum col widths col  math max maximum col widths col maximum size width if rowspans contains cell minimum row heights row  math max minimum row heights row minimum size height preferred row heights row  math max preferred row heights row preferred size height maximum row heights row  math max maximum row heights row maximum size height correct cases where minimum col widths col preferred col widths col maximum col widths col is not true by clipping to the minimum col widths and maximum col widths for int col col grid size width col if minimum col widths col maximum col widths col maximum col widths col minimum col widths col preferred col widths col minimum col widths col else if preferred col widths col minimum col widths col preferred col widths col minimum col widths col else if preferred col widths col maximum col widths col preferred col widths col maximum col widths col plug in the colspans and correct the minimum preferred and maximum column widths the colspans are part of for  extended grid layout constraints cell colspans int from col cell get col int colspan cell get effective colspan int to col from col colspan int current minimum col width int current preferred col width int current maximum col width for int col from col col to col col int minimum col width minimum col widths col if  integer max value minimum col width current minimum col width current minimum col width  integer max value else current minimum col width minimum col width int preferred col width preferred col widths col if  integer max value preferred col width current preferred col width current preferred col width  integer max value else current preferred col width preferred col width int maximum col width maximum col widths col if  integer max value maximum col width current maximum col width current maximum col width  integer max value else current maximum col width maximum col width  component component cell get component int wanted maximum col width component get maximum size width colspan hgap if current maximum col width wanted maximum col width redistribute space current maximum col width wanted maximum col width from col to col maximum col widths maximum col widths maximum col widths int wanted minimum col width component get minimum size width colspan hgap if current minimum col width wanted minimum col width redistribute space current minimum col width wanted minimum col width from col to col minimum col widths minimum col widths maximum col widths int wanted preferred col width component get preferred size width colspan hgap if current preferred col width wanted preferred col width redistribute space current preferred col width wanted preferred col width from col to col preferred col widths minimum col widths maximum col widths correct cases where minimum col widths col preferred col widths col maximum col widths col is not true by clipping to the minimum col widths and maximum col widths for int col col grid size width col if minimum col widths col maximum col widths col maximum col widths col minimum col widths col preferred col widths col minimum col widths col else if preferred col widths col minimum col widths col preferred col widths col minimum col widths col else if preferred col widths col maximum col widths col preferred col widths col maximum col widths col correct cases where minimum row heights row preferred row heights row maximum row heights row is not true by clipping to the minimum row heights and maximum row heights for int row row grid size height row if minimum row heights row maximum row heights row maximum row heights row minimum row heights row preferred row heights row minimum row heights row else if preferred row heights row minimum row heights row preferred row heights row minimum row heights row else if preferred row heights row maximum row heights row preferred row heights row maximum row heights row plug in the rowspans and correct the minimum preferred and maximum row heights the rowspans are part of for  extended grid layout constraints cell rowspans int from row cell get row int rowspan cell get effective rowspan int to row from row rowspan int current minimum row height int current preferred row height int current maximum row height for int row from row row to row row int minimum row height minimum row heights row if  integer max value minimum row height current minimum row height current minimum row height  integer max value else current minimum row height minimum row height int preferred row height preferred row heights row if  integer max value preferred row height current preferred row height current preferred row height  integer max value else current preferred row height preferred row height int maximum row height maximum row heights row if  integer max value maximum row height current maximum row height current maximum row height  integer max value else current maximum row height maximum row height  component component cell get component int wanted maximum row height component get maximum size height rowspan vgap if current maximum row height wanted maximum row height redistribute space current maximum row height wanted maximum row height from row to row maximum row heights maximum row heights maximum row heights int wanted minimum row height component get minimum size height rowspan vgap if current minimum row height wanted minimum row height redistribute space current minimum row height wanted minimum row height from row to row minimum row heights minimum row heights maximum row heights int wanted preferred row height component get preferred size height rowspan vgap if current preferred row height wanted preferred row height redistribute space current preferred row height wanted preferred row height from row to row preferred row heights minimum row heights maximum row heights correct cases where minimum row heights row preferred row heights row maximum row heights row is not true by clipping to the minimum row heights and maximum row heights for int row row grid size height row if minimum row heights row maximum row heights row maximum row heights row minimum row heights row preferred row heights row minimum row heights row else if preferred row heights row minimum row heights row preferred row heights row minimum row heights row else if preferred row heights row maximum row heights row preferred row heights row maximum row heights row copies the computed sizes to the result arrays if fill raw sizes result arrays minimum col widths result arrays minimum row heights result arrays preferred col widths result arrays preferred row heights result arrays maximum col widths result arrays maximum row heights sums up the sizes for return value int col widths int row heights switch layout size case minimum col widths minimum col widths row heights minimum row heights break case preferred col widths preferred col widths row heights preferred row heights break case maximum col widths maximum col widths row heights maximum row heights break default throw new  internal error  missing case branch for  layout size layout size long total width long total height for int width col widths total width width for int height row heights total height height add space between components or between componetns and the borders of the parent container if fill raw sizes  insets insets parent get insets total width insets left insets right grid size width hgap distance to borders left distance to borders right total height insets top insets bottom grid size height vgap distance to borders top distance to borders bottom clip the size to  integer max value if too big if total width  integer max value total width  integer max value if total height  integer max value total height  integer max value return new  dimension int total width int total height 
 builds up the grid for the specified container given the components it contains param parent  the container to be laid out param grid rows  in this code  list  list the grid gets stored param colspans  in this code  set the constraints which are part of a colspan get stored param rowspans  in this code  set the constraints which are part of a rowspan get stored return  the amount of rows and columns in the grid private  dimension build grid  container parent  list  list  extended grid layout constraints grid rows  set  extended grid layout constraints colspans  set  extended grid layout constraints rowspans put the parent s components in source rows  list  list  extended grid layout constraints rows new  array list  list  extended grid layout constraints  component components parent get components for  component component components if component is visible  extended grid layout constraints constraints lookup constraints component get work copy int row number constraints get row for int i row number c rows size i c i rows add new  array list  extended grid layout constraints  list  extended grid layout constraints row rows get row number row add constraints initialize the row iterators grid row iterators and grid rows  list  iterator  extended grid layout constraints row iterators new  array list  iterator  extended grid layout constraints  list  list iterator  extended grid layout constraints grid row iterators new  array list  list iterator  extended grid layout constraints boolean have next false for  list  extended grid layout constraints row rows  iterator  extended grid layout constraints row iterator row iterator row iterators add row iterator if row iterator has next have next true  list  extended grid layout constraints grid row new  array list  extended grid layout constraints grid rows add grid row grid row iterators add grid row list iterator build the grid int col while have next col have next false for int row c grid rows size row c row  iterator  extended grid layout constraints row iterator row iterators get row  list iterator  extended grid layout constraints grid row iterator grid row iterators get row look for a rowspan in the previous row if row  extended grid layout constraints rowspan source grid rows get row get col if null rowspan source  extended grid layout constraints rowspan placeholder rowspan source get rowspan placeholder true if null rowspan placeholder rowspans add rowspan source grid row iterator add rowspan placeholder if null rowspan placeholder get colspan placeholder false switch rowspan placeholder get colspan case remainder break default have next true else if row iterator has next have next true continue look for a colspan in the previous column if grid row iterator has previous  extended grid layout constraints colspan source grid row iterator previous grid row iterator next if null colspan source  extended grid layout constraints colspan placeholder colspan source get colspan placeholder true if null colspan placeholder colspans add colspan source grid row iterator add colspan placeholder if null colspan placeholder get colspan placeholder false switch colspan placeholder get colspan case remainder break default have next true else if row iterator has next have next true continue add a new element or null if row iterator has next  extended grid layout constraints new constraints row iterator next new constraints set col col grid row iterator add new constraints if null new constraints get colspan placeholder false switch new constraints get colspan case remainder break default have next true else if row iterator has next have next true else grid row iterator add null check the last grid row for rowspans and probably add rows for these have next false int grid rows size grid rows size if grid rows size  list iterator  extended grid layout constraints grid row iterator grid rows get grid rows size list iterator while grid row iterator has next  extended grid layout constraints cell grid row iterator next if null cell remainder cell get rowspan null cell get rowspan placeholder false have next true break while have next have next false grid row iterator grid rows get grid rows size list iterator  list  extended grid layout constraints grid row new  array list  extended grid layout constraints grid rows add grid row  list iterator  extended grid layout constraints new grid row iterator grid row list iterator while grid row iterator has next  extended grid layout constraints cell grid row iterator next if null cell null cell get rowspan placeholder false rowspans add cell  extended grid layout constraints rowspan placeholder cell get rowspan placeholder true new grid row iterator add rowspan placeholder else new grid row iterator add null grid row iterator grid row list iterator while grid row iterator has next  extended grid layout constraints cell grid row iterator next if null cell remainder cell get rowspan null cell get rowspan placeholder false have next true break return new  dimension col grid rows size 
 returns a string representation of the object  in general the code to string method returns a string that textually represents this object  the result should be a concise but informative representation that is easy for a person to read return a string representation of the object public  string to string return get class get name hgap hgap vgap vgap distance to borders distance to borders comptable comptable 
 creates an code  extended grid layout constraints object with all of its fields set to their default value  for further information about the default values see link  extended grid layout constraints int int int java awt  component param component  the code  component this constraints object describes public  extended grid layout constraints  component component this component false null 
 creates an code  extended grid layout constraints object with all of its fields set to their default value except of the row which is specified  for further information about the default values see link  extended grid layout constraints int int int java awt  component param row  the row in which a component starts its display area  first row is param component  the code  component this constraints object d describes throws  illegal argument exception  if row literal public  extended grid layout constraints int row  component component this row component false null 
 creates an code  extended grid layout constraints object with all of its fields set to the passed in arguments param row  the row in which a component starts its display area  first row is  default value is param colspan  the number of cells in a row for the component s display area  use code remainder to specify that the component s display area will be from its grid position to the last cell in the row  default value is param rowspan  the number of cells in a column for the component s display area  use code remainder to specify that the component s display area will be from its grid position to the last cell in the column  default value is param component  the code  component this constraints object describes throws  illegal argument exception  if row literal throws  illegal argument exception  if colspan literal throws  illegal argument exception  if rowspan literal public  extended grid layout constraints int row int colspan int rowspan  component component this row colspan rowspan component false null 
 creates an code  extended grid layout constraints object with all of its fields set to the passed in arguments param row  the row in which a component starts its display area  first row is param col  the col in which a component starts its display area  first col is param colspan  the number of cells in a row for the component s display area  use code remainder to specify that the component s display area will be from its grid position to the last cell in the row param rowspan  the number of cells in a column for the component s display area  use code remainder to specify that the component s display area will be from its grid position to the last cell in the column param component  the code  component this constraints object describes param placeholder  if this constraints are used as placeholder to build the grid param main constraints  the main constraints object for which this constraints object is a placeholder throws  illegal argument exception  if row literal throws  illegal argument exception  if col literal throws  illegal argument exception  if colspan literal throws  illegal argument exception  if rowspan literal private  extended grid layout constraints int row int col int colspan int rowspan  component component boolean placeholder  extended grid layout constraints main constraints if row throw new  illegal argument exception row must be non negative row if col throw new  illegal argument exception col must be non negative col if colspan throw new  illegal argument exception colspan must be at least colspan if rowspan throw new  illegal argument exception rowspan must be at least rowspan this row row this col col this colspan colspan effective colspan this rowspan rowspan effective rowspan this component component this placeholder placeholder this main constraints main constraints 
 creates an code  extended grid layout constraints object which can be used as placeholder for building a grid with colspans param for usage  if the returned object will be used in the grid and therefor the effective colspan should be raised by one return  the newly created code  extended grid layout constraints object or code null if no colspan is applicable see get rowspan placeholder boolean  extended grid layout constraints get colspan placeholder boolean for usage if colspan return null  extended grid layout constraints result new  extended grid layout constraints row col colspan remainder remainder colspan rowspan component true null main constraints this main constraints if for usage result main constraints row row result main constraints effective colspan return result 
 creates an code  extended grid layout constraints object which can be used as placeholder for building a grid with rowspans param for usage  if the returned object will be used in the grid and therefor the effective rowspan should be raised by one return  the newly created code  extended grid layout constraints object or code null if no rowspan is applicable see get colspan placeholder boolean  extended grid layout constraints get rowspan placeholder boolean for usage if rowspan return null  extended grid layout constraints result new  extended grid layout constraints row col colspan rowspan remainder remainder rowspan component true null main constraints this main constraints if for usage result main constraints col col result main constraints effective rowspan return result 
return  the row in which the component starts its display area public int get row return row 
return  the column in which the component starts its display area public int get col return col 
param col  the column in which the component starts its display area void set col int col if col throw new  illegal argument exception col must be non negative col this col col 
return  the number of cells in a row for the component s display area or code remainder if the component s display area will be from its grid position to the last cell in the row public int get colspan return colspan 
return  the effective number of cells in a row for the component s display area int get effective colspan return null main constraints effective colspan main constraints effective colspan 
return  the number of cells in a column for the component s display area or code remainder if the component s display area will be from its grid position to the last cell in the column public int get rowspan return rowspan 
return  the effective number of cells in a column for the component s display area int get effective rowspan return null main constraints effective rowspan main constraints effective rowspan 
return  the code  component this constraints object describes  component get component return component 
return  whether this constraints object is a placeholder or not public boolean is placeholder return placeholder 
return a work copy if this constraints object  this is a flat copy which means that the reference to the component stays the same  the returned object could be used without modifying this constraints object  extended grid layout constraints get work copy return new  extended grid layout constraints row col colspan rowspan component placeholder null main constraints null main constraints get work copy 
 indicates whether some other object is equal to this one p  the code equals method implements an equivalence relation on non null object references ul li  it is i reflexive i for any non null reference value code x code x equals x returns code true li  it is i symmetric i for any non null reference values code x and code y code x equals y returns code true if and only if code y equals x returns code true li  it is i transitive i for any non null reference values code x code y and code z if code x equals y returns code true and code y equals z returns code true then code x equals z returns code true li  it is i consistent i for any non null reference values code x and code y multiple invocations of tt x equals y tt consistently return code true or consistently return code false provided no information used in code equals comparisons on the objects is modified li  for any non null reference value code x code x equals null returns code false ul p  the tt equals tt method for class code  extended grid layout constraints returns code true if and only if the constraints objects describe the same code  component param o the reference object with which to compare return code true if this object is the same as the o argument code false otherwise see hash code see a href http java sun com j se docs api java util  hashtable html code java util  hashtable code a public boolean equals  object o if o null o instanceof  extended grid layout constraints return false if component null return  extended grid layout constraints o component null return component equals  extended grid layout constraints o component 
 returns a hash code value for the object  this method is supported for the benefit of hashtables such as those provided by code java util  hashtable p  the general contract of code hash code is ul li  whenever it is invoked on the same object more than once during an execution of a  java application the tt hash code tt method must consistently return the same integer provided no information used in tt equals tt comparisons on the object is modified  this integer need not remain consistent from one execution of an application to another execution of the same application li  if two objects are equal according to the tt equals  object tt method then calling the code hash code method on each of the two objects must produce the same integer result li  it is em not em required that if two objects are unequal according to the a href http java sun com j se docs api java lang  object html equals java lang  object code java lang  object equals java lang  object a method then calling the tt hash code tt method on each of the two objects must produce distinct integer results  however the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables ul return a hash code value for this object see equals java lang  object see a href http java sun com j se docs api java util  hashtable html code java util  hashtable code a public int hash code if null component return return component hash code 
 returns a string representation of the object  in general the code to string method returns a string that textually represents this object  the result should be a concise but informative representation that is easy for a person to read return a string representation of the object public  string to string return get class get name row row col col colspan colspan effective colspan effective colspan rowspan rowspan effective rowspan effective rowspan placeholder placeholder component component main constraints main constraints 
 add an extension  see link  gutter and link  text area painter to know the layers param layer the layer  it could be defined in  gutter or  text area painter param ext the extension to add void add extension int layer  text area extension ext  entry entry new  entry layer ext int i for  entry extension extensions int  layer extension layer if layer  layer extensions add i entry return i extensions add entry 
void remove extension  text area extension ext  iterator  entry iter extensions iterator while iter has next if iter next ext ext iter remove return 
 text area extension get extensions  text area extension ret val new  text area extension extensions size  iterator  entry iter extensions iterator int i while iter has next ret val i iter next ext return ret val 
void paint screen line range  text area text area  graphics d gfx int first line int last line int y int line height try int physical lines new int last line first line int start new int physical lines length int end new int physical lines length for int i i physical lines length i int screen line i first line  chunk cache  line info line info text area chunk cache get line info screen line if line info physical line physical lines i else physical lines i line info physical line start i text area get screen line start offset screen line end i text area get screen line end offset screen line paint screen line range gfx first line last line physical lines start end y line height catch  exception e  log log  log error this  error repainting line range first line last line  log log  log error this e 
 string get tool tip text int x int y for int i i extensions size i  text area extension ext extensions get i ext  string tool tip ext get tool tip text x y if tool tip null return tool tip return null 
private void paint screen line range  graphics d gfx int first line int last line int physical lines int start int end int y int line height  iterator  entry iter extensions iterator while iter has next  text area extension ext iter next ext try ext paint screen line range gfx first line last line physical lines start end y line height catch  throwable t  log log  log error this t remove it so editor can continue functioning iter remove 
 entry int layer  text area extension ext this layer layer this ext ext 
public  external name space this null  external  map  namespace null 
public  external name space  name space parent  string name  map external map super parent name if external map null external map new  hash map this external map external map 
 get the map view of this namespace public  map get map return external map 
 set the external  map which to which this namespace synchronizes  the previous external map is detached from this namespace  previous map values are retained in the external map but are removed from the  bean shell namespace public void set map  map map  detach any existing namespace to preserve it then clear this namespace and set the new one this external map null clear this external map map 
void set variable  string name  object value boolean strict java boolean recurse throws  util eval error super set variable name value strict java recurse put external map name value 
public void unset variable  string name super unset variable name external map remove name 
public  string get variable names union of the names in the internal namespace and external map  set name set new  hash set  string ns names super get variable names name set add all  arrays as list ns names name set add all external map key set return  string name set to array new  string 
 notes  this implmenetation of get variable impl handles the following cases var in map not in local scope var was added through map var in map and in local scope var was added through namespace var not in map but in local scope var was removed via map var not in map and not in local scope non existent var protected  variable get variable impl  string name boolean recurse throws  util eval error check the external map for the variable name  object value external map get name  variable var if value null  the var is not in external map and it should therefore not be found in local scope it may have been removed via the map  clear it prophalactically super unset variable name  search parent for var if applicable var super get variable impl name recurse else  var in external map may be found in local scope with type and modifier info  variable local var super get variable impl name false  if not in local scope then it was added via the external map we ll wrap it and pass it along  else we ll use the local version if local var null var new  variable name  class null value  modifiers null else var local var return var 
 note the meaning of get declared variables is not entirely clear but the name and current usage in class generation support suggests that untyped variables should not be inclueded  therefore we do not currently have to add the external names here public  variable get declared variables return super get declared variables 
public void set typed variable  string name  class type  object value  modifiers modifiers throws  util eval error super set typed variable name type value modifiers put external map name value 
public void set method  string name  bsh method method throws  util eval error super set method name method 
public  bsh method get method  string name  class sig boolean declared only throws  util eval error return super get method name sig declared only 
protected void get all names aux  vector vec super get all names aux vec 
 clear all variables methods and imports from this namespace and clear all values from the external map via  map clear public void clear super clear external map clear 
 place an unwrapped value in the external map  bean shell primitive types are represented by their object wrappers so it is not possible to differentiate between wrapper types and primitive types via the external  map protected void put external map  string name  object value if value instanceof  variable try value unwrap variable  variable value catch  util eval error ute  there should be no case for this unwrap variable throws  util eval error in some cases where it holds an lhs or array index throw new  interpreter error unexpected  util eval error if value instanceof  primitive value  primitive unwrap  primitive value external map put name value 
public boolean update every time return false 
public void update j menu menu final  view view gui utilities get view menu  action listeners  action listener file listener new  action listener public void action performed  action event evt j edit open file view evt get action command  action listener dir listener new  action listener public void action performed  action event evt vfs browser browse directory view evt get action command vfs file favorites  favorites vfs get favorites if favorites length j menu item mi new j menu item j edit get property vfs browser favorites no favorites label mi set enabled false menu add mi else  arrays sort favorites new vfs  directory entry compare j edit get boolean property vfs browser sort mix files and dirs j edit get boolean property vfs browser sort ignore case for int i i favorites length i vfs file favorite favorites i j menu item mi new j menu item favorite get path mi set icon  file cell renderer get icon for file favorite false if favorite get type vfs file file mi add action listener file listener else mi add action listener dir listener menu add mi 
public  favorites vfs super favorites delete cap low latency cap new  string ea type add to favorites which is a static method for convinience needs an instance of the vfs to pass to vfs manager send vfs update hence this hack instance this 
public  string get parent of path  string path return protocol 
public vfs file  list files  object session  string url  component comp return get favorites 
public vfs file  get file  object session  string path  component comp does it matter that this doesn t set the type correctly return new  favorite path vfs file directory 
public boolean  delete  object session  string path  component comp synchronized lock path path substring protocol length  iterator  favorite iter favorites iterator while iter has next if iter next get path equals path iter remove vfs manager send vfs update this protocol false  edit bus send new  dynamic menu changed favorites return true return false 
public static void load favorites synchronized lock favorites new  linked list  favorite  string favorite int i while favorite j edit get property vfs favorite i null favorites add new  favorite favorite j edit get integer property vfs favorite i type vfs file directory i 
public static void add to favorites  string path int type synchronized lock if favorites null load favorites for  favorite favorite favorites if favorite get path equals path return favorites add new  favorite path type vfs manager send vfs update instance protocol false  edit bus send new  dynamic menu changed favorites 
public static void save favorites synchronized lock if favorites null return int i for  favorite favorite favorites j edit set property vfs favorite i favorite get path j edit set integer property vfs favorite i type favorite get type i j edit unset property vfs favorite favorites size j edit unset property vfs favorite favorites size type 
public static vfs file get favorites synchronized lock if favorites null load favorites return favorites to array new vfs file favorites size 
 favorite  string path int type super path path protocol path type false 
public  string get extended attribute  string name if name equals ea type return super get extended attribute name else don t want it to show bytes for size etc return null 
public  file cell renderer plain font ui manager get font  tree font if plain font null plain font j edit get font property metal secondary font bold font plain font derive font  font bold 
public  component get table cell renderer component j table table  object value boolean is selected boolean has focus int row int column super get table cell renderer component table value is selected has focus row column if value instanceof vfs directory entry table model  entry vfs directory entry table model  entry entry vfs directory entry table model  entry value vfs file file entry dir entry set font file get type vfs file file plain font bold font this is selected is selected this file file if column while its broken to have a null symlink path some older plugins might  string path if file get symlink path null path file get path else path file get symlink path open buffer j edit  get buffer path null set icon show icons get icon for file file entry expanded open buffer null set text file get name int state if file get type vfs file file state  expansion toggle border state none else if entry expanded state  expansion toggle border state expanded else state  expansion toggle border state collapsed set border new  expansion toggle border state entry level else vfs directory entry table model model vfs directory entry table model table get model  string ext attr model get extended attribute column open buffer false set icon null set text file get extended attribute ext attr set border new  empty border return this 
public void paint component  graphics g if is selected  color color file get color set foreground color null ui manager get color  tree foreground color super paint component g if open buffer  font font get font  font metrics fm get font metrics font int x y if get icon null x y fm get ascent else x get icon get icon width get icon text gap y  math max fm get ascent  insets border get border get border insets this x border left g set color get foreground g draw line x y x fm string width get text y 
since j edit pre public static  icon get icon for file vfs file file boolean expanded return get icon for file file expanded j edit  get buffer file get symlink path null 
public static  icon get icon for file vfs file file boolean expanded boolean open buffer if default icons return file get default icon expanded open buffer return file get icon expanded open buffer 
void properties changed show icons j edit get boolean property vfs browser show icons default icons j edit get boolean property vfs browser use default icons 
int get entry width vfs directory entry table model  entry entry  font font  font render context font render context  string name entry dir entry get name int width int font get string bounds name font render context get width width  expansion toggle border icon width entry level  expansion toggle border level width if show icons width file icon get icon width width get icon text gap return width 
 expansion toggle border int state int level this state state this level level 
public void paint border  component c  graphics g int x int y int width int height paint the opposite icon of what the state is switch state case state collapsed expand icon paint icon c g x level level width y height expand icon get icon height break case state expanded collapse icon paint icon c g x level level width y height collapse icon get icon height break 
public  insets get border insets  component c return new  insets level level width icon width 
public boolean is border opaque return false 
public static boolean is expansion toggle int level int x return x level level width x level level width icon width 
 the  file properties dialog s constructor param view  the view param browser  the vfs browser public  file properties dialog  view view vfs browser browser vfs file files super view j edit get property vfs browser properties title true gui utilities load geometry this propdialog this browser browser if files length selected files files else selected files browser get selected files local  local file selected files create and show gui 
public void add components to pane j panel content new j panel new  border layout content set border new  empty border set content pane content if selected files length content add  border layout north create north panel content add  border layout center create center panel content add  border layout south create south panel else if selected files length content add  border layout north create north panel all content add  border layout center create center panel all content add  border layout south create south panel all 
public j panel create north panel all j panel north panel new j panel new  border layout info icon new j label info icon set icon ui manager get icon  option pane information icon north panel add  border layout west info icon int files counter int directories counter for int i i selected files length i if selected files i get type vfs file directory directories counter else if selected files i get type vfs file file files counter j panel name field new j panel name field add new j label j edit get property fileprop selected files files counter j edit get property fileprop selected directories directories counter north panel add  border layout center name field north panel add  border layout south new j panel return north panel 
public j panel create center panel all long files size l j panel center panel new j panel new  border layout for int i i selected files length i if selected files i get type vfs file directory  file io file new  file selected files i get path files size io utilities file length io file else if selected files i get type vfs file file files size selected files i get length j panel prop field new j panel prop field set layout new  grid layout  string path local get path if  operating system is windows  operating system is windows x  operating system is windows nt path path substring path last index of else path path substring path last index of prop field add new j label j edit get property fileprop path path prop field add new j label j edit get property fileprop size  misc utilities format file size files size  border etch  border factory create etched border prop field set border  border factory create titled border etch j edit get property fileprop properties center panel add  border layout center prop field return center panel 
public j panel create south panel all  button action handler action handler new  button action handler j panel south panel new j panel new  border layout j panel buttons field new j panel ok button new j button j edit get property fileprop ok btn buttons field add ok button ok button add action listener action handler cancel button new j button j edit get property fileprop cancel btn buttons field add cancel button cancel button add action listener action handler south panel add  border layout east buttons field return south panel 
public j panel create north panel j panel north panel new j panel new  border layout info icon new j label info icon set icon ui manager get icon  option pane information icon north panel add  border layout west info icon j panel name field new j panel name field add new j label j edit get property fileprop name name text field new j text field local get name name field add name text field north panel add  border layout center name field north panel add  border layout south new j panel return north panel 
public j panel create center panel  simple date format sdf new  simple date format yyyy mm dd hh mm j panel center panel new j panel new  border layout j panel prop field new j panel prop field set layout new  grid layout prop field add new j label j edit get property fileprop name local get name prop field add new j label j edit get property fileprop path local get path prop field add new j label j edit get property fileprop lastmod sdf format new  date local get modified if local get type vfs file directory  file io file new  file local get path prop field add new j label j edit get property fileprop size  misc utilities format file size io utilities file length io file else prop field add new j label j edit get property fileprop size  misc utilities format file size local get length  border etch  border factory create etched border prop field set border  border factory create titled border etch j edit get property fileprop properties center panel add  border layout center prop field j panel attribute field new j panel attribute field set layout new  grid layout readable new j check box j edit get property fileprop readable readable set selected local is readable readable set enabled false attribute field add readable write new j check box j edit get property fileprop writeable write set selected local is writeable write set enabled false attribute field add write attribute field set border  border factory create titled border etch j edit get property fileprop attribute center panel add  border layout south attribute field return center panel 
public j panel create south panel  button action handler action handler new  button action handler j panel south panel new j panel new  border layout j panel buttons field new j panel ok button new j button j edit get property fileprop ok btn buttons field add ok button ok button add action listener action handler cancel button new j button j edit get property fileprop cancel btn buttons field add cancel button cancel button add action listener action handler south panel add  border layout east buttons field return south panel 
 override public void ok if name text field null browser rename browser get selected files get path name text field get text gui utilities save geometry this propdialog set visible false 
 override public void cancel gui utilities save geometry this propdialog set visible false 
private void create and show gui add components to pane pack set default close operation dispose on close set focusable true to front request focus set resizable false set visible true 
public void action performed  action event evt  object source evt get source if source ok button ok else if source cancel button cancel 
public  file roots vfs super roots low latency cap browse cap new  string ea type 
public  string get parent of path  string path return protocol 
public vfs file  list files  object session  string url  component comp  file roots list roots if roots null return null vfs file root de new vfs file roots length for int i i roots length i root de i new  root roots i return root de 
public vfs file  get file  object session  string path  component comp return new  root new  file path 
private static  file list roots if  operating system is mac os  nasty hardcoded values  file volumes new  file  volumes list files  linked list  file roots new  linked list  file roots add new  file for int i i volumes length i  make sure people don t do stupid things like putting files in  volumes if volumes i is directory roots add volumes i return roots to array new  file roots size else  file roots  file list roots  file desktop fs view get roots if desktop null return roots  file roots plus new  file roots length desktop length  system arraycopy desktop roots plus desktop length  system arraycopy roots roots plus roots length return roots plus 
 root  file file remind calling is directory on a floppy drive displays stupid i o error dialog box on  windows  string path file get path set path path set delete path path set symlink path path if fs view is floppy drive file set type vfs file filesystem set name path else if fs view is drive file set type vfs file filesystem set name path fs view get system display name file else if file is directory if fs view is file system root file set type vfs file directory else set type vfs file filesystem if  operating system is mac os set name  misc utilities get file name path else set name path else set type vfs file file 
public  string get extended attribute  string name if name equals ea type return super get extended attribute name else don t want it to show bytes for size etc return null 
public  files changed dialog  view view int states boolean already reloaded super view j edit get property files changed title false this view view j panel content new j panel new  border layout content set border new  empty border set content pane content  box icon box new  box  box layout y axis icon box add new j label ui manager get icon  option pane warning icon icon box add  box create glue content add  border layout west icon box j panel center panel new j panel new  border layout j label label new j label j edit get property files changed caption label set border new  empty border center panel add  border layout north label  default mutable tree node deleted new  default mutable tree node j edit get property files changed deleted true  default mutable tree node changed new  default mutable tree node j edit get property files changed changed already reloaded auto true  default mutable tree node changed dirty new  default mutable tree node j edit get property files changed changed dirty already reloaded auto true  buffer buffers j edit get buffers for int i i states length i  buffer buffer buffers i  default mutable tree node add to switch states i case  buffer file deleted add to deleted break case  buffer file changed add to buffer is dirty changed dirty changed break default add to null break if add to null add to add new  default mutable tree node buffer get path root new  default mutable tree node true if deleted get child count root add deleted if changed get child count root add changed if changed dirty get child count root add changed dirty buffer tree model new  default tree model root buffer tree new j tree buffer tree model buffer tree set root visible false buffer tree set visible row count buffer tree set cell renderer new  renderer buffer tree get selection model add tree selection listener new  tree handler buffer tree get selection model set selection mode  tree selection model discontiguous tree selection center panel add  border layout center new j scroll pane buffer tree content add  border layout center center panel  box buttons new  box  box layout x axis buttons add  box create glue if already reloaded select all new j button j edit get property files changed select all select all set mnemonic j edit get property files changed select all mnemonic char at buttons add select all select all add action listener new  action handler buttons add  box create horizontal strut reload new j button j edit get property files changed reload reload set mnemonic j edit get property files changed reload mnemonic char at buttons add reload reload add action listener new  action handler buttons add  box create horizontal strut ignore new j button j edit get property files changed ignore ignore set mnemonic j edit get property files changed ignore mnemonic char at buttons add ignore ignore add action listener new  action handler buttons add  box create horizontal strut close new j button j edit get property common close get root pane set default button close buttons add close close add action listener new  action handler buttons add  box create glue content add  border layout south buttons buffer tree expand path new  tree path new  object root deleted buffer tree expand path new  tree path new  object root changed buffer tree expand path new  tree path new  object root changed dirty gui utilities request focus this buffer tree update enabled pack set location relative to view set visible true 
public void ok dispose 
public void cancel dispose 
private void update enabled  tree path paths buffer tree get selection paths boolean enabled false if paths null for int i i paths length i  object path paths i get path if path length enabled true if reload null reload set enabled enabled if ignore null ignore set enabled enabled 
private void select all select all in progress true  tree node path new  tree node path root for int i i root get child count i  default mutable tree node node  default mutable tree node root get child at i path node for int j j node get child count j  default mutable tree node node  default mutable tree node node get child at j path node buffer tree get selection model add selection path new  tree path path select all in progress false update enabled 
private void action  string action  tree path paths buffer tree get selection paths if paths null paths length return int row buffer tree get row for path paths for int i i paths length i  tree path path paths i is it a header if path get path count continue  default mutable tree node node  default mutable tree node path get last path component if node get user object instanceof  string return  buffer buffer j edit get buffer  string node get user object if buffer null return if reload equals action buffer reload view else buffer set auto reload false buffer set auto reload dialog false  default mutable tree node parent  default mutable tree node node get parent parent remove node buffer tree model reload root we expand those that are non empty and remove those that are empty  tree node nodes root null remove empty category branches for int j j root get child count j  default mutable tree node node  default mutable tree node root get child at j if root get child at j get child count root remove j j else nodes node buffer tree expand path new  tree path nodes if root get child count dispose else if row buffer tree get row count row buffer tree get row count  tree path path buffer tree get path for row row if path get path count selected a header skip to the next row buffer tree set selection row row else buffer tree set selection path path 
public void action performed  action event evt  object source evt get source if source select all select all else if source reload action reload else if source close dispose else if source ignore action ignore 
public void value changed  tree selection event evt if select all in progress return update enabled  tree path paths buffer tree get selection paths if paths null paths length return  tree path path paths paths length  default mutable tree node node  default mutable tree node path get last path component if node get user object instanceof  string  buffer buffer j edit get buffer  string node get user object if buffer null view show buffer buffer 
 renderer entry font ui manager get font  tree font if entry font null entry font j edit get font property metal secondary font group font entry font derive font  font bold 
public  component get tree cell renderer component j tree tree  object value boolean selected boolean expanded boolean leaf int row boolean has focus super get tree cell renderer component tree value selected expanded leaf row has focus  default mutable tree node node  default mutable tree node value if node get parent tree get model get root set font group font else set font entry font set icon null return this 
public  file vfs super file read cap write cap browse cap delete cap rename cap mkdir cap low latency cap  operating system is case insensitive fs case insensitive cap new  string ea type ea size ea status ea modified 
 override public  string get parent of path  string path if  operating system is dos derived if path length path char at return  file roots vfs protocol else if path length path ends with return  file roots vfs protocol else if path starts with path index of return path return super get parent of path path 
 override public  string construct path  string parent  string path if parent ends with  file separator parent ends with return parent path else return parent  file separator path 
 override public char get file separator return  file separator char 
 returns a temporary file name based on the given path p  if the directory where the file would be created cannot be written i e no new files can be created in that directory this method returns code null code p param path  the path name  override public  string get two stage save name  string path  file parent new  file get parent of path path the ignorance of the can write method for windows is because the read only flag on windows has not the effect of preventing the creation of new files  the only way to make a directory read only in this means the acl of the directory has to be set to read only which is not checkable by java  the  operating system is windows can be removed if the can write method gives back the right value return parent can write  operating system is windows super get two stage save name path null 
 override public boolean save  view view  buffer buffer  string path if  operating system is unix int permissions get permissions buffer get path  log log  log debug this buffer get path has permissions  integer to string permissions buffer set integer property permissions property permissions return super save view buffer path 
 override public boolean insert  view view  buffer buffer  string path  file file new  file path  check if file is valid if file exists return false if file is directory vfs manager error view file get path ioerror open directory null return false if file can read vfs manager error view file get path ioerror no read null return false return super insert view buffer path 
param path the directory path to recursive delete return true if successful else false public static boolean recursive delete  file path if path exists  file files path list files for int i i files length i if files i is directory recursive delete files i else files i delete return path delete 
 returns the canonical form if the specified path name  for example code code might be expanded to the user s home directory param session  the session param path  the path param comp  the component that will parent error dialog boxes exception io exception if an i o error occurred since j edit pre  override public  string  canon path  object session  string path  component comp throws io exception return  misc utilities canon path path 
public  local file  file file this file file  these attributes are fetched relatively quickly  the rest are lazily filled in set name file get name  string path file get path set path path set delete path path set hidden file is hidden set type file is directory vfs file directory vfs file file 
 override public  string get extended attribute  string name fetch attrs if name equals ea modified return date format format new  date modified else return super get extended attribute name 
 fetch the attributes of the local file  override protected void fetch attrs if fetched attrs return super fetch attrs set symlink path  misc utilities resolve symlinks file get path set readable file can read set writeable file can write set length file length set modified file last modified 
 returns the file system icon for the file param expanded not used here param open buffer not used here return the file system icon since pre  override public  icon get icon boolean expanded boolean open buffer if icon null if fs view null fs view  file system view get file system view icon fs view get system icon file return icon 
 override public  string get symlink path fetch attrs return super get symlink path 
 override public long get length fetch attrs return super get length 
 override public boolean is readable fetch attrs return super is readable 
 override public boolean is writeable fetch attrs return super is writeable 
public long get modified fetch attrs return modified 
public void set modified long modified this modified modified 
 override public vfs file  list files  object session  string path  component comp  windows work around  on  windows paths of the form x list the last working directory on that drive  to list the root of the drive you must use x  however the vfs browser and friends strip off trailing path separators for various reasons  so to work around that we add a to drive letter paths on  windows if  operating system is windows if path length path char at path path concat  file separator  file directory new  file path  file list null if directory exists list fs view get files directory false if list null vfs manager error comp path ioerror directory error nomsg null return null vfs file list new vfs file list length for int i i list length i list i new  local file list i return list 
 override public vfs file  get file  object session  string path  component comp if path equals  operating system is unix return new vfs  directory entry path path path vfs file directory l false  file file new  file path if file exists return null return new  local file file 
 override public boolean  delete  object session  string path  component comp  file file new  file path do some platforms throw exceptions if the file does not exist when we ask for the canonical path  string canon path try canon path file get canonical path catch io exception io canon path path if directory do recursive delete boolean ret val if file is directory ret val file delete else ret val recursive delete file if ret val vfs manager send vfs update this canon path true return ret val 
 override public boolean  rename  object session  string from  string to  component comp  file  to new  file to  string to canon path try to canon path  to get canonical path catch io exception io to canon path to this is needed because on os x renaming to a non existent directory causes problems  file parent new  file  to get parent if parent exists if parent is directory return false else parent mkdirs if parent exists return false  file  from new  file from  string from canon path try from canon path  from get canonical path catch io exception io from canon path from  case insensitive fs workaround if from canon path equals ignore case to canon path  to delete boolean ret val  from rename to  to vfs manager send vfs update this from canon path true vfs manager send vfs update this to canon path true return ret val 
 override public boolean  mkdir  object session  string directory  component comp  string parent get parent of path directory if new  file parent exists if  mkdir session parent comp return false  file file new  file directory boolean ret val file mkdir  string canon path try canon path file get canonical path catch io exception io canon path directory vfs manager send vfs update this canon path true return ret val 
 override public void  backup  object session  string path  component comp throws io exception  fetch properties int backups j edit get integer property backups if backups return  string backup prefix j edit get property backup prefix  string backup suffix j edit get property backup suffix  string backup directory j edit get property backup directory int backup time distance j edit get integer property backup min time  file file new  file path if file exists return  check for backup directory and create that directory if it doesn t exist if backup directory null backup directory length backup directory file get parent else backup directory  misc utilities construct path  system get property user home backup directory  perhaps here we would want to guard with a property for parallel backups or not backup directory  misc utilities concat path backup directory file get parent  file dir new  file backup directory if dir exists dir mkdirs  misc utilities save backup file backups backup prefix backup suffix backup directory backup time distance 
 override public  input stream  create input stream  object session  string path boolean ignore errors  component comp throws io exception try return new  file input stream path catch io exception io if ignore errors return null else throw io 
 override public  output stream  create output stream  object session  string path  component comp throws io exception return new  file output stream path 
 override public void  save complete  object session  buffer buffer  string path  component comp int permissions buffer get integer property permissions property set permissions path permissions 
 returns numeric permissions of a file  on non  unix systems always returns zero since j edit pre public static int get permissions  string path int permissions if j edit get boolean property chmod disabled return permissions if  operating system is unix  string cmdarray ls ld path try  process process  runtime get runtime exec cmdarray  buffered reader reader new  buffered reader new  input stream reader process get input stream  string output reader read line if output null  string s output substring permissions  misc utilities parse permissions s  feb pm  catch  throwable here rather than  exception  kaffe s implementation of  runtime exec throws java lang  internal error catch  throwable t return permissions 
 sets numeric permissions of a file  on non  unix platforms does nothing since j edit pre public static void set permissions  string path int permissions if j edit get boolean property chmod disabled return if permissions if  operating system is unix  string cmdarray chmod  integer to string permissions path try  process process  runtime get runtime exec cmdarray process get input stream close process get output stream close process get error stream close  jun pm wait for hangs on some  java implementations int exit code process wait for if exit code  log log  log notice  file vfs class chmod exited with code exit code  feb pm  catch  throwable here rather than  exception  kaffe s implementation of  runtime exec throws java lang  internal error catch  throwable t 
protected  filtered list model e delegated this delegated delegated delegated add list data listener this reset filter 
 set the j list that uses this model  it is used to restore the selection after the filter has been applied  if it is null param list the list that uses the model public void set list j list list if list get model this throw new  illegal argument exception  the given list list doesn t use this model this this list list 
public e get delegated return delegated 
public void set delegated e delegated this delegated remove list data listener this delegated add list data listener this this delegated delegated 
private void reset filter filtered indices null 
public void set filter final  string filter  runnable runner new  runnable public void run  set  integer selected indices save selection list clear selection  filtered list model this filter filter if filter null filter length int size delegated get size  string prepped filter prepare filter filter  vector  integer indices new  vector  integer size  map  integer  integer inverted indices new  hash map  integer  integer for int i i size i if pass filter i prepped filter  integer delegated indice  integer value of i indices add delegated indice inverted indices put delegated indice indices size  filtered list model this inverted indices inverted indices filtered indices indices else reset filter fire contents changed this get size restore selection selected indices  swing utilities invoke later runner 
public  string prepare filter  string filter return filter 
protected  set  integer save selection if list null return null int rows list get selected indices if rows length return null  set  integer selected rows new  hash set  integer rows length for int row rows selected rows add get true row row return selected rows 
protected void restore selection  set  integer selected indices if selected indices null get size return  to correctly handle single interval selection mode each interval has to be selected using a single call to set selection interval calling set selection interval on each item cancels the previous selection  sort the list of selected indices to simplify interval identification  vector  integer sel new  vector  integer selected indices  collections sort sel int from int to for  integer selected index sel int i get internal  external row selected index int value if i if from from to i else if i to to i else list set selection interval from to from to i if from list set selection interval from to 
 converts a row index from the j table to an internal row index from the delegated model param row index the row index return the row index in the delegated model public int get true row int row index if filtered indices null return row index return filtered indices get row index int value 
 converts a row index from the delegated table model into a row index of the j table param internal row index the internal row index return the table row index or if this row is not visible public int get internal  external row int internal row index if inverted indices null return internal row index  integer external row index inverted indices get internal row index if external row index null return return external row index int value 
public  object get element at int index int true row index get true row index return delegated get element at true row index 
public int get size if filtered indices null return delegated get size return filtered indices size 
public void contents changed  list data event e set filter filter 
public void interval added  list data event e set filter filter 
public void interval removed  list data event e set filter filter 
protected  filtered table model e delegated this delegated delegated delegated add table model listener this reset filter 
 set the j table that uses this model  it is used to restore the selection after the filter has been applied  if it is null param table the table that uses the model public void set table j table table if table get model this throw new  illegal argument exception  the given table table doesn t use this model this this table table 
public e get delegated return delegated 
public void set delegated e delegated this delegated remove table model listener this delegated add table model listener this this delegated delegated 
private void reset filter filtered indices null 
public void set filter  string filter  set  integer selected indices save selection this filter filter if filter null filter length int size delegated get row count filter prepare filter filter  vector  integer indices new  vector  integer size  map  integer  integer inverted indices new  hash map  integer  integer for int i i size i if pass filter i filter  integer delegated indice  integer value of i indices add delegated indice inverted indices put delegated indice indices size this inverted indices inverted indices filtered indices indices else reset filter fire table data changed restore selection selected indices 
public  string prepare filter  string filter return filter 
private  set  integer save selection if table null return null int rows table get selected rows if rows length return null  set  integer selected rows new  hash set  integer rows length for int row rows selected rows add get true row row return selected rows 
private void restore selection  set  integer selected indices if selected indices null get row count return for  integer selected index selected indices int i get internal  external row selected index int value if i table get selection model set selection interval i i 
public int get row count if filtered indices null return delegated get row count return filtered indices size 
public int get column count return delegated get column count 
public  string get column name int column index return delegated get column name column index 
public  class get column class int column index return delegated get column class column index 
public boolean is cell editable int row index int column index int true row index get true row row index return delegated is cell editable true row index column index 
public  object get value at int row index int column index int true row index get true row row index return delegated get value at true row index column index 
public void set value at  object a value int row index int column index int true row index get true row row index delegated set value at a value true row index column index 
 converts a row index from the j table to an internal row index from the delegated model param row index the row index return the row index in the delegated model public int get true row int row index if filtered indices null return row index return filtered indices get row index int value 
 converts a row index from the delegated table model into a row index of the j table param internal row index the internal row index return the table row index or if this row is not visible public int get internal  external row int internal row index if inverted indices null return internal row index  integer external row index inverted indices get internal row index if external row index null return return external row index int value 
 this fine grain notification tells listeners the exact range of cells rows or columns that changed public void table changed  table model event e set filter filter 
public  firewall option pane super firewall 
public void  init checkbox add component http enabled new j check box j edit get property options firewall http enabled proxy host add component j edit get property options firewall http host http host new j text field j edit get property firewall host proxy port add component j edit get property options firewall http port http port new j text field j edit get property firewall port proxy username add component j edit get property options firewall http user http user new j text field j edit get property firewall user proxy password add component j edit get property options firewall http password http pass new j password field j edit get property firewall password no proxy for add component j edit get property options firewall http non proxy http non proxy new j text field j edit get property firewall non proxy hosts boolean enabled j edit get boolean property firewall enabled http enabled set selected enabled http host set enabled enabled http port set enabled enabled http user set enabled enabled http pass set enabled enabled http non proxy set enabled enabled http enabled add action listener new  action handler checkbox add component socks enabled new j check box j edit get property options firewall socks enabled proxy host add component j edit get property options firewall socks host socks host new j text field j edit get property firewall socks host proxy port add component j edit get property options firewall socks port socks port new j text field j edit get property firewall socks port enabled j edit get boolean property firewall socks enabled socks enabled set selected enabled socks host set enabled enabled socks port set enabled enabled socks enabled add action listener new  action handler 
public void  save j edit set boolean property firewall enabled http enabled is selected j edit set property firewall host http host get text j edit set property firewall port http port get text j edit set property firewall user http user get text j edit set property firewall password new  string http pass get password j edit set property firewall non proxy hosts http non proxy get text j edit set boolean property firewall socks enabled socks enabled is selected j edit set property firewall socks host socks host get text j edit set property firewall socks port socks port get text 
public void action performed  action event evt http host set enabled http enabled is selected http port set enabled http enabled is selected http user set enabled http enabled is selected http pass set enabled http enabled is selected http non proxy set enabled http enabled is selected socks host set enabled socks enabled is selected socks port set enabled socks enabled is selected 
 first line  display manager display manager  text area text area super display manager text area 
 override public void changed  debug code if  debug scroll debug  log log  log debug this changed before physical line scroll line skew ensure physical line is visible int screen lines display manager get screen line count physical line if skew screen lines skew screen lines  debug code if  debug scroll verify  system err println scroll verify int verify scroll line for int i i display manager get buffer get line count i if display manager is line visible i continue if i physical line break verify scroll line display manager get screen line count i if verify scroll line scroll line  exception ex new  exception scroll line verify scroll line  log log  log error this ex if  debug scroll debug  log log  log debug this changed after physical line scroll line skew 
 override public void reset if  debug scroll debug  log log  log debug this reset int old physical line physical line physical line scroll line int i display manager get first visible line for if i old physical line break scroll line display manager get screen line count i int next line display manager get next visible line i if next line break else i next line physical line i int screen lines display manager get screen line count physical line if skew screen lines skew screen lines text area update scroll bar 
void phys down int amount int screen amount if  debug scroll debug  log log  log debug this phys down start physical line scroll line skew if display manager is line visible physical line int last visible line display manager get last visible line if physical line last visible line physical line last visible line else int next physical line display manager get next visible line physical line amount next physical line physical line scroll line display manager get screen line count physical line physical line next physical line for int next physical line display manager get next visible line physical line if next physical line break else if next physical line physical line amount break else scroll line display manager get screen line count physical line amount next physical line physical line physical line next physical line if  debug scroll debug  log log  log debug this phys down end physical line scroll line call changed true j edit text area scroll to needs this to simplify its code if screen amount scroll up screen amount else if screen amount scroll down screen amount 
void phys up int amount int screen amount if  debug scroll debug  log log  log debug this phys up start physical line scroll line skew if display manager is line visible physical line int first visible line display manager get first visible line if physical line first visible line physical line first visible line else int prev physical line display manager get prev visible line physical line amount physical line prev physical line for int prev physical line display manager get prev visible line physical line if prev physical line break else if prev physical line physical line amount break else amount physical line prev physical line physical line prev physical line scroll line display manager get screen line count prev physical line if  debug scroll debug  log log  log debug this phys up end physical line scroll line call changed true j edit text area scroll to needs this to simplify its code if screen amount scroll up screen amount else if screen amount scroll down screen amount 
void scroll down int amount if  debug scroll debug  log log  log debug this scroll down ensure physical line is visible amount skew skew while amount int screen lines display manager get screen line count physical line if amount screen lines skew amount break else int next line display manager get next visible line physical line if next line break boolean visible display manager is line visible physical line physical line next line if visible amount screen lines scroll line screen lines call changed true 
void scroll up int amount if  debug scroll debug  log log  log debug this scroll up before this ensure physical line is visible if amount skew the amount is less than the skew so we stay in the same like just going upper skew amount else moving to the first screen line of the current physical line amount skew skew while amount int prev line display manager get prev visible line physical line if prev line break moving to the previous visible physical line physical line prev line int screen lines display manager get screen line count physical line scroll line screen lines if amount screen lines skew screen lines amount break else amount screen lines if  debug scroll debug  log log  log debug this scroll up after this call changed true 
void ensure physical line is visible if display manager is line visible physical line if physical line display manager get last visible line physical line display manager get last visible line scroll line display manager get scroll line count else if physical line display manager get first visible line physical line display manager get first visible line scroll line else physical line display manager get next visible line physical line scroll line display manager get screen line count physical line 
 override public  string to string return  first line physical line scroll line skew 
public  floating window container  dockable window manager impl dockable window manager boolean clone this dockable window manager dockable window manager dockable window manager add property change listener this this clone clone set icon image gui utilities get plugin icon set default close operation dispose on close  box caption new  box  box layout x axis caption add menu new  rollover button gui utilities load icon j edit get property dropdown arrow icon menu add mouse listener new  mouse handler menu set tool tip text j edit get property docking menu label  box separator box new  box  box layout y axis separator box add  box create vertical strut separator box add new j separator j separator horizontal separator box add  box create vertical strut caption add separator box get content pane add  border layout north caption 
public void register  dockable window manager impl  entry entry this entry entry dockable name entry factory name set title entry short title get content pane add  border layout center entry win pack  container parent dockable window manager get view gui utilities load geometry this parent dockable name gui utilities add size saver this parent dockable name  key listener listener dockable window manager close listener dockable name add key listener listener get content pane add key listener listener menu add key listener listener entry win add key listener listener set visible true if entry win is visible entry win set visible true 
public void remove  dockable window manager impl  entry entry dispose 
public void unregister  dockable window manager impl  entry entry this entry null entry btn null entry container null  note entry win must not be reset to enable the dockable instance to be moved instead of recreated if it uses the movable attribute super dispose 
public void show final  dockable window manager impl  entry entry if entry null dispose else set title entry long title to front request focus  swing utilities invoke later new  runnable public void run if entry win instanceof  default focus component  default focus component entry win focus on default component else entry win request focus 
public boolean is visible  dockable window manager impl  entry entry return true 
 override public void dispose entry container null entry win null super dispose 
public  dockable window manager impl get dockable window manager return dockable window manager 
 override public  dimension get minimum size return new  dimension 
 override public void mouse pressed  mouse event evt if popup null popup is visible popup set visible false else popup dockable window manager create popup menu  floating window container this entry factory name clone gui utilities show popup menu popup menu menu get x menu get y menu get height false 
public void property change  property change event evt if dockable name null return  string pn evt get property name if pn starts with dockable name pn ends with title set title evt get new value to string 
 returns the internal name of this  fold handler return  the internal name of this  fold handler since j edit pre public  string get name return name 
 returns the fold levels of the lines preceding the specified line which depend on the specified line param buffer  the buffer in question param line index  the line index param seg a segment the fold handler can use to obtain any param line fold level  the fold level of the specified line return  the fold levels of the preceding lines in decreasing line number order i e bottomost line first since j edit pre public  list  integer get preceding fold levels j edit buffer buffer int line index  segment seg int line fold level return null 
 returns if the specified fold handler is equal to this one param o  the object public boolean equals  object o  default implementation subclasses can extend this if o null return false else return get class o get class 
public int hash code return get class hash code 
 returns the fold handler with the specified name or null if there is no registered handler with that name param name  the name of the desired fold handler since j edit pre public static  fold handler get fold handler  string name return fold handler provider get fold handler name 
 returns an array containing the names of all registered fold handlers since j edit pre public static  string get fold modes return fold handler provider get fold modes 
protected  fold handler  string name this name name 
public  string to string return name 
public  widget get widget  view view  widget fold new  fold widget view return fold 
public  fold widget final  view view fold new  tool tip label this view view fold set tool tip text j edit get property view status mode tooltip fold add mouse listener new  mouse adapter  override public void mouse clicked  mouse event evt if evt get click count new  buffer options view view get buffer 
public j component get component return fold 
public void update  buffer buffer view get buffer if buffer is loaded fold set text  string view get buffer get property folding 
public void properties changed 
 creates a new font selector control param font  the font public  font selector  font font this font false 
 creates a new font selector control param font  the font param anti alias  is anti aliasing enabled since j edit pre public  font selector  font font boolean anti alias set font font this anti alias anti alias update text set request focus enabled false add action listener new  action handler 
public void paint component  graphics g set anti alias enabled g super paint component g 
public boolean is anti alias enabled return anti alias 
public void set anti alias enabled boolean anti alias this anti alias anti alias 
private void update text  font font get font  string style string switch font get style case  font plain style string j edit get property font selector plain break case  font bold style string j edit get property font selector bold break case  font italic style string j edit get property font selector italic break case  font bold  font italic style string j edit get property font selector bolditalic break default style string unknown break set text font get name font get size style string 
void set anti alias enabled  graphics g if anti alias  graphics d g  graphics d g g set rendering hint  rendering hints key antialiasing  rendering hints value antialias on 
public void action performed  action event evt  font font j dialog dialog gui utilities get parent dialog  font selector this if dialog null font new  font selector dialog j option pane get frame for component  font selector this get font  font selector this get selected font else font new  font selector dialog dialog get font  font selector this get selected font if font null set font font update text 
 font selector dialog  frame parent  font font super parent j edit get property font selector title true init font 
 font selector dialog  dialog parent  font font super parent j edit get property font selector title true init font 
 font selector dialog  frame parent  font font  font selector font selector super parent j edit get property font selector title true this font selector font selector init font 
 font selector dialog  dialog parent  font font  font selector font selector super parent j edit get property font selector title true this font selector font selector init font 
public void ok is ok true dispose 
public void cancel dispose 
public  font get selected font if is ok return null int size try size  integer parse int size field get text catch  exception e size return new  font family field get text style list get selected index size 
private void init  font font j panel content new j panel new  border layout content set border new  empty border set content pane content j panel list panel new j panel new  grid layout  string fonts try fonts get font list catch  exception e  log log  log error this  broken  java implementation  log log  log error this  using deprecated  toolkit get font list  log log  log error this e fonts get toolkit get font list fonts new  string  broken  java implementation j panel family panel create text field and list panel font selector family family field new j text field family list new j list fonts list panel add family panel  string sizes j panel size panel create text field and list panel font selector size size field new j text field size list new j list sizes list panel add size panel  string styles j edit get property font selector plain j edit get property font selector bold j edit get property font selector italic j edit get property font selector bolditalic j panel style panel create text field and list panel font selector style style field new j text field style list new j list styles style field set editable false list panel add style panel family list set selected value font get family true family field set text font get family size list set selected value  string value of font get size true size field set text  string value of font get size style list set selected index font get style style field set text  string style list get selected value  list handler list handler new  list handler family list add list selection listener list handler size list add list selection listener list handler style list add list selection listener list handler content add  border layout north list panel preview new j label j edit get property font selector long text public void paint component  graphics g if font selector null font selector set anti alias enabled g super paint component g preview set border new  titled border j edit get property font selector preview update preview  dimension pref size preview get preferred size pref size height preview set preferred size pref size content add  border layout center preview j panel buttons new j panel buttons set layout new  box layout buttons  box layout x axis buttons set border new  empty border buttons add  box create glue ok new j button j edit get property common ok ok add action listener new  action handler get root pane set default button ok buttons add ok buttons add  box create horizontal strut cancel new j button j edit get property common cancel cancel add action listener new  action handler buttons add cancel buttons add  box create glue content add  border layout south buttons pack set location relative to get parent set visible true 
private static  string get font list  string name array  graphics environment get local graphics environment get available font family names  list  string name vector new  array list  string name array length for int i j i name array length i for j j hidefonts length j if name array i contains hidefonts j break if j hidefonts length name vector add name array i  string  array new  string name vector size return name vector to array  array 
private static j panel create text field and list panel  string label j text field text field j list list  grid bag layout layout new  grid bag layout j panel panel new j panel layout  grid bag constraints cons new  grid bag constraints cons gridx cons gridy cons gridwidth cons gridheight cons fill  grid bag constraints both cons weightx f j label  label new j label j edit get property label layout set constraints  label cons panel add  label cons gridy  component vs  box create vertical strut layout set constraints vs cons panel add vs cons gridy layout set constraints text field cons panel add text field cons gridy vs  box create vertical strut layout set constraints vs cons panel add vs cons gridy cons gridheight  grid bag constraints remainder cons weighty f j scroll pane scroller new j scroll pane list layout set constraints scroller cons panel add scroller return panel 
private void update preview  string family family field get text int size try size  integer parse int size field get text catch  exception e size int style style list get selected index preview set font new  font family style size 
public void action performed  action event evt if evt get source ok ok else if evt get source cancel cancel 
public void value changed  list selection event evt  object source evt get source if source family list  string family  string family list get selected value if family null family field set text family else if source size list  string size  string size list get selected value if size null size field set text size else if source style list  string style  string style list get selected value if style null style field set text style update preview 
public  general option pane super general 
 override protected void  init  line separator  string line seps j edit get property line sep unix j edit get property line sep windows j edit get property line sep mac line separator new j combo box line seps  string line sep j edit get property buffer j edit buffer linesep  system get property line separator if n equals line sep line separator set selected index else if r n equals line sep line separator set selected index else if r equals line sep line separator set selected index add component j edit get property options general line separator line separator  check mod status  string mod check options j edit get property options general check mod status nothing j edit get property options general check mod status prompt j edit get property options general check mod status reload j edit get property options general check mod status silent reload check mod status new j combo box mod check options if j edit get boolean property auto reload if j edit get boolean property auto reload dialog reload and notify check mod status set selected index else reload silently check mod status set selected index else if j edit get boolean property auto reload dialog prompt check mod status set selected index else do nothing check mod status set selected index add component j edit get property options general check mod status check mod status  check mod status upon  string mod check upon options j edit get property options general check mod status upon focus j edit get property options general check mod status upon all j edit get property options general check mod status upon operations j edit get property options general check mod status upon focus buffer j edit get property options general check mod status upon none check mod status upon new j combo box mod check upon options check mod status upon set selected index j edit get integer property check file status add component j edit get property options general check mod status upon check mod status upon  recent file list size recent files new j text field j edit get property options general recent files recent files set text j edit get property recent files add component j edit get property options general recent files recent files  sort recent file list sort recent new j check box j edit get property options general sort recent sort recent set selected j edit get boolean property sort recent add component sort recent  save caret positions save caret new j check box j edit get property options general save caret save caret set selected j edit get boolean property save caret add component save caret  persistent markers persistent markers new j check box j edit get property options general persistent markers persistent markers set selected j edit get boolean property persistent markers add component persistent markers  session management restore new j check box j edit get property options general restore restore set selected j edit get boolean property restore restore add action listener new  action listener public void action performed  action event evt restore cli set enabled restore is selected restore remote set enabled restore is selected add component restore restore remote new j check box j edit get property options general restore remote restore remote set selected j edit get boolean property restore remote false restore remote set enabled restore is selected add component restore remote restore cli new j check box j edit get property options general restore cli restore cli set selected j edit get boolean property restore cli restore cli set enabled restore is selected add component restore cli hypersearch results warning new j text field j edit get property hypersearch max warning results add component j edit get property options general hypersearch max warning results hypersearch results warning 
 override protected void  save  string line sep null switch line separator get selected index case line sep n break case line sep r n break case line sep r break j edit set property buffer j edit buffer linesep line sep switch check mod status get selected index case j edit set boolean property auto reload dialog false j edit set boolean property auto reload false break case j edit set boolean property auto reload dialog true j edit set boolean property auto reload false break case j edit set boolean property auto reload dialog true j edit set boolean property auto reload true break case j edit set boolean property auto reload dialog false j edit set boolean property auto reload true break j edit set integer property check file status check mod status upon get selected index j edit set property recent files recent files get text j edit set boolean property sort recent sort recent is selected j edit set boolean property save caret save caret is selected j edit set boolean property persistent markers persistent markers is selected j edit set boolean property restore restore is selected j edit set boolean property restore cli restore cli is selected j edit set boolean property restore remote restore remote is selected try j edit set integer property hypersearch max warning results  integer parse int hypersearch results warning get text catch  number format exception e  log log  log warning this hypersearch results warning hypersearch results warning get text is not a valid value for this option 
public  global options  frame frame super frame options j edit get property options last 
public  global options  frame frame  string pane super frame options pane 
public  global options  dialog dialog super dialog options j edit get property options last 
public  global options  dialog dialog  string pane super dialog options pane 
protected  option tree model create option tree model  option tree model pane tree model new  option tree model  option group root group  option group pane tree model get root initialize the j edit branch of the options tree  option group j edit group new  option group jedit j edit group add option pane general j edit group add option pane abbrevs j edit group add option pane appearance j edit group add option pane context j edit group add option pane docking j edit group add option pane editing j edit group add option pane encodings j edit group add option pane gutter j edit group add option pane mouse j edit group add option pane plugin manager j edit group add option pane print j edit group add option pane firewall j edit group add option pane save back j edit group add option pane shortcuts j edit group add option pane status j edit group add option pane syntax j edit group add option pane textarea j edit group add option pane toolbar j edit group add option pane view root group add option group j edit group  option group browser group new  option group browser browser group add option pane browser general browser group add option pane browser colors root group add option group browser group return pane tree model 
 override public void cancel  edit bus send new  properties changing null  properties changing  state canceled super cancel 
 override protected void init  string name  string pane  edit bus send new  properties changing null  properties changing  state loading super init name pane 
protected  option group get default group return null 
public  glob vfs file filter  string glob this glob glob 
public boolean accept vfs file file if file get type vfs file directory file get type vfs file filesystem return true else return accept file get name 
public boolean accept  string url if pattern null pattern  pattern compile  standard utilities glob to re glob  pattern case insensitive return pattern matcher url matches 
public  string get description return j edit get property vfs browser file filter glob 
public  string to string return glob 
public void set glob  string glob this glob glob pattern null 
public  string get glob return glob 
deprecated use link org gjt sp jedit input  abstract input handler to string java awt event  key event  deprecated public static  string to string  key event evt return  abstract input handler to string evt 
 create and show a new modal dialog param parent center dialog on this component param binding the action macro that should get a binding param all bindings all other key bindings param debug buffer debug info will be dumped to this buffer may be null since j edit pre public  grab key dialog  dialog parent  key binding binding  list  key binding all bindings  buffer debug buffer super parent j edit get property grab key title true init binding all bindings debug buffer 
 create and show a new modal dialog param parent center dialog on this component param binding the action macro that should get a binding param all bindings all other key bindings param debug buffer debug info will be dumped to this buffer may be null since j edit pre public  grab key dialog  frame parent  key binding binding  list  key binding all bindings  buffer debug buffer super parent j edit get property grab key title true init binding all bindings debug buffer 
 returns the shortcut or null if the current shortcut should be removed or the dialog either has been cancelled  use is ok to determine if the latter is true public  string get shortcut if is ok return shortcut get text else return null 
 returns true if the dialog has not been cancelled since j edit pre public boolean is ok return is ok 
 returns if this component can be traversed by pressing the  tab key  this returns false public boolean is managing focus return false 
 makes the tab key work in  java since j edit pre  override public boolean get focus traversal keys enabled return false 
 override protected void process key event  key event evt shortcut process key event evt 
private void init  key binding binding  list  key binding all bindings  buffer debug buffer this binding binding this all bindings all bindings this debug buffer debug buffer enable events awt event key event mask create a panel with a  box layout  can t use  box here because  box doesn t have set border j panel content new j panel new  grid layout  makes the tab key work in  java since j edit pre  override public boolean get focus traversal keys enabled return false content set border new  empty border set content pane content j label label new j label debug buffer null j edit get property grab key caption new  string binding label j edit get property grab key keyboard test  box input  box create horizontal box shortcut new  input pane  dimension size shortcut get preferred size size width  integer max value shortcut set maximum size size input add shortcut input add  box create horizontal strut clear new j button j edit get property grab key clear clear add action listener new  action handler input add clear assigned to new j label if debug buffer null update assigned to null  box buttons  box create horizontal box buttons add  box create glue if debug buffer null ok new j button j edit get property common ok ok add action listener new  action handler buttons add ok buttons add  box create horizontal strut if binding is assigned show remove button remove new j button j edit get property grab key remove remove add action listener new  action handler buttons add remove buttons add  box create horizontal strut cancel new j button j edit get property common cancel cancel add action listener new  action handler buttons add cancel buttons add  box create glue content add label content add input if debug buffer null content add assigned to content add buttons set default close operation dispose on close pack set location relative to get parent set resizable false set visible true 
public static  string get symbolic name int key code if  debug dump key events  log log  log debug  grab key dialog class get symbolic name key code if key code  key event vk undefined return null else if key code  key event vk open bracket return else if key code  key event vk close bracket return if key code  key event vk a key code  key event vk z return  string value of  character to lower case char key code try  field fields  key event class get fields for int i i fields length i  field field fields i  string name field get name if name starts with vk  field get int null key code return name substring catch  exception e  log log  log error  grab key dialog class e return null 
private void update assigned to  string shortcut  string text j edit get property grab key assigned to none  key binding kb get key binding shortcut if kb null if kb is prefix text j edit get property grab key assigned to prefix new  string shortcut else text kb label if ok null ok set enabled kb null kb is prefix assigned to set text j edit get property grab key assigned to new  string text 
private  key binding get key binding  string shortcut if shortcut null shortcut length return null  string spaced shortcut shortcut for  key binding kb all bindings if kb is assigned continue  string spaced kb shortcut kb shortcut eg trying to bind c n c p if c n already bound if spaced shortcut starts with spaced kb shortcut return kb eg trying to bind c e if c e is a prefix if spaced kb shortcut starts with spaced shortcut create a temporary synthetic prefix  key binding that won t be saved return new  key binding kb name kb label shortcut true return null 
public  key binding  string name  string label  string shortcut boolean is prefix this name name this label label this shortcut shortcut this is prefix is prefix 
public boolean is assigned return shortcut null shortcut length 
 makes the tab key work in  java since j edit pre  override public boolean get focus traversal keys enabled return false 
 override protected void process key event  key event  evt  key event evt  key event workaround process key event  evt if  key event workaround is bindable  evt get key code evt null if debug buffer null debug buffer insert debug buffer get length  event  abstract input handler to string  evt evt null filtered n passed n if evt null return evt consume  key event translator  key key  key event translator translate key event evt if  debug dump key events  log log  log debug  grab key dialog class process key event key key  evt  evt if key null return if debug buffer null debug buffer insert debug buffer get length  translated to key n  string builder key string new  string builder get text if get document get length key string append if key modifiers null key string append key modifiers append  string symbolic name get symbolic name key key if symbolic name null key string append symbolic name else if key input if key input key string append space else key string append key input else return set text key string to string if debug buffer null update assigned to key string to string 
public void action performed  action event evt if evt get source ok if can close dispose else if evt get source remove shortcut set text null is ok true dispose else if evt get source cancel dispose else if evt get source clear shortcut set text null if debug buffer null update assigned to null shortcut request focus 
private boolean can close  string shortcut string shortcut get text if shortcut string length binding is assigned ask whether to remove the old shortcut int answer gui utilities confirm  grab key dialog this grab key remove ask null j option pane yes no option j option pane question message if answer j option pane yes option shortcut set text null is ok true else return false check whether this shortcut already exists  key binding other get key binding shortcut string if other null other binding is ok true return true check whether the other shortcut is the alt shortcut if other name binding name we don t need two identical shortcuts gui utilities error  grab key dialog this grab key duplicate alt shortcut null return false check whether shortcut is a prefix to others if other is prefix can t override prefix shortcuts gui utilities error  grab key dialog this grab key prefix shortcut null return false ask whether to override that other shortcut int answer gui utilities confirm  grab key dialog this grab key duplicate shortcut new  object other label j option pane yes no option j option pane question message if answer j option pane yes option if other shortcut null shortcut string starts with other shortcut other shortcut null is ok true return true else return false 
 sets the path where j edit looks for icons since j edit pre public static void set icon path  string icon path gui utilities icon path icon path if icons null icons clear 
 loads an icon param icon name  the icon name since j edit pre public static  icon load icon  string icon name if icon name null return null  enable old icon naming scheme support if deprecated icons null deprecated icons contains key icon name icon name deprecated icons get icon name if icons null icons new  hashtable  string  icon check if there is a cached version first  icon icon icons get icon name if icon null return icon url url try get the icon if  misc utilities is url icon name url new url icon name else url new url icon path icon name catch  exception e try url new url default icon path icon name catch  exception ex  log log  log error gui utilities class  icon not found icon name  log log  log error gui utilities class ex return null icon new  image icon url icons put icon name icon return icon 
 returns the default editor window image public static  image get editor icon return  image icon load icon j edit get property logo icon medium get image 
 returns the default plugin window image public static  image get plugin icon return get editor icon 
 creates a menubar  plugins should not need to call this method param name  the menu bar name since j edit pre public static j menu bar load menu bar  string name return load menu bar j edit get action context name 
 creates a menubar  plugins should not need to call this method param context  an action context param name  the menu bar name since j edit pre public static j menu bar load menu bar  action context context  string name  string menus j edit get property name  string tokenizer st new  string tokenizer menus j menu bar mbar new j menu bar while st has more tokens  string menu name st next token mbar add load menu context menu name return mbar 
 creates a menu  the menu label is set from the code i name i label code property  the menu contents is taken from the code i name i code property which is a whitespace separated list of action names  an action name of code code inserts a separator in the menu param name  the menu name see load menu item  string since j edit pre public static j menu load menu  string name return load menu j edit get action context name 
 creates a menu  the menu label is set from the code i name i label code property  the menu contents is taken from the code i name i code property which is a whitespace separated list of action names  an action name of code code inserts a separator in the menu param context  an action context either code j edit get action context code or code vfs browser get action context code param name  the menu name see load menu item  string since j edit pre public static j menu load menu  action context context  string name return new  enhanced menu name j edit get property name concat label context 
 creates a popup menu param name  the menu name since j edit pre public static j popup menu load popup menu  string name j edit text area text area  mouse event evt return load popup menu j edit get action context name text area evt 
 creates a popup menu param name  the menu name since j edit pre public static j popup menu load popup menu  string name return load popup menu j edit get action context name 
 creates a popup menu param context  an action context either code j edit get action context code or code vfs browser get action context code param name  the menu name since j edit pre public static j popup menu load popup menu  action context context  string name return load popup menu context name null null 
 creates a popup menu param context  an action context either code j edit get action context code or code vfs browser get action context code param name  the menu name param text area the text area wanting to show the popup  if not null include context menu items defined by services param evt additional context info about where the mouse was when menu was requested since j edit pre public static j popup menu load popup menu  action context context  string name j edit text area text area  mouse event evt j popup menu menu new j popup menu  string menu items j edit get property name if menu items null  string tokenizer st new  string tokenizer menu items while st has more tokens  string menu item name st next token if menu item name equals menu add separator else menu add load menu item context menu item name false load menu items defined by services if text area null  list j menu item list gui utilities get service context menu items text area evt if list is empty menu add separator for j menu item mi list menu add mi return menu 
return a list of menu items defined by services param text area the  text area desiring to display these menu items since j edit pre public static  list j menu item get service context menu items j edit text area text area  mouse event evt  list j menu item list new  array list j menu item  string service class name  dynamic context menu service class get name  string menu service list  service manager get service names service class name for  string menu service name menu service list if menu service name null menu service name trim length  dynamic context menu service dcms  dynamic context menu service  service manager get service service class name menu service name if dcms null j menu item items dcms create menu text area evt if items null list add all  arrays as list items return list 
 creates a menu item  the menu item is bound to the action named by code name code with label taken from the return value of the link  edit action get label method param name  the menu item name see load menu  string since j edit pre public static j menu item load menu item  string name return load menu item j edit get action context name true 
 creates a menu item param name  the menu item name param set mnemonic  true if the menu item should have a mnemonic since j edit pre public static j menu item load menu item  string name boolean set mnemonic return load menu item j edit get action context name set mnemonic 
 creates a menu item param context  an action context either code j edit get action context code or code vfs browser get action context code param name  the menu item name param set mnemonic  true if the menu item should have a mnemonic since j edit pre public static j menu item load menu item  action context context  string name boolean set mnemonic if name char at return load menu context name substring return  load menu item name context set mnemonic 
public static j menu item load menu item  edit action edit action boolean set mnemonic  string name edit action get name  action context context j edit get action context return  load menu item name context set mnemonic 
 creates a toolbar param name  the toolbar name since j edit pre public static  container load tool bar  string name return load tool bar j edit get action context name 
 creates a toolbar param context  an action context either code j edit get action context code or code vfs browser get action context code param name  the toolbar name since j edit pre public static  container load tool bar  action context context  string name j panel tool bar new j panel new  border layout j tool bar tool b new j tool bar tool b set floatable false tool b set margin new  insets  string buttons j edit get property name if buttons null  string tokenizer st new  string tokenizer buttons while st has more tokens  string button st next token if button equals tool b add separator new  dimension else j button b load tool button context button if b null tool b add b tool bar add tool b return tool bar 
 loads a tool bar button  the tooltip is constructed from the code i name i label code and code i name i shortcut code properties and the icon is loaded from the resource named org gjt sp jedit icons suffixed with the value of the code i name i icon code property param name  the name of the button public static  enhanced button load tool button  string name return load tool button j edit get action context name 
 loads a tool bar button  the tooltip is constructed from the code i name i label code and code i name i shortcut code properties and the icon is loaded from the resource named org gjt sp jedit icons suffixed with the value of the code i name i icon code property param context  an action context either code j edit get action context code or code vfs browser get action context code param name  the name of the button since j edit pre public static  enhanced button load tool button  action context context  string name  string label j edit get property name label if label null label name  icon icon  string icon name j edit get property name icon if icon name null icon load icon j edit get property broken image icon else icon load icon icon name if icon null icon load icon j edit get property broken image icon  string tool tip prettify menu label label  string shortcut label get shortcut label name if shortcut label null tool tip tool tip shortcut label  enhanced button b new  enhanced button icon tool tip name context b set preferred size new  dimension return b 
 prettifies a menu item label by removing the sign  this can be used to process the contents of an i action i label property public static  string prettify menu label  string label int index label index of if index label label substring index concat label substring index return label 
 returns a label string to show users what shortcut are assigned to the action public static  string get shortcut label  string action if action null return null else  string shortcut j edit get property action shortcut  string shortcut j edit get property action shortcut if shortcut null shortcut length if shortcut null shortcut length return null else return shortcut else if shortcut null shortcut length return shortcut else return shortcut or shortcut 
 displays a dialog box  the title of the dialog is fetched from the code i name i title code property  the message is fetched from the code i name i message code property  the message is formatted by the property manager with code args code as positional parameters param comp  the component to display the dialog for param name  the name of the dialog param args  positional parameters to be substituted into the message text public static void message  component comp  string name  object args hide splash screen j option pane show message dialog comp j edit get property name concat message args j edit get property name concat title args j option pane information message 
 displays an error dialog box  the title of the dialog is fetched from the code i name i title code property  the message is fetched from the code i name i message code property  the message is formatted by the property manager with code args code as positional parameters param comp  the component to display the dialog for param name  the name of the dialog param args  positional parameters to be substituted into the message text public static void error  component comp  string name  object args hide splash screen j option pane show message dialog comp j edit get property name concat message args j edit get property name concat title args j option pane error message 
 displays an input dialog box and returns any text the user entered  the title of the dialog is fetched from the code i name i title code property  the message is fetched from the code i name i message code property param comp  the component to display the dialog for param name  the name of the dialog param def  the text to display by default in the input field public static  string input  component comp  string name  object def return input comp name null def 
 displays an input dialog box and returns any text the user entered  the title of the dialog is fetched from the code i name i title code property  the message is fetched from the code i name i message code property param comp  the component to display the dialog for param name  the name of the dialog param def  the property whose text to display in the input field public static  string input property  component comp  string name  string def return input property comp name null def 
 displays an input dialog box and returns any text the user entered  the title of the dialog is fetched from the code i name i title code property  the message is fetched from the code i name i message code property param comp  the component to display the dialog for param name  the name of the dialog param def  the text to display by default in the input field param args  positional parameters to be substituted into the message text since j edit pre public static  string input  component comp  string name  object args  object def hide splash screen  string ret val  string j option pane show input dialog comp j edit get property name concat message args j edit get property name concat title j option pane question message null null def return ret val 
 displays an input dialog box and returns any text the user entered  the title of the dialog is fetched from the code i name i title code property  the message is fetched from the code i name i message code property param comp  the component to display the dialog for param name  the name of the dialog param args  positional parameters to be substituted into the message text param def  the property whose text to display in the input field since j edit pre public static  string input property  component comp  string name  object args  string def hide splash screen  string ret val  string j option pane show input dialog comp j edit get property name concat message args j edit get property name concat title j option pane question message null null j edit get property def if ret val null j edit set property def ret val return ret val 
 displays a confirm dialog box and returns the button pushed by the user  the title of the dialog is fetched from the code i name i title code property  the message is fetched from the code i name i message code property param comp  the component to display the dialog for param name  the name of the dialog param args  positional parameters to be substituted into the message text param buttons  the buttons to display for example j option pane yes no cancel option param type  the dialog type for example j option pane warning message since j edit pre public static int confirm  component comp  string name  object args int buttons int type hide splash screen return j option pane show confirm dialog comp j edit get property name message args j edit get property name title buttons type 
 displays a confirm dialog box and returns the button pushed by the user  the title of the dialog is fetched from the code i name i title code property  the message is fetched from the code i name i message code property  the dialog also shows a list of entries given by the code list model code parameter param comp the parent component param name the name of the confirm dialog param args the for the message param list model the items in the list return an integer indicating the option selected by the user since j edit pre public static int list confirm  component comp  string name  string args  object list model j list list new j list list model list set visible row count  object message j edit get property name message args new j scroll pane list return j option pane show confirm dialog comp message j edit get property name title j option pane yes no option j option pane question message 
 displays a confirm dialog box and returns the button pushed by the user  the title of the dialog is fetched from the code i name i title code property  the message is fetched from the code i name i message code property  the dialog also shows a list of entries given by the code list model code parameter param comp the parent component param name the name of the confirm dialog param args the for the message param list model the items in the list param selected items give an empty list it will contains in return the selected items return an integer indicating the option selected by the user since j edit pre public static int list confirm  component comp  string name  string args  object list model  list selected items j list list new j list list model list set selection mode  list selection model multiple interval selection list set visible row count list add selection interval list model length  object message j edit get property name message args new j scroll pane list int ret j option pane show confirm dialog comp message j edit get property name title j option pane yes no option j option pane question message  object selected values list get selected values selected items add all  arrays as list selected values return ret 
 displays a vfs file selection dialog box param view  the view should be non null param path  the initial directory to display  may be null param type  the dialog type  one of link org gjt sp jedit browser vfs browser open dialog link org gjt sp jedit browser vfs browser save dialog or link org gjt sp jedit browser vfs browser choose directory dialog param multiple selection  true if multiple selection should be allowed return  the selected file s since j edit pre public static  string show vfs file dialog  view view  string path int type boolean multiple selection the view should not be null but some plugins might do this if view null  log log  log warning gui utilities class show vfs file dialog given null view assuming j edit get active view view j edit get active view hide splash screen vfs file chooser dialog file chooser new vfs file chooser dialog view path type multiple selection return file chooser get selected files 
 displays a vfs file selection dialog box  this version can specify a dialog as the parent instead of the view param view  the view should be non null param path  the initial directory to display  may be null param type  the dialog type  one of link org gjt sp jedit browser vfs browser open dialog link org gjt sp jedit browser vfs browser save dialog or link org gjt sp jedit browser vfs browser choose directory dialog param multiple selection  true if multiple selection should be allowed return  the selected file s since j edit pre public static  string show vfs file dialog  dialog parent  view view  string path int type boolean multiple selection hide splash screen vfs file chooser dialog file chooser new vfs file chooser dialog parent view path type multiple selection true return file chooser get selected files 
 displays a vfs file selection dialog box  this version can specify a frame as the parent instead of the view param parent  the parent frame param view  the view should be non null param path  the initial directory to display  may be null param type  the dialog type  one of link org gjt sp jedit browser vfs browser open dialog link org gjt sp jedit browser vfs browser save dialog or link org gjt sp jedit browser vfs browser choose directory dialog param multiple selection  true if multiple selection should be allowed return  the selected file s since j edit pre public static  string show vfs file dialog  frame parent  view view  string path int type boolean multiple selection hide splash screen vfs file chooser dialog file chooser new vfs file chooser dialog parent view path type multiple selection true return file chooser get selected files 
 converts a color name to a color object  the name must either be a known string such as red green etc complete list is in the code java awt  color code class or a hex color value prefixed with for example ff param name  the color name public static  color parse color  string name return  syntax utilities parse color name  color black 
deprecated use link  syntax utilities parse color  string  color  deprecated public static  color parse color  string name  color default color return  syntax utilities parse color name default color 
 converts a color object to its hex value  the hex value prefixed is with for example ff param c  the color object deprecated use link  syntax utilities parse style  string  string int boolean  deprecated public static  string get color hex string  color c return  syntax utilities get color hex string c 
 converts a style string to a style object param str  the style string param family  style strings only specify font style not font family param size  style strings only specify font style not font family exception  illegal argument exception if the style is invalid since j edit pre public static  syntax style parse style  string str  string family int size throws  illegal argument exception return  syntax utilities parse style str family size true 
 converts a style string to a style object param str  the style string param family  style strings only specify font style not font family param size  style strings only specify font style not font family param color  if false the styles will be monochrome exception  illegal argument exception if the style is invalid since j edit pre deprecated use link  syntax utilities parse style  string  string int boolean  deprecated public static  syntax style parse style  string str  string family int size boolean color throws  illegal argument exception return  syntax utilities parse style str family size color 
 converts a style into it s string representation param style  the style public static  string get style string  syntax style style  string builder buf new  string builder if style get foreground color null buf append color append  syntax utilities get color hex string style get foreground color if style get background color null buf append bg color append  syntax utilities get color hex string style get background color  font font style get font if font is plain buf append style if font is italic buf append i if font is bold buf append b return buf to string 
 loads the syntax styles from the properties giving them the specified base font family and size param family  the font family param size  the font size since j edit pre deprecated use link  syntax utilities load styles  string int  deprecated public static  syntax style load styles  string family int size return  syntax utilities load styles family size true 
 loads the syntax styles from the properties giving them the specified base font family and size param family  the font family param size  the font size param color  if false the styles will be monochrome since j edit pre deprecated use link  syntax utilities load styles  string int boolean  deprecated public static  syntax style load styles  string family int size boolean color return  syntax utilities load styles family size color 
 loads a windows s geometry from the properties  the geometry is loaded from the code i name i x code code i name i y code code i name i width code and code i name i height code properties param win  the window to load geometry from param parent  the parent frame to be relative to param name  the name of the window public static void load geometry  window win  container parent  string name  dimension size win get size int width j edit get integer property name width size width int height j edit get integer property name height size height int x j edit get integer property name x int y j edit get integer property name y if parent null  point location parent get location x location x x y location y y int ext state j edit get integer property name extended state  frame normal  rectangle desired new  rectangle x y width height try if  debug disable multihead adjust for screen bounds desired catch  exception e  workaround for os x bug  log log  log error gui utilities class e if  operating system is x  debug geometry workaround new  unix workaround win name desired ext state else win set bounds desired if win instanceof  frame  frame win set extended state ext state 
 loads a windows s geometry from the properties  the geometry is loaded from the code i name i x code code i name i y code code i name i width code and code i name i height code properties param win  the window to load geometry from param name  the name of the window public static void load geometry  window win  string name load geometry win win get parent name 
 gives a rectangle the specified bounds ensuring it is within the screen bounds since j edit pre public static void adjust for screen bounds  rectangle desired  make sure the window is displayed in visible region  rectangle osbounds  operating system get screen bounds desired if desired width osbounds width desired width osbounds width if desired x osbounds x desired x osbounds x if desired x desired width osbounds x osbounds width desired x osbounds x osbounds width desired width if desired height osbounds height desired height osbounds height if desired y osbounds y desired y osbounds y if desired y desired height osbounds y osbounds height desired y osbounds y osbounds height desired height 
public  unix workaround  window win  string name  rectangle desired int ext state this win win this name name this desired desired int adjust x j edit get integer property name dx int adjust y j edit get integer property name dy int adjust width j edit get integer property name d width int adjust height j edit get integer property name d height required new  rectangle desired x adjust x desired y adjust y desired width adjust width desired height adjust height  log log  log debug gui utilities class  window name desired geometry is desired  log log  log debug gui utilities class  window name setting geometry to required start  system current time millis win set bounds required if win instanceof  frame  frame win set extended state ext state win add component listener new  component handler win add window listener new  window handler 
 override public void component moved  component event evt if  system current time millis start l  rectangle r win get bounds if window opened r equals required return if r equals desired  log log  log debug gui utilities class  window resize blocked win get bounds win set bounds desired win remove component listener this 
 override public void component resized  component event evt if  system current time millis start l  rectangle r win get bounds if window opened r equals required return if r equals desired  log log  log debug gui utilities class  window resize blocked win get bounds win set bounds desired win remove component listener this 
 override public void window opened  window event evt window opened true  rectangle r win get bounds  log log  log debug gui utilities class  window name bounds after opening r j edit set integer property name dx r x required x j edit set integer property name dy r y required y j edit set integer property name d width r width required width j edit set integer property name d height r height required height win remove window listener this 
 saves a window s geometry to the properties  the geometry is saved to the code i name i x code code i name i y code code i name i width code and code i name i height code properties br  for  frame s and descendents use link add size saver  frame  string to save the sizes correct even if the  frame is in maximized or iconified state param win  the window to load geometry from param name  the name of the window see add size saver  frame  string public static void save geometry  window win  string name save geometry win win get parent name 
 saves a window s geometry to the properties  the geometry is saved to the code i name i x code code i name i y code code i name i width code and code i name i height code properties br  for  frame s and descendents use link add size saver  frame  container  string to save the sizes correct even if the  frame is in maximized or iconified state param win  the window to load geometry from param parent  the parent frame to be relative to param name  the name of the window see add size saver  frame  container  string public static void save geometry  window win  container parent  string name if win instanceof  frame j edit set integer property name extended state  frame win get extended state  rectangle bounds win get bounds int x bounds x int y bounds y if parent null  rectangle parent bounds parent get bounds x parent bounds x y parent bounds y j edit set integer property name x x j edit set integer property name y y j edit set integer property name width bounds width j edit set integer property name height bounds height 
 centers the given window on the screen  this method is needed because jdk does not have a code j window set location relative to code method since j edit pre deprecated use link javax swing j window set location relative to java awt  component  deprecated public static void center on screen  window win  graphics device gd  graphics environment get local graphics environment get default screen device  rectangle gcbounds gd get default configuration get bounds int x gcbounds x gcbounds width win get width int y gcbounds y gcbounds height win get height win set location x y 
 ensures that the splash screen is not visible  this should be called before displaying any dialog boxes or windows at startup public static void hide splash screen if splash null splash dispose splash null 
 creates a component that displays a multiple line message  this is implemented by assembling a number of code j labels code in a code j panel code param str  the string with lines delimited by newline code n code characters since j edit pre public static j component create multiline label  string str j panel panel new j panel new  variable grid layout  variable grid layout fixed num columns int last offset while true int index str index of n last offset if index break else panel add new j label str substring last offset index last offset index if last offset str length panel add new j label str substring last offset return panel 
 focuses on the specified component as soon as the window becomes active param win  the window param comp  the component public static void request focus final  window win final  component comp win add window focus listener new  window adapter  override public void window gained focus  window event evt  swing utilities invoke later new  runnable public void run comp request focus in window win remove window focus listener this 
 returns if the specified event is the popup trigger event  this implements precisely defined behavior as opposed to  mouse event is popup trigger param evt  the event since j edit pre public static boolean is popup trigger  mouse event evt return  text area mouse handler is right button evt get modifiers 
param modifiers  the modifiers flag from a mouse event since j edit pre public static boolean is middle button int modifiers return  text area mouse handler is middle button modifiers 
param modifiers  the modifiers flag from a mouse event since j edit pre public static boolean is right button int modifiers return  text area mouse handler is right button modifiers 
 returns the screen bounds taking into account multi screen environments since j edit pre public static  rectangle get screen bounds  rectangle bounds  graphics environment get local graphics environment get maximum window bounds  graphics device devices  graphics environment get local graphics environment get screen devices if devices length for  graphics device device devices for  graphics configuration config device get configurations bounds bounds union config get bounds return bounds 
 shows the specified popup menu ensuring it is displayed within the bounds of the screen param popup  the popup menu param comp  the component to show it for param x  the x co ordinate param y  the y co ordinate since j edit pre see javax swing j component set component popup menu javax swing j popup menu set component popup menu which works better and is simpler to use you don t have to write the code to show hide popups in response to mouse events anymore public static void show popup menu j popup menu popup  component comp int x int y show popup menu popup comp x y true 
 shows the specified popup menu ensuring it is displayed within the bounds of the screen param popup  the popup menu param comp  the component to show it for param x  the x co ordinate param y  the y co ordinate param point  if true then the popup originates from a single point otherwise it will originate from the component itself  this affects positioning in the case where the popup does not fit onscreen since j edit pre public static void show popup menu j popup menu popup  component comp int x int y boolean point int offset x int offset y int extra offset point  component win comp while win instanceof  window win null offset x win get x offset y win get y win win get parent if win null  dimension size popup get preferred size  rectangle screen size get screen bounds if x offset x size width win get x screen size width x offset x win get x size width  system err println x overflow if point x size width extra offset else x win get width size width offset x extra offset else x extra offset  system err println y y offset y offset y size height size height win height win get height if y offset y size height win get y screen size height y offset y win get y size height if point y win get height size height offset y extra offset else y size height else y extra offset popup show comp x y else popup show comp x extra offset y extra offset 
 returns if the first component is an ancestor of the second by traversing up the component hierarchy param comp  the ancestor param comp  the component to check since j edit pre public static boolean is ancestor of  component comp  component comp while comp null if comp comp return true else comp comp get parent return false 
 traverses the given component s parent tree looking for an instance of j dialog and return it  if not found return null param c  the component public static j dialog get parent dialog  component c return j dialog  swing utilities get ancestor of class j dialog class c 
 finds a parent of the specified component param comp  the component param clazz  looks for a parent with this class exact match not derived since j edit pre public static  component get component parent  component comp  class clazz while true if comp null break if comp instanceof j component  component real  component j component comp get client property korte real frame if real null comp real if comp get class equals clazz return comp else if comp instanceof j popup menu comp j popup menu comp get invoker else if comp instanceof  floating window container comp  floating window container comp get dockable window manager else comp comp get parent return null 
 call set enabled recursively on the container and its descendants param c  the container param enabled  the enabled state to set since j edit pre public static void set enabled recursively  container c boolean enabled for  component child c get components if child instanceof  container set enabled recursively  container child enabled else child set enabled enabled c set enabled enabled 
 finds the view parent of the specified component since j edit pre public static  view get view  component comp return  view get component parent comp  view class 
 adds a  size saver to the specified  frame  for non  frame s use link save geometry  window  string param frame  the  frame for which to save the size param name  the prefix for the settings since j edit pre see save geometry  window  string public static void add size saver  frame frame  string name add size saver frame frame get parent name 
 adds a  size saver to the specified  frame  for non  frame s use link save geometry  window  container  string param frame  the  frame for which to save the size param parent  the parent to be relative to param name  the prefix for the settings since j edit pre see save geometry  window  container  string public static void add size saver  frame frame  container parent  string name  size saver ss new  size saver frame parent name frame add window state listener ss frame add component listener ss 
 init the continuous layout flag using the j edit s property appearance continuous layout param split the split  it must never be null since j edit pre public static void init continuous layout j split pane split boolean continuous layout split is continuous layout if continuous layout j edit get boolean property appearance continuous layout split set continuous layout continuous layout 
 initializes a list of mappings between old icon names and new names private static void initialize deprecated icons deprecated icons put  file png x mimetypes text x generic png deprecated icons put  folder png x places folder png deprecated icons put  open folder png x status folder open png deprecated icons put  open file png x actions edit select all png deprecated icons put  reload small png x actions view refresh png deprecated icons put  drive small png x devices drive harddisk png deprecated icons put  new png x actions document new png deprecated icons put  new dir png x actions folder new png deprecated icons put  reload png x actions view refresh png deprecated icons put  load png x places plugins png deprecated icons put  save png x actions document save png deprecated icons put  save as png x actions document save as png deprecated icons put  save all png x actions document save all png deprecated icons put  open png x actions document open png deprecated icons put  print png x actions document print png deprecated icons put  drive png x devices drive harddisk png deprecated icons put  clear png x actions edit clear png deprecated icons put  run png x actions application run png deprecated icons put  run again png x actions application run again png deprecated icons put  run to buffer png x actions run to buffer png deprecated icons put  copy to buffer png x actions copy to buffer png deprecated icons put  plus png x actions list add png deprecated icons put  minus png x actions list remove png deprecated icons put  find png x actions edit find png deprecated icons put  find again png x actions edit find next png deprecated icons put  find in dir png x actions edit find in folder png deprecated icons put  parse png x actions document reload png deprecated icons put  delete png x actions edit delete png deprecated icons put  paste png x actions edit paste png deprecated icons put  cut png x actions edit cut png deprecated icons put  copy png x actions edit copy png deprecated icons put  undo png x actions edit undo png deprecated icons put  redo png x actions edit redo png deprecated icons put  current dir png x status folder visiting png deprecated icons put  parent dir png x actions go parent png deprecated icons put  page setup png x actions printer setup png deprecated icons put  plugins png x apps system installer png deprecated icons put  floppy png x devices media floppy png deprecated icons put  stop png x actions process stop png deprecated icons put  cancel png x actions process stop png deprecated icons put  home png x actions go home png deprecated icons put  help png x apps help browser png deprecated icons put  properties png x actions document properties png deprecated icons put  preferences png x categories preferences system png deprecated icons put  zoom in png x actions zoom in png deprecated icons put  zoom out png x actions zoom out png deprecated icons put  broken image png x status image missing png deprecated icons put  adjust width png x actions resize horisontal png deprecated icons put  toolbar menu gif  toolbar menu gif deprecated icons put  play png x actions media playback start png deprecated icons put  pause png x actions media playback pause png deprecated icons put  multiple results png x actions edit find multiple png deprecated icons put  single result png x actions edit find single png deprecated icons put  next file png x go last png deprecated icons put  previous file png x go first png deprecated icons put closebox gif x actions close png deprecated icons put normal gif x status document unmodified png deprecated icons put readonly gif x emblem emblem readonly png deprecated icons put dirty gif x status document modified png deprecated icons put new gif x status document new png deprecated icons put  arrow u png x actions go up png deprecated icons put  arrow r png x actions go next png deprecated icons put  arrow d png x actions go down png deprecated icons put  arrow l png x actions go previous png deprecated icons put arrow png x actions group expand png deprecated icons put arrow png x actions group collapse png deprecated icons put  new view png x actions window new png deprecated icons put  un split png x actions window unsplit png deprecated icons put  split vertical png x actions window split vertical png deprecated icons put  split horizontal png x actions window split horizontal png deprecated icons put  button properties png x actions document properties png 
static void init initialize deprecated icons  load the icon theme but fallback on the old icons  string theme j edit get property icon theme tango  log log  log debug gui utilities class  icon theme set to theme set icon path jeditresource org gjt sp jedit icons themes theme  log log  log debug gui utilities class  loading icon theme from icon path don t do this in static since we need j edit init misc run first so we have the jeditresource protocol new buffer icon load icon new gif dirty buffer icon load icon dirty gif read only buffer icon load icon readonly gif normal buffer icon load icon normal gif window icon load icon j edit get property logo icon medium 
static void show splash screen splash new  splash screen 
static void advance splash progress if splash null splash advance 
static void advance splash progress  string label if splash null splash advance label 
private static j menu item  load menu item  string name  action context context boolean set mnemonic  string label j edit get property name label if label null label name char mnemonic int index label index of if index label length index mnemonic  character to lower case label char at index label label substring index concat label substring index else mnemonic j menu item mi if j edit get boolean property name toggle mi new  enhanced check box menu item label name context else mi new  enhanced menu item label name context if  operating system is mac os set mnemonic mnemonic mi set mnemonic mnemonic  icon item icon load icon j edit get property name icon small if item icon null mi set icon item icon return mi 
private gui utilities 
 constructs a new  size saver param frame  the  frame for which to save the size param parent  the parent to be relative to param name  the prefix for the settings  size saver  frame frame  container parent  string name if frame null name null throw new  null pointer exception this frame frame this parent parent this name name 
public void window state changed  window event wse int extended state wse get new state j edit set integer property name extended state extended state  rectangle bounds frame get bounds save extended state bounds 
private void save int extended state  rectangle bounds switch extended state case  frame maximized vert j edit set integer property name x bounds x j edit set integer property name width bounds width break case  frame maximized horiz j edit set integer property name y bounds y j edit set integer property name height bounds height break case  frame normal save geometry frame parent name break 
 override public void component resized  component event ce component moved ce 
 override public void component moved  component event ce final  rectangle bounds frame get bounds final  runnable size saver new  runnable public void run int extended state frame get extended state save extended state bounds new  thread  sizesavingdelay  override public void run try  thread sleep l catch  interrupted exception ie  swing utilities invoke later size saver start 
public void set fold painter  fold painter painter if painter null fold painter new  triangle fold painter else fold painter painter 
public  gutter  text area text area this text area text area enabled true selection area enabled true selection area width selection gutter width set autoscrolls true set opaque true set request focus enabled false extension mgr new  extension manager mouse handler new  mouse handler add mouse listener mouse handler add mouse motion listener mouse handler buffer listener new  buffer adapter public void buffer loaded j edit buffer buffer update line number width public void content inserted j edit buffer buffer int start line int offset int num lines int length update line number width public void content removed j edit buffer buffer int start line int offset int num lines int length update line number width update border set fold painter text area get fold painter 
public void paint component  graphics  gfx  graphics d gfx  graphics d  gfx gfx set rendering hints text area get painter rendering hints fill the background  rectangle clip gfx get clip bounds gfx set color get background int bg color width is selection area enabled fold marker size clip width gfx fill rect clip x clip y bg color width clip height if is selection area enabled if selection area bg color null selection area bg color get background gfx set color selection area bg color gfx fill rect clip x fold marker size clip y clip width fold marker size clip height if buffer is loading don t paint anything if text area get buffer is loading return int line height text area get painter get font metrics get height if line height return int first line clip y line height int last line clip y clip height line height if last line first line text area get visible lines  log log  log error this bug first line first line  log log  log error this last line last line  log log  log error this visible lines text area get visible lines  log log  log error this height get height  log log  log error this painter height text area get painter get height  log log  log error this clip y clip y  log log  log error this clip height clip height  log log  log error this line height line height int y clip y clip y line height extension mgr paint screen line range text area gfx first line last line y line height for int line first line line last line line y line height paint line gfx line y 
 adds a text area extension which can perform custom painting and tool tip handling param extension  the extension since j edit pre public void add extension  text area extension extension extension mgr add extension default layer extension repaint 
 adds a text area extension which can perform custom painting and tool tip handling param layer  the layer to add the extension to  note that more than extension can share the same layer param extension  the extension since j edit pre public void add extension int layer  text area extension extension extension mgr add extension layer extension repaint 
 removes a text area extension  it will no longer be asked to perform custom painting and tool tip handling param extension  the extension since j edit pre public void remove extension  text area extension extension extension mgr remove extension extension repaint 
 returns an array of registered text area extensions  useful for debugging purposes since j edit pre public  text area extension get extensions return extension mgr get extensions 
 returns the tool tip to display at the specified location param evt  the mouse event public  string get tool tip text  mouse event evt if text area get buffer is loading return null return extension mgr get tool tip text evt get x evt get y 
 convenience method for setting a default matte border on the right with the specified border width and color param width  the border width in pixels param color  the focused border color param color  the unfocused border color param color  the gutter text area gap color public void set border int width  color color  color color  color color border width width focus border new  compound border new  matte border width color new  matte border width color no focus border new  compound border new  matte border width color new  matte border width color update border 
 sets the border differently if the text area has focus or not public void update border if text area has focus set border focus border else set border no focus border 
public void set border  border border super set border border if border null collapsed size width collapsed size height else  insets insets border get border insets this collapsed size width fold marker size insets right if is selection area enabled collapsed size width selection area width collapsed size height gutter size height insets top insets bottom line number width fm char width get line number digit count gutter size width fold marker size insets right line number width revalidate 
public void set min line number digit count int min if min min line number digits return min line number digits min if text area get buffer null update line number width 
private int get min line number digit count return min line number digits 
private int get line number digit count j edit buffer buf text area get buffer int min digits get min line number digit count if buf null return min digits int count buf get line count int digits for digits count digits count return digits min digits min digits digits 
void set buffer j edit buffer new buffer if buffer null buffer remove buffer listener buffer listener buffer new buffer if buffer null buffer add buffer listener buffer listener update line number width 
private void update line number width  font f get font if f null set font get font 
void dispose if buffer null buffer remove buffer listener buffer listener buffer null 
public void set font  font font super set font font fm get font metrics font  border border get border if border null line number width fm char width get line number digit count gutter size width fold marker size border get border insets this right line number width revalidate 
public void set gutter enabled boolean enabled this enabled enabled revalidate 
public boolean is selection area enabled return selection area enabled 
public void set selection area enabled boolean enabled if is selection area enabled enabled return selection area enabled enabled if enabled collapsed size width selection area width else collapsed size width selection area width revalidate 
public void set selection area background  color bg color selection area bg color bg color repaint 
public void set selection area width int width selection area width width revalidate 
 get the foreground color for highlighted line numbers return  the highlight color public  color get highlighted foreground return interval highlight 
public void set highlighted foreground  color highlight interval highlight highlight 
public  color get current line foreground return current line highlight 
public void set current line foreground  color highlight current line highlight highlight 
public  color get fold color return fold color 
public void set fold color  color fold color this fold color fold color 
public  dimension get preferred size if enabled return disabled size if expanded return gutter size else return collapsed size 
public  dimension get minimum size return get preferred size 
 identifies whether the horizontal alignment of the line numbers return  gutter right  gutter center  gutter left public int get line number alignment return alignment 
 sets the horizontal alignment of the line numbers param alignment  gutter right  gutter center  gutter left public void set line number alignment int alignment if this alignment alignment return this alignment alignment repaint 
 identifies whether the gutter is collapsed or expanded return true if the gutter is expanded false if it is collapsed public boolean is expanded return expanded 
 sets whether the gutter is collapsed or expanded and force the text area to update its layout if there is a change param expanded true if the gutter is expanded false if it is collapsed public void set expanded boolean expanded if this expanded expanded return this expanded expanded text area revalidate 
 toggles whether the gutter is collapsed or expanded public void toggle expanded set expanded expanded 
 sets the number of lines between highlighted line numbers return  the number of lines between highlighted line numbers or zero if highlighting is disabled public int get highlight interval return interval 
 sets the number of lines between highlighted line numbers  any value less than or equal to one will result in highlighting being disabled param interval  the number of lines between highlighted line numbers public void set highlight interval int interval if interval interval this interval interval repaint 
public boolean is current line highlight enabled return current line highlight enabled 
public void set current line highlight enabled boolean enabled if current line highlight enabled enabled return current line highlight enabled enabled repaint 
 returns the structure highlight color since j edit pre public final  color get structure highlight color return structure highlight color 
 sets the structure highlight color param structure highlight color  the structure highlight color since j edit pre public final void set structure highlight color  color structure highlight color this structure highlight color structure highlight color repaint 
 returns true if structure highlighting is enabled false otherwise since j edit pre public final boolean is structure highlight enabled return structure highlight 
 enables or disables structure highlighting param structure highlight  true if structure highlighting should be enabled false otherwise since j edit pre public final void set structure highlight enabled boolean structure highlight this structure highlight structure highlight repaint 
public void set selection popup handler  gutter popup handler handler mouse handler selection popup handler handler 
public void set mouse actions provider  mouse actions provider mouse actions provider mouse handler mouse actions mouse actions provider 
private void paint line  graphics d gfx int line int y j edit buffer buffer text area get buffer if buffer is loading return  font metrics text area fm text area get painter get font metrics int line height text area fm get height int baseline text area fm get ascent  chunk cache  line info info text area chunk cache get line info line int physical line info physical line  skip lines beyond eof if physical line return boolean draw fold middle true  paint fold start and end indicators if info first subregion buffer is fold start physical line draw fold middle false fold painter paint fold start this gfx line physical line text area display manager is line visible physical line y line height buffer else if info last subregion buffer is fold end physical line draw fold middle false fold painter paint fold end this gfx line physical line y line height buffer  paint bracket scope else if structure highlight  structure matcher  match match text area get structure match int caret line text area get caret line if text area is structure highlight visible physical line  math min caret line match start line physical line  math max caret line match start line int caret screen line if caret line text area get last physical line caret screen line  integer max value else if text area display manager is line visible text area get caret line caret screen line text area get screen line of offset text area get caret position else caret screen line int struct screen line if match start line text area get last physical line struct screen line  integer max value else if text area display manager is line visible match start line struct screen line text area get screen line of offset match start else struct screen line if caret screen line struct screen line int tmp caret screen line caret screen line struct screen line struct screen line tmp gfx set color structure highlight color draw fold middle false if struct screen line caret screen line do nothing draw fold middle true draw else if line caret screen line gfx fill rect y line height gfx fill rect y line height line height line height draw   else if line struct screen line gfx fill rect y line height gfx fill rect y line height draw else if line caret screen line line struct screen line gfx fill rect y line height if draw fold middle buffer get fold level physical line fold painter paint fold middle this gfx line physical line y line height buffer  paint line numbers if info first subregion expanded  string number  integer to string physical line int offset switch alignment case right offset line number width fm string width number break case center offset line number width fm string width number break case left default offset break if physical line text area get caret line current line highlight enabled gfx set color current line highlight else if interval physical line interval gfx set color interval highlight else gfx set color get foreground gfx draw string number fold marker size offset baseline y 
public void mouse entered  mouse event e  tool tip manager ttm  tool tip manager shared instance tool tip initial delay ttm get initial delay tool tip reshow delay ttm get reshow delay ttm set initial delay ttm set reshow delay 
public void mouse exited  mouse event evt  tool tip manager ttm  tool tip manager shared instance ttm set initial delay tool tip initial delay ttm set reshow delay tool tip reshow delay 
public void mouse pressed  mouse event e text area request focus boolean outside gutter e get x get width border width if  text area mouse handler is popup trigger e outside gutter if selection popup handler null outside gutter e get x fold marker size int screen line e get y text area get painter get font metrics get height int line text area chunk cache get line info screen line physical line if line selection popup handler handle popup e get x e get y line return e translate point get width text area mouse handler mouse pressed e drag true else j edit buffer buffer text area get buffer int screen line e get y text area get painter get font metrics get height int line text area chunk cache get line info screen line physical line if line return if e get x fold marker size  selection s new  selection  range text area get line start offset line get fold end offset line if text area is multiple selection enabled text area add to selection s else text area set selection s select lines true sel anchor line line return  determine action  string default action  string variant if buffer is fold start line default action toggle fold variant fold else if structure highlight text area is structure highlight visible text area line in structure scope line default action match struct variant struct else return  string action null if mouse actions null action mouse actions get action for event e variant if action null action default action  handle actions  structure matcher  match match text area get structure match if action equals select fold text area display manager expand fold line true text area select fold line else if action equals narrow fold int lines buffer get fold at line line text area display manager narrow lines lines else if action starts with toggle fold if text area display manager is line visible line text area collapse fold line else if action ends with fully text area display manager expand fold line true else text area display manager expand fold line false else if action equals match struct if match null text area set caret position match end else if action equals select struct if match null match matcher select match text area else if action equals narrow struct if match null int start  math min match start line text area get caret line int end  math max match end line text area get caret line text area display manager narrow start end 
public void mouse dragged  mouse event e if drag e get x get width border width e translate point get width text area mouse handler mouse dragged e else if select lines int screen line e get y text area get painter get font metrics get height int line if e get y text area scroll up line line text area get first physical line else if e get y get height text area scroll down line line text area get last physical line else line text area chunk cache get line info screen line physical line int sel start sel end if line sel anchor line sel start text area get line start offset line sel end get fold end offset sel anchor line else sel start text area get line start offset sel anchor line sel end get fold end offset line text area resize selection sel start sel end false 
private int get fold end offset int line j edit buffer buffer text area get buffer int end line if line buffer get line count text area display manager is line visible line end line line else int lines buffer get fold at line line end line lines if end line buffer get line count return buffer get line end offset end line else return buffer get line end offset end line 
public void mouse released  mouse event e if drag e get x get width border width e translate point get width text area mouse handler mouse released e drag false select lines false 
public  gutter option pane super gutter 
public void  init  gutter enable gutter enabled new j check box j edit get property options gutter enabled gutter enabled set selected is gutter enabled add component gutter enabled  gutter components frame  grid bag constraints cons new  grid bag constraints cons gridheight cons gridwidth  grid bag constraints remainder cons fill  grid bag constraints horizontal cons anchor  grid bag constraints west cons weightx f cons ipadx cons ipady cons insets new  insets gutter components new j panel new  grid bag layout gutter components set border  border factory create titled border j edit get property options gutter optional components  line numbering line numbers enabled new j check box j edit get property options gutter line numbers line numbers enabled set selected j edit get boolean property view gutter line numbers gutter components add line numbers enabled cons  input verifier integer input verifier new  input verifier  override public boolean verify j component input if input instanceof j text field return true j text field tf j text field input int i try i  integer value of tf get text int value catch  exception e return false return i min line number digits new j text field  string value of get min line number digits min line number digits set input verifier integer input verifier j panel min line number digits panel new j panel min line number digits panel add new j label j edit get property options gutter min line number digits min line number digits panel add min line number digits cons gridy gutter components add min line number digits panel cons  selection area enable selection area enabled new j check box j edit get property options gutter selection area enabled selection area enabled set selected is selection area enabled cons gridy gutter components add selection area enabled cons add component gutter components  disable gutter components when show gutter is unchecked set gutter components enabled state gutter enabled add change listener new  change listener public void state changed  change event e set gutter components enabled state  selection area background color add component j edit get property options gutter selection area bg color selection area bg color new  color well button get selection area background  grid bag constraints vertical  selection area width selection area width new j text field  string value of get selection area width default selection gutter width selection area width set input verifier integer input verifier add component j edit get property options gutter selection area width selection area width  text font gutter font new  font selector j edit get font property view gutter font new  font  monospaced  font plain add component j edit get property options gutter font gutter font  text color add component j edit get property options gutter foreground gutter foreground new  color well button j edit get color property view gutter fg color  grid bag constraints vertical  background color add component j edit get property options gutter background gutter background new  color well button j edit get color property view gutter bg color  grid bag constraints vertical  border width gutter border width new j text field j edit get property view gutter border width add component j edit get property options gutter border width gutter border width  number alignment  string alignments new  string  left  center  right gutter number alignment new j combo box alignments  string alignment j edit get property view gutter number alignment if right equals alignment gutter number alignment set selected index else if center equals alignment gutter number alignment set selected index else gutter number alignment set selected index add component j edit get property options gutter number alignment gutter number alignment  current line highlight gutter current line highlight enabled new j check box j edit get property options gutter current line highlight gutter current line highlight enabled set selected j edit get boolean property view gutter highlight current line add component gutter current line highlight enabled gutter current line highlight new  color well button j edit get color property view gutter current line color  grid bag constraints vertical  highlight interval and color gutter highlight interval new j text field j edit get property view gutter highlight interval  box gutter highlight box new  box  box layout x axis gutter highlight box add new j label j edit get property options gutter interval gutter highlight box add  box create horizontal strut gutter highlight box add gutter highlight interval gutter highlight box add  box create horizontal strut gutter highlight box add new j label j edit get property options gutter interval gutter highlight box add  box create horizontal strut add component gutter highlight box gutter highlight color new  color well button j edit get color property view gutter highlight color  grid bag constraints vertical  structure highlight gutter structure highlight enabled new j check box j edit get property options gutter structure highlight gutter structure highlight enabled set selected j edit get boolean property view gutter structure highlight add component gutter structure highlight enabled gutter structure highlight new  color well button j edit get color property view gutter structure highlight color  grid bag constraints vertical  marker highlight gutter marker highlight enabled new j check box j edit get property options gutter marker highlight gutter marker highlight enabled set selected j edit get boolean property view gutter marker highlight add component gutter marker highlight enabled gutter marker highlight new  color well button j edit get color property view gutter marker color  grid bag constraints vertical  fold marker color add component j edit get property options gutter fold color gutter fold markers new  color well button j edit get color property view gutter fold color  grid bag constraints vertical  focused border color add component j edit get property options gutter focus border color gutter focus border new  color well button j edit get color property view gutter focus border color  grid bag constraints vertical unfocused border color add component j edit get property options gutter no focus border color gutter no focus border new  color well button j edit get color property view gutter no focus border color  grid bag constraints vertical add fold style chooser 
public void  save j edit set boolean property view gutter line numbers line numbers enabled is selected j edit set integer property view gutter min digit count  integer value of min line number digits get text j edit set font property view gutter font gutter font get font j edit set color property view gutter fg color gutter foreground get selected color j edit set color property view gutter bg color gutter background get selected color j edit set property view gutter border width gutter border width get text  string alignment null switch gutter number alignment get selected index case alignment right break case alignment center break case default alignment left j edit set property view gutter number alignment alignment j edit set boolean property view gutter highlight current line gutter current line highlight enabled is selected j edit set color property view gutter current line color gutter current line highlight get selected color j edit set property view gutter highlight interval gutter highlight interval get text j edit set color property view gutter highlight color gutter highlight color get selected color j edit set boolean property view gutter structure highlight gutter structure highlight enabled is selected j edit set color property view gutter structure highlight color gutter structure highlight get selected color j edit set boolean property view gutter marker highlight gutter marker highlight enabled is selected j edit set color property view gutter marker color gutter marker highlight get selected color j edit set color property view gutter fold color gutter fold markers get selected color j edit set property j edit text area fold painter property painters fold painter get selected index j edit set color property view gutter focus border color gutter focus border get selected color j edit set color property view gutter no focus border color gutter no focus border get selected color j edit set boolean property gutter enabled property gutter enabled is selected j edit set boolean property selection area enabled property selection area enabled is selected j edit set color property selection area bgcolor property selection area bg color get selected color j edit set integer property view gutter selection area width  integer value of selection area width get text 
private void set gutter components enabled state gui utilities set enabled recursively gutter components gutter enabled is selected 
private void add fold style chooser painters  service manager get service names j edit text area fold painter service fold painter new j combo box  string current j edit text area get fold painter name int selected for int i i painters length i  string painter painters i fold painter add item j edit get property options gutter fold style names painter painter if painter equals current selected i fold painter set selected index selected add component new j label j edit get property options gutter fold style label fold painter 
public static boolean is gutter enabled return j edit get boolean property gutter enabled property 
public static int get min line number digits int n j edit get integer property view gutter min digit count if n n return n 
public static boolean is selection area enabled return j edit get boolean property selection area enabled property 
public static  color get selection area background  string color j edit get property selection area bgcolor property if color null return j edit get color property view gutter bg color return  syntax utilities parse color color  color black 
public static int get selection area width int n j edit get integer property view gutter selection area width default selection gutter width if n n default selection gutter width return n 
public url connection open connection url url throws io exception  plugin res url connection c new  plugin res url connection url c connect return c 
public  help history model int size history new  history entry size listeners new  array list  help history model listener 
 history entry forward  help viewer help viewer if history length history pos return null if history history pos null return null set current scroll position help viewer get current page help viewer get current scroll position  history entry result new  history entry history history pos history pos fire update return result 
public boolean has next return history length history pos history history pos null 
 history entry back  help viewer help viewer if history pos return null set current scroll position help viewer get current page help viewer get current scroll position  history entry result new  history entry history history pos fire update return result 
public boolean has previous return history pos 
public void add to history  string url history history pos new  history entry url url if history pos history length  system arraycopy history history history length history history pos null else history pos for int i history pos i history length i history i null fire update 
public void set current scroll position url current page int scroll position if null current page history pos current page to string equals history history pos url history history pos scroll position scroll position 
public void set current entry  history entry entry for int i i history length i if history i null history i equals entry history pos i fire update break  do nothing 
public void update title  string url  string title for int i i history length i if history i null history i url equals url history i title title fire update 
 history entry get previous ur ls if history pos return new  help history model  history entry  history entry previous new  history entry history pos  system arraycopy history previous history pos return previous 
 history entry get next ur ls if history length history pos return new  help history model  history entry if history history pos null return new  help history model  history entry  history entry next new  history entry history length history pos  system arraycopy history history pos next history length history pos return next 
public void add help history model listener  help history model listener hhml listeners add hhml 
public void remove help history model listener  help history model listener hhml listeners remove hhml 
public void fire update for int i i listeners size i listeners get i history updated 
 history entry  string url  string title this url title 
 history entry  history entry original this original url original title original scroll position 
 history entry  string url  string title int scroll position this url url this title title this scroll position scroll position 
public boolean equals  history entry he return he url equals this url he title equals this title he scroll position scroll position 
public  string to string return get class get name url url title title scroll position scroll position 
public  help index words new  hash map  string  object files new  array list  help file ignore word a ignore word an ignore word and ignore word are ignore word as ignore word be ignore word by ignore word can ignore word do ignore word for ignore word from ignore word how ignore word i ignore word if ignore word in ignore word is ignore word it ignore word not ignore word of ignore word on ignore word or ignore word s ignore word that ignore word the ignore word this ignore word to ignore word will ignore word with ignore word you 
 indexes all available help including the j edit user s guide faq and plugin documentation public void index editor help try  string j edit home j edit get j edit home if j edit home null index directory  misc utilities construct path j edit home doc users guide index directory  misc utilities construct path j edit home doc faq index directory  misc utilities construct path j edit home doc news catch  throwable e  log log  log error this  error indexing editor help  log log  log error this e  plugin jar jars j edit get plugin ja rs for int i i jars length i try index jar jars i get zip file catch  throwable e  log log  log error this  error indexing jar jars i get path  log log  log error this e  log log  log debug this  indexed words size words 
 indexes all html and text files in the specified directory param dir  the directory public void index directory  string dir throws  exception  string files vfs manager get file vfs  list directory null dir html txt true null for int i i files length i index url files i 
 indexes all html and text files in the specified jar file param jar  the jar file public void index jar  zip file jar throws  exception  enumeration e jar entries while e has more elements  zip entry entry  zip entry e next element  string name entry get name  string lname name to lower case if lname ends with html lname ends with txt only works for j edit plugins  string url jeditresource  misc utilities get file name jar get name name  log log  log debug this url index stream jar get input stream entry url 
 reads the specified html file and adds all words defined therein to the index param url  the html file s url public void index url  string url throws  exception  input stream  in if  misc utilities is url url  in new url url open stream else  in new  file input stream url hack since  help viewer needs a url url file url index stream  in url 
public  word lookup word  string word  object o words get word if o ignore return null else return  word o 
public  help file get file int index return files get index 
private void ignore word  string word words put word ignore 
 reads the specified html file and adds all words defined therein to the index param  in  the input stream param file name  the file private void index stream  input stream  in  string file name throws  exception  help file file new  help file file name files add file int index files size  string builder title text new  string builder  buffered reader in new  buffered reader new  input stream reader  in try  string builder word new  string builder boolean inside tag false boolean inside entity false boolean title false int c while c in read char ch char c if inside tag if ch if word to string equals title title true inside tag false word set length else word append ch else if inside entity if ch inside entity false else if ch if title title false if word length add word word to string index title word set length inside tag true else if ch inside entity true else if title title text append ch else if  character is letter or digit ch if word length add word word to string index title word set length else word append ch finally in close if title text length file title file name else file title title text to string 
private void add word  string word int file boolean title word word to lower case  object o words get word if o ignore return if o null words put word new  word word file title else  word o add occurrence file title 
 word  string word int file boolean title this word word occurrences new  occurrence add occurrence file title 
void add occurrence int file boolean title for int i i occur count i if occurrences i file file occurrences i count title title occur return if occur count occurrences length  occurrence new occur new  occurrence occurrences length  system arraycopy occurrences new occur occur count occurrences new occur occurrences occur count new  occurrence file title 
 occurrence int file boolean title this file file this count title title occur 
 help file  string file this file file 
public  string to string return title 
public boolean equals  object o if o instanceof  help file return  help file o file equals file else return false 
public  help search panel  help viewer interface help viewer super new  border layout this help viewer help viewer  box box new  box  box layout x axis box add new j label j edit get property helpviewer search caption box add  box create horizontal strut box add search field new  history text field helpviewer search search field add action listener new  action handler add  border layout north box results new j list results add mouse listener new  mouse handler results set selection mode  list selection model single selection results set cell renderer new  result renderer add  border layout center new j scroll pane results 
private  help index get help index if index null index new  help index try index index editor help catch  exception e index null  log log  log error this e gui utilities error help viewer get component helpviewer search error new  string e to string return index 
 result icon int rank this rank rank 
public int get icon width return 
public int get icon height return 
public void paint icon  component c  graphics g int x int y  graphics d g d  graphics d g create g d set rendering hints rendering hints for int i i i if rank i g d set color ui manager get color  label foreground else g d set color ui manager get color  label disabled foreground g d fill oval x i y 
public  component get list cell renderer component j list list  object value int index boolean is selected boolean cell has focus super get list cell renderer component list null index is selected cell has focus if value instanceof  string set icon null set text  string value else  result result  result value set icon new  result icon result rank set text result title return this 
 result  help index  help file file int count this file file file this title file title rank count 
public int compare  result r  result r if r rank r rank return r title compare to r title else return r rank r rank 
public void action performed  action event evt final  help index index get help index if index null return results set list data new  string j edit get property helpviewer searching final  string text search field get text final  vector  result result model new  vector  result vfs manager run in work thread new  runnable public void run  string tokenizer st new  string tokenizer text we later use this to compute a relative ranking int max rank while st has more tokens  string word st next token to lower case  help index  word lookup index lookup word word if lookup null continue for int i i lookup occur count i  help index  word  occurrence occur lookup occurrences i boolean ok false  help index  help file file index get file occur file for int j j result model size j  result result result model element at j if result file equals file file result rank occur count result rank multiple files w word bonus max rank  math max result rank max rank ok true break if ok max rank  math max occur count max rank result model add element new  result file occur count if max rank turn the rankings into relative rankings from to for int i i result model size i  result result result model element at i result rank int  math ceil double result rank max rank  collections sort result model new  result compare vfs manager run in awt thread new  runnable public void run if result model is empty results set list data new  string j edit get property helpviewer no results get toolkit beep else results set list data result model 
public void mouse released  mouse event evt int row results location to index evt get point if row  result result  result results get model get element at row help viewer goto url result file true 
public  help toc panel  help viewer interface help viewer super new  border layout this help viewer help viewer nodes new  hashtable toc new toc tree looks bad with the os x l f apparently if  operating system is mac oslf toc put client property j tree line style  angled toc set cell renderer new toc cell renderer toc set editable false toc set shows root handles true add  border layout center new j scroll pane toc load 
public void select node  string short url if toc model null return  default mutable tree node node  default mutable tree node nodes get short url if node null return  tree path path new  tree path toc model get path to root node toc expand path path toc set selection path path toc scroll path to visible path 
public void load  default tree model empty new  default tree model new  default mutable tree node j edit get property helpviewer toc loading toc set model empty toc set root visible true vfs manager run in work thread new  runnable public void run create toc toc model reload toc root toc set model toc model toc set root visible false for int i i toc root get child count i  default mutable tree node node  default mutable tree node toc root get child at i toc expand path new  tree path node get path if help viewer get short url null select node help viewer get short url 
private  default mutable tree node create node  string href  string title  default mutable tree node node new  default mutable tree node new  help node href title true nodes put href node return node 
private void create toc  edit plugin plugins j edit get plugins  arrays sort plugins new  plugin compare toc root new  default mutable tree node toc root add create node welcome html j edit get property helpviewer toc welcome toc root add create node readme txt j edit get property helpviewer toc readme toc root add create node changes txt j edit get property helpviewer toc changes toc root add create node todo txt j edit get property helpviewer toc todo toc root add create node copying txt j edit get property helpviewer toc copying toc root add create node copying doc txt j edit get property helpviewer toc copying doc toc root add create node  apache license txt j edit get property helpviewer toc copying apache toc root add create node copying plugins txt j edit get property helpviewer toc copying plugins load toc toc root news toc xml load toc toc root users guide toc xml load toc toc root faq toc xml  default mutable tree node plugin tree new  default mutable tree node j edit get property helpviewer toc plugins true for int i i plugins length i  edit plugin plugin plugins i  string name plugin get class name  string docs j edit get property plugin name docs  string label j edit get property plugin name name if docs null if label null docs null  string path plugin get plugin jar get class loader get resource as path docs plugin tree add create node path label if plugin tree get child count toc root add plugin tree else so that  help viewer constructor doesn t try to expand plugin tree null load toc toc root api toc xml toc model new  default tree model toc root 
private void load toc  default mutable tree node root  string path toc handler h new toc handler root  misc utilities get parent of path path try xml utilities parse xml new url help viewer get base url path open stream h catch io exception e  log log  log error this e 
 help node  string href  string title this href href this title title 
public  string to string return title 
toc handler  default mutable tree node root  string dir nodes new  stack node root this dir dir 
public void characters char c int off int len if tag equals title boolean first non whitespace false for int i i len i char ch c off i if first non whitespace  character is whitespace ch continue first non whitespace true title append ch 
public void start element  string uri  string local name  string name  attributes attrs tag name if name equals entry href attrs get value href 
public void end element  string uri  string local name  string name if name null return if name equals title  default mutable tree node new node create node dir href title to string node add new node nodes push node node new node title set length else if name equals entry node  default mutable tree node nodes pop href null 
toc tree  tool tip manager shared instance register component this selection model set selection mode single tree selection 
public final  string get tool tip text  mouse event evt  tree path path get path for location evt get x evt get y if path null  rectangle cell rect get path bounds path if cell rect null cell rect is visible cell rect return path get last path component to string return null 
public void process key event  key event evt if  key event key pressed evt get id  key event vk enter evt get key code  tree path path get selection path if path null  object obj  default mutable tree node path get last path component get user object if obj instanceof  help node this expand path path return  help node node  help node obj help viewer goto url node href true evt consume else super process key event evt 
protected void process mouse event  mouse event evt  tool tip manager ttm  tool tip manager shared instance switch evt get id case  mouse event mouse entered tool tip initial delay ttm get initial delay tool tip reshow delay ttm get reshow delay ttm set initial delay ttm set reshow delay super process mouse event evt break case  mouse event mouse exited ttm set initial delay tool tip initial delay ttm set reshow delay tool tip reshow delay super process mouse event evt break case  mouse event mouse clicked  tree path path get path for location evt get x evt get y if path null if is path selected path set selection path path  object obj  default mutable tree node path get last path component get user object if obj instanceof  help node this expand path path return  help node node  help node obj help viewer goto url node href true super process mouse event evt break default super process mouse event evt break 
private boolean cell rect is visible  rectangle cell rect  rectangle vr toc tree this get visible rect return vr contains cell rect x cell rect y vr contains cell rect x cell rect width cell rect y cell rect height 
public  component get tree cell renderer component j tree tree  object value boolean sel boolean expanded boolean leaf int row boolean focus super get tree cell renderer component tree value sel expanded leaf row focus set icon leaf  file cell renderer file icon expanded  file cell renderer open dir icon  file cell renderer dir icon set border border return this 
public int compare  object o  object o  edit plugin p  edit plugin o  edit plugin p  edit plugin o return  standard utilities compare strings j edit get property plugin p get class name name j edit get property plugin p get class name name true 
 creates a new help viewer with the default help page since j edit pre public  help viewer this welcome html 
 creates a new help viewer for the specified url param url  the url public  help viewer url url this url to string 
 creates a new help viewer for the specified url param url  the url public  help viewer  string url super j edit get property helpviewer title set icon image gui utilities get editor icon try base url new  file  misc utilities construct path j edit get j edit home doc to url to string catch  malformed url exception mu  log log  log error this mu what to do  action handler action listener new  action handler j tabbed pane tabs new j tabbed pane tabs add tab j edit get property helpviewer toc label toc new  help toc panel this tabs add tab j edit get property helpviewer search label new  help search panel this tabs set minimum size new  dimension j panel right panel new j panel new  border layout  box tool bar new  box  box layout x axis tool bar set floatable false tool bar add title new j label tool bar add  box create glue history model new  help history model back new  history button  history button back history model back add action listener action listener tool bar add back forward new  history button  history button forward history model forward add action listener action listener tool bar add forward back set preferred size forward get preferred size right panel add  border layout north tool bar viewer new j editor pane viewer set editable false viewer add hyperlink listener new  link handler viewer set font new  font  monospaced  font plain viewer add property change listener new  property change handler viewer add key listener new  key handler viewer scroll pane new j scroll pane viewer right panel add  border layout center viewer scroll pane splitter new j split pane j split pane horizontal split j edit get boolean property appearance continuous layout tabs right panel splitter set border null get content pane add  border layout center splitter history model add help history model listener this history updated goto url url true set default close operation dispose on close get root pane set preferred size new  dimension pack gui utilities load geometry this helpviewer gui utilities add size saver this helpviewer  edit bus add to bus this set visible true  swing utilities invoke later new  runnable public void run splitter set divider location j edit get integer property helpviewer splitter viewer request focus 
 displays the specified url in the html component param url  the url param add to history  should the url be added to the back forward history param scroll position  the vertical scroll position public void goto url  string url boolean add to history final int scroll position the toc pane looks up user s guide ur ls relative to the doc directory  string short url if  misc utilities is url url if url starts with base url short url url substring base url length if short url starts with short url short url substring else short url url else short url url if base url ends with url base url url else url base url url reset default cursor so that the hand cursor doesn t stick around viewer set cursor  cursor get default cursor try url  url new url url if  url equals viewer get page title set text j edit get property helpviewer loading else don t show loading msg because we won t receive a property changed history model set current scroll position viewer get page get current scroll position viewer set page  url if scroll position  swing utilities invoke later new  runnable public void run viewer scroll pane get vertical scroll bar set value scroll position if add to history history model add to history url catch  malformed url exception mf  log log  log error this mf  string args url mf get message gui utilities error this badurl args return catch io exception io  log log  log error this io  string args url io to string gui utilities error this read error args return this short url short url select the appropriate tree node if short url null toc select node short url viewer request focus 
int get current scroll position return viewer scroll pane get vertical scroll bar get value 
url get current page return viewer get page 
public void dispose  edit bus remove from bus this j edit set integer property helpviewer splitter splitter get divider location super dispose 
public void handle message eb message msg if msg instanceof  plugin update  plugin update pmsg  plugin update msg if pmsg get what  plugin update loaded pmsg get what  plugin update unloaded if pmsg is exiting if queued toc reload queue toc reload queued toc reload true else if msg instanceof  properties changed gui utilities init continuous layout splitter 
public  string get base url return base url 
public  string get short url return short url 
public void history updated back set enabled history model has previous forward set enabled history model has next 
public  component get component return get root pane 
public void queue toc reload  swing utilities invoke later new  runnable public void run queued toc reload false toc load 
public void action performed  action event evt  object source evt get source  string action command evt get action command int separator position action command last index of  string url int scroll position if separator position url action command scroll position else url action command substring separator position scroll position  integer parse int action command substring separator position if url length goto url url false scroll position return if source back  history entry entry history model back  help viewer this if entry null get toolkit beep else goto url entry url false entry scroll position else if source forward  history entry entry history model forward  help viewer this if entry null get toolkit beep else goto url entry url false entry scroll position 
public void hyperlink update  hyperlink event evt if evt get event type  hyperlink event  event type activated if evt instanceof html frame hyperlink event html document viewer get document process html frame hyperlink event html frame hyperlink event evt history updated else url url evt get url if url null goto url url to string true else if evt get event type  hyperlink event  event type entered viewer set cursor  cursor get predefined cursor  cursor hand cursor else if evt get event type  hyperlink event  event type exited viewer set cursor  cursor get default cursor 
public void property change  property change event evt if page equals evt get property name  string title str  string viewer get document get property title if title str null title str  misc utilities get file name viewer get page to string title set text title str history model update title viewer get page to string title str 
public void key pressed  key event ke switch ke get key code case  key event vk up j scroll bar scroll bar viewer scroll pane get vertical scroll bar scroll bar set value scroll bar get value scroll bar get unit increment ke consume break case  key event vk down scroll bar viewer scroll pane get vertical scroll bar scroll bar set value scroll bar get value scroll bar get unit increment ke consume break case  key event vk left scroll bar viewer scroll pane get horizontal scroll bar scroll bar set value scroll bar get value scroll bar get unit increment ke consume break case  key event vk right scroll bar viewer scroll pane get horizontal scroll bar scroll bar set value scroll bar get value scroll bar get unit increment ke consume break 
public  history button int type  help history model model super arrow button new  rollover button gui utilities load icon j edit get property type back helpviewer back icon helpviewer forward icon arrow button set tool tip text j edit get property type back helpviewer back label helpviewer forward label  box box new  box  box layout x axis drop button new  rollover button gui utilities load icon j edit get property dropdown arrow icon drop button add action listener new  drop action handler box add arrow button box add drop button this set maximum size new  dimension drop button get preferred size width arrow button get preferred size width arrow button get preferred size height this add box this type type this history model 
public void set enabled boolean state super set enabled state drop button set enabled state arrow button set enabled state 
public void add action listener  action listener al arrow button add action listener this arrow action listener al 
public void action performed  action event evt arrow action listener action performed new  action event this  action event action performed evt get action command evt get when evt get modifiers 
private  history button get parent history button return this 
public void action performed  action event evt history list new j popup menu  help history model  history entry urls if type back urls history get previous ur ls else urls history get next ur ls if urls null if type back for int i urls length i i if urls i null history list add new  history list action handler urls i else for int i i urls length i if urls i null history list add new  history list action handler urls i history list show j component evt get source 
 history list action handler  help history model  history entry entry super entry title this entry entry this put value  action action command key entry url entry scroll position 
public void action performed  action event ae get parent history button action performed ae history set current entry entry 
 creates a new history list  calling this is normally not necessary public  history model  string name this name name 
 adds an item to the end of this history list trimming the list to the maximum number of items if necessary param text  the item public void add item  string text if text null text length return int index index of text if index remove element at index insert element at text while get size max remove element at get size 
public void insert element at  object obj int index modified true super insert element at obj index 
 returns an item from the history list param index  the index public  string get item int index return  string element at index 
public boolean remove element  object obj modified true return super remove element obj 
deprecated  call code remove all elements code instead public void clear remove all elements 
public void remove all elements modified true super remove all elements 
 returns the name of this history list  this can be passed to the  history text field constructor public  string get name return name 
 returns a named model  if the specified model does not already exist it will be created param name  the model name public static  history model get model  string name if models null models  collections synchronized map new  hash map  string  history model  history model model models get name if model null model new  history model name models put name model return model 
public static void load history if saver null models saver load models 
public static void save history if saver null modified saver save models modified false 
public static void set max int max  history model max max 
public static void set saver  history model saver saver  history model saver saver 
public  history text j text component text  string name this text text set model name index 
public void fire action performed 
public int get index return index 
public void set index int index this index index 
 returns the underlying history controller since j edit pre public  history model get model return history model 
 sets the history list controller param name  the model name since j edit pre public void set model  string name if name null history model null else history model  history model get model name index 
 sets if selecting a value from the popup should immediately fire an  action event public void set instant popups boolean instant popups this instant popups instant popups 
 returns if selecting a value from the popup should immediately fire an  action event public boolean get instant popups return instant popups 
 adds the currently entered item to the history public void add current to history if history model null history model add item get text index 
public void do backward search if history model null return if text get selection end get document get length text set caret position get document get length int start get input start  string t get text substring text get selection start start if t null history previous return for int i index i history model get size i  string item history model get item i if item starts with t text replace selection item substring t length text select get input start t length get document get length index i return text get toolkit beep 
public void do forward search if history model null return if text get selection end get document get length text set caret position get document get length int start get input start  string t get text substring text get selection start start if t null history next return for int i index i i  string item history model get item i if item starts with t text replace selection item substring t length text select get input start t length get document get length index i return text get toolkit beep 
public void history previous if history model null return if index history model get size text get toolkit beep else if index current get text set text history model get item index else have to do this because set text sets index to int new index index set text history model get item new index index new index 
public void history next if history model null return if index text get toolkit beep else if index set text current else have to do this because set text sets index to int new index index set text history model get item new index index new index 
public  document get document return text get document 
 subclasses can override this to provide funky history behavior for j text panes and such public  string get text return text get text 
 subclasses can override this to provide funky history behavior for j text panes and such public void set text  string text this index this text set text text 
 subclasses can override this to provide funky history behavior for j text panes and such public int get input start return 
public void show popup menu  string t int x int y if history model null return text request focus if popup null popup is visible popup set visible false popup null return popup new j popup menu  override public void set visible boolean b if b popup null super set visible b j menu item caption new j menu item j edit get property history caption caption add action listener new  action listener public void action performed  action event e new  list model editor open history model popup add caption popup add separator for int i i history model get size i  string item history model get item i if item starts with t j menu item menu item new j menu item item menu item set action command  string value of i menu item add action listener new  action handler popup add menu item gui utilities show popup menu popup text x y false 
public void show popup menu boolean search if search show popup menu get text substring get input start text get selection start text get height else show popup menu text get height 
public void action performed  action event evt int ind  integer parse int evt get action command if ind if index set text current else set text history model get item ind index ind if instant popups add current to history fire action performed 
public  history text area  string name super controller new  history text this name set focus traversal keys  keyboard focus manager forward traversal keys  collections singleton  key stroke get key stroke  key event vk tab set focus traversal keys  keyboard focus manager backward traversal keys  collections singleton  key stroke get key stroke  key event vk tab  input event shift mask 
 returns the underlying history controller since j edit pre public  history model get model return controller get model 
 sets the history list controller param name  the model name since j edit pre public void set model  string name controller set model name 
 sets if selecting a value from the popup should immediately fire an  action event public void set instant popups boolean instant popups controller set instant popups instant popups 
 returns if selecting a value from the popup should immediately fire an  action event public boolean get instant popups return controller get instant popups 
 adds the currently entered item to the history public void add current to history controller add current to history 
 sets the displayed text public void set text  string text super set text text controller set index 
protected void process key event  key event evt if is enabled return if evt get id  key event key pressed switch evt get key code case  key event vk enter if evt is control down replace selection n evt consume break case  key event vk tab if evt is control down replace selection t evt consume break case  key event vk page up if evt is shift down controller do backward search else controller history previous evt consume break case  key event vk page down if evt is shift down controller do forward search else controller history next evt consume break case  key event vk up if evt is alt down controller show popup menu evt is shift down evt consume break if evt is consumed super process key event evt 
protected void process mouse event  mouse event evt if is enabled return switch evt get id case  mouse event mouse pressed if gui utilities is popup trigger evt controller show popup menu evt is shift down else super process mouse event evt break default super process mouse event evt break 
 creates a new history text field since j edit pre public  history text field this null 
 creates a new history text field param name  the history model name public  history text field  string name this name false true 
 creates a new history text field param name  the history model name param instant popups  if true selecting a value from the history popup will immediately fire an  action event  if false the user will have to press  enter first since j edit pre public  history text field  string name boolean instant popups this name instant popups true 
 creates a new history text field param name  the history model name param instant popups  if true selecting a value from the history popup will immediately fire an  action event  if false the user will have to press  enter first param enter adds to history  if true pressing the  enter key will automatically add the currently entered text to the history since j edit pre public  history text field  string name boolean instant popups boolean enter adds to history controller new  history text this null public void fire action performed  history text field this fire action performed set model name  mouse handler mouse handler new  mouse handler add mouse listener mouse handler add mouse motion listener mouse handler set instant popups instant popups set enter adds to history enter adds to history 
 sets if selecting a value from the popup should immediately fire an  action event since j edit pre public void set instant popups boolean instant popups controller set instant popups instant popups 
 returns if selecting a value from the popup should immediately fire an  action event since j edit pre public boolean get instant popups return controller get instant popups 
 sets if pressing  enter should automatically add the currently entered text to the history since j edit pre public void set enter adds to history boolean enter adds to history this enter adds to history enter adds to history 
 returns if pressing  enter should automatically add the currently entered text to the history since j edit pre public boolean set enter adds to history return enter adds to history 
 sets if all text should be selected when the field gets focus since j edit pre public void set select all on focus boolean select all on focus this select all on focus select all on focus 
 returns if all text should be selected when the field gets focus since j edit pre public boolean set select all on focus return select all on focus 
 returns the underlying history model public  history model get model return controller get model 
 sets the history list model param name  the model name since j edit pre public void set model  string name controller set model name if name null set border new  compound border this get border new  history border repaint 
 adds the currently entered item to the history public void add current to history controller add current to history 
 sets the displayed text public void set text  string text super set text text controller set index 
 make it public public void fire action performed super fire action performed 
protected void process key event  key event evt if is enabled return if evt get id  key event key pressed switch evt get key code case  key event vk enter if enter adds to history add current to history if evt get modifiers fire action performed evt consume break case  key event vk up if evt is shift down controller do backward search else controller history previous evt consume break case  key event vk down if evt is shift down controller do forward search else if evt is alt down controller show popup menu evt is shift down else controller history next evt consume break case  key event vk tab if evt is control down controller do backward search evt consume break if evt is consumed super process key event evt 
protected void process mouse event  mouse event evt if is enabled return switch evt get id case  mouse event mouse pressed  border border get border  insets insets border get border insets  history text field this if evt get x get width insets right gui utilities is popup trigger evt controller show popup menu evt is shift down else super process mouse event evt break case  mouse event mouse exited set cursor  cursor get default cursor super process mouse event evt break default super process mouse event evt break 
public void mouse pressed  mouse event evt select all has focus select all on focus 
public void mouse released  mouse event evt  swing utilities invoke later new  runnable public void run if select all select all 
public void mouse moved  mouse event evt  border border get border  insets insets border get border insets  history text field this if evt get x get width insets right set cursor  cursor get default cursor else set cursor  cursor get predefined cursor  cursor text cursor 
public void mouse dragged  mouse event evt select all false 
public void paint border  component c  graphics g int x int y int w int h g translate x w width y if c is enabled vertical separation line g set color ui manager get color control dk shadow g draw line h down arrow int w width int h h g set color ui manager get color c is enabled  history text field c get model null  text field foreground  text field disabled foreground g draw line w h w h g draw line w h w h g draw line w h w h g draw line w h w h g draw line w h w h g translate x w width y 
public  insets get border insets  component c return new  insets width 
public  hyper search file node  string path this path path 
public  buffer get buffer  view view return j edit open file view path 
public void go to  edit pane edit pane  buffer buffer get buffer edit pane get view if buffer null return edit pane set buffer buffer 
public  string to string if show full path return path  string paths path split file sep return paths paths length 
public boolean equals  object compare obj if compare obj instanceof  hyper search file node return false  hyper search file node other result  hyper search file node compare obj return path equals  misc utilities resolve symlinks other result path 
 returns the result count return the result count since j edit pre public int get count return count 
 set the result count param count the result count since j edit pre public void set count int count this count count 
public  file get node file return node file 
public  hyper search folder node  file node file boolean show full path this node file node file this show full path show full path 
public  string to string if show full path return node file get absolute path  string paths node file get absolute path split file sep return paths paths length 
public  hyper search operation node  string search string  search matcher search matcher this search string search string this search matcher search matcher 
public  string to string return search string 
public boolean is tree view displayed return tree view displayed 
public void set tree view displayed boolean tree view displayed this tree view displayed tree view displayed 
public void restore flat nodes j tree result tree  default mutable tree node oper node for int i i result nodes size i  default mutable tree node element result nodes get i if element get user object instanceof  hyper search file node  hyper search file node element get user object show full path true oper node insert element oper node get child count  default tree model result tree get model node structure changed oper node for  enumeration e oper node children e has more elements  default mutable tree node node  default mutable tree node e next element result tree expand path new  tree path node get path result tree scroll path to visible new  tree path oper node get path 
public void cache result nodes  default mutable tree node oper node result nodes new  array list  default mutable tree node oper node get child count for  enumeration e oper node children e has more elements result nodes add  default mutable tree node e next element 
public static void remove node from cache  mutable tree node mnode  default mutable tree node node  default mutable tree node mnode if node get user object instanceof  hyper search operation node return  default mutable tree node tmp node node while tmp node  default mutable tree node tmp node get parent null if tmp node get user object instanceof  hyper search operation node continue  hyper search operation node oper node  hyper search operation node tmp node get user object if oper node result nodes null the nodes aren t cached so no need to remove the node from cache oper node result nodes remove node break 
public void insert tree nodes j tree result tree  default mutable tree node oper node  string file sep  system get property file separator  string file sep regex  system get property file separator if file sep equals file sep regex find the highest level common path  string top path tmp null int top path ndx for int i i result nodes size i  default mutable tree node file tree node result nodes get i  object obj file tree node get user object if obj instanceof  hyper search file node continue  hyper search file node file node  hyper search file node obj int pos file node path last index of file sep  string path name file node path substring pos  string paths path name split file sep regex if top path ndx top path ndx paths length top path tmp paths else if paths length top path ndx top path ndx paths length top path tmp paths else for int ndx ndx top path ndx ndx if paths ndx equals top path tmp ndx top path ndx ndx break  string top path new  string top path ndx  string top path path for int ndx ndx top path ndx ndx top path ndx top path tmp ndx top path path top path path concat top path ndx file sep  map  string  default mutable tree node tree nodes new  hash map  string  default mutable tree node  hyper search folder node folder node new  hyper search folder node new  file top path path true  default mutable tree node folder tree node new  default mutable tree node folder node oper node insert folder tree node oper node get child count tree nodes put top path path folder tree node for int i i result nodes size i  default mutable tree node file tree node result nodes get i  object obj file tree node get user object if obj instanceof  hyper search file node continue  hyper search file node file node  hyper search file node obj file node show full path false int pos file node path last index of file sep  string path name file node path substring pos  string paths path name split file sep regex  default mutable tree node ins node folder tree node  string partial path top path path for int ndx top path ndx ndx paths length ndx partial path partial path concat paths ndx file sep  default mutable tree node tmp node tree nodes get partial path if tmp node null  hyper search folder node tmp folder node new  hyper search folder node new  file partial path false tmp node new  default mutable tree node tmp folder node ins node insert tmp node ins node get child count tree nodes put partial path tmp node ins node tmp node ins node insert file tree node ins node get child count tree nodes put file node path ins node 
public  search matcher get search matcher return search matcher 
public  string get search string return search string 
 hyper search request  view view  search matcher matcher  hyper search results results  selection selection this view view this matcher matcher this results results search string  search and replace get search string root search node new  default mutable tree node new  hyper search operation node search string matcher this selection selection 
public void run set status j edit get property hypersearch status  search file set fileset  search and replace get search file set  string files fileset get files view if files null files length  swing utilities invoke later new  runnable public void run gui utilities error view empty fileset null results search done root search node return set maximum fileset get file count view to minimize synchronization and stuff like that we only show a status message at most twice a second initially zero so that we always show the first message  string searching caption j edit get property hypersearch results searching new  string  search and replace get search string try if selection null  buffer buffer view get buffer search in selection buffer else int current long last status time int result count boolean asked false int max results j edit get integer property hypersearch max warning results loop for int i i files length i if j edit get boolean property hyper search stop button j edit set temporary property hyper search stop button false  log log  log message this  search stopped by user action stop button break if asked result count max results max results  log log  log debug this  search in progress result count occurrences found asking the user to stop asked true int ret gui utilities confirm view hypersearch too many results new  object result count j option pane yes no option j option pane question message if ret j option pane yes option  log log  log message this  search stopped by user action break  string file files i current long current time  system current time millis if current time last status time set value current last status time current time results set search status searching caption file  buffer buffer j edit open temporary null null file false if buffer null continue loop result count do hyper search buffer buffer get length  log log  log message this result count occurences catch final  exception e  log log  log error this e  swing utilities invoke later new  runnable public void run  search and replace handle error view e catch  work thread  abort a finally vfs manager run in awt thread new  runnable public void run results search done root search node select node 
private int search in selection  buffer buffer throws  exception set abortable false int result count try buffer read lock for int i i selection length i  selection s selection i if s instanceof  selection  rect for int j s get start line j s get end line j result count do hyper search buffer s get start buffer j s get end buffer j else result count do hyper search buffer s get start s get end finally buffer read unlock set abortable true return result count 
private int do hyper search  buffer buffer int start int end throws  exception set abortable false  hyper search file node hyper search file node new  hyper search file node buffer get path  default mutable tree node buffer node new  default mutable tree node hyper search file node int result count do hyper search buffer start end buffer node hyper search file node set count result count if result count root search node insert buffer node root search node get child count set abortable true return result count 
private int do hyper search  buffer buffer int start int end  default mutable tree node buffer node int result count j edit text area text area j edit get active view get text area int caret line text area get buffer buffer text area get caret line try buffer read lock boolean end of line buffer get line end offset buffer get line of offset end end int offset start  hyper search result last result null loop for int counter counter boolean start of line buffer get line start offset buffer get line of offset offset offset  search matcher  match match matcher next match buffer get segment offset end offset start of line end of line counter false if match null break loop int new line buffer get line of offset offset match start if last result null last result line new line last result new  hyper search result buffer new line  default mutable tree node child new  default mutable tree node last result false if last result line caret line select node child buffer node add child last result add occur offset match start offset match end offset match end result count finally buffer read unlock return result count 
public  buffer get buffer  view view if buffer null buffer j edit open file view path return buffer 
 returns an array of selection objects pointing to the occurrences of the search term on the current line  the buffer must be opened first since j edit pre public  selection get selection if buffer null return null  selection return value new  selection occur count  occur o occur int i while o null  selection  range s new  selection  range o start pos get offset o end pos get offset return value i s o o next return return value 
public void go to final  edit pane edit pane final  buffer buffer get buffer edit pane get view if buffer null return edit pane set buffer buffer vfs manager run in awt thread new  runnable public void run  selection s get selection if s null return j edit text area text area edit pane get text area if text area is multiple selection enabled text area add to selection s else text area set selection s text area move caret position occur end pos get offset 
public  string to string return str 
 hyper search result  buffer buffer int line path buffer get path if buffer is temporary buffer opened buffer this line line str line buffer get line text line replace t trim 
void buffer opened  buffer buffer this buffer buffer  occur o occur while o null o buffer opened o o next 
void buffer closed buffer null  occur o occur while o null o buffer closed o o next 
void add occur int start int end  occur o new  occur start end o next occur occur o occur count 
param path a canonical path boolean path equals  string path return path equals  misc utilities resolve symlinks this path 
public boolean equals  object compare obj if compare obj instanceof  hyper search result return false  hyper search result other result  hyper search result compare obj return path equals other result path line other result line buffer equals other result buffer 
 occur int start int end this start start this end end if buffer null buffer is temporary buffer opened 
void buffer opened start pos buffer create position  math min buffer get length start end pos buffer create position  math min buffer get length end 
void buffer closed start start pos get offset end end pos get offset start pos end pos null 
public  hyper search results  view view super new  border layout this view view caption new j label  box tool bar new  box  box layout x axis tool bar add caption tool bar add  box create glue  action handler ah new  action handler highlight new  rollover button highlight set tool tip text j edit get property hypersearch results highlight label highlight add action listener ah tool bar add highlight clear new  rollover button gui utilities load icon j edit get property hypersearch results clear icon clear set tool tip text j edit get property hypersearch results clear label clear add action listener ah tool bar add clear multi new  rollover button multi set tool tip text j edit get property hypersearch results multi label multi add action listener ah tool bar add multi stop new  rollover button gui utilities load icon j edit get property hypersearch results stop icon stop set tool tip text j edit get property hypersearch results stop label stop add action listener ah tool bar add stop stop set enabled false add  border layout north tool bar result tree root new  default mutable tree node result tree model new  default tree model result tree root result tree new  highlighting tree result tree model result tree set tool tip text null result tree set cell renderer new  result cell renderer result tree set visible row count result tree set root visible false result tree set shows root handles true the escape keystroke is assigned to hide tip action by swing it breaks the action usually assigned to close docking area by j edit so we remove this keystroke binding bug  key stroke key stroke  key stroke get key stroke  key event vk escape result tree get input map remove key stroke looks bad with the os x l f apparently if  operating system is mac oslf result tree put client property j tree line style  angled result tree set editable false result tree add key listener new  key handler result tree add mouse listener new  mouse handler j scroll pane scroll pane new j scroll pane result tree  dimension dim scroll pane get preferred size dim width scroll pane set preferred size dim add  border layout center scroll pane result tree set transfer handler new  result tree transfer handler 
public void focus on default component result tree request focus 
public void add notify super add notify  edit bus add to bus this multi status j edit get boolean property hypersearch results multi update highlight status update multi status 
public void remove notify super remove notify  edit bus remove from bus this j edit set boolean property hypersearch results multi multi status 
private void visit buffers final  result visitor visitor final  buffer buffer impl note since multi level hierarchies now allowed use traverse nodes to process  hyper search result nodes traverse nodes result tree root new  tree node callback adapter public boolean process node  default mutable tree node node  object user object node get user object if user object instanceof  hyper search result return true  hyper search result result  hyper search result user object if result path equals buffer get symlink path visitor visit buffer result return true 
public void handle message eb message msg if msg instanceof  buffer update  buffer update bmsg  buffer update msg  buffer buffer bmsg get buffer  object what bmsg get what if what  buffer update loaded visit buffers new  buffer loaded visitor buffer else if what  buffer update closed visit buffers new  buffer closed visitor buffer 
public static boolean traverse nodes  default mutable tree node node  hyper search tree node callback callback interface if callback interface process node node return false for  enumeration e node children e has more elements  default mutable tree node child node  default mutable tree node e next element if traverse nodes child node callback interface return false return true 
public  default tree model get tree model return result tree model 
 returns the result tree return the result tree since j edit pre public j tree get tree return result tree 
public void search started stop set enabled true caption set text j edit get property hypersearch results searching new  string  search and replace get search string 
public void set search status  string status caption set text status 
public void search failed caption set text j edit get property hypersearch results no results new  string  search and replace get search string collapse all nodes as suggested on user mailing list for int i i result tree root get child count i  default mutable tree node node  default mutable tree node result tree root get child at i result tree collapse path new  tree path new  object result tree root node 
param search node the result node param select node the node that must be selected or null since j edit pre public void search done final  default mutable tree node search node final  default mutable tree node select node stop set enabled false final int node count search node get child count if node count search failed return caption set text j edit get property hypersearch results done new  string  search and replace get search string  swing utilities invoke later new  runnable public void run if multi status for int i i result tree root get child count i result tree root remove result tree root add search node result tree model reload result tree root for int i i node count i  tree path last node new  tree path  default mutable tree node search node get child at i get path result tree expand path last node  tree path tree path if select node null tree path new  tree path new  object result tree root search node else tree path new  tree path select node get path result tree set selection path tree path result tree scroll path to visible tree path 
public void search done final  default mutable tree node search node search done search node null 
private void update highlight status  string prop j edit get property highlight prop if prop null prop length highlight set icon gui utilities load icon j edit get property hypersearch results match highlight icon else highlight set icon gui utilities load icon j edit get property hypersearch results match normal icon result tree repaint 
private void update multi status if multi status multi set icon gui utilities load icon j edit get property hypersearch results multi multiple icon else multi set icon gui utilities load icon j edit get property hypersearch results multi single icon 
private void go to selected node int mode  tree path path result tree get selection path if path null return  default mutable tree node node  default mutable tree node path get last path component  object value node get user object do nothing if clicked foo showing n occurrences in m files if node get parent result tree root value instanceof  hyper search node  hyper search node n  hyper search node value  buffer buffer n get buffer view if buffer null return  edit pane pane switch mode case m open pane view go to buffer buffer break case m open new view pane j edit new view view buffer false get edit pane break case m open new plain view pane j edit new view view buffer true get edit pane break case m open new split pane view split horizontally break default throw new  illegal argument exception  bad mode mode n go to pane 
private void remove selected node  tree path path result tree get selection path if path null return  mutable tree node value  mutable tree node path get last path component if path get path count  adjust selection so that repeating some removals behave naturally  tree path parent path path get parent path  mutable tree node parent  mutable tree node parent path get last path component int removing index parent get index value int next index removing index if next index parent get child count  tree node next parent get child at next index result tree set selection path parent path path by adding child next else result tree set selection path parent path result tree model remove node from parent value  hyper search operation node remove node from cache value if result tree root get child count hide dockable 
private void remove all nodes result tree root remove all children result tree model reload result tree root set search status null hide dockable 
private void hide dockable view get dockable window manager hide dockable window name 
 syntax style parse highlight style  string style  font f result tree null result tree get font ui manager get font  tree font  syntax style s try s  syntax utilities parse style style f get family f get size true null catch  exception e style color s  syntax utilities parse style style f get family f get size true return s 
public void action performed  action event evt  object source evt get source if source highlight  string prop j edit get property highlight prop  syntax style style new  style editor j edit get active view parse highlight style prop hypersearch get style if style null j edit set property highlight prop gui utilities get style string style update highlight status else if source clear remove all nodes else if source multi multi status multi status update multi status if multi status for int i result tree root get child count i i result tree model remove node from parent  mutable tree node result tree root get child at i else if source stop j edit set temporary property hyper search stop button true 
public  highlighting tree  default tree model model super model prop j edit get property highlight prop if prop null prop length style tag style html prop 
 override public  string convert value to text  object value boolean selected boolean expanded boolean leaf int row boolean has focus  string s super convert value to text value selected expanded leaf row has focus  string new prop j edit get property highlight prop if new prop null new prop length return s  default mutable tree node node  default mutable tree node value while node null node get user object instanceof  hyper search operation node node  default mutable tree node node get parent if node null return s if new prop equals prop prop new prop style tag style html prop  search matcher matcher  hyper search operation node node get user object get search matcher  string builder sb new  string builder html style highlight sb append style tag sb append style body int line text index s index of if line text index line text index append string html sb s substring line text index s s substring line text index int i  match m while m matcher next match s substring i true true true false null append string html sb s substring i i m start sb append span class highlight append string html sb s substring i m start i m end sb append span i m end append string html sb s substring i sb append body html return sb to string 
private  string color html  color c  string builder cs new  string builder rgb cs append c get red cs append cs append c get green cs append cs append c get blue cs append return cs to string 
private  string style html  string prop  string builder tag new  string builder  syntax style style parse highlight style prop  font f style get font  color c style get foreground color if c null tag append color append color html c c style get background color if c null tag append background append color html c if f is bold tag append font weight bold if f is italic tag append font style italic return tag to string 
private void append string html  string builder sb  string s for int i i s length i char c s char at i  string r switch c case r quot break case r apos break case r amp break case r lt break case r gt break default r  string value of c break sb append r 
public void key pressed  key event evt switch evt get key code case  key event vk space go to selected node m open fuck me dead  swing utilities invoke later new  runnable public void run result tree request focus evt consume break case  key event vk enter go to selected node m open evt consume break case  key event vk delete remove selected node evt consume break default break 
public void mouse pressed  mouse event evt if evt is consumed return  tree path path result tree get path for location evt get x evt get y if path null return result tree set selection path path if gui utilities is popup trigger evt show popup menu evt else go to selected node m open 
private void show popup menu  mouse event evt  tree path path result tree get selection path  default mutable tree node node  default mutable tree node path get last path component popup menu new j popup menu  object user obj node get user object if user obj instanceof  hyper search file node user obj instanceof  hyper search result popup menu add new  go to node action hypersearch results open m open popup menu add new  go to node action hypersearch results open view m open new view popup menu add new  go to node action hypersearch results open plain view m open new plain view popup menu add new  go to node action hypersearch results open split m open new split if user obj instanceof  hyper search folder node popup menu add new  remove tree node action popup menu add new  expand child tree nodes action if user obj instanceof  hyper search folder node user obj instanceof  hyper search operation node popup menu add new  collapse child tree nodes action if user obj instanceof  hyper search folder node popup menu add new  new search action if user obj instanceof  hyper search operation node popup menu add new j popup menu  separator  hyper search operation node result node  hyper search operation node user obj j check box menu item chk item new j check box menu item j edit get property hypersearch results tree view result node is tree view displayed chk item add action listener new  tree display action popup menu add chk item popup menu add new  redo search action  hyper search operation node user obj popup menu add new  copy to clipboard action gui utilities show popup menu popup menu evt get component evt get x evt get y evt consume 
 remove tree node action super j edit get property hypersearch results remove node 
public void action performed  action event evt remove selected node 
 remove all tree nodes action super j edit get property hypersearch results remove all nodes 
public void action performed  action event evt remove all nodes 
 new search action super j edit get property hypersearch results new search 
public void action performed  action event evt  tree path path result tree get selection path  default mutable tree node oper node  default mutable tree node path get last path component  hyper search folder node node obj  hyper search folder node oper node get user object  string glob  search file set dir list  search and replace get search file set if dir list instanceof  directory list set glob  directory list set dir list get file filter  search and replace set search file set new  directory list set node obj get node file get absolute path glob true  search dialog show search dialog view null  search dialog directory 
 expand child tree nodes action super j edit get property hypersearch results expand child nodes 
public void action performed  action event evt  tree path path result tree get selection path  default mutable tree node oper node  default mutable tree node path get last path component expand all nodes oper node 
 copy to clipboard action super j edit get property hypersearch results copy to clipboard 
public void action performed  action event evt  tree path path result tree get selection path  default mutable tree node oper node  default mutable tree node path get last path component  to string nodes to string nodes new  to string nodes traverse nodes oper node to string nodes  string selection selection new  string selection to string nodes nodes string to string  clipboard clipboard  toolkit get default toolkit get system clipboard clipboard set contents selection null 
public boolean process node  default mutable tree node node  object user object node get user object if user object instanceof  hyper search file node nodes string append  hyper search file node user object path else if user object instanceof  hyper search result  hyper search result hsr  hyper search result user object  copy the original line from the buffer nodes string append hsr buffer null hsr to string hsr buffer get line text hsr line else nodes string append user object to string nodes string append  system get property line separator return true 
 collapse child tree nodes action super j edit get property hypersearch results collapse child nodes 
public void action performed  action event evt  tree path path result tree get selection path  default mutable tree node oper node  default mutable tree node path get last path component for  enumeration e oper node children e has more elements  default mutable tree node node  default mutable tree node e next element result tree collapse path new  tree path node get path result tree scroll path to visible new  tree path oper node get path 
public  redo search action  hyper search operation node hyper search operation node super j edit get property hypersearch results redo this hyper search operation node hyper search operation node 
 invoked when an action occurs public void action performed  action event e  search and replace set search string hyper search operation node get search string  search and replace set search matcher hyper search operation node get search matcher remove selected node  search and replace hyper search view false 
public void action performed  action event evt j check box menu item menu item j check box menu item evt get source boolean cur state menu item is selected  tree path path result tree get selection path  default mutable tree node oper node  default mutable tree node path get last path component  hyper search operation node oper node obj  hyper search operation node oper node get user object if cur state oper node obj cache result nodes oper node oper node remove all children  exception excp null if cur state try oper node obj insert tree nodes result tree oper node catch  exception ex oper node obj restore flat nodes result tree oper node menu item set selected false excp ex finally  default tree model result tree get model node structure changed oper node expand all nodes oper node result tree scroll path to visible new  tree path oper node get path if excp null throw new  runtime exception excp else oper node obj restore flat nodes result tree oper node oper node obj set tree view displayed menu item is selected 
public void expand all nodes  default mutable tree node node traverse nodes node new  tree node callback adapter public boolean process node  default mutable tree node node result tree expand path new  tree path node get path return true 
 go to node action  string label prop int mode super j edit get property label prop this mode mode 
public void action performed  action event evt go to selected node mode 
 result cell renderer plain font ui manager get font  tree font if plain font null plain font j edit get font property metal secondary font bold font new  font plain font get name  font bold plain font get size 
public  component get tree cell renderer component j tree tree  object value boolean sel boolean expanded boolean leaf int row boolean has focus super get tree cell renderer component tree value sel expanded leaf row has focus set icon null  default mutable tree node node  default mutable tree node value if node get user object instanceof  hyper search operation node set font bold font  count nodes count nodes new  count nodes traverse nodes node count nodes set text j edit get property hypersearch results result caption new  object node to string  integer value of count nodes result count  integer value of count nodes buffer count else if node get user object instanceof  hyper search folder node set font plain font set text node to string node get child count files folders else if node get user object instanceof  hyper search file node file name set font bold font  hyper search file node hyper search file node  hyper search file node node get user object set text j edit get property hypersearch results file caption new  object hyper search file node  integer value of hyper search file node get count  integer value of node get child count else set font plain font return this 
public boolean process node  default mutable tree node node  object user object node get user object if user object instanceof  hyper search file node result count  hyper search file node user object get count buffer count return true 
 override public void export to clipboard j component comp  clipboard clip int action throws  illegal state exception  tree path paths result tree get selection paths  to string nodes to string nodes new  to string nodes for  tree path path paths  default mutable tree node oper node  default mutable tree node path get last path component to string nodes process node oper node  string selection selection new  string selection to string nodes nodes string to string  clipboard clipboard  toolkit get default toolkit get system clipboard clipboard set contents selection null 
public void visit  buffer buffer  hyper search result result result buffer opened buffer 
public void visit  buffer buffer  hyper search result result result buffer closed 
public boolean process node  default mutable tree node node return false 
public static  string built in names return built in 
public static  string get return j edit get property icon theme tango 
public static void set  string name gui utilities set icon path jeditresource org gjt sp jedit icons themes name j edit set property icon theme name 
 this does nothing it is merely a sentinel for the code  open bracket indent rule code public int calculate indent j edit buffer buffer int line int old indent int new indent return new indent 
public boolean keep checking return true 
private  collapse 
public int calculate indent j edit buffer buffer int line int old indent int new indent return old indent 
public boolean keep checking return true 
public  increase amount 
public  increase int amount this amount amount 
public int calculate indent j edit buffer buffer int line int old indent int new indent return new indent buffer get indent size amount 
public boolean keep checking return true 
public boolean equals  object o if o instanceof  increase return  increase o amount amount else return false 
public int calculate indent j edit buffer buffer int line int old indent int new indent return new indent buffer get indent size 
public boolean keep checking return true 
public  align offset int offset this offset offset 
public int calculate indent j edit buffer buffer int line int old indent int new indent return offset 
public boolean keep checking return false 
public  align parameter int open parens column this open parens column open parens column 
public int calculate indent j edit buffer buffer int line int old indent int new indent return open parens column 
public boolean keep checking return false 
public int calculate indent j edit buffer buffer int line int old indent int new indent int current  standard utilities get leading white space width buffer get line segment line buffer get tab size return current new indent current new indent 
public boolean keep checking return true 
public  indent fold handler super indent 
private int get leading whitespace width  segment seg int tab size int offset seg offset int count seg count int whitespace for int i i count i switch seg array offset i case whitespace break case t whitespace tab size whitespace tab size break default return whitespace return 
 returns the fold level of the specified line  for a whitespace only line returns the fold level of the next non whitespace line or the level of the previous line if no non whitespace line follows or if the level of the previous line is higher param buffer  the buffer in question param line index  the line index param seg a segment the fold handler can use to obtain any text from the buffer if necessary return  the fold level of the specified line since j edit pre public int get fold level j edit buffer buffer int line index  segment seg int tab size buffer get tab size  look for first non whitespace line starting at line index int prev level for int index line index index buffer get line count index buffer get line text index seg int whitespace get leading whitespace width seg tab size if whitespace  non whitespace found on line return whitespace prev level whitespace prev level if index return if index line index prev level buffer get fold level line index  all lines from line index are whitespace only use fold level of previous line return prev level 
 returns the fold levels of the lines preceding the specified line which depend on the specified line param buffer  the buffer in question param line index  the line index param seg a segment the fold handler can use to obtain any param line fold level  the fold level of the specified line return  the fold levels of the preceding lines in decreasing line number order i e bottomost line first since j edit pre public  list  integer get preceding fold levels j edit buffer buffer int line index  segment seg int line fold level  list  integer preceding fold levels new  array list  integer int tab size buffer get tab size int whitespace int index  find previous non whitespace only line for index line index index index buffer get line text index seg whitespace get leading whitespace width seg tab size if whitespace break int max line fold level whitespace line fold level whitespace for index index line index index preceding fold levels add  integer value of max return preceding fold levels 
public static  indent rule indent next lines  string regexp throws  pattern syntax exception return new  regexp indent rule regexp null new  indent action  increase null false 
public static  indent rule indent next line  string regexp throws  pattern syntax exception return new  regexp indent rule regexp new  indent action  decrease new  indent action  increase null true 
public static  indent rule unindent this line  string regexp throws  pattern syntax exception return new  regexp indent rule regexp null new  indent action  increase new  indent action  decrease false 
public static  indent rule unindent next lines  string regexp throws  pattern syntax exception return new  regexp indent rule regexp null new  indent action  decrease null false 
public static  indent rule indent open bracket char bracket throws  pattern syntax exception return new  open bracket indent rule bracket true 
public static  indent rule indent close bracket char bracket throws  pattern syntax exception return new  close bracket indent rule bracket true 
public static  indent rule unaligned open bracket char bracket throws  pattern syntax exception return new  open bracket indent rule bracket false 
public static  indent rule unaligned close bracket char bracket throws  pattern syntax exception return new  close bracket indent rule bracket false 
 creates a new input handler param view  the view protected  input handler  view view this view view 
 handles a keystroke param key stroke  the key stroke return true if the input could be handled since j edit pre public final boolean handle key  key event translator  key key stroke return handle key key stroke false 
 forwards key events directly to the input handler  this is slightly faster than using a  key listener because some  swing overhead is avoided since pre  override public void process key event  key event evt int from boolean global if  debug dump key events  log log  log debug this  key event  abstract input handler to string evt from from  log log  log debug this view is focused view is focused new  exception if view get text area has focus from  view view return evt  preprocess key event evt if evt null return if  debug dump key events  log log  log debug this  key event after workaround  abstract input handler to string evt from from  component prefix focus owner view get prefix focus owner boolean focus on text area false switch evt get id case  key event key typed if the user pressed eg c e n n in the search bar we want focus to go back there after the prefix is done if prefix focus owner null if prefix focus owner is showing prefix focus owner request focus focus on text area true if key event interceptor null key event interceptor key typed evt else if from  view action bar is prefix active view get text area has focus process key event key stroke handling evt from type global process key event sub focus on text area break case  key event key pressed if key event interceptor null key event interceptor key pressed evt else if  key event workaround is bindable evt get key code if prefix focus owner null if prefix focus owner is showing prefix focus owner request focus focus on text area true view set prefix focus owner null process key event key stroke handling evt from press global process key event sub focus on text area break case  key event key released if key event interceptor null key event interceptor key released evt break 
private  key event  preprocess key event  key event evt if view is closed return null  component focus owner view get focus owner if focus owner instanceof j component j component comp j component focus owner  input map map comp get input map  action map am comp get action map if map null am null comp is enabled  key stroke key stroke  key stroke get key stroke for event evt  object binding map get key stroke if binding null am get binding null return null if focus owner instanceof j text component fix for the bug where key events in j text components inside views are also handled by the input handler if evt get id  key event key pressed switch evt get key code case  key event vk enter case  key event vk tab case  key event vk back space case  key event vk space return null if evt is consumed return null if  debug dump key events  log log  log debug this  key event preprocessing  abstract input handler to string evt return  key event workaround process key event evt 
private void process key event sub boolean focus on text area we might have been closed as a result of the above if view is closed return this is a weird hack we don t want c e a to insert a in the search bar if the search bar has focus if is prefix active  component focus owner view get focus owner if focus owner instanceof j text component view set prefix focus owner focus owner view get text area request focus else if focus on text area view get text area request focus else view set prefix focus owner null else view set prefix focus owner null 
 returns the number of times the next action will be repeated public int get repeat count return repeat count 
 sets the number of times the next action will be repeated param repeat count  the repeat count public void set repeat count int repeat count int old repeat count this repeat count this repeat count repeat count if old repeat count repeat count view get status set message null 
 returns the last executed action since j edit pre public  edit action get last action return last action 
 invokes the specified  bean shell code replacing   char   in the code with the next input character param msg  the prompt to display in the status bar param code  the code since j edit pre public void read next char  string msg  string code view get status set message msg read next char code 
deprecated  use the other form of this method instead  deprecated public void read next char  string code read next char code 
 invokes the specified action repeating and recording it as necessary param action  the action since j edit pre  override public void invoke action  string action invoke action j edit get action action 
 invokes the specified action repeating and recording it as necessary param action  the action  override public void invoke action  edit action action j edit buffer buffer view get buffer if buffer inside compound edit buffer end compound edit remember the last executed action if action no remember last  history model get model action add item action get name if last action action last action count else last action action last action count remember old values in case action changes them int  repeat count repeat count execute the action if action no repeat  repeat count action invoke view else stop people doing dumb stuff like c enter c n if  repeat count repeat count threshold  string label action get label if label null label action get name else label gui utilities prettify menu label label  object pp label  repeat count if gui utilities confirm view large repeat count pp j option pane warning message j option pane yes no option j option pane yes option repeat count view get status set message null return try buffer begin compound edit for int i i  repeat count i action invoke view finally buffer end compound edit  macros  recorder recorder view get macro recorder if recorder null action no record recorder record  repeat count action get code  if repeat was true originally clear it  otherwise it might have been set by the action etc if  repeat count first of all if this action set a read next char do not clear the repeat if read next char null return repeat count view get status set message null 
public void invoke last action if last action null view get toolkit beep else invoke action last action 
protected void user input char ch last action count j edit text area text area view get text area  buffer buffer view get buffer if buffer inside compound edit buffer begin compound edit if repeat count text area user input ch else stop people doing dumb stuff like c enter c n if repeat count repeat count threshold  object pp  string value of ch repeat count if gui utilities confirm view large repeat count user input pp j option pane warning message j option pane yes no option j option pane yes option repeat count view get status set message null return j edit buffer buffer view get buffer try if repeat count buffer begin compound edit for int i i repeat count i text area user input ch finally if repeat count buffer end compound edit  macros  recorder recorder view get macro recorder if recorder null recorder record input repeat count ch text area is overwrite enabled repeat count 
protected void invoke read next char char ch j edit buffer buffer view get buffer if buffer inside compound edit buffer end compound edit  string char str  standard utilities chars to escapes  string value of ch this might be a bit slow if   char   occurs a lot int index while index read next char index of   char   read next char read next char substring index char str read next char substring index  macros  recorder recorder view get macro recorder if recorder null recorder record get repeat count read next char view get status set message null if get repeat count try buffer begin compound edit  bean shell eval view  bean shell get name space for int i i get repeat count i n n read next char n finally buffer end compound edit else  bean shell eval view  bean shell get name space read next char read next char null 
public  input method support  text area owner this owner owner owner add input method listener this owner get painter add extension  text area painter highest layer this 
private  rectangle get caret rectangle int x int y  text area painter painter owner get painter  point origin painter get location on screen int height painter get font metrics get height return new  rectangle origin x x origin y y height 
public void paint valid line  graphics d gfx int screen line int physical line int start int end int y if composed text layout null int caret owner get caret position if start caret caret end  text area painter painter owner get painter  the hight and baseline are taken from painter s  font metrics instead of  text layout so that the composed text is rendered at the same position with text in the  text area  font metrics fm painter get font metrics int x owner offset to xy caret x int width  math round composed text layout get advance int height fm get height int offset to baseline height fm get leading fm get descent int caret x x composed caret x gfx set color painter get background gfx fill rect x y width height gfx set color painter get foreground composed text layout draw gfx x y offset to baseline gfx set color painter get caret color gfx draw line caret x y caret x y height 
public  rectangle get text location  text hit info offset if composed text layout null return location of composed text  point caret owner offset to xy owner get caret position return get caret rectangle caret x composed caret x caret y else return location of selected text  selection selection on caret owner get selection at offset owner get caret position if selection on caret null  point selection start owner offset to xy selection on caret get start return get caret rectangle selection start x selection start y return null 
public  text hit info get location offset int x int y if composed text layout null  point origin owner get painter get location on screen  point caret owner offset to xy owner get caret position float local x x origin x caret x float local y y origin y caret y composed text layout get leading composed text layout get ascent return composed text layout hit test char local x local y return null 
public int get insert position offset return owner get caret position 
public  attributed character iterator get committed text int begin index int end index  attributed character iterator  attribute attributes return new  attributed string owner get text begin index end index begin index get iterator 
public int get committed text length return owner get buffer length 
public  attributed character iterator cancel latest committed text  attributed character iterator  attribute attributes if last committed text null int offset last committed at int length last committed text length  string sample owner get text offset length if sample null sample equals last committed text  attributed character iterator canceled new  attributed string sample get iterator owner get buffer remove offset length owner set caret position offset last committed text null return canceled  cleare last committed information to prevent accidental match last committed text null return null 
public  attributed character iterator get selected text  attributed character iterator  attribute attributes  selection selection on caret owner get selection at offset owner get caret position if selection on caret null return new  attributed string owner get selected text selection on caret get iterator return null 
public void input method text changed  input method event event composed text layout null  attributed character iterator text event get text if text null int committed count event get committed character count if committed count last committed text null last committed at owner get caret position  string builder committed new  string builder committed count char c int count for c text first count committed count c  attributed character iterator done count c text next count owner user input c committed append c last committed text committed to string int end index text get end index if committed count end index  attributed string composed new  attributed string text committed count end index  text area painter painter owner get painter composed add attribute  text attribute font painter get font composed text layout new  text layout composed get iterator painter get font render context  also updates caret caret position changed event 
public void caret position changed  input method event event composed caret x if composed text layout null  text hit info caret event get caret if caret null composed caret x  math round composed text layout get caret info caret  adjust visiblity int insertion x owner offset to xy owner get caret position x  text hit info visible event get visible position int composed visible x visible null  math round composed text layout get caret info visible composed caret x int visible x insertion x composed visible x int painter width owner get painter get width int adjustment if visible x adjustment visible x if visible x painter width adjustment visible x painter width if adjustment owner set horizontal offset owner get horizontal offset adjustment else  cancel horizontal adjustment for composed text fixme  the horizontal offset may be beyond the max value of owner s horizontal scroll bar owner scroll to caret false  invalidate one more line below the caret because the underline for composed text goes beyond the caret line in some font settings int caret line owner get caret line owner invalidate line range caret line caret line event consume 
 install panel  plugin manager window boolean updates super new  border layout this window window this updates updates set border new  empty border final j split pane split new j split pane j split pane vertical split j edit get boolean property appearance continuous layout split set resize weight  setup the table table new j table plugin model new  plugin table model table set show grid false table set intercell spacing new  dimension table set row height table get row height table set preferred scrollable viewport size new  dimension table set default renderer  object class new  text renderer  default table cell renderer table get default renderer  object class table add focus listener new  table focus handler  input map table input map table get input map j component when focused  action map table action map table get action map table input map put  key stroke get key stroke  key event vk tab tab out forward table action map put tab out forward new  keyboard action  keyboard command tab out forward table input map put  key stroke get key stroke  key event vk tab  input event shift mask tab out back table action map put tab out back new  keyboard action  keyboard command tab out back table input map put  key stroke get key stroke  key event vk space edit plugin table action map put edit plugin new  keyboard action  keyboard command edit plugin table input map put  key stroke get key stroke  key event vk enter close plugin manager table action map put close plugin manager new  keyboard action  keyboard command close plugin manager  table column col table get column model get column  table column col table get column model get column  table column col table get column model get column  table column col table get column model get column  table column col table get column model get column col set preferred width col set min width col set max width col set resizable false col set preferred width col set preferred width col set preferred width col set preferred width j table header header table get table header header set reordering allowed false header add mouse listener new  header mouse handler header set default renderer new  header renderer  default table cell renderer header get default renderer scrollpane new j scroll pane table scrollpane get viewport set background table get background split set top component scrollpane  create description j scroll pane info pane new j scroll pane info box new  plugin info box info pane set preferred size new  dimension split set bottom component info pane  swing utilities invoke later new  runnable public void run split set divider location add  border layout center split  create buttons  box buttons new  box  box layout x axis buttons add new  install button buttons add  box create horizontal strut buttons add new  selectall button buttons add choose button new  choose plugin set buttons add new  clear plugin set buttons add  box create glue buttons add new  size label add  border layout south buttons  string path j edit get property  plugin manager property pluginset if path equals load plugin set path 
loads a plugin set xml file and updates the model to reflect certain checked selections since j edit pre author  alan  ezust boolean load plugin set  string path vfs vfs vfs manager get vfs for path path  object session vfs create vfs session path  install panel this try  input stream is vfs  create input stream session path false  install panel this xml utilities parse xml is new  string map handler catch  exception e  log log  log warning this  loading  pluginset failed e get message return false plugin model update return true 
public void update model final  set  string saved checked new  hash set  string final  set  string saved selection new  hash set  string plugin model save selection saved checked saved selection plugin model clear info box set text j edit get property plugin manager list download vfs manager run in awt thread new  runnable public void run info box set text null plugin model update plugin model restore selection saved checked saved selection 
public void handle message eb message message if message get source  plugin manager get instance choose button path j edit get property  plugin manager property pluginset if choose button path length load plugin set choose button path plugin model restore selection new  hash set  string new  hash set  string choose button update ui 
private static  string format size int size  number format df  number format get instance df set maximum fraction digits df set minimum fraction digits  string size text if size size text size kb else size text df format size d mb return size text 
 override public  class get column class int column index switch column index case return  boolean class case case case case case return  object class default throw new  error  column out of range 
public int get column count return 
 override public  string get column name int column switch column case return case return j edit get property install plugins info name case return j edit get property install plugins info category case return j edit get property install plugins info version case return j edit get property install plugins info size case return  release date default throw new  error  column out of range 
public int get row count return entries size 
public  object get value at int row index int column index  object obj entries get row index if obj instanceof  string if column index return obj else return null else  entry entry  entry obj switch column index case return entry install case return entry name case return entry set case if updates return entry installed version entry version return entry version case return format size entry size case return entry date default throw new  error  column out of range 
 override public boolean is cell editable int row index int column index return column index 
public void set select all boolean b if is downloading list return int length get row count for int i i length i if b set value at  boolean true i else  entry entry  entry entries get i entry parents new  linked list  entry entry install false fire table changed new  table model event this 
public void set sort type int type sort type type sort type 
private void deselect parents  entry entry  entry parents entry get parents if parents length return  string args entry name int result gui utilities list confirm window plugin manager dependency args parents if result j option pane ok option entry install true return for int i i parents length i parents i install false fire table rows updated get row count 
 override public void set value at  object a value int row int column if column return  object obj entries get row if obj instanceof  string return  entry entry  entry obj entry install  boolean true equals a value if entry install deselect parents entry  list  plugin list  dependency deps entry plugin get compatible branch deps for int i i deps size i  plugin list  dependency dep deps get i if dep what equals plugin for int j j entries size j  entry temp  entry entries get j if temp plugin dep plugin if entry install temp parents add entry set value at  boolean true j else temp parents remove entry fire table cell updated row column 
public void sort int type  set  string saved checked new  hash set  string  set  string saved selection new  hash set  string save selection saved checked saved selection if sort type type sort direction sort type type if is downloading list return  collections sort entries new  entry compare type sort direction fire table changed new  table model event this restore selection saved checked saved selection table get table header repaint 
private boolean is downloading list return entries size entries get instanceof  string 
public void clear entries new  array list fire table changed new  table model event this 
public void update  set  string saved checked new  hash set  string  set  string saved selection new  hash set  string save selection saved checked saved selection  plugin list plugin list window get plugin list if plugin list null return entries new  array list for int i i plugin list plugin sets size i  plugin list  plugin set set plugin list plugin sets get i for int j j set plugins size j  plugin list  plugin plugin plugin list plugin hash get set plugins get j  plugin list  branch branch plugin get compatible branch  string installed version plugin get installed version if updates if branch null branch can satisfy dependencies installed version null  standard utilities compare strings branch version installed version false entries add new  entry plugin set name else if installed version null plugin can be installed entries add new  entry plugin set name sort sort type fire table changed new  table model event this restore selection saved checked saved selection 
public void save selection  set  string saved checked  set  string saved selection if entries is empty return for int i c get row count i c i if  boolean get value at i saved checked add entries get i to string int rows table get selected rows for int i i rows length i saved selection add entries get rows i to string 
public void restore selection  set  string saved checked  set  string saved selection for int i c get row count i c i  string name entries get i to string if plugin set contains name set value at true i else set value at saved checked contains name i if null table table set column selection interval if saved selection is empty int i int row count get row count for i row count i  string name entries get i to string if saved selection contains name table set row selection interval i i break  list selection model lsm table get selection model for i row count i  string name entries get i to string if saved selection contains name lsm add selection interval i i else if table get row count table set row selection interval j scroll bar scrollbar scrollpane get vertical scroll bar scrollbar set value scrollbar get minimum 
 entry  plugin list  plugin plugin  string set  plugin list  branch branch plugin get compatible branch boolean download source j edit get boolean property plugin manager download source int size download source branch download source size branch download size this name plugin name this author plugin author this installed version plugin get installed version this version branch version this size size this date branch date this description plugin description this set set this install false this plugin plugin  simple date format format new  simple date format d mmmm yyyy  locale english try timestamp format parse date get time catch  parse exception e  log log  log error this e 
private void get parents  list  entry list for  entry entry parents if entry install list contains entry list add entry entry get parents list 
 entry get parents  list  entry list new  array list  entry get parents list  entry array list to array new  entry list size  arrays sort array new  standard utilities  string compare  entry true return array 
 override public  string to string return name 
 plugin info box set background j edit get color property view bg color set foreground j edit get color property view fg color put client property j editor pane honor display properties true set editable false set editor kit new html editor kit set line wrap true set wrap style word true params new  string table get selection model add list selection listener this 
public void value changed  list selection event e  string text if table get selected row count  entry entry  entry plugin model entries get table get selected row params entry author params entry date params entry description text j edit get property install plugins info params text text replace n br text html text html set text text set caret position 
 size label size set text j edit get property install plugins total size format size size plugin model add table model listener this 
public void table changed  table model event e if e get type  table model event update if plugin model is downloading list return size int length plugin model get row count for int i i length i  entry entry  entry plugin model entries get i if entry install size entry size set text j edit get property install plugins total size format size size 
 selectall button super j edit get property install plugins select all add action listener this plugin model add table model listener this set enabled false 
public void action performed  action event evt plugin model set select all is selected 
public void table changed  table model event e if plugin model is downloading list return set enabled plugin model get row count if e get type  table model event update int length plugin model get row count for int i i length i if  boolean plugin model get value at i boolean value set selected false return if length set selected true 
 string map handler plugin set clear 
 override public void start element  string uri  string local name  string q name  attributes attrs throws sax exception if local name equals plugin plugin set add attrs get value name 
 choose plugin set set icon gui utilities load icon j edit get property install plugins choose plugin set icon add action listener this update ui 
 override public void update ui path j edit get property  plugin manager property pluginset if path length set tool tip text  click here to choose a predefined plugin set else set tool tip text  choose pluginset path super update ui 
public void action performed  action event ae path j edit get property  plugin manager property pluginset j edit get settings directory  file separator  string selected files gui utilities show vfs file dialog  install panel this window j edit get active view path vfs browser open dialog false if selected files null selected files length return path selected files boolean success load plugin set path if success j edit set property  plugin manager property pluginset path update ui 
 clear plugin set set icon gui utilities load icon j edit get property install plugins clear plugin set icon set tool tip text clear plugin set add action listener this 
public void action performed  action event e plugin set clear plugin model restore selection new  hash set  string new  hash set  string j edit unset property  plugin manager property pluginset choose button update ui 
 install button super j edit get property install plugins install plugin model add table model listener this add action listener this set enabled false 
public void action performed  action event evt if plugin model is downloading list return boolean download source j edit get boolean property plugin manager download source boolean install user j edit get boolean property plugin manager install user  roster roster new  roster  string install directory if install user install directory  misc utilities construct path j edit get settings directory jars else install directory  misc utilities construct path j edit get j edit home jars int length plugin model get row count int instcount for int i i length i  entry entry  entry plugin model entries get i if entry install entry plugin install roster install directory download source if updates entry plugin get compatible branch satisfy dependencies roster install directory download source instcount if roster is empty return boolean cancel false if updates roster get operation count instcount if gui utilities confirm window install plugins depend null j option pane ok cancel option j option pane warning message j option pane cancel option cancel true if cancel new  plugin manager progress window roster roster perform operations in awt thread window plugin model update 
public void table changed  table model event e if plugin model is downloading list return if e get type  table model event update int length plugin model get row count for int i i length i if  boolean plugin model get value at i boolean value set enabled true return set enabled false 
 entry compare int type int sort direction this type type this sort direction sort direction 
public int compare  entry e  entry e int result switch type case column install result e install e install e install break case column name result e name compare to ignore case e name break case column category result e set compare to ignore case e set if result result e name compare to ignore case e name break case column version lets avoid npe  maybe we should move this code to  standard utilities compare strings if e version e version result else if e version null result else if e version null result else result  standard utilities compare strings e version e version true break case column size result e size e size e size e size break case column release result e timestamp e timestamp e timestamp e timestamp break default result return result sort direction 
 override public void mouse clicked  mouse event evt int column table get table header column at point evt get point plugin model sort direction plugin model sort column 
 text renderer  default table cell renderer tcr this tcr tcr 
 override public  component get table cell renderer component j table table  object value boolean is selected boolean has focus int row int column if column tcr set horizontal alignment trailing else tcr set horizontal alignment leading return tcr get table cell renderer component table value is selected false row column 
 keyboard action  keyboard command command this command command 
public void action performed  action event evt switch command case tab out forward  keyboard focus manager get current keyboard focus manager focus next component break case tab out back  keyboard focus manager get current keyboard focus manager focus previous component break case edit plugin int rows table get selected rows  object state new  object rows length for int i i rows length i state i plugin model get value at rows i for int i i rows length i plugin model set value at state i equals  boolean false rows i break case close plugin manager window ok break default throw new  internal error 
 override public void focus gained  focus event fe if table get selected row table get row count table set row selection interval j scroll bar scrollbar scrollpane get vertical scroll bar scrollbar set value scrollbar get minimum if table get selected column table set column selection interval 
 header renderer  default table cell renderer tcr this tcr tcr 
 override public  component get table cell renderer component j table table  object value boolean is selected boolean has focus int row int column j label l j label tcr get table cell renderer component table value is selected has focus row column  plugin table model model  plugin table model table get model  icon icon column model sort type model sort direction asc icon desc icon null l set icon icon l set horizontal text position l leading return l 
public  integer array this 
public  integer array int initial size array new int initial size 
public void add int num if len array length int array n new int len  system arraycopy array array n len array array n array len num 
public final int get int index return array index 
public final int get size return len 
public final void set size int len this len len 
public final void clear len 
public int get array return array 
 the main constructor  all constructors should now pass through here param namespace  if namespace is non null then this interpreter s root namespace will be set to the one provided  if it is null a new one will be created for it param parent  the parent interpreter if this interpreter is a child of another  may be null  children share a  bsh class manager with their parent instance param source file info  an informative string holding the filename or other description of the source from which this interpreter is reading used for debugging  may be null public  interpreter  reader in  print stream out  print stream err boolean interactive  name space namespace  interpreter parent  string source file info  system out println  new  interpreter this sourcefile source file info parser new  parser in long t  system current time millis this in in this out out this err err this interactive interactive debug err this parent parent if parent null set strict java parent get strict java this source file info source file info  bsh class manager bcm  bsh class manager create class manager this if namespace null this global name space new  name space bcm global else this global name space namespace now done in  name space automatically when root  the classes which are imported by default global name space load default imports  create the root bsh system object if it doesn t exist if getu bsh instanceof org gjt sp jedit bsh  this init root system object if interactive load rc files long t  system current time millis if  interpreter debug  interpreter debug  time to initialize interpreter t t 
public  interpreter  reader in  print stream out  print stream err boolean interactive  name space namespace this in out err interactive namespace null null 
public  interpreter  reader in  print stream out  print stream err boolean interactive this in out err interactive null 
 construct a new interactive interpreter attached to the specified console using the specified parent namespace public  interpreter  console interface console  name space global name space this console get in console get out console get err true global name space set console console 
 construct a new interactive interpreter attached to the specified console public  interpreter  console interface console this console null 
 create an interpreter for evaluation only public  interpreter this new  string reader  system out  system err false null eval only true setu bsh eval only new  primitive true 
 attach a console  note this method is incomplete public void set console  console interface console this console console setu bsh console console redundant with constructor set out console get out set err console get err need to set the input stream reinit the parser 
private void init root system object  bsh class manager bcm get class manager bsh setu bsh new  name space bcm  bsh  object get this this init the static shared shared object if it s not there yet if shared object null shared object new  name space bcm  bsh  shared  system  object get this this bsh system setu bsh system shared object setu bsh shared shared object alias bsh help  this help text new  name space bcm  bsh  command  help  text get this this setu bsh help help text bsh cwd try setu bsh cwd  system get property user dir catch  security exception e applets can t see sys props setu bsh cwd bsh interactive setu bsh interactive new  primitive interactive bsh eval only setu bsh eval only new  primitive eval only 
 set the global namespace for this interpreter p  note  this is here for completeness  if you re using this a lot it may be an indication that you are doing more work than you have to  for example caching the interpreter instance rather than the namespace should not add a significant overhead  no state other than the debug status is stored in the interpreter p  all features of the namespace can also be accessed using the interpreter via eval and the script variable this namespace or global namespace as necessary public void set name space  name space global name space this global name space global name space 
 get the global namespace of this interpreter p  note  this is here for completeness  if you re using this a lot it may be an indication that you are doing more work than you have to  for example caching the interpreter instance rather than the namespace should not add a significant overhead  no state other than the debug status is stored in the interpreter p  all features of the namespace can also be accessed using the interpreter via eval and the script variable this namespace or global namespace as necessary public  name space get name space return global name space 
 run the text only interpreter on the command line or specify a file public static void main  string args if args length  string filename args  string bsh args if args length bsh args new  string args length  system arraycopy args bsh args args length else bsh args new  string  interpreter interpreter new  interpreter  system out println run i interpreter interpreter setu bsh args bsh args try  object result interpreter source filename interpreter global name space if result instanceof  class try invoke main  class result bsh args catch  exception e  object o e if e instanceof  invocation target exception o  invocation target exception e get target exception  system err println  class result main method threw exception o catch  file not found exception e  system out println  file not found e catch  target error e  system out println  script threw exception e if e in native code e print stack trace debug  system err catch  eval error e  system out println  evaluation  error e catch io exception e  system out println i o  error e else  workaround for jdk bug where system in available returns too large a value  this bug has been fixed in jdk  input stream src if  system get property os name starts with  windows  system get property java version starts with src new  filter input stream  system in public int available throws io exception return else src  system in  reader in new  command line reader new  input stream reader src  interpreter interpreter new  interpreter in  system out  system err true interpreter run 
public static void invoke main  class clas  string args throws  exception  method main  reflect resolve java method null  bsh class manager clas main new  class  string class true only static if main null main invoke null new  object args 
 run interactively printing prompts etc public void run if eval only throw new  runtime exception bsh  interpreter  no stream  we ll print our banner using eval  string in order to exercise the parser and get the basic expression classes loaded  this ameliorates the delay after typing the first statement if interactive try eval print banner catch  eval error e println  bean shell version by  pat  niemeyer pat pat net init the callstack  call stack callstack new  call stack global name space boolean eof false while eof try try to sync up the console  system out flush  system err flush  thread yield this helps a little if interactive print get bsh prompt eof  line if get jjtree node arity number of child nodes  simple node node  simple node get jjtree root node if debug node dump  object ret node eval callstack this sanity check during development if callstack depth throw new  interpreter error  callstack growing callstack if ret instanceof  return control ret  return control ret value if ret  primitive void setu   ret if show results println ret catch  parse exception e error  parser  error e get message debug if debug e print stack trace if interactive eof true parser re init input in catch  interpreter error e error  internal  error e get message e print stack trace if interactive eof true catch  target error e error  uncaught  exception e if e in native code e print stack trace debug err if interactive eof true setu  e e get target catch  eval error e if interactive error  eval error e to string else error  eval error e get message if debug e print stack trace if interactive eof true catch  exception e error  unknown error e if debug e print stack trace if interactive eof true catch  token mgr error e error  error parsing input e  we get stuck in infinite loops here when unicode escapes fail  must re init the char stream reader ascii u code esc  char stream java parser re init token input in if interactive eof true finally get jjtree reset reinit the callstack if callstack depth callstack clear callstack push global name space if interactive exit on eof  system exit 
 read text from file name and eval it public  object source  string filename  name space name space throws  file not found exception io exception  eval error  file file path to file filename if  interpreter debug debug  sourcing file file  reader source in new  buffered reader new  file reader file try return eval source in name space filename finally source in close 
 read text from file name and eval it  convenience method  use the global namespace public  object source  string filename throws  file not found exception io exception  eval error return source filename global name space 
 spawn a non interactive local interpreter to evaluate text in the specified namespace  return value is the evaluated object or corresponding primitive wrapper param source file info is for information purposes only  it is used to display error messages and in the future may be made available to the script throws  eval error on script problems throws  target error on unhandled exceptions from the script  note we need a form of eval that passes the callstack through  can t this be combined with run run seems to have stuff in it for interactive vs non interactive compare them side by side and see what they do differently aside from the exception handling public  object eval  reader in  name space name space  string source file info  call stack callstack throws  eval error  object ret val null if  interpreter debug debug eval name space name space  create non interactive local interpreter for this namespace with source from the input stream and out err same as this interpreter  interpreter local interpreter new  interpreter in out err false name space this source file info  call stack callstack new  call stack name space boolean eof false while eof  simple node node null try eof local interpreter  line if local interpreter get jjtree node arity node  simple node local interpreter get jjtree root node nodes remember from where they were sourced node set source file source file info if trace println node get text ret val node eval callstack local interpreter sanity check during development if callstack depth throw new  interpreter error  callstack growing callstack if ret val instanceof  return control ret val  return control ret val value break non interactive return control now if local interpreter show results ret val  primitive void println ret val catch  parse exception e throw new  eval error  sourced file source file info parser  error e get message debug node callstack if debug show extra expecting info error e get message debug add the source file info and throw again e set error source file source file info throw e catch  interpreter error e e print stack trace throw new  eval error  sourced file source file info internal  error e get message node callstack catch  target error e failsafe set the  line as the origin of the error if e get node null e set node node e re throw  sourced file source file info catch  eval error e if debug e print stack trace failsafe set the  line as the origin of the error if e get node null e set node node e re throw  sourced file source file info catch  exception e if debug e print stack trace throw new  eval error  sourced file source file info unknown error e get message node callstack catch  token mgr error e throw new  eval error  sourced file source file info  token  parsing  error e get message node callstack finally local interpreter get jjtree reset reinit the callstack if callstack depth callstack clear callstack push name space return  primitive unwrap ret val 
 evaluate the inputstream in this interpreter s global namespace public  object eval  reader in throws  eval error return eval in global name space eval stream 
 evaluate the string in this interpreter s global namespace public  object eval  string statements throws  eval error if  interpreter debug debug eval  string statements return eval statements global name space 
 evaluate the string in the specified namespace public  object eval  string statements  name space name space throws  eval error  string s statements ends with statements statements return eval new  string reader s name space inline evaluation of show eval string s 
private  string show eval string  string s s s replace n s s replace r if s length s s substring return s 
 print an error message in a standard format on the output stream associated with this interpreter  on the gui console this will appear in red etc public final void error  object o if console null console error  error o n else err println  error o err flush 
 get the input stream associated with this interpreter  this may be be stdin or the gui console public  reader get in return in 
 get the outptut stream associated with this interpreter  this may be be stdout or the gui console public  print stream get out return out 
 get the error output stream associated with this interpreter  this may be be stderr or the gui console public  print stream get err return err 
public final void println  object o print  string value of o system line separator 
public final void print  object o if console null console print o else out print o out flush 
 print a debug message on debug stream associated with this interpreter only if debugging is turned on public final static void debug  string s if debug debug println  debug s 
 get the value of the name name may be any value e g a variable or field public  object get  string name throws  eval error try  object ret global name space get name this return  primitive unwrap ret catch  util eval error e throw e to eval error  simple node javacode new  call stack 
 unchecked get for internal use  object getu  string name try return get name catch  eval error e throw new  interpreter error set e 
 assign the value to the name name may evaluate to anything assignable e g a variable or field public void set  string name  object value throws  eval error map null to  primtive null coming in if value null value  primitive null  call stack callstack new  call stack try if  name is compound name lhs lhs global name space get name resolver name to lhs callstack this lhs assign value false else optimization for common case global name space set variable name value false catch  util eval error e throw e to eval error  simple node javacode callstack 
 unchecked set for internal use void setu  string name  object value try set name value catch  eval error e throw new  interpreter error set e 
public void set  string name long value throws  eval error set name new  primitive value 
public void set  string name int value throws  eval error set name new  primitive value 
public void set  string name double value throws  eval error set name new  primitive value 
public void set  string name float value throws  eval error set name new  primitive value 
public void set  string name boolean value throws  eval error set name new  primitive value 
 unassign the variable name  name should evaluate to a variable public void unset  string name throws  eval error  we jump through some hoops here to handle arbitrary cases like unset bsh foo  call stack callstack new  call stack try lhs lhs global name space get name resolver name to lhs callstack this if lhs type lhs variable throw new  eval error  can t unset not a variable name  simple node javacode new  call stack lhs assign null false lhs name space unset variable name catch  util eval error e throw new  eval error e get message  simple node javacode new  call stack 
 get a reference to the interpreter global namespace cast to the specified interface type  assuming the appropriate methods of the interface are defined in the interpreter then you may use this interface from  java just like any other  java object p  for example pre  interpreter interpreter new  interpreter define a method called run interpreter eval run  fetch a reference to the interpreter as a  runnable  runnable runnable  runnable interpreter get interface  runnable class pre p  note that the interpreter does not require that any or all of the methods of the interface be defined at the time the interface is generated  however if you attempt to invoke one that is not defined you will get a runtime exception p  note also that this convenience method has exactly the same effect as evaluating the script pre  type this pre p  for example the following is identical to the previous example p pre  fetch a reference to the interpreter as a  runnable  runnable runnable  runnable interpreter eval  runnable this pre p em  version requirement em  although standard  java interface types are always available to be used with arbitrary interfaces this feature requires that you are using  java or greater p throws  eval error if the interface cannot be generated because the version of  java does not support the proxy mechanism public  object get interface  class interf throws  eval error try return global name space get this this get interface interf catch  util eval error e throw e to eval error  simple node javacode new  call stack 
private jjt parser state get jjtree return parser jjtree 
private  java char stream get jj input stream return parser jj input stream 
private boolean  line throws  parse exception return parser  line 
void load rc files try  string rcfile  default is c windows under win home under  unix  system get property user home  file separator bshrc source rcfile global name space catch  exception e squeltch security exception filenotfoundexception if  interpreter debug debug  could not find rc file e 
 localize a path to the file name based on the bsh cwd interpreter working directory public  file path to file  string file name throws io exception  file file new  file file name if relative fix up to bsh cwd if file is absolute  string cwd  string getu bsh cwd file new  file cwd  file separator file name  the canonical file name is also absolute  no need for get absolute path here return new  file file get canonical path 
public static void redirect output to file  string filename try  print stream pout new  print stream new  file output stream filename  system set out pout  system set err pout catch io exception e  system err println  can t redirect output to file filename 
 set an external class loader to be used as the base classloader for  bean shell  the base classloader is used for all classloading unless until the add classpath set classpath reload classes commands are called to modify the interpreter s classpath  at that time the new paths updated paths are added on top of the base classloader p  bean shell will use this at the same point it would otherwise use the plain  class for name i e if no explicit classpath management is done from the script add class path set class path reload classes then  bean shell will only use the supplied classloader  if additional classpath management is done then  bean shell will perform that in addition to the supplied external classloader  however  bean shell is not currently able to reload classes supplied through the external classloader p see  bsh class manager set class loader  class loader public void set class loader  class loader external cl get class manager set class loader external cl 
 get the class manager associated with this interpreter the  bsh class manager of this interpreter s global namespace  this is primarily a convenience method public  bsh class manager get class manager return get name space get class manager 
 set strict  java mode on or off  this mode attempts to make  bean shell syntax behave as  java syntax eliminating conveniences like loose variables etc  when enabled variables are required to be declared or initialized before use and method arguments are reqired to have types p  this mode will become more strict in a future release when classes are interpreted and there is an alternative to scripting objects as method closures public void set strict java boolean b this strict java b 
see set strict java boolean public boolean get strict java return this strict java 
static void static init  apparently in some environments you can t catch the security exception at all e g as an applet in ie will probably have to work around try system line separator  system get property line separator debug  system err debug  boolean get boolean debug trace  boolean get boolean trace localscoping  boolean get boolean localscoping  string outfilename  system get property outfile if outfilename null redirect output to file outfilename catch  security exception e  system err println  could not init static e catch  exception e  system err println  could not init static e catch  throwable e  system err println  could not init static e 
 specify the source of the text from which this interpreter is reading  note there is a difference between what file the interrpeter is sourcing and from what file a method was originally parsed  one file may call a method sourced from another file  see  simple node for origination file info see org gjt sp jedit bsh  simple node get source file public  string get source file info if source file info null return source file info else return unknown source 
 get the parent  interpreter of this interpreter if any  currently this relationship implies the following  parent and child share a  bsh class manager  children indicate the parent s source file information in error reporting  when created as part of a source eval the child also shares the parent s namespace  but that is not necessary in general public  interpreter get parent return parent 
public void set out  print stream out this out out 
public void set err  print stream err this err err 
 de serialization setup  default out and err streams to stdout stderr if they are null private void read object  object input stream stream throws java io io exception  class not found exception stream default read object set transient fields if console null set out console get out set err console get err else set out  system out set err  system err 
 get the prompt string defined by the get bsh prompt method in the global namespace  this may be from the get bsh prompt command or may be defined by the user as with any other method  defaults to bsh if the method is not defined or there is an error private  string get bsh prompt try return  string eval get bsh prompt catch  exception e return bsh 
 specify whether in interactive mode the interpreter exits  java upon end of input  if true when in interactive mode the interpreter will issue a  system exit upon eof  if false the interpreter no  system exit will be done p  note if you wish to cause an eof externally you can try closing the input stream  this is not guaranteed to work in older versions of  java due to  java limitations but should work in newer jdk jr es  that was the motivation for the  java nio package public void set exit on eof boolean value exit on eof value ug 
 turn on off the verbose printing of results as for the show command  if this interpreter has a parent the call is delegated  see the  bean shell show command public void set show results boolean show results this show results show results 
 show on off verbose printing status for the show command  see the  bean shell show command  if this interpreter has a parent the call is delegated public boolean get show results return show results 
public  interpreter error  string s super s 
public io progress monitor super new  border layout caption new j label update caption add  border layout north caption threads new  thread progress vfs manager get io thread pool get thread count  box box new  box  box layout y axis for int i i threads length i if i box add  box create vertical strut threads i new  thread progress i box add threads i j panel thread panel new j panel new  border layout thread panel set border new  empty border thread panel add  border layout north box add  border layout center new j scroll pane thread panel work thread handler new  work thread handler 
public void add notify vfs manager get io thread pool add progress listener work thread handler super add notify 
public void remove notify vfs manager get io thread pool remove progress listener work thread handler super remove notify 
private void update caption  string args  string value of vfs manager get io thread pool get request count caption set text j edit get property io progress monitor caption args 
public void status update final  work thread pool thread pool final int thread index  swing utilities invoke later new  runnable public void run update caption threads thread index update 
public void progress update final  work thread pool thread pool final int thread index  swing utilities invoke later new  runnable public void run update caption threads thread index update 
public  thread progress int index super new  border layout this index index  box box new  box  box layout y axis box add  box create glue box add progress new j progress bar progress set string painted true box add  box create glue  thread progress this add  border layout center box abort new j button j edit get property io progress monitor abort abort add action listener new  action handler  thread progress this add  border layout east abort update 
public void update  work thread thread vfs manager get io thread pool get thread index if thread is request running if progress is indeterminate if thread get progress maximum progress set indeterminate false else if thread get progress maximum progress set indeterminate true abort set enabled true  string status thread get status if status null status progress set string status progress set maximum thread get progress maximum  system err println value thread get progress value progress set value thread get progress value else abort set enabled false progress set string j edit get property io progress monitor idle progress set indeterminate false progress set value 
public void action performed  action event evt if evt get source abort int result gui utilities confirm io progress monitor this abort null j option pane yes no option j option pane question message if result j option pane yes option vfs manager get io thread pool get thread index abort current request 
 moves the source file to the destination  if the destination cannot be created or is a read only file the method returns code false code  otherwise the contents of the source are copied to the destination the source is deleted and code true code is returned param source  the source file to move param dest  the destination where to move the file return true on success false otherwise since j edit pre public static boolean move file  file source  file dest boolean ok false if dest exists dest can write dest exists dest get parent file can write  output stream fos null  input stream fis null try fos new  file output stream dest fis new  file input stream source ok copy stream null fis fos false catch io exception ioe  log log  log warning io utilities class  error moving file ioe ioe get message finally close quietly fos close quietly fis if ok source delete return ok 
 copy an input stream to an output stream param buffer size the size of the buffer param progress the progress observer it could be null param in the input stream param out the output stream param can stop if true the copy can be stopped by interrupting the thread return code true code if the copy was done code false code if it was interrupted throws io exception io exception  if an i o error occurs public static boolean copy stream int buffer size  progress observer progress  input stream in  output stream out boolean can stop throws io exception byte buffer new byte buffer size int n long copied l while n in read buffer out write buffer n copied n if progress null progress set value copied if can stop  thread interrupted return false return true 
 copy an input stream to an output stream with a buffer of bytes param progress the progress observer it could be null param in the input stream param out the output stream param can stop if true the copy can be stopped by interrupting the thread return code true code if the copy was done code false code if it was interrupted throws io exception io exception  if an i o error occurs public static boolean copy stream  progress observer progress  input stream in  output stream out boolean can stop throws io exception return copy stream progress in out can stop 
 returns the length of a file  if it is a directory it will calculate recursively the length param file the file or directory return the length of the file or directory  if the file doesn t exist it will return since pre public static long file length  file file long length l if file is file length file length else if file is directory  file files file list files for int i i files length i length file length files i return length 
 method that will close an link  input stream ignoring it if it is null and ignoring exceptions param in the  input stream to close public static void close quietly  input stream in if in null try in close catch io exception e ignore 
 method that will close an link  output stream ignoring it if it is null and ignoring exceptions param out the  output stream to close public static void close quietly  output stream out if out null try if out instanceof  flushable  flushable out flush catch io exception e ignore try out close catch io exception e ignore 
 method that will close an link  reader ignoring it if it is null and ignoring exceptions param r the  reader to close since j edit pre public static void close quietly  reader r if r null try r close catch io exception e ignore 
 method that will close a link  writer ignoring it if it is null and ignoring exceptions param out the  writer to close public static void close quietly  writer out if out null try if out instanceof  flushable  flushable out flush catch io exception e ignore try out close catch io exception e ignore 
 method that will close an link java io  closeable ignoring it if it is null and ignoring exceptions param closeable the closeable to close since j edit pre public static void close quietly  closeable closeable if closeable null try if closeable instanceof  flushable  flushable closeable flush catch io exception e ignore try closeable close catch io exception e ignore 
private io utilities 
 constructs an uninitialized link  item  item object  item 
 constructs a copy of the given item param index index of the item to be constructed param i the item that must be copied into the item to be constructed  item final short index final  item i this index index type i type int val i int val long val i long val float val i float val double val i double val str val i str val str val i str val str val i str val hash code i hash code 
 sets this item to an link  class writer int int item param int val the value of this item void set final int int val this type  class writer int this int val int val this hash code type int val 
 sets this item to a link  class writer long long item param long val the value of this item void set final long long val this type  class writer long this long val long val this hash code type int long val 
 sets this item to a link  class writer float float item param float val the value of this item void set final float float val this type  class writer float this float val float val this hash code type int float val 
 sets this item to a link  class writer double double item param double val the value of this item void set final double double val this type  class writer double this double val double val this hash code type int double val 
 sets this item to an item that do not hold a primitive value param type the type of this item param str val first part of the value of this item param str val second part of the value of this item param str val third part of the value of this item void set final int type final  string str val final  string str val final  string str val this type type this str val str val this str val str val this str val str val switch type case  class writer utf case  class writer str case  class writer class hash code type str val hash code return case  class writer name type hash code type str val hash code str val hash code return case  class writer field case  class writer meth case  class writer imeth default hash code type str val hash code str val hash code str val hash code return 
 indicates if the given item is equal to this one param i the item to be compared to this one return tt true tt if the given item if equal to this one tt false tt otherwise boolean is equal to final  item i if i type type switch type case  class writer int return i int val int val case  class writer long return i long val long val case  class writer float return i float val float val case  class writer double return i double val double val case  class writer utf case  class writer str case  class writer class return i str val equals str val case  class writer name type return i str val equals str val i str val equals str val case  class writer field case  class writer meth case  class writer imeth default return i str val equals str val i str val equals str val i str val equals str val return false 
 this constructor creates a class loader for loading classes from all plugins  for example  bean shell uses one of these so that scripts can use plugin classes public jar class loader this true 
 creates a class loader that will optionally delegate the finding of classes to the parent class loader by default since j edit pre public jar class loader boolean delegate first this delegate first delegate first for debugging id index live 
exception  class not found exception if the class could not be found public  class load class  string clazz boolean resolve it throws  class not found exception  class not found exception pending null if delegate first try return load from parent clazz catch  class not found exception cnf keep going if class was not found pending cnf  object obj class hash get clazz if obj no class we remember which classes we don t exist because  bean shell tries loading all possible imported prefix class name combinations throw new  class not found exception clazz else if obj instanceof jar class loader jar class loader class loader jar class loader obj try return class loader  load class clazz resolve it catch  class not found exception cnf class hash put clazz no class throw cnf else if delegate first if delegating reaching this statement means the class was really not found  otherwise we ll try loading from the parent class loader throw pending return load from parent clazz 
public  input stream get resource as stream  string name try try in current jar first if jar null  zip file zip file jar get zip file  zip entry entry zip file get entry name if entry null return zip file get input stream entry then try from another jar  object obj resources hash get name if obj instanceof jar class loader jar class loader class loader jar class loader obj return class loader get resource as stream name finally try from the system class loader return get system resource as stream name catch io exception io  log log  log error this io return null 
overriding get resource because we want to search first in this  class loader then the parent the path etc public url get resource  string name try if jar null  zip file zip file jar get zip file  zip entry entry zip file get entry name if entry null return new url get resource as path name  object obj resources hash get name if obj instanceof jar class loader jar class loader class loader jar class loader obj return class loader get resource name else url ret get system resource name if ret null  log log  log debug jar class loader class  would have returned null for get resource name  log log  log debug jar class loader class returning ret return ret catch io exception io  log log  log error this io return null 
construct a jeditresource etc path from the name of a resource in the associated jar  the existence of the resource is not actually checked param name name of the resource return jeditresource path to the jar name of the resource throws  unsupported operation exception if this is an anonymous jar class loader no associated jar public  string get resource as path  string name this must be fixed during plugin development if jar null throw new  unsupported operation exception don t call get resource as path on anonymous jar class loader if name starts with name name return jeditresource  misc utilities get file name jar get path name 
deprecated  call code  plugin jar get zip file code instead public  zip file get zip file try return jar get zip file catch io exception io  log log  log error this io return null 
 for debugging public static void dump  log log  log debug jar class loader class  total instances created index  log log  log debug jar class loader class  live instances live synchronized class hash for  map  entry  string  object entry class hash entry set if entry get value no class  log log  log debug jar class loader class entry get key entry get value 
public  string to string if jar null return anonymous id else return jar get path id 
return zero or one resource as returned by get resource public  enumeration get resources  string name throws io exception class  single element enumeration implements  enumeration private  object element  single element enumeration  object element this element element public boolean has more elements return element null public  object next element if element null  object retval element element null return retval else throw new  no such element exception url resource get resource name return new  single element enumeration resource 
protected void finalize live 
since j edit pre jar class loader  plugin jar jar this this jar jar 
void activate if jar get plugin null  string  delegate j edit get property plugin jar get plugin get class name class loader delegate delegate first  delegate null true equals  delegate  string classes jar get classes if classes null for int i i classes length i class hash put classes i this  string resources jar get resources if resources null for int i i resources length i resources hash put resources i this 
void deactivate  string classes jar get classes if classes null for int i i classes length i  object loader class hash get classes i if loader this class hash remove classes i else two plugins provide same class  string resources jar get resources if resources null return for int i i resources length i  object loader resources hash get resources i if loader this resources hash remove resources i else two plugins provide same resource 
 load class from this jar only private synchronized  class  load class  string clazz boolean resolve it throws  class not found exception jar activate plugin synchronized this  class cls find loaded class clazz if cls null if resolve it resolve class cls return cls  string name  misc utilities class to file clazz try define package clazz  zip file zip file jar get zip file  zip entry entry zip file get entry name if entry null throw new  class not found exception clazz  input stream in zip file get input stream entry int len int entry get size byte data new byte len int success int offset while success len len success offset success success in read data offset len if success  log log  log error this  failed to load class clazz from zip file get name throw new  class not found exception clazz cls define class clazz data data length if resolve it resolve class cls return cls catch io exception io  log log  log error this io throw new  class not found exception clazz 
private void define package  string clazz throws io exception int idx clazz last index of if idx  string name clazz substring idx if get package name null define package name new  jar file jar get file get manifest 
private static  string get mf value  attributes section attrs  attributes main attrs  attributes  name name  string value null if section attrs null value section attrs get value name else if main attrs null value main attrs get value name return value 
private void define package  string name  manifest mf if mf null define package name null null null null null null null return  attributes sa mf get attributes name replace  attributes ma mf get main attributes url seal base null if  boolean value of get mf value sa ma  name sealed boolean value try seal base jar get file to url catch  malformed url exception e  package pkg define package name get mf value sa ma  name specification title get mf value sa ma  name specification version get mf value sa ma  name specification vendor get mf value sa ma  name implementation title get mf value sa ma  name implementation version get mf value sa ma  name implementation vendor seal base 
private  class load from parent  string clazz throws  class not found exception  class cls  class loader parent loader get class get class loader if parent loader null cls parent loader load class clazz else cls find system class clazz return cls 
static final int hexval char c throws java io io exception switch c case return case return case return case return case return case return case return case return case return case return case a case a return case b case b return case c case c return case d case d return case e case e return case f case f return throw new java io io exception  should never come here 
protected void  expand buff boolean wrap around char newbuffer new char bufsize int newbufline new int bufsize int newbufcolumn new int bufsize try if wrap around  system arraycopy buffer token begin newbuffer bufsize token begin  system arraycopy buffer newbuffer bufsize token begin bufpos buffer newbuffer  system arraycopy bufline token begin newbufline bufsize token begin  system arraycopy bufline newbufline bufsize token begin bufpos bufline newbufline  system arraycopy bufcolumn token begin newbufcolumn bufsize token begin  system arraycopy bufcolumn newbufcolumn bufsize token begin bufpos bufcolumn newbufcolumn bufpos bufsize token begin else  system arraycopy buffer token begin newbuffer bufsize token begin buffer newbuffer  system arraycopy bufline token begin newbufline bufsize token begin bufline newbufline  system arraycopy bufcolumn token begin newbufcolumn bufsize token begin bufcolumn newbufcolumn bufpos token begin catch  throwable t throw new  error t get message available bufsize token begin 
protected void  fill buff throws java io io exception int i if max next char ind max next char ind next char ind try if i input stream read next char buf max next char ind max next char ind input stream close throw new java io io exception else max next char ind i return catch java io io exception e if bufpos bufpos backup else bufline bufpos line bufcolumn bufpos column throw e 
protected char  read byte throws java io io exception if next char ind max next char ind  fill buff return next char buf next char ind 
public char  begin token throws java io io exception if in buf in buf if bufpos bufsize bufpos token begin bufpos return buffer bufpos token begin bufpos return read char 
protected void  adjust buff size if available bufsize if token begin bufpos available token begin else  expand buff false else if available token begin available bufsize else if token begin available  expand buff true else available token begin 
protected void  update line column char c column if prev char is lf prev char is lf false line column else if prev char is cr prev char is cr false if c n prev char is lf true else line column switch c case r prev char is cr true break case n prev char is lf true break case t column column column break default break bufline bufpos line bufcolumn bufpos column 
public char read char throws java io io exception if in buf in buf if bufpos bufsize bufpos return buffer bufpos char c if bufpos available  adjust buff size if buffer bufpos c  read byte  update line column c int back slash cnt for  read all the backslashes if bufpos available  adjust buff size try if buffer bufpos c  read byte  update line column c found a non backslash char if c u back slash cnt if bufpos bufpos bufsize break backup back slash cnt return catch java io io exception e if back slash cnt backup back slash cnt return  update line column c back slash cnt  here we have seen an odd number of backslash s followed by a u try while c  read byte u column buffer bufpos c char hexval c hexval  read byte hexval  read byte hexval  read byte column catch java io io exception e throw new  error  invalid escape character at line line column column if back slash cnt return c else backup back slash cnt return else  update line column c return c 
deprecated see get end column public int get column return bufcolumn bufpos 
deprecated see get end line public int get line return bufline bufpos 
public int get end column return bufcolumn bufpos 
public int get end line return bufline bufpos 
public int get begin column return bufcolumn token begin 
public int get begin line return bufline token begin 
public void backup int amount in buf amount if bufpos amount bufpos bufsize 
public  java char stream java io  reader dstream int startline int startcolumn int buffersize input stream dstream line startline column startcolumn available bufsize buffersize buffer new char buffersize bufline new int buffersize bufcolumn new int buffersize next char buf new char 
public  java char stream java io  reader dstream int startline int startcolumn this dstream startline startcolumn 
public  java char stream java io  reader dstream this dstream 
public void  re init java io  reader dstream int startline int startcolumn int buffersize input stream dstream line startline column startcolumn if buffer null buffersize buffer length available bufsize buffersize buffer new char buffersize bufline new int buffersize bufcolumn new int buffersize next char buf new char prev char is lf prev char is cr false token begin in buf max next char ind next char ind bufpos 
public void  re init java io  reader dstream int startline int startcolumn  re init dstream startline startcolumn 
public void  re init java io  reader dstream  re init dstream 
public  java char stream java io  input stream dstream int startline int startcolumn int buffersize this new java io  input stream reader dstream startline startcolumn 
public  java char stream java io  input stream dstream int startline int startcolumn this dstream startline startcolumn 
public  java char stream java io  input stream dstream this dstream 
public void  re init java io  input stream dstream int startline int startcolumn int buffersize  re init new java io  input stream reader dstream startline startcolumn 
public void  re init java io  input stream dstream int startline int startcolumn  re init dstream startline startcolumn 
public void  re init java io  input stream dstream  re init dstream 
public  string  get image if bufpos token begin return new  string buffer token begin bufpos token begin else return new  string buffer token begin bufsize token begin new  string buffer bufpos 
public char  get suffix int len char ret new char len if bufpos len  system arraycopy buffer bufpos len ret len else  system arraycopy buffer bufsize len bufpos ret len bufpos  system arraycopy buffer ret len bufpos bufpos return ret 
public void  done next char buf null buffer null bufline null bufcolumn null 
 method to adjust line and column numbers for the start of a token br public void adjust begin line column int new line int new col int start token begin int len if bufpos token begin len bufpos token begin in buf else len bufsize token begin bufpos in buf int i j k int next col diff column diff while i len bufline j start bufsize bufline k start bufsize bufline j new line next col diff column diff bufcolumn k bufcolumn j bufcolumn j new col column diff column diff next col diff i if i len bufline j new line bufcolumn j new col column diff while i len if bufline j start bufsize bufline start bufsize bufline j new line else bufline j new line line bufline j column bufcolumn j 
 creates a checkbox list with the given list of objects  the elements of this array can either be  entry instances or other objects if the latter they will default to being unchecked public j check box list  object items set model items 
 creates a checkbox list with the given list of objects  the elements of this vector can either be  entry instances or other objects if the latter they will default to being unchecked public j check box list  vector items set model items 
 sets the model to the given list of objects  the elements of this array can either be  entry instances or other objects if the latter they will default to being unchecked public void set model  object items set model new  check box list model items init 
 sets the model to the given list of objects  the elements of this vector can either be  entry instances or other objects if the latter they will default to being unchecked public void set model  vector items set model new  check box list model items init 
public  object get checked values  list  object values new  array list  object  check box list model model  check box list model get model for int i i model items size i  entry entry model items get i if entry checked entry caption values add entry value  object ret val new  object values size return values to array ret val 
 override public void select all  check box list model model  check box list model get model for int i i model items size i  entry entry model items element at i if entry caption entry checked true model fire table rows updated model get row count 
public  entry get values  check box list model model  check box list model get model  entry ret val new  entry model items size model items copy into ret val return ret val 
public  object get selected value int row get selected row if row return null else return get model get value at row 
 override public  table cell renderer get cell renderer int row int column if column  entry entry  check box list model get model items get row if entry caption return dummy return super get cell renderer row column 
private void init dummy new  dummy renderer get selection model set selection mode  list selection model single selection set show grid false set auto resize mode j table auto resize last column  table column column get column model get column int check box width new j check box get preferred size width column set preferred width check box width column set min width check box width column set width check box width column set max width check box width column set resizable false column get column model get column column set cell renderer new  label renderer 
public  entry  object value this caption true this value value 
public  entry boolean checked  object value this checked checked this value value 
public boolean is checked return checked 
public  object get value return value 
 override public  component get table cell renderer component j table table  object value boolean is selected boolean has focus int row int column return super get table cell renderer component table null value is selected false has focus row column 
 label renderer plain font ui manager get font  tree font bold font plain font derive font  font bold 
 override public  component get table cell renderer component j table table  object value boolean is selected boolean has focus int row int column super get table cell renderer component table value is selected has focus row column  entry entry  check box list model get model items get row if entry caption set font bold font else set font plain font return this 
 check box list model  vector  items items new  vector j check box list  entry  items size for int i i  items size i items add create entry  items element at i 
 check box list model  object  items items new  vector j check box list  entry  items length for int i i  items length i items add create entry  items i 
private static j check box list  entry create entry  object obj if obj instanceof j check box list  entry return j check box list  entry obj else return new j check box list  entry false obj 
public int get row count return items size 
public int get column count return 
 override public  string get column name int col return null 
public  object get value at int row int col j check box list  entry entry items get row switch col case return  boolean value of entry checked case return entry value default throw new  internal error 
 override public  class get column class int col switch col case return  boolean class case return  string class default throw new  internal error 
 override public boolean is cell editable int row int col j check box list  entry entry items get row return col entry caption 
 override public void set value at  object value int row int col if col j check box list  entry entry items get row if entry caption entry checked value equals  boolean true fire table rows updated row row 
 returns the j edit version as a human readable string public static  string get version return  misc utilities build to version get build 
 returns the internal version  misc utilities compare strings can be used to compare different internal versions public static  string get build major minor pre x final bug fix return 
 the main method of the j edit application  this should never be invoked directly param args  the command line arguments public static void main  string args  check for  java or later  string java version  system get property java version if java version compare to  system err println  you are running  java version java version  system err println j edit requires  java or later  system exit startup done add false later on we need to know if certain code is called from the main thread main thread  thread current thread settings directory jedit  on mac different rules should apply if  operating system is mac os settings directory  library j edit  mac os users expect the app to keep running after all windows are closed background  operating system is mac os  parse command line boolean end opts false int level  log warning  string port file server boolean restore true boolean new view true boolean new plain view false boolean gui true open initial view boolean load plugins true boolean run startup scripts true boolean quit false boolean wait false boolean should relocate settings true  string user dir  system get property user dir script to run  string script file null for int i i args length i  string arg args i if arg null continue else if arg length args i null else if arg starts with end opts if arg equals end opts true else if arg equals usage version  system err println usage  system exit else if arg equals version version  system exit else if arg starts with log try level  integer parse int arg substring log length catch  number format exception nf  system err println  malformed option arg else if arg equals nosettings settings directory null else if arg starts with settings settings directory arg substring should relocate settings false else if arg starts with noserver port file null else if arg equals server port file server else if arg starts with server port file arg substring else if arg starts with background background true else if arg starts with nobackground background false else if arg equals gui gui true else if arg equals nogui gui false else if arg equals newview new view true else if arg equals newplainview new plain view true else if arg equals reuseview new plain view new view false else if arg equals restore restore true else if arg equals norestore restore false else if arg equals plugins load plugins true else if arg equals noplugins load plugins false else if arg equals startupscripts run startup scripts true else if arg equals nostartupscripts run startup scripts false else if arg starts with run script file arg substring else if arg equals wait wait true else if arg equals quit quit true else  system err println  unknown option arg usage  system exit args i null  we need these initializations very early on if settings directory null settings directory  misc utilities construct path  system get property user home settings directory settings directory  misc utilities resolve symlinks settings directory if settings directory null port file null port file  misc utilities construct path settings directory port file else port file null  log init true level  try connecting to another running j edit instance if port file null new  file port file exists try  buffered reader in new  buffered reader new  file reader port file  string check in read line if check equals b throw new  exception  wrong port file format int port  integer parse int in read line int key  integer parse int in read line  socket socket new  socket  inet address get by name port  data output stream out new  data output stream socket get output stream out write int key  string script if quit script socket close n j edit exit null true n else script make server script wait restore new view new plain view args script file out write utf script  log log  log debug j edit class  waiting for server block until its closed try socket get input stream read catch  exception e in close out close  system exit catch  exception e ok this one seems to confuse newbies endlessly so log it as notice not error  log log  log notice j edit class  an error occurred while connecting to the j edit server instance  log log  log notice j edit class  this probably means that j edit crashed and or exited abnormally  log log  log notice j edit class the last time it was run  log log  log notice j edit class  if you don t know what this means don t worry  log log  log notice j edit class e if quit if no server running and user runs jedit quit just exit  system exit don t show splash screen if there is a file named nosplash in the settings directory if new  file settings directory nosplash exists gui utilities show splash screen  mac settings migration code  should eventually be removed if  operating system is mac os should relocate settings settings directory null relocate settings  initialize settings directory  writer stream if settings directory null  file  settings directory new  file settings directory if  settings directory exists  settings directory mkdirs  file  macros directory new  file settings directory macros if  macros directory exists  macros directory mkdir  string log path  misc utilities construct path settings directory activity log backup settings file new  file log path try stream new  buffered writer new  file writer log path  write a warning message  string line sep  system get property line separator stream write  log file created on new  date stream write line sep stream write important stream write line sep stream write  because updating this file after every log message would kill stream write line sep stream write performance it will be incomplete unless you invoke the stream write line sep stream write  utilities  troubleshooting  update  activity  log on  disk command stream write line sep catch  exception e e print stack trace stream null else stream null  log set log writer stream  log log  log notice j edit class j edit version get version  log log  log message j edit class  settings directory is settings directory  get things rolling gui utilities advance splash progress init init misc gui utilities advance splash progress init system properties init system properties gui utilities advance splash progress init beanshell  bean shell init gui utilities advance splash progress loading site properties if j edit home null init site properties gui utilities advance splash progress loading user properties init user properties gui utilities advance splash progress init gui gui utilities init global buffer set new  buffer set buffer set manager new  buffer set manager  options simplified key handling j edit get boolean property newkeyhandling  initialize server if port file null gui utilities advance splash progress init server server new  edit server port file if server is ok server null else gui utilities advance splash progress if background background false  log log  log warning j edit class  you cannot specify both the background and noserver switches  do more stuff gui utilities advance splash progress init look and feel init plaf gui utilities advance splash progress init vfs  manager vfs manager init gui utilities advance splash progress init resources init resources  search and replace load if load plugins gui utilities advance splash progress init plugins init plugins else gui utilities advance splash progress  registers set saver new j edit register saver  registers set listener new j edit registers listener gui utilities advance splash progress init history model  history model set saver new j edit history model saver  history model load history gui utilities advance splash progress init buffer history  buffer history load gui utilities advance splash progress init killring  kill ring set instance new j edit kill ring  kill ring get instance load gui utilities advance splash progress init various properties properties changed gui utilities advance splash progress init modes  buffer sort sort buffers get boolean property sort buffers sort by name get boolean property sort by name reload modes gui utilities advance splash progress activate plugins  activate plugins that must be activated at startup for int i i jars size i jars element at i activate plugin if necessary  load macros and run startup scripts after plugins and settings are loaded gui utilities advance splash progress init macros  macros load macros  macros get macro action set init key bindings if run startup scripts j edit home null  string path  misc utilities construct path j edit home startup  file file new  file path if file exists run startup scripts file else gui utilities advance splash progress else gui utilities advance splash progress run startup scripts if run startup scripts settings directory null  string path  misc utilities construct path settings directory startup  file file new  file path if file exists gui utilities advance splash progress run startup scripts run startup scripts file else gui utilities advance splash progress file mkdirs else gui utilities advance splash progress  run script specified with run parameter if script file null gui utilities advance splash progress run script file script file  misc utilities construct path user dir script file try  bean shell get name space set variable args args catch  util eval error e  log log  log error j edit class e  bean shell run script null script file null false else gui utilities advance splash progress gui utilities advance splash progress  create dynamic actions for switching to saved layouts  the list of saved layouts is retrieved from the docking framework which can be provided by a plugin so this must be called only after the plugins are loaded  docking layout manager init  open files create the view and hide the splash screen  syntax utilities property manager j edit property manager finish startup gui restore new plain view user dir args 
 returns the properties object which contains all known j edit properties  note that as of j edit pre this returns a new collection not the existing properties instance since j edit pre public static  properties get properties return prop mgr get properties 
 fetches a property returning null if it s not defined param name  the property public static  string get property  string name return prop mgr get property name 
 fetches a property returning the default value if it s not defined param name  the property param def  the default value public static  string get property  string name  string def  string value prop mgr get property name if value null return def else return value 
 returns the property with the specified name p  the elements of the code args code array are substituted into the value of the property in place of strings of the form code i n i code where code i n i code is an index in the array p  you can find out more about this feature by reading the documentation for the code format code method of the code java text  message format code class param name  the property param args  the positional parameters public static  string get property  string name  object args if name null return null if args null return get property name else  string value get property name if value null return null else return  message format format value args 
 returns the value of a boolean property param name  the property public static boolean get boolean property  string name return get boolean property name false 
 returns the value of a boolean property param name  the property param def  the default value public static boolean get boolean property  string name boolean def  string value get property name return  standard utilities get boolean value def 
 returns the value of an integer property param name  the property public static int get integer property  string name return get integer property name 
 returns the value of an integer property param name  the property param def  the default value since j edit pre public static int get integer property  string name int def  string value get property name if value null return def else try return  integer parse int value trim catch  number format exception nf return def 
public static double get double property  string name double def  string value get property name if value null return def else try return  double parse double value trim catch  number format exception nf return def 
 returns the value of a font property  the family is stored in the code i name i code property the font size is stored in the code i name i size code property and the font style is stored in code i name i style code  for example if code i name i code is code view gutter font code the properties will be named code view gutter font code code view gutter fontsize code and code view gutter fontstyle code param name  the property since j edit pre public static  font get font property  string name return get font property name null 
 returns the value of a font property  the family is stored in the code i name i code property the font size is stored in the code i name i size code property and the font style is stored in code i name i style code  for example if code i name i code is code view gutter font code the properties will be named code view gutter font code code view gutter fontsize code and code view gutter fontstyle code param name  the property param def  the default value since j edit pre public static  font get font property  string name  font def  string family get property name  string size string get property name size  string style string get property name style if family null size string null style string null return def else int size style try size  integer parse int size string catch  number format exception nf return def try style  integer parse int style string catch  number format exception nf return def return new  font family style size 
 returns the value of a color property param name  the property name since j edit pre public static  color get color property  string name return get color property name  color black 
 returns the value of a color property param name  the property name param def  the default value since j edit pre public static  color get color property  string name  color def  string value get property name if value null return def else return  syntax utilities parse color value def 
 sets the value of a color property param name  the property name param value  the value since j edit pre public static void set color property  string name  color value set property name  syntax utilities get color hex string value 
 sets a property to a new value param name  the property param value  the new value public static void set property  string name  string value prop mgr set property name value 
 sets a property to a new value  properties set using this method are not saved to the user properties list param name  the property param value  the new value since j edit final public static void set temporary property  string name  string value prop mgr set temporary property name value 
 sets a boolean property param name  the property param value  the value public static void set boolean property  string name boolean value set property name value true false 
 sets the value of an integer property param name  the property param value  the value since j edit pre public static void set integer property  string name int value set property name  string value of value 
public static void set double property  string name double value set property name  string value of value 
 sets the value of a font property  the family is stored in the code i name i code property the font size is stored in the code i name i size code property and the font style is stored in code i name i style code  for example if code i name i code is code view gutter font code the properties will be named code view gutter font code code view gutter fontsize code and code view gutter fontstyle code param name  the property param value  the value since j edit pre public static void set font property  string name  font value set property name value get family set integer property name size value get size set integer property name style value get style 
 unsets clears a property param name  the property public static void unset property  string name prop mgr unset property name 
 resets a property to its default value param name  the property since j edit pre public static void reset property  string name prop mgr reset property name 
 reloads various settings from the properties public static void properties changed init key bindings  autosave set interval get integer property autosave save caret get boolean property save caret ui defaults defaults ui manager get defaults give all text areas the same font  font font get font property view font defaults put  text field font font defaults put  text area font font defaults put  text pane font font  enable  disable tooltips  tool tip manager shared instance set enabled j edit get boolean property show tooltips init proxy we do this here instead of adding buffers to the bus  buffer buffer buffers first while buffer null buffer reset cached properties buffer properties changed buffer buffer next  history model set max get integer property history  kill ring get instance properties changed get integer property history  edit bus send new  properties changed null 
 returns a list of plugin ja rs pathnames that are not currently loaded by examining the user and system plugin directories since j edit pre public static  string get not loaded plugin ja rs  list  string return value new  array list  string if j edit home null  string system plugin dir  misc utilities construct path j edit home jars  string list new  file system plugin dir list if list null get not loaded plugin ja rs return value system plugin dir list if settings directory null  string user plugin dir  misc utilities construct path settings directory jars  string list new  file user plugin dir list if list null get not loaded plugin ja rs return value user plugin dir list  string  return value new  string return value size return value to array  return value return  return value 
 returns the plugin with the specified class name  only works for plugins that were loaded public static  edit plugin get plugin  string name return get plugin name false 
 returns the plugin with the specified class name  if code load if necessary code is true the plugin will be searched for loaded and activated in case it has not yet been loaded param name the classname of the main  plugin class param load if necessary loads plugin dependencies if it is not loaded yet since j edit pre public static  edit plugin get plugin  string name boolean load if necessary  edit plugin plugins get plugins  edit plugin plugin null for int i i plugins length i if plugins i get class name equals name plugin plugins i if load if necessary if plugin instanceof  edit plugin  deferred plugin get plugin jar activate plugin plugin plugin get plugin jar get plugin break if load if necessary return plugin  string jar path  plugin jar find plugin name  plugin jar pjar  plugin jar load jar path true return pjar get plugin 
 returns an array of installed plugins public static  edit plugin get plugins  list  edit plugin plugin list new  array list  edit plugin for int i i jars size i  edit plugin plugin jars element at i get plugin if plugin null plugin list add plugin  edit plugin array new  edit plugin plugin list size plugin list to array array return array 
 returns an array of installed plugins since j edit pre public static  plugin jar get plugin ja rs  plugin jar array new  plugin jar jars size jars copy into array return array 
 returns the jar with the specified path name param path  the path name since j edit pre public static  plugin jar get plugin jar  string path for int i i jars size i  plugin jar jar jars element at i if jar get path equals path return jar return null 
 loads the plugin jar with the specified path  some notes about this method ul li  calling this at a time other than j edit startup can have unpredictable results if the plugin has not been updated for the j edit plugin api li  you must make sure yourself the plugin is not already loaded li  after loading you just make sure all the plugin s dependencies are satisified before activating the plugin using the link  plugin jar check dependencies method ul param path  the jar file path since j edit pre public static void add plugin jar  string path  plugin jar jar new  plugin jar new  file path jars add element jar jar init j edit unset property plugin blacklist  misc utilities get file name path  edit bus send new  plugin update jar  plugin update loaded false if is main thread  edit bus send new  dynamic menu changed plugins init key bindings 
 loads all plugins in a directory param directory  the directory since j edit pre private static void add plugin ja rs from directory  string directory  log log  log notice j edit class  loading plugins from directory  file file new  file directory if file exists file is directory return  string plugins file list if plugins null return for int i i plugins length i  string plugin plugins i if plugin to lower case ends with jar continue  string path  misc utilities construct path directory plugin if j edit get boolean property plugin blacklist plugin continue remove this when plugin api is deprecated if plugin equals  edit buddy jar plugin equals  plugin manager jar plugin equals  firewall jar plugin equals  tidy jar plugin equals  drag and drop jar plugin error path plugin error obsolete null continue add plugin jar path 
 unloads the given plugin jar with the specified path  note that calling this at a time other than j edit shutdown can have unpredictable results if the plugin has not been updated for the j edit plugin api param jar  the code  plugin jar code instance param exit  set to true if j edit is exiting enables some shortcuts so the editor can close faster since j edit pre public static void remove plugin jar  plugin jar jar boolean exit if exit jar uninit true else jar uninit false jars remove element jar init key bindings  edit bus send new  plugin update jar  plugin update unloaded exit if is main thread exit  edit bus send new  dynamic menu changed plugins 
 returns the action context used to store editor actions since j edit pre public static  action context get action context return action context 
 adds a new action set to j edit s list of  action sets viewable from the shortcuts option pane  by default each plugin has one  action set but some plugins may create dynamic action sets such as  project viewer and  console  these plugins must call remove action set when the plugin is unloaded since j edit pre see remove action set  action set public static void add action set  action set action set action context add action set action set 
 removes an action set from j edit s list  plugins that add a dynamic action set must call this method at plugin unload time since j edit pre public static void remove action set  action set action set action context remove action set action set 
 returns the set of commands built into j edit since j edit pre public static  action set get built in action set return built in action set 
 returns all registered action sets return the  action set s since j edit pre public static  action set get action sets return action context get action sets 
 returns the specified action param name  the action name public static  edit action get action  string name return action context get action name 
 returns the action set that contains the specified action param action  the action since j edit pre public static  action set get action set for action  string action return action context get action set for action action 
deprecated  use the form that takes a  string instead  deprecated public static  action set get action set for action  edit action action return action context get action set for action action get name 
deprecated  call get action names instead  deprecated public static  edit action get actions  string names action context get action names  edit action actions new  edit action names length for int i i actions length i actions i action context get action names i if actions i null  log log  log error j edit class wtf names i return actions 
 returns all registered action names public static  string get action names return action context get action names 
 reloads all edit modes since j edit pre public static void reload modes  try to guess the eventual size to avoid unnecessary copying  mode provider instance remove all  load the global catalog if j edit home null load mode catalog modes catalog true else load mode catalog  misc utilities construct path j edit home modes catalog false  load user catalog if settings directory null  file user mode dir new  file  misc utilities construct path settings directory modes if user mode dir exists user mode dir mkdirs  file user catalog new  file  misc utilities construct path settings directory modes catalog if user catalog exists create dummy catalog  file writer out null try out new  file writer user catalog out write j edit get property default catalog catch io exception io  log log  log error j edit class io finally io utilities close quietly out load mode catalog user catalog get path false  buffer buffer buffers first while buffer null  this reloads the token marker and sends a message which causes edit panes to repaint their text areas buffer set mode buffer buffer next 
 returns the edit mode with the specified name param name  the edit mode public static  mode get mode  string name return  mode provider instance get mode name 
 returns an array of installed edit modes public static  mode get modes return  mode provider instance get modes 
 opens the file names specified in the argument array  this handles line and marker arguments just like the command line parser param parent  the parent directory param args  the file names to open since j edit pre public static  buffer open files  view view  string parent  string args  buffer ret val null  buffer last buffer null for int i i args length i  string arg args i if arg null continue else if arg starts with line arg starts with marker if last buffer null goto marker view last buffer arg continue last buffer open file  view null parent arg false null if ret val null last buffer null ret val last buffer if view null ret val null view set buffer ret val true return ret val 
 opens a file  note that as of j edit pre this may return null if the buffer could not be opened param view  the view to open the file in param path  the file path return the buffer or null if j edit was unable to load it since j edit pre public static  buffer open file  view view  string path return open file view null path false new  hashtable 
deprecated  the open file forms with the read only parameter should not be used  the read only prameter is no longer supported  deprecated public static  buffer open file  view view  string parent  string path boolean read only boolean new file return open file view parent path new file new  hashtable 
deprecated  the open file forms with the read only parameter should not be used  the read only prameter is no longer supported  deprecated public static  buffer open file  view view  string parent  string path boolean read only boolean new file  hashtable props return open file view parent path new file props 
 opens a file  this may return null if the buffer could not be opened for some reason param view  the view to open the file in  if it is null the file will be opened and added to the buffer set of the current edit pane but not selected param parent  the parent directory of the file param path  the path name of the file param new file  true if the file should not be loaded from disk be prompted if it should be reloaded param props  buffer local properties to set in the buffer return the buffer or null if j edit was unable to load it since j edit pre public static  buffer open file  view view  string parent  string path boolean new file  hashtable props return open file view null null view get edit pane parent path new file props 
 opens a file  note that as of j edit pre this may return null if the buffer could not be opened param edit pane the  edit pane to open the file in param path  the file path return the buffer or null if j edit was unable to load it since j edit pre public static  buffer open file  edit pane edit pane  string path return open file edit pane null path false new  hashtable 
 opens a file  this may return null if the buffer could not be opened for some reason param edit pane the  edit pane to open the file in param parent  the parent directory of the file param path  the path name of the file param new file  true if the file should not be loaded from disk be prompted if it should be reloaded param props  buffer local properties to set in the buffer return the buffer or null if j edit was unable to load it since j edit pre public static  buffer open file  edit pane edit pane  string parent  string path boolean new file  hashtable props  perspective manager set perspective dirty true if edit pane null parent null edit pane get buffer null parent edit pane get buffer get directory try url u new url path if u get protocol equals file path url decoder decode u get path catch  malformed url exception mue path  misc utilities construct path parent path if props null props new  hashtable compose buffer props from history props path  buffer new buffer synchronized edit bus ordering lock  view view edit pane null null edit pane get view synchronized buffer list lock  buffer buffer get buffer path if buffer null if edit pane null edit pane set buffer buffer true return buffer new buffer new  buffer path new file false props if new buffer load view false return null add buffer to list new buffer if edit pane null buffer set manager add buffer edit pane get buffer set new buffer else buffer set manager add buffer j edit get active view new buffer  edit bus send new  buffer update new buffer view  buffer update created if edit pane null edit pane set buffer new buffer true return new buffer 
 opens a temporary buffer a temporary buffer is like a normal buffer except that an event is not fired the the buffer is not added to the buffers list param view  the view to open the file in param parent  the parent directory of the file param path  the path name of the file param new file  true if the file should not be loaded from disk return the buffer or null if j edit was unable to load it since j edit pre public static  buffer open temporary  view view  string parent  string path boolean new file return open temporary view parent path new file null 
 opens a temporary buffer a temporary buffer is like a normal buffer except that an event is not fired the the buffer is not added to the buffers list param view  the view to open the file in param parent  the parent directory of the file param path  the path name of the file param new file  true if the file should not be loaded from disk param props  buffer local properties to set in the buffer return the buffer or null if j edit was unable to load it since j edit pre public static  buffer open temporary  view view  string parent  string path boolean new file  hashtable props if view null parent null parent view get buffer get directory if  misc utilities is url path if  misc utilities get protocol of url path equals file path path substring path  misc utilities construct path parent path if props null props new  hashtable compose buffer props from history props path synchronized buffer list lock  buffer buffer get buffer path if buffer null return buffer buffer new  buffer path new file true props buffer set boolean property  buffer encoding autodetect true if buffer load view false return null else return buffer 
 adds a temporary buffer to the buffer list  this must be done before allowing the user to interact with the buffer in any way param buffer  the buffer public static void commit temporary  buffer buffer if buffer is temporary return  perspective manager set perspective dirty true add buffer to list buffer buffer commit temporary send full range of events to avoid breaking plugins  edit bus send new  buffer update buffer null  buffer update created  edit bus send new  buffer update buffer null  buffer update load started  edit bus send new  buffer update buffer null  buffer update loaded 
 creates a new untitled file param view  the view to create the file in return the new buffer public static  buffer new file  view view return new file view null null view get edit pane 
 creates a new untitled file param view  the view to create the file in param dir  the directory to create the file in return the new buffer since j edit pre public static  buffer new file  view view  string dir  edit pane edit pane null if view null edit pane view get edit pane else  view v get active view if v null edit pane v get edit pane return new file edit pane dir 
 creates a new untitled file param edit pane  the edit pane to create the file in return the new buffer since j edit pre public static  buffer new file  edit pane edit pane  string path if edit pane null edit pane get buffer null path edit pane get buffer get directory vfs vfs vfs manager get vfs for path path don t want  new  file to create a read only buffer if current file is on sql vfs or something if vfs get capabilities vfs write cap path  system get property user home else path null return new file edit pane path 
 creates a new untitled file param edit pane  the edit pane to create the file in param dir  the directory to create the file in return the new buffer since j edit pre public static  buffer new file  edit pane edit pane  string dir if edit pane null  buffer set buffer set edit pane get buffer set  buffer buffers buffer set get all buffers for  buffer buf buffers if buf is untitled buf is dirty if  misc utilities get parent of path buf get path equals dir  find the highest  untitled n file int untitled count get next untitled buffer id  buffer new buffer open file edit pane dir  untitled untitled count true null j edit close buffer edit pane buf return new buffer if never mark untitled buffers dirty is selected we might have contents in non dirty untitled buffers  we must clear those contents if user requested new file int l buf get length if l buf remove l edit pane set buffer buf return buf  find the highest  untitled n file int untitled count get next untitled buffer id return open file edit pane dir  untitled untitled count true null 
 closes a buffer  if there are unsaved changes the user is prompted if they should be saved first param view  the view param buffer  the buffer return  true if the buffer was really closed false otherwise public static boolean close buffer  view view  buffer buffer  wait for pending i o requests if buffer is performing io vfs manager wait for requests if vfs manager error occurred return false if buffer is dirty  object args buffer get name int result gui utilities confirm view notsaved args j option pane yes no cancel option j option pane warning message if result j option pane yes option if buffer save view null true return false vfs manager wait for requests if buffer get boolean property  buffer io request error occurred return false else if result j option pane no option return false  close buffer view buffer return true 
 close a buffer  the buffer is first removed from the  edit pane s buffer set  if the buffer is not in any buffer set after that it is closed param edit pane the edit pane it cannot be null param buffer the buffer it cannot be null since j edit pre public static void close buffer  edit pane edit pane  buffer buffer int buffer sets count buffer set manager count buffer sets buffer if buffer sets count close buffer edit pane get view buffer else buffer set manager remove buffer edit pane buffer 
 closes the buffer even if it has unsaved changes param view  the view may be null param buffer  the buffer exception  null pointer exception if the buffer is null since j edit pre public static void  close buffer  view view  buffer buffer if buffer is closed can happen if the user presses c w twice real quick and the buffer has unsaved changes return  perspective manager set perspective dirty true if buffer is new file if view null view get edit pane save caret info  integer  caret  integer buffer get property  buffer caret int caret  caret null  caret int value  buffer history set entry buffer get path caret  selection buffer get property  buffer selection buffer get string property j edit buffer encoding buffer get mode get name  string path buffer get symlink path if vfs manager get vfs for path path get capabilities vfs case insensitive cap path path to lower case  edit bus send new  buffer update buffer view  buffer update closing buffer hash remove path remove buffer from list buffer buffer close  display manager buffer closed buffer buffer set manager remove buffer buffer  edit bus send new  buffer update buffer view  buffer update closed if j edit get boolean property persistent markers buffer update markers file view 
 closes all open buffers param view  the view return true if all buffers were closed false otherwise public static boolean close all buffers  view view return close all buffers view false 
 closes all open buffers param view  the view param is exiting  this must be false unless this method is being called by the exit method return true if all buffers were closed false otherwise public static boolean close all buffers  view view boolean is exiting if view null view get edit pane save caret info boolean dirty false boolean save recent is exiting j edit get boolean property restore  buffer buffer buffers first while buffer null if buffer is dirty dirty true break buffer buffer next if dirty boolean ok new  close dialog view is ok if ok return false  wait for pending i o requests vfs manager wait for requests if vfs manager error occurred return false close remaining buffers the close dialog only deals with dirty ones buffer buffers first zero it here so that  buffer tabs doesn t have any problems buffers first buffers last null buffer hash clear buffer count while buffer null if buffer is new file save recent  integer  caret  integer buffer get property  buffer caret int caret  caret null  caret int value  buffer history set entry buffer get path caret  selection buffer get property  buffer selection buffer get string property j edit buffer encoding buffer get mode get name buffer close  display manager buffer closed buffer if is exiting buffer set manager remove buffer buffer  edit bus send new  buffer update buffer view  buffer update closed if j edit get boolean property persistent markers buffer update markers file view buffer buffer next  perspective manager set perspective dirty true return true 
 saves all open buffers param view  the view since j edit pre public static void save all buffers  view view save all buffers view j edit get boolean property confirm save all 
 saves all open buffers param view  the view param confirm  if true a confirmation dialog will be shown first since j edit pre public static void save all buffers  view view boolean confirm if confirm int result gui utilities confirm view saveall null j option pane yes no option j option pane question message if result j option pane yes option return  buffer current view get buffer  buffer buffer buffers first while buffer null if buffer is dirty if buffer is new file view set buffer buffer true buffer save view null true true buffer buffer next view set buffer current true 
 reloads all open buffers param view  the view param confirm  if true a confirmation dialog will be shown first if any buffers are dirty since j edit pre public static void reload all buffers  view view boolean confirm boolean has dirty false  buffer buffers j edit get buffers for int i i buffers length has dirty i has dirty buffers i is untitled buffers i is dirty if confirm has dirty int result gui utilities confirm view reload all null j option pane yes no option j option pane question message if result j option pane yes option return save caret info  buffer load will load it visit new  save caret info visitor for int i i buffers length i  buffer buffer buffers i if buffer is untitled continue buffer load view true 
 returns the buffer with the specified path name  the path name must be an absolute canonical path param path  the path name return the searched buffer or null if it is not already open see  misc utilities construct path  string  string see  misc utilities resolve symlinks  string see get buffer  string since j edit pre public static  buffer  get buffer  string path paths on case insensitive filesystems are stored as lower case in the hash if vfs manager get vfs for path path get capabilities vfs case insensitive cap path path to lower case synchronized buffer list lock return buffer hash get path 
 returns the buffer with the specified path name  the path name must be an absolute path  this method automatically resolves symbolic links  if performance is critical cache the canonical path and call link  get buffer  string instead param path  the path name return the searched buffer or null if it is not already open see  misc utilities construct path  string  string see  misc utilities resolve symlinks  string public static  buffer get buffer  string path return  get buffer  misc utilities resolve symlinks path 
 returns an array of open buffers return an array of all open buffers public static  buffer get buffers synchronized buffer list lock  buffer buffers new  buffer buffer count  buffer buffer buffers first for int i i buffer count i buffers i buffer buffer buffer next return buffers 
 returns the number of open buffers public static int get buffer count return buffer count 
 returns the first buffer public static  buffer get first buffer return buffers first 
 returns the last buffer return the last buffer public static  buffer get last buffer return buffers last 
 moves a buffer from a old position to a new position in the  buffer set used in an  edit pane param edit pane  the  edit pane in which a buffer is moved param old position  the position before the move param new position  the position after the move public static void move buffer  edit pane edit pane int old position int new position buffer set manager move buffer edit pane old position new position 
 returns the global buffer set which can be shared by several views editpanes return the global buffer set since j edit pre public static  buffer set get global buffer set return global buffer set 
 returns the buffer set manager return the buffer set manager since j edit pre public static  buffer set manager get buffer set manager return buffer set manager 
return the property manager since j edit pre public static j edit property manager get property manager return property manager 
 checks each buffer s status on disk and shows the dialog box informing the user that buffers changed on disk if necessary param view  the view since j edit pre public static void check buffer status  view view check buffer status view false 
 checks buffer status on disk and shows the dialog box informing the user that buffers changed on disk if necessary param view  the view param current buffer indicates whether to check only the current buffer since j edit pre public static void check buffer status  view view boolean current buffer still need to call the status check even if the option is off so that the write protection is updated if it changes on disk auto reload changed buffers boolean auto reload get boolean property auto reload the problem with this is that if we have two edit panes looking at the same buffer and the file is reloaded both will jump to the same location visit new  save caret info visitor  buffer buffer buffer buffers first int states new int buffer count int i boolean notify file changed false while buffer null if current buffer buffer view get buffer buffer buffer next i continue states i buffer check file status view switch states i case  buffer file changed if buffer get auto reload if buffer is dirty notify file changed true else buffer load view true else no automatic reload even if general setting is true auto reload false don t notify user if do nothing was chosen if buffer get auto reload dialog notify file changed true break case  buffer file deleted notify file changed true break buffer buffer next i if notify file changed new  files changed dialog view states auto reload 
 returns the current input handler key binding to action mapping see org gjt sp jedit gui  input handler public static  input handler get input handler return input handler 
 creates a new view param view  an existing view since j edit pre public static  view new view  view view return new view view null false 
 creates a new view of a buffer param view  an existing view param buffer  the buffer public static  view new view  view view  buffer buffer return new view view buffer false 
 creates a new view of a buffer param view  an existing view param buffer  the buffer param plain view  if true the view will not have dockable windows or tool bars since pre public static  view new view  view view  buffer buffer boolean plain view  view  view config config if view null plain view view is plain view config view get view config config x config y else config new  view  view config plain view return new view view buffer config 
 creates a new view param view  an existing view param buffer a buffer to display or null param config  encapsulates the view geometry split configuration and if the view is a plain view since j edit pre public static  view new view  view view  buffer buffer  view  view config config  mark the perspective as dirty unless the new view is created during j edit startup by the loading of the perspective if is startup done  perspective manager set perspective dirty true try if view null view show wait cursor view get edit pane save caret info  view new view new  view buffer config add view to list new view new view pack new view adjust view config  edit bus send new  view update new view  view update created new view set visible true if config plain view int index synchronized startup done index startup done size startup done add false  swing utilities invoke later new  docking layout setter new view config index show tip of the day if new view views first new view get text area request focus  don t show the welcome message if j edit was started with the nosettings switch if settings directory null get boolean property first time new  help viewer welcome html else if j edit get boolean property tip show new  tip of the day new view set boolean property first time false else gui utilities request focus new view new view get text area return new view finally if view null view hide wait cursor 
 closes a view j edit will exit if this was the last open view public static void close view  view view close view view true 
 returns an array of all open views public static  view get views  view views new  view view count  view view views first for int i i view count i views i view view view next return views 
 returns the number of open views public static int get view count return view count 
 returns the first view public static  view get first view return views first 
 returns the last view public static  view get last view return views last 
 returns the currently focused view since j edit pre public static  view get active view if active view null eg user just closed a view and didn t focus another return views first else return active view 
public static void relocate settings  string old settings path  misc utilities construct path  system get property user home jedit  file old settings dir new  file old settings path  file new settings dir new  file settings directory if old settings dir exists new settings dir exists  log log  log notice j edit class  old settings directory found home jedit  moving to new location new settings dir try old settings dir rename to new settings dir catch  security exception se  log log  log error j edit class se 
 whether j edit startup is over since j edit pre public static boolean is startup done return startup done contains false 
 returns true if the currently running thread is the main thread since j edit pre public static boolean is main thread return  thread current thread main thread 
 returns true if j edit was started with the code background code command line switch since j edit pre public static boolean is background mode enabled return background 
 performs garbage collection and displays a dialog box showing memory status param view  the view since j edit pre public static void show memory dialog  view view  runtime rt  runtime get runtime long used before rt total memory rt free memory  system gc long free rt free memory long total rt total memory long used total free int total kb int total int used kb int used j progress bar progress new j progress bar total kb progress set value used kb progress set string painted true progress set string j edit get property memory status use new  object used kb total kb  object message new  object message get property memory status gc new  object used before used message  box create vertical strut message progress message  box create vertical strut j option pane show message dialog view message j edit get property memory status title j option pane information message 
 returns the j edit install directory public static  string get j edit home return j edit home 
 returns the path of the directory where user specific settings are stored  this will be code null code if j edit was started with the code nosettings code command line switch do not blindly use this method without checking for a code null code return value first public static  string get settings directory return settings directory 
 returns the directory where plugin cache files are stored since j edit pre public static  string get jar cache directory return jar cache directory 
 backs up the specified file in the settings directory  you should call this on any settings files your plugin writes param file  the file since j edit pre public static void backup settings file  file file if settings directory null file exists return  string backup dir  misc utilities construct path settings directory settings backup  file dir new  file backup dir if dir exists dir mkdirs sweet save backup will create backup dir if it doesn t exist  misc utilities save backup file null backup dir 
 saves all user preferences to disk public static void save settings if settings directory null return  abbrevs save  favorites vfs save favorites  history model save history  registers save registers  search and replace save  buffer history save  kill ring get instance save  file file new  file  misc utilities construct path settings directory properties save  file file new  file  misc utilities construct path settings directory properties if file exists file last modified props mod time  log log  log warning j edit class file changed on disk will not save user properties else backup settings file file  output stream out null try out new  file output stream file prop mgr save user props out catch io exception io  log log  log error j edit class io finally io utilities close quietly out file delete if file rename to file  log log  log error j edit class  failed to rename file to the user properties file file props mod time file last modified 
 create a standalone  text area return a textarea since pre deprecated use new j edit embedded text area instead  deprecated public static  text area create text area return new j edit embedded text area 
 exits cleanly from j edit prompting the user if any unsaved files should be saved first param view  the view from which this exit was called param really exit  if background mode is enabled and this parameter is true then j edit will close all open views instead of exiting entirely public static void exit  view view boolean really exit  close dialog view close call need a view if view null view active view  wait for pending i o requests vfs manager wait for requests  create a new  editor exit requested  editor exit requested eer new  editor exit requested view  send  editor exit requested  edit bus send eer  check if the  exit request has been cancelled if so do not proceed anymore in the exiting if eer has been exit cancelled  log log  log message j edit class  exit has been cancelled return  even if really exit is false we still exit properly if background mode is off really exit background  perspective manager save perspective false try  perspective manager set perspective enabled false  close all buffers if close all buffers view really exit return finally  perspective manager set perspective enabled true  if we are running in background mode and really exit was not specified then return here if really exit in this case we can t directly call view close we have to call close view for all open views view views first while view null close view view false view view next  save settings in case user kills the backgrounded j edit process save settings else  send  editor exiting  edit bus send new  editor exiting null  save view properties here if view null view close remove view from list view  stop autosave timer  autosave stop  stop server if server null server stop server  stop all plugins  plugin jar plugins get plugin ja rs for int i i plugins length i remove plugin jar plugins i true  save settings save settings  close activity log stream  log close stream  byebye  system exit 
 returns the edit server instance  you can use this to find out the port number j edit is listening on since j edit pre public static  edit server get edit server return server 
 visit the views editpanes and textareas param visitor the visitor since j edit pre public static void visit j edit visitor visitor  view view j edit get first view while view null visitor visit view view visit visitor view view get next 
 returns the status prompt for the given register action  only intended to be called from code actions xml code since j edit pre public static  string get register status prompt  string action  string register name string  registers get register name string return j edit get property view status action new  string register name string null j edit get property view status no registers register name string 
 if buffer sorting is enabled this repositions the buffer static void update position  string old path  buffer buffer if vfs manager get vfs for path old path get capabilities vfs case insensitive cap old path old path to lower case buffer hash remove old path  string path buffer get symlink path if vfs manager get vfs for path path get capabilities vfs case insensitive cap path path to lower case buffer hash put path buffer if sort buffers remove buffer from list buffer add buffer to list buffer 
 loads an xml defined edit mode from the specified reader param mode  the edit mode package private static void load mode  mode mode final  string file name  string mode get property file x mode handler xmh new x mode handler mode get name  override public void error  string what  object subst  string msg  object line unknown if subst null msg j edit get property xmode error what else msg j edit get property xmode error what new  string subst to string if subst instanceof  throwable  log log  log error this subst if subst instanceof sax parse exception line sax parse exception subst get line number  object args file name line null msg gui utilities error null xmode error args  override public  token marker get token marker  string mode name  mode mode get mode mode name if mode null return null else return mode get token marker  mode provider instance load mode mode xmh 
static void add plugin props  properties map prop mgr add plugin props map 
static void remove plugin props  properties map prop mgr remove plugin props map 
param message prop a property of a message to print param args a list of arguments whch correspond to and in the string to print static void plugin error  string path  string message prop  object args synchronized plugin error lock if plugin errors null plugin errors new  vector  error list dialog  error entry  error list dialog  error entry new entry new  error list dialog  error entry path message prop args for int i i plugin errors size i if plugin errors get i equals new entry return plugin errors add element new entry if is startup done  swing utilities invoke later new  runnable public void run show plugin error dialog 
static void set active view  view view j edit active view view 
 returns the internal active view which might be null since pre public static  view get active view internal return active view 
private j edit 
private static void usage  system out println  usage jedit options files  system out println file marker marker  positions caret at marker marker  system out println file line line  positions caret at line number line  system out println file line line column  positions caret at line number line and column number column  system out println  end of options  system out println background  run in background mode  system out println nobackground  disable background mode default  system out println gui  only if running in background mode open initial view default  system out println nogui  only if running in background mode don t open initial view  system out println log level  log messages with level equal to or higher than this to  system out println standard error level must be between and  default is  system out println newplainview  client instance opens a new plain view  system out println newview  client instance opens a new view default  system out println plugins  load plugins default  system out println noplugins  don t load any plugins  system out println restore  restore previously open files default  system out println norestore  don t restore previously open files  system out println reuseview  client instance reuses existing view  system out println quit  quit a running instance  system out println run script  run the specified  bean shell script  system out println server  read write server info from to home jedit server default  system out println server name  read write server info from to home jedit name  system out println noserver  don t start edit server  system out println settings path  load user specific settings from path  system out println nosettings  don t load user specific settings  system out println startupscripts  run startup scripts default  system out println nostartupscripts  don t run startup scripts  system out println usage  print this message and exit  system out println version  print j edit version and exit  system out println wait  wait until the user closes the specified buffer in the server  system out println instance  does nothing if passed to the initial j edit instance  system out println  system out println  report bugs to http sourceforge net tracker group id atid 
private static void version  system out println j edit get version 
 creates a  bean shell script that can be sent to a running edit server private static  string make server script boolean wait boolean restore boolean new view boolean new plain view  string args  string script file  string builder script new  string builder  string user dir  system get property user dir script append parent script append  standard utilities chars to escapes user dir script append n script append args new  string script append args length script append n for int i i args length i script append args script append i script append if args i null script append null else script append script append  standard utilities chars to escapes args i script append script append n script append view j edit get last view n script append buffer  edit server handle client script append restore append append new view append append new plain view script append parent args n script append if buffer null append wait append n script append tbuffer set wait socket socket n script append tdo not close socket true n script append n script append if view j edit get last view append wait append n script append tj edit get last view set wait socket socket n script append tdo not close socket true n script append n script append if do not close socket void n script append tsocket close n if script file null script file  misc utilities construct path user dir script file script append  bean shell run script view append  standard utilities chars to escapes script file append null this namespace n return script to string 
 initialise various objects register protocol handlers private static void init misc  mode provider instance new  mode provider  override protected void error  string file name  throwable e  log log  log error this e if e instanceof sax parse exception  string message e get message int line sax parse exception e get line number int col sax parse exception e get column number  object args file name line col message gui utilities error null xmode error args jars new  vector  plugin jar  fold handler fold handler provider new  service manager  service fold handler provider action context new  action context  override public void invoke action  event object evt  edit action action  view view gui utilities get view  component evt get source boolean action bar visible if view get action bar null view get action bar is showing action bar visible false else action bar visible view get action bar is visible view get input handler invoke action action if action bar visible xxx action bar might not be temp  action bar action bar view get action bar if action bar null view remove tool bar action bar buffer hash new  hash map  string  buffer input handler new  default input handler null  add our protocols to java net url s list  system get properties put java protocol handler pkgs org gjt sp jedit proto  system get property java protocol handler pkgs  set the  user  agent string used by the java net http handler  string user agent j edit get version  java  system get property java version  system get property java vendor  system get property os arch  system get properties put http agent user agent  determine installation directory  if the jedit home property is set use that  then look for jedit jar in the classpath  if that fails assume this is the web start version j edit home  system get property jedit home if j edit home null  string classpath  system get property java class path int index classpath to lower case index of jedit jar int start classpath last index of  file path separator index if started with java jar jedit jar if start index j edit home  system get property user dir else if index start j edit home classpath substring start index else check if web start if j edit class get resource modes catalog null modes bundled in hence web start j edit home null else use user dir as last resort j edit home  system get property user dir  log log  log warning j edit class jedit jar not in class path  log log  log warning j edit class  assuming j edit is installed in j edit home  log log  log warning j edit class  override with jedit home system property j edit home  misc utilities resolve symlinks j edit home  log log  log message j edit class j edit home directory is j edit home if settings directory null jar cache directory  misc utilities construct path settings directory jars cache new  file jar cache directory mkdirs if j edit home null  log log  log debug j edit class  web start mode  add an  edit bus component that will reload edit modes and macros if they are changed from within the editor  edit bus add to bus new  settings reloader  perhaps if  xerces wasn t slightly brain damaged we would not need this  swing utilities invoke later new  runnable public void run  thread current thread set context class loader new jar class loader  also set the  context class loader for the main j edit thread  this way the  context class loader will be a jar class loader even at plugin activation  thread current thread set context class loader new jar class loader 
 load system properties private static void init system properties prop mgr new  property manager try prop mgr load system props j edit class get resource as stream org gjt sp jedit jedit props prop mgr load system props j edit class get resource as stream org gjt sp jedit jedit gui props prop mgr load system props j edit class get resource as stream org gjt sp jedit jedit keys props catch  exception e  log log  log error j edit class  error while loading system properties  log log  log error j edit class  one of the following property files could not be loaded n jedit props n jedit gui props n jedit keys props n jedit jar is probably corrupt  log log  log error j edit class e  system exit 
 load site properties private static void init site properties site properties are loaded as default properties overwriting j edit s system properties  string site settings directory  misc utilities construct path j edit home properties  file site settings new  file site settings directory if site settings exists site settings is directory return  string snippets site settings list if snippets null return  arrays sort snippets new  standard utilities  string compare  string true for int i i snippets length i  string snippet snippets i if snippet to lower case ends with props continue try  string path  misc utilities construct path site settings directory snippet  log log  log debug j edit class  loading site snippet path prop mgr load site props new  file input stream new  file path catch  file not found exception fnf  log log  log debug j edit class fnf catch io exception e  log log  log error j edit class  cannot load site snippet snippet  log log  log error j edit class e 
private static void init resources built in action set new  action set null null null j edit class get resource actions xml built in action set set label get property action set j edit built in action set load action context add action set built in action set  dockable window factory get instance load dockable windows null j edit class get resource dockables xml null  service manager load services null j edit class get resource services xml null 
 loads plugins private static void init plugins if j edit home null add plugin ja rs from directory  misc utilities construct path j edit home jars if settings directory null  file jars directory new  file settings directory jars if jars directory exists jars directory mkdir add plugin ja rs from directory jars directory get path  plugin jar jars get plugin ja rs for int i i jars length i jars i check dependencies 
 loads user properties private static void init user properties if settings directory null  file file new  file  misc utilities construct path settings directory properties props mod time file last modified try prop mgr load user props new  file input stream file catch  file not found exception fnf  log log  log debug j edit class fnf catch  exception e  log log  log error j edit class e 
private static  string font style to string int style if style return plain else if style  font bold return bold else if style  font italic return italic else if style  font bold  font italic return bolditalic else throw new  runtime exception  invalid style style 
private static  string font to string  font font return font get family font style to string font get style font get size 
 sets the  swing look and feel private static void init plaf  font primary font j edit get font property metal primary font if primary font null  string primary font string font to string primary font  system get properties put swing plaf metal control font primary font string  system get properties put swing plaf metal menu font primary font string  font secondary font j edit get font property metal secondary font if secondary font null  string secondary font string font to string secondary font  system get properties put swing plaf metal system font secondary font string  system get properties put swing plaf metal user font secondary font string try  string lf get property look and feel if lf null lf length ui manager set look and feel lf else if  operating system is mac os ui manager set look and feel ui manager get system look and feel class name else ui manager set look and feel ui manager get cross platform look and feel class name catch  exception e  log log  log error j edit class e ui defaults defaults ui manager get defaults give all  swing components our colors if j edit get boolean property text colors  color background new javax swing plaf  color ui resource j edit get color property view bg color  color foreground new javax swing plaf  color ui resource j edit get color property view fg color  color caret color new javax swing plaf  color ui resource j edit get color property view caret color  color selection color new javax swing plaf  color ui resource j edit get color property view selection color  string prefixes  password field  text field  text area  list  table for int i i prefixes length i  string prefix prefixes i defaults put prefix foreground foreground defaults put prefix background background defaults put prefix disabled foreground foreground defaults put prefix disabled background background defaults put prefix caret foreground caret color defaults put prefix selection foreground foreground defaults put prefix selection background selection color defaults put  combo box foreground foreground defaults put  combo box background background defaults put  combo box disabled foreground foreground defaults put  combo box disabled background background defaults put  combo box selected foreground foreground defaults put  combo box selected background selection color defaults put  tree background background defaults put  tree foreground foreground defaults put  tree text background background defaults put  tree text foreground foreground defaults put  tree selection foreground foreground defaults put  tree selection background selection color defaults remove  split pane border defaults remove  split pane divider border j frame set default look and feel decorated get boolean property decorate frames j dialog set default look and feel decorated get boolean property decorate dialogs  keyboard focus manager set current keyboard focus manager new  my focus manager 
public static int get next untitled buffer id int untitled count  buffer buffer buffers first while buffer null if buffer get name starts with  untitled try untitled count  math max untitled count  integer parse int buffer get name substring catch  number format exception nf buffer buffer next return untitled count 
 runs scripts in a directory private static void run startup scripts  file directory if directory is directory return  file snippets directory list files if snippets null return  arrays sort snippets new  standard utilities  string compare  file true  force the default encoding to utf temporarily  the shipped scripts use that encoding so we need to make sure we can load them correctly  if users want to write script with a different encoding they can use buffer local properties on the script to set it  string default encoding get property buffer encoding set property buffer encoding utf for int i i snippets length i  file snippet snippets i  macros  handler handler  macros get handler for path name snippet get path if handler null continue try  macros  macro new macro handler create macro snippet get name snippet get path handler run macro null new macro false catch  exception e  log log  log error j edit class e set property buffer encoding default encoding 
private static void init proxy boolean socks enabled j edit get boolean property socks enabled if socks enabled  log log  log debug j edit class socks proxy disabled  system get properties remove socks proxy host  system get properties remove socks proxy port else  string socks host j edit get property firewall socks host if socks host null  system set property socks proxy host socks host  log log  log debug j edit class socks proxy enabled socks host  string socks port j edit get property firewall socks port if socks port null  system set property socks proxy port socks port boolean http enabled j edit get boolean property firewall enabled if http enabled  log log  log debug j edit class http proxy disabled  system get properties remove proxy set  system get properties remove proxy host  system get properties remove proxy port  system get properties remove http proxy host  system get properties remove http proxy port  system get properties remove http non proxy hosts  authenticator set default null else set proxy host  string host j edit get property firewall host if host null return  system set property http proxy host host  log log  log debug j edit class http proxy enabled host set proxy port  string port j edit get property firewall port if port null  system set property http proxy port port set non proxy hosts list  string non proxy hosts j edit get property firewall non proxy hosts if non proxy hosts null  system set property http non proxy hosts non proxy hosts set proxy authentication  string username j edit get property firewall user  string password j edit get property firewall password null not supported if password null password if username null username length  log log  log debug j edit class http proxy without user  authenticator set default new  firewall authenticator null else  log log  log debug j edit class http proxy user username  password authentication pw new  password authentication username password to char array  authenticator set default new  firewall authenticator pw 
 firewall authenticator  password authentication pw this pw pw 
 override protected  password authentication get password authentication return pw 
private static void finish startup final boolean gui final boolean restore final boolean new plain view final  string user dir final  string args  swing utilities invoke later new  runnable public void run int count get buffer count boolean restore files restore j edit get boolean property restore count j edit get boolean property restore cli if gui count  view view if new plain view view new view null null true else view  perspective manager load perspective restore files if view null view new view null null  buffer buffer open files null user dir args if buffer null view set buffer buffer true else open files null user dir args  start i o threads  edit bus send new  editor started null vfs manager start  start edit server if server null server start gui utilities hide splash screen  log log  log message j edit class  startup complete  report any plugin errors if plugin errors null show plugin error dialog startup done set true in one case not a single awt class will have been touched splash screen off nogui nobackground switches on command line  toolkit get default toolkit 
private static void show plugin error dialog if plugin errors null return  string caption get property plugin error caption plugin errors size  frame frame  plugin manager get instance null views first  plugin manager get instance new  error list dialog frame get property plugin error title caption plugin errors true plugin errors null 
private static void get not loaded plugin ja rs  list  string return value  string dir  string list loop for int i i list length i  string name list i if name to lower case ends with jar continue loop  string path  misc utilities construct path dir name for int j j jars size j  plugin jar jar jars element at j  string jar path jar get path  string jar name  misc utilities get file name jar path if path equals jar path continue loop else if new  file jar path exists name equals jar name continue loop return value add path 
private static void goto marker final  view view final  buffer buffer final  string marker vfs manager run in awt thread new  runnable public void run int pos  handle line number if marker starts with line try  string arg marker substring  string line col arg split int line col if line col length line  integer parse int line col col  integer parse int line col else line  integer parse int marker substring col pos buffer get line start offset line col catch  exception e return  handle marker else if marker starts with marker if marker length return  marker m buffer get marker marker char at if m null return pos m get position  can t happen else throw new  internal error if view null view get buffer buffer view get text area set caret position pos buffer set integer property  buffer caret pos buffer set boolean property  buffer caret positioned true else buffer set integer property  buffer caret pos buffer set boolean property  buffer caret positioned true buffer unset property  buffer scroll vert 
private static void add buffer to list  buffer buffer synchronized buffer list lock  string symlink path buffer get symlink path if vfs manager get vfs for path symlink path get capabilities vfs case insensitive cap symlink path symlink path to lower case buffer count buffer hash put symlink path buffer if buffers first null buffers first buffers last buffer return  sort buffer list else if sort buffers  string str str if sort by name str buffer get name str buffer get directory else str buffer get directory str buffer get name  buffer  buffer buffers first while  buffer null  string str str if sort by name str  buffer get name str  buffer get directory else str  buffer get directory str  buffer get name int comp  standard utilities compare strings str str true if comp comp  standard utilities compare strings str str true buffer next  buffer buffer prev  buffer prev  buffer prev buffer if  buffer buffers first buffer prev next buffer else buffers first buffer return  buffer  buffer next buffer prev buffers last fixes the hang that can occur if we save as to a new filename which requires re sorting buffer next null buffers last next buffer buffers last buffer 
private static void remove buffer from list  buffer buffer synchronized buffer list lock buffer count  string path buffer get path if  operating system is case insensitive fs path path to lower case buffer hash remove path if buffer buffers first buffer buffers last buffers first buffers last null return if buffer buffers first buffers first buffer next buffer next prev null else if buffer prev null buffer prev next buffer next if buffer buffers last buffers last buffers last prev buffer prev next null else if buffer next null buffer next prev buffer prev fixes the hang that can occur if we save as to a new filename which requires re sorting buffer next buffer prev null 
private static void add view to list  view view view count if views first null views first views last view else view prev views last views last next view views last view 
private static void remove view from list  view view view count if views first views last views first views last null return if view views first views first view next view next prev null else view prev next view next if view views last views last views last prev view prev next null else view next prev view prev 
close view used by exit private static boolean close view  view view boolean call exit  perspective manager set perspective dirty true if views first views last call exit exit view false exit does editor event save  coming here means the request has been canceled return false else if view confirm to close dirty return false view close view dispose remove view from list view if view active view active view null return true 
 loads a mode catalog file since j edit pre private static void load mode catalog  string path boolean resource  log log  log message j edit class  loading mode catalog file path  mode catalog handler handler new  mode catalog handler  misc utilities get parent of path path resource  override protected  mode instantiate mode  string mode name return new j edit mode mode name try  input stream  in if resource  in j edit class get resource as stream path else  in new  file input stream path xml utilities parse xml  in handler catch io exception e  log log  log error j edit class e 
 loads all key bindings from the properties since pre private static void init key bindings input handler remove all key bindings  action set action sets get action sets for int i i action sets length i action sets i init key bindings 
 compose buffer local properties which can be got from history since pre private static void compose buffer props from history  map props  string path  buffer history  entry entry  buffer history get entry path if entry null save caret props get  buffer caret null props put  buffer caret entry caret if entry selection null get selection converts from string to  selection props put  buffer selection entry get selection if entry null props get j edit buffer encoding null if entry encoding null props put j edit buffer encoding entry encoding if entry null props get mode null if entry mode null props put mode entry mode 
 my focus manager set default focus traversal policy new  layout focus traversal policy 
 override public boolean post process key event  key event evt if evt is consumed  component comp  component evt get source if comp is showing return true for if comp instanceof  view  view comp get input handler process key event evt  view view false return true else if comp null comp instanceof  window comp instanceof j edit text area if comp instanceof  plugin manager evt set source comp  plugin manager comp process key events evt break else comp comp get parent return super post process key event evt 
public  string get property  string name return j edit get property name 
 docking layout setter  view view  view config config int startup done index this view view this config config this startup done index startup done index 
public void run  dockable window manager wm view get dockable window manager wm set docking layout config docking startup done set startup done index true 
 creates a new edit action with the specified name param name  the action name protected j edit abstract edit action  string name this name name 
protected j edit abstract edit action  string name  object new args this name name this args new args 
 returns the internal name of this action return the action name public  string get name return name 
 changes the name of an action param new name the new name of the action since j edit pre public void set name  string new name name new name 
param arg the arguments of the action param new args new argument list public final void invoke e arg  object new args args new args invoke arg 
 override public  string to string return name 
 adds a new action set to the context since j edit pre public void add action set e action set action names null action sets add element action set action set context this  string actions action set get action names for int i i actions length i  is it already there if action hash contains key actions i  save it for plugin unloading time e old action action hash get actions i overridden actions put actions i old action action hash put actions i action set 
 removes an action set from the context since j edit pre public void remove action set e action set action names null action sets remove element action set action set context null  string actions action set get action names for int i i actions length i action hash remove actions i if overridden actions contains key actions i e old action overridden actions remove actions i action hash put actions i old action 
 returns all registered action sets since j edit pre public e get action sets if action sets is empty return null  class clazz action sets get get class e ret val e  array new instance clazz action sets size action sets copy into ret val return ret val 
 returns the specified action param name  the action name return a j edit abstract edit action or null if it doesn t exist since j edit pre public f get action  string name e set action hash get name if set null return null else return set get action name 
 returns the action set that contains the specified action param action  the action return the action set that contains the given action since j edit pre public e get action set for action  string action return action hash get action 
 returns all registered action names public  string get action names if action names null  list  string vec new  linked list  string for int i i action sets size i action sets element at i get action names vec action names vec to array new  string vec size  arrays sort action names new  standard utilities  string compare  string true return action names 
 creates a new action set since j edit pre public j edit action set actions new  hashtable  string  object loaded true 
 creates a new action set param cached action names  the list of cached action names param uri  the actions xml uri since j edit pre public j edit action set  string cached action names url uri this this uri uri if cached action names null for int i i cached action names length i actions put cached action names i placeholder loaded false 
 adds an action to the action set param action  the action since j edit pre public void add action e action actions put action get name action if context null context action names null context action hash put action get name this 
 removes an action from the action set param name  the action name since j edit pre public void remove action  string name actions remove name if context null context action names null context action hash remove name 
 removes all actions from the action set since j edit pre public void remove all actions if context null context action names null  string actions get action names for int i i actions length i context action hash remove actions i this actions clear 
 returns an action with the specified name p b  deferred loading b this will load the action set if necessary param name  the action name since j edit pre public e get action  string name  object obj actions get name if obj placeholder load obj actions get name if obj placeholder  log log  log warning this  outdated cache obj null return e obj 
 returns the number of actions in the set since j edit pre public int get action count return actions size 
 returns an array of all action names in this action set since j edit pre public  string get action names  string ret val new  string actions size  enumeration e actions keys int i while e has more elements ret val i  string e next element return ret val 
 returns an array of all action names in this action set that should be cached namely code  bean shell action code s since j edit pre public  string get cacheable action names  linked list  string ret val new  linked list  string  enumeration e actions elements while e has more elements  object obj e next element if obj placeholder this should only be called with fully loaded action set  log log  log warning this  action set not up to date else if obj instanceof j edit bean shell action ret val add j edit bean shell action obj get name return ret val to array new  string ret val size 
 returns an array of all actions in this action set p b  deferred loading b this will load the action set if necessary since j edit pre public e get actions load e ret val get array actions size  enumeration e actions elements int i while e has more elements ret val i e e next element return ret val 
 returns if this action set contains the specified action param action  the action since j edit pre public boolean contains  string action boolean retval actions contains key action return retval return actions contains key action 
 returns the number of actions in this action set since j edit pre public int size return actions size 
 forces the action set to be loaded  plugins and macros should not call this method since j edit pre public void load if loaded return loaded true actions clear if uri null return try  log log  log debug this  loading actions from uri  action list handler ah new  action list handler uri to string this if xml utilities parse xml uri open stream ah  log log  log error this  unable to parse uri catch io exception e  log log  log error this uri e 
 initializes the action set s key bindings j edit calls this method for all registered action sets when the user changes key bindings in the b  global  options b dialog box p  note if your plugin adds a custom action set to j edit s collection it must also call this method on the action set after adding it since j edit pre public void init key bindings  abstract input handler input handler get input handler  iterator  map  entry  string  object iter actions entry set iterator while iter has next  map  entry  string  object entry iter next  string name entry get key  string shortcut get property name shortcut if shortcut null input handler add key binding shortcut name  string shortcut get property name shortcut if shortcut null input handler add key binding shortcut name 
void get action names  list  string vec  enumeration  string e actions keys while e has more elements vec add e next element 
public j edit bean shell action  string name  string code  string is selected boolean no repeat boolean no record boolean no remember last super name this code code this is selected is selected this no repeat no repeat this no record no record this no remember last no remember last  some characters that we like to use in action names are not allowed in  bean shell identifiers sanitized name name replace   replace   
public void invoke  text area text area try if cached code null  string cached code name action  sanitized name cached code bsh cache block cached code name code true bsh run cached block cached code text area new  name space bsh get name space  bean shell action invoke catch  throwable e  log log  log error this e 
public boolean is selected  component comp if is selected null return false  name space global bsh get name space try if cached is selected null  string cached is selected name selected  sanitized name cached is selected bsh cache block cached is selected name is selected true undocumented hack to allow browser actions to work xxx clean up in global set variable  comp comp return  boolean true equals bsh run cached block cached is selected null new  name space bsh get name space  bean shell action is selected catch  throwable e  log log  log error this e dialogs fuck things up if a menu is visible etc new  bean shell error dialog view e so that in the future we don t see streams of exceptions is selected null return false finally try global set variable  comp null catch  util eval error err  log log  log error this err 
public boolean no repeat return no repeat 
public boolean no record return no record 
 returns if this edit action should not be remembered as the most recently invoked action since j edit pre public boolean no remember last return no remember last 
public  string get code return code trim 
 override protected void setup default variables  name space namespace  text area text area throws  util eval error if text area null namespace set variable buffer text area get buffer false namespace set variable text area text area false 
 override protected void reset default variables  name space namespace throws  util eval error namespace set variable buffer null false namespace set variable text area null false 
 override protected void handle exception  text area text area  string path  throwable t  log log  log error this t t new  bean shell error dialog null t 
public j edit buffer  map props buffer listeners new  vector  listener undo listeners new  vector  buffer undo listener lock new  reentrant read write lock content mgr new  content manager line mgr new  line manager position mgr new  position manager this undo mgr new  undo manager this integer array new  integer array property lock new  object properties new  hash map  object  prop value need to convert entries of props to  prop value instances  set  map  entry set props entry set for  map  entry entry set properties put entry get key new  prop value entry get value false fill in defaults for these from system properties if the corresponding buffer xxx properties not set if get property encoding null properties put encoding new  prop value  system get property file encoding false if get property linesep null properties put linesep new  prop value  system get property line separator false 
 create a new j edit buffer  it is used by independent textarea only public j edit buffer buffer listeners new  vector  listener undo listeners new  vector  buffer undo listener lock new  reentrant read write lock content mgr new  content manager line mgr new  line manager position mgr new  position manager this undo mgr new  undo manager this integer array new  integer array property lock new  object properties new  hash map  object  prop value properties put wrap new  prop value none false properties put folding new  prop value none false token marker new  token marker token marker add rule set new  parser rule set text main set token marker token marker load text null null corresponding buffer xxx properties not set if get property encoding null properties put encoding new  prop value  system get property file encoding false if get property linesep null properties put linesep new  prop value  system get property line separator false set fold handler new  dummy fold handler 
 returns whether there have been unsaved changes to this buffer  this method is thread safe public boolean is dirty return dirty 
public boolean is loading return loading 
public void set loading boolean loading this loading loading 
 returns true if the buffer is currently performing i o  this method is thread safe since j edit pre public boolean is performing io return is loading io 
 returns true if the buffer is currently performing i o  this method is thread safe since j edit pre public void set performing io boolean io this io io 
 returns true if this file is editable false otherwise a file may become uneditable if it is read only or if i o is in progress  this method is thread safe since j edit pre public boolean is editable return is read only is performing io 
 returns true if this file is read only false otherwise  this method is thread safe public boolean is read only return read only read only override 
 sets the read only flag param read only  the read only flag public void set read only boolean read only read only override read only 
 sets the dirty changed since last save flag of this buffer public void set dirty boolean d boolean editable is editable if d if editable dirty true else dirty false fixes dirty flag not being reset on save insert undo redo undo if is undo in progress this ensures that undo can clear the dirty flag properly when all edits up to a save are undone undo mgr reset clear dirty 
 the buffer is guaranteed not to change between calls to link read lock and link read unlock public void read lock lock read lock lock 
 the buffer is guaranteed not to change between calls to link read lock and link read unlock public void read unlock lock read lock unlock 
 attempting to obtain read lock will block between calls to link write lock and link write unlock public void write lock lock write lock lock 
 attempting to obtain read lock will block between calls to link write lock and link write unlock public void write unlock lock write lock unlock 
 returns the number of characters in the buffer  this method is thread safe public int get length no need to lock since this just returns a value and that s it return content mgr get length 
 returns the number of physical lines in the buffer  this method is thread safe since j edit pre public int get line count no need to lock since this just returns a value and that s it return line mgr get line count 
 returns the line containing the specified offset  this method is thread safe param offset  the offset since j edit pre public int get line of offset int offset try read lock if offset offset get length throw new  array index out of bounds exception offset return line mgr get line of offset offset finally read unlock 
 returns the start offset of the specified line  this method is thread safe param line  the line return  the start offset of the specified line since j edit pre public int get line start offset int line try read lock if line line line mgr get line count throw new  array index out of bounds exception line else if line return return line mgr get line end offset line finally read unlock 
 returns the end offset of the specified line  this method is thread safe param line  the line return  the end offset of the specified line invalid since j edit pre public int get line end offset int line try read lock if line line line mgr get line count throw new  array index out of bounds exception line return line mgr get line end offset line finally read unlock 
 returns the length of the specified line  this method is thread safe param line  the line since j edit pre public int get line length int line try read lock return get line end offset line get line start offset line finally read unlock 
 auto indent needs this public int get prior non empty line int line index int return value if mode get ignore whitespace return line index for int i line index i i  segment seg new  segment get line text i seg if seg count return value i for int j j seg count j char ch seg array seg offset j if  character is whitespace ch return i didn t find a line that contains non whitespace chars so return index of prior whitespace line return return value 
 returns the text on the specified line  this method is thread safe param line  the line return  the text or null if the line is invalid since j edit pre public  string get line text int line if line line line mgr get line count throw new  array index out of bounds exception line try read lock int start line line mgr get line end offset line int end line mgr get line end offset line return get text start end start finally read unlock 
 returns the specified line in a code  segment code p  using a classname  segment classname is generally more efficient than using a classname  string classname because it results in less memory allocation and array copying p  this method is thread safe param line  the line since j edit pre public void get line text int line  segment segment if line line line mgr get line count throw new  array index out of bounds exception line try read lock int start line line mgr get line end offset line int end line mgr get line end offset line get text start end start segment finally read unlock 
 returns the text on the specified line  this method is thread safe param line  the line index return  the text or null if the line is invalid since j edit pre public  char sequence get line segment int line if line line line mgr get line count throw new  array index out of bounds exception line try read lock int start line line mgr get line end offset line int end line mgr get line end offset line return get segment start end start finally read unlock 
 returns the specified text range  this method is thread safe param start  the start offset param length  the number of characters to get public  string get text int start int length try read lock if start length start length content mgr get length throw new  array index out of bounds exception start length return content mgr get text start length finally read unlock 
 returns the specified text range in a code  segment code p  using a classname  segment classname is generally more efficient than using a classname  string classname because it results in less memory allocation and array copying p  this method is thread safe param start  the start offset param length  the number of characters to get param seg  the segment to copy the text to public void get text int start int length  segment seg try read lock if start length start length content mgr get length throw new  array index out of bounds exception start length content mgr get text start length seg finally read unlock 
 returns the specified text range  this method is thread safe param start  the start offset param length  the number of characters to get since j edit pre public  char sequence get segment int start int length try read lock if start length start length content mgr get length throw new  array index out of bounds exception start length return content mgr get segment start length finally read unlock 
 inserts a string into the buffer param offset  the offset param str  the string since j edit pre public void insert int offset  string str if str null return int len str length if len return if is read only throw new  runtime exception buffer read only try write lock if offset offset content mgr get length throw new  array index out of bounds exception offset content mgr insert offset str integer array clear for int i i len i if str char at i n integer array add i if undo in progress undo mgr content inserted offset len str dirty content inserted offset len integer array finally write unlock 
 inserts a string into the buffer param offset  the offset param seg  the segment since j edit pre public void insert int offset  segment seg if seg count return if is read only throw new  runtime exception buffer read only try write lock if offset offset content mgr get length throw new  array index out of bounds exception offset content mgr insert offset seg integer array clear for int i i seg count i if seg array seg offset i n integer array add i if undo in progress undo mgr content inserted offset seg count seg to string dirty content inserted offset seg count integer array finally write unlock 
 removes the specified rang efrom the buffer param offset  the start offset param length  the number of characters to remove public void remove int offset int length if length return if is read only throw new  runtime exception buffer read only try transaction true write lock if offset length offset length content mgr get length throw new  array index out of bounds exception offset length int start line line mgr get line of offset offset int end line line mgr get line of offset offset length int num lines end line start line if undo in progress loading undo mgr content removed offset length get text offset length dirty fire pre content removed start line offset num lines length content mgr remove offset length line mgr content removed start line offset num lines length position mgr content removed offset length fire content removed start line offset num lines length otherwise it will be delivered later if undo in progress inside compound edit fire transaction complete set dirty true finally transaction false write unlock 
 removes trailing whitespace from all lines in the specified list param lines  the line numbers since j edit pre public void remove trailing white space int lines try begin compound edit for int i i lines length i int pos line start line end tail  segment seg new  segment get line text lines i seg blank line if seg count continue line start seg offset line end seg offset seg count for pos line end pos line start pos if  character is whitespace seg array pos break tail line end pos no whitespace if tail continue remove get line end offset lines i tail tail finally end compound edit 
 shifts the indent of each line in the specified list to the left param lines  the line numbers since j edit pre public void shift indent left int lines int tab size get tab size int indent size get indent size boolean no tabs get boolean property no tabs try begin compound edit for int i i lines length i int line start get line start offset lines i  char sequence line get line segment lines i int white space  standard utilities get leading white space line if white space continue int white space width  math max  standard utilities get leading white space width line tab size indent size insert line start white space  standard utilities create white space white space width no tabs tab size remove line start white space finally end compound edit 
 shifts the indent of each line in the specified list to the right param lines  the line numbers since j edit pre public void shift indent right int lines try begin compound edit int tab size get tab size int indent size get indent size boolean no tabs get boolean property no tabs for int i i lines length i int line start get line start offset lines i  char sequence line get line segment lines i int white space  standard utilities get leading white space line silly usability hack if lines length white space continue int white space width  standard utilities get leading white space width line tab size indent size insert line start white space  standard utilities create white space white space width no tabs tab size remove line start white space finally end compound edit 
 indents all specified lines param start  the first line to indent param end  the last line to indent since j edit pre public void indent lines int start int end try begin compound edit for int i start i end i indent line i true finally end compound edit 
 indents all specified lines param lines  the line numbers since j edit pre public void indent lines int lines try begin compound edit for int i i lines length i indent line lines i true finally end compound edit 
deprecated  use link indent line int boolean instead  deprecated public boolean indent line int line index boolean can increase indent boolean can decrease indent return indent line line index can decrease indent 
 indents the specified line param line index  the line number to indent param can decrease indent  if true the indent can be decreased as a result of this  set this to false for  tab key return true  if indentation took place false otherwise since j edit pre public boolean indent line int line index boolean can decrease indent int whitespace chars new int int current indent get current indent for line line index whitespace chars int prev line index get prior non empty line line index int prev line indent prev line index  standard utilities get leading white space width get line segment prev line index get tab size int ideal indent get ideal indent for line line index prev line index prev line indent if ideal indent ideal indent current indent can decrease indent ideal indent current indent return false  do it try begin compound edit int start get line start offset line index remove start whitespace chars  string prev indent string prev line index  standard utilities get indent string get line text prev line index null  string indent string if prev indent string null indent string  standard utilities create white space ideal indent get boolean property no tabs get tab size else if ideal indent prev line indent indent string prev indent string else if ideal indent prev line indent indent string  standard utilities truncate white space ideal indent get tab size prev indent string else indent string prev indent string  standard utilities create white space ideal indent prev line indent get boolean property no tabs get tab size prev line indent insert start indent string finally end compound edit return true 
 returns the line s current leading indent param line index  the line number param whitespace chars  if this is non null the number of whitespace characters is stored at the index since j edit pre public int get current indent for line int line index int whitespace chars  segment seg new  segment get line text line index seg int tab size get tab size int current indent loop for int i i seg count i char c seg array seg offset i switch c case current indent if whitespace chars null whitespace chars break case t current indent tab size current indent tab size if whitespace chars null whitespace chars break default break loop return current indent 
 returns the ideal leading indent for the specified line  this will apply the various auto indent rules param line index  the line number public int get ideal indent for line int line index int prev line index get prior non empty line line index int old indent prev line index  standard utilities get leading white space width get line segment prev line index get tab size return get ideal indent for line line index prev line index old indent 
 returns the ideal leading indent for the specified line  this will apply the various auto indent rules param line index  the line number param prev line index  the index of the previous non empty line param old indent  the indent width of the previous line or private int get ideal indent for line int line index int prev line index int old indent int prev prev line index prev line index get prior non empty line prev line index int new indent old indent  list  indent rule indent rules get indent rules line index  list  indent action actions new  linked list  indent action for int i i indent rules size i  indent rule rule indent rules get i rule apply this line index prev line index prev prev line index actions for  indent action action actions new indent action calculate indent this line index old indent new indent if action keep checking break if new indent new indent return new indent 
 returns the virtual column number taking tabs into account of the specified position param line  the line number param column  the column number since j edit pre public int get virtual width int line int column try read lock int start get line start offset line  segment seg new  segment get text start column seg return  standard utilities get virtual width seg get tab size finally read unlock 
 returns the offset of a virtual column number taking tabs into account relative to the start of the line in question param line  the line number param column  the virtual column number param total virtual width  if this array is non null the total virtual width will be stored in its first location if this method returns return if the column is out of bounds since j edit pre public int get offset of virtual column int line int column int total virtual width try read lock  segment seg new  segment get line text line seg return  standard utilities get offset of virtual column seg get tab size column total virtual width finally read unlock 
 like the link insert int  string method but inserts the string at the specified virtual column  inserts spaces as appropriate if the line is shorter than the column param line  the line number param col  the virtual column number param str  the string public void insert at column int line int col  string str try write lock int total new int int offset get offset of virtual column line col total if offset offset get line end offset line str  standard utilities create white space col total str else offset get line start offset line insert offset str finally write unlock 
 inserts a string into the buffer indenting each line of the string to match the indent of the first line param offset  the offset param text  the text return  the number of characters of indent inserted on each new line  this is used by the abbreviations code since j edit pre public int insert indented int offset  string text try begin compound edit obtain the leading indent for later use int first line get line of offset offset  char sequence line text get line segment first line int leading indent  standard utilities get leading white space width line text get tab size  string white space  standard utilities create white space leading indent get boolean property no tabs get tab size insert offset text int last line get line of offset offset text length note that if first line last line loop does not execute for int i first line i last line i insert get line start offset i white space return white space length finally end compound edit 
 should inserting this character trigger a re indent of the current line since j edit pre deprecated  use is electric key char int public boolean is electric key char ch return mode is electric key ch 
 should inserting this character trigger a re indent of the current line since j edit pre public boolean is electric key char ch int line  token marker  line context ctx line mgr get line context line  mode mode  mode provider instance get mode ctx rules get mode name mode can be null though that s probably an error further up if mode null return false return mode is electric key ch 
 returns the syntax tokens for the specified line param line index  the line number param token handler  the token handler that will receive the syntax tokens since j edit pre public void mark tokens int line index  token handler token handler  segment seg new  segment if line index line index line mgr get line count throw new  array index out of bounds exception line index int first invalid line context line mgr get first invalid line context int start if text mode first invalid line context start line index else start  math min first invalid line context line index if  debug token marker debug  log log  log debug this tokenize from start to line index  token marker  line context old context null  token marker  line context context null for int i start i line index i get line text i seg old context line mgr get line context i  token marker  line context prev context i text mode null line mgr get line context i context token marker mark tokens prev context i line index token handler  dummy token handler instance seg line mgr set line context i context int line count line mgr get line count if line count line index line mgr set first invalid line context else if old context context line mgr set first invalid line context line index else if first invalid line context do nothing else line mgr set first invalid line context  math max first invalid line context line index 
public  token marker get token marker return token marker 
public void set token marker  token marker token marker  token marker old token marker this token marker this token marker token marker don t do this on initial token marker if old token marker null token marker old token marker line mgr set first invalid line context 
 creates a floating position param offset  the offset public  position create position int offset try read lock if offset offset content mgr get length throw new  array index out of bounds exception offset return position mgr create position offset finally read unlock 
 reloads settings from the properties  this should be called after the code syntax code or code folding code buffer local properties are changed public void properties changed  string folding get string property folding  fold handler handler  fold handler get fold handler folding if handler null set fold handler handler else if folding null  log log  log warning this invalid folding property folding set fold handler new  dummy fold handler 
 returns the tab size used in this buffer  this is equivalent to calling code get property tab size code  this method is thread safe public int get tab size int tab size get integer property tab size if tab size return else return tab size 
 returns the indent size used in this buffer  this is equivalent to calling code get property indent size code  this method is thread safe since j edit pre public int get indent size int indent size get integer property indent size if indent size return else return indent size 
 returns the value of a buffer local property p  using this method is generally discouraged because it returns an code  object code which must be cast to another type in order to be useful and this can cause problems if the object is of a different type than what the caller expects p  the following methods should be used instead ul li link get string property  string li li link get boolean property  string li li link get integer property  string int li ul  this method is thread safe param name  the property name  for backwards compatibility this is an code  object code not a code  string code public  object get property  object name synchronized property lock  first try the buffer local properties  prop value o properties get name if o null return o value  for backwards compatibility if name instanceof  string return null  object ret val get default property  string name if ret val null return null else properties put name new  prop value ret val true return ret val 
public  object get default property  string key return null 
 sets the value of a buffer local property param name  the property name param value  the property value since j edit pre public void set property  string name  object value if value null properties remove name else  prop value test properties get name if test null properties put name new  prop value value false else if test value equals value do nothing else test value value test default value false 
public void set default property  string name  object value properties put name new  prop value value true 
 clears the value of a buffer local property param name  the property name since j edit pre public void unset property  string name properties remove name 
public void reset cached properties  need to reset properties that were cached defaults since the defaults might have changed  iterator  prop value iter properties values iterator while iter has next  prop value value iter next if value default value iter remove 
 returns the value of a string property  this method is thread safe param name  the property name since j edit pre public  string get string property  string name  object obj get property name if obj null return obj to string else return null 
 sets a string property param name  the property name param value  the value since j edit pre public void set string property  string name  string value set property name value 
 returns the value of a boolean property  this method is thread safe param name  the property name since j edit pre public boolean get boolean property  string name return get boolean property name false 
 returns the value of a boolean property  this method is thread safe param name  the property name param def  the default value since j edit pre public boolean get boolean property  string name boolean def  object obj get property name return  standard utilities get boolean obj def 
 sets a boolean property param name  the property name param value  the value since j edit pre public void set boolean property  string name boolean value set property name value  boolean true  boolean false 
 returns the value of an integer property  this method is thread safe param name  the property name since j edit pre public int get integer property  string name int default value boolean default value flag  object obj  prop value value properties get name if value null obj value value default value flag value default value else obj get property name will be cached from now on default value flag true if obj null return default value else if obj instanceof  number return  number obj int value else try int return value  integer parse int obj to string trim properties put name new  prop value return value default value flag return return value catch  exception e return default value 
 sets an integer property param name  the property name param value  the value since j edit pre public void set integer property  string name int value set property name value 
 returns the value of a property as a regular expression  this method is thread safe param name  the property name param flags  regular expression compilation flags since j edit pre public  pattern get pattern property  string name int flags synchronized property lock boolean default value flag  object obj  prop value value properties get name if value null obj value value default value flag value default value else obj get property name will be cached from now on default value flag true if obj null return null else if obj instanceof  pattern return  pattern obj else  pattern re  pattern compile obj to string flags properties put name new  prop value re default value flag return re 
 returns the syntax highlighting ruleset at the specified offset since j edit pre public  parser rule set get rule set at offset int offset int line get line of offset offset offset get line start offset line if offset offset  default token handler tokens new  default token handler mark tokens line tokens  token token  text utilities get token at offset tokens get tokens offset return token rules 
 returns the syntax highlighting keyword map in effect at the specified offset  used by the b  complete  word b command to complete keywords param offset  the offset since j edit pre public  keyword map get keyword map at offset int offset return get rule set at offset offset get keywords 
 some settings like comment start and end strings can vary between different parts of a buffer html text and inline  java script for example param offset  the offset param name  the property name since j edit pre public  string get context sensitive property int offset  string name  parser rule set rules get rule set at offset offset  object value null  map  string  string ruleset props rules get properties if ruleset props null value ruleset props get name if value null return null else return  string value of value 
 returns this buffer s edit mode  this method is thread safe public  mode get mode return mode 
 sets this buffer s edit mode  note that calling this before a buffer is loaded will have no effect in that case set the mode property to the name of the mode a bit inelegant i know param mode  the mode name since j edit pre public void set mode  string mode set mode  mode provider instance get mode mode 
 sets this buffer s edit mode  note that calling this before a buffer is loaded will have no effect in that case set the mode property to the name of the mode a bit inelegant i know param mode  the mode public void set mode  mode mode  this protects against stupid people like me doing stuff like buffer set mode j edit get mode if mode null throw new  null pointer exception  mode must be non null this mode mode text mode text equals mode get name set token marker mode get token marker reset cached properties properties changed 
 returns if the specified line begins a fold since j edit pre public boolean is fold start int line return line get line count get fold level line get fold level line 
 returns if the specified line ends a fold since j edit pre public boolean is fold end int line return line get line count get fold level line get fold level line 
 invalidates all cached fold level information since j edit pre public void invalidate cached fold levels line mgr set first invalid fold level fire fold level changed get line count 
 returns the fold level of the specified line param line a physical line index since j edit pre public int get fold level int line if line line line mgr get line count throw new  array index out of bounds exception line if fold handler instanceof  dummy fold handler return int first invalid fold level line mgr get first invalid fold level if first invalid fold level line first invalid fold level return line mgr get fold level line else if  debug fold debug  log log  log debug this  invalid fold levels from first invalid fold level to line int new fold level boolean changed false int first updated fold level first invalid fold level for int i first invalid fold level i line i  segment seg new  segment new fold level fold handler get fold level this i seg if new fold level line mgr get fold level i if  debug fold debug  log log  log debug this i fold level changed changed true  update preceding fold levels if necessary if i first invalid fold level  list  integer preceding fold levels fold handler get preceding fold levels this i seg new fold level if preceding fold levels null int j i for  integer fold level preceding fold levels j line mgr set fold level j fold level int value if j first updated fold level first updated fold level j line mgr set fold level i new fold level if line line mgr get line count line mgr set first invalid fold level else line mgr set first invalid fold level line if changed if  debug fold debug  log log  log debug this fold level changed first updated fold level line fire fold level changed first updated fold level line return new fold level 
 returns an array  the first element is the start line the second element is the end line of the fold containing the specified line number param line  the line number since j edit pre public int get fold at line int line int start end if is fold start line start line int fold level get fold level line line while get fold level line fold level line if line get line count break end line else start line int fold level get fold level line while get fold level start fold level if start break else start end line while get fold level end fold level end if end get line count break end while get line length end end start end return new int start end 
 returns the current buffer s fold handler since j edit pre public  fold handler get fold handler return fold handler 
 sets the buffer s fold handler since j edit pre public void set fold handler  fold handler fold handler  fold handler old fold handler this fold handler if fold handler equals old fold handler return this fold handler fold handler line mgr set first invalid fold level fire fold handler changed 
 undoes the most recent edit since j edit pre public void undo  text area text area if undo mgr null return if is editable text area get toolkit beep return try write lock undo in progress true fire begin undo int caret undo mgr undo if caret text area get toolkit beep else text area set caret position caret fire end undo fire transaction complete finally undo in progress false write unlock 
 redoes the most recently undone edit since j edit pre public void redo  text area text area if undo mgr null return if is editable  toolkit get default toolkit beep return try write lock undo in progress true fire begin redo int caret undo mgr redo if caret text area get toolkit beep else text area set caret position caret fire end redo fire transaction complete finally undo in progress false write unlock 
 returns if an undo or compound edit is currently in progress  if this method returns true then eventually a link org gjt sp jedit buffer  buffer listener transaction complete j edit buffer buffer event will get fired since j edit pre public boolean is transaction in progress return transaction undo in progress inside compound edit 
 starts a compound edit  all edits from now on until link end compound edit are called will be merged into one  this can be used to make a complex operation undoable in one step  nested calls to link begin compound edit behave as expected requiring the same number of link end compound edit calls to end the edit see end compound edit public void begin compound edit try write lock undo mgr begin compound edit finally write unlock 
 ends a compound edit  all edits performed since link begin compound edit was called can now be undone in one step by calling link undo  text area see begin compound edit public void end compound edit try write lock undo mgr end compound edit if inside compound edit fire transaction complete finally write unlock 
 returns if a compound edit is currently active since j edit pre public boolean inside compound edit return undo mgr inside compound edit 
 returns if an undo or redo is currently being performed since j edit pre public boolean is undo in progress return undo in progress 
 returns an object that identifies the undo operation to which the current content change belongs  this method can be used by buffer listeners during content changes content inserted content removed to find out which content changes belong to the same undo operation  the same undo id object will be returned for all content changes belonging to the same undo operation  only the identity of the undo id can be used by comparing it with a previously returned undo id using since j edit pre public  object get undo id return undo mgr get undo id 
 listener  buffer listener listener int priority this listener listener this priority priority 
 adds a buffer change listener param listener  the listener param priority  listeners with high priority get the event before listeners with normal priority since j edit pre public void add buffer listener  buffer listener listener int priority  listener l new  listener listener priority for int i i buffer listeners size i  listener  l buffer listeners get i if  l priority priority buffer listeners add i l return buffer listeners add l 
 adds a buffer change listener param listener  the listener since j edit pre public void add buffer listener  buffer listener listener add buffer listener listener normal priority 
 removes a buffer change listener param listener  the listener since j edit pre public void remove buffer listener  buffer listener listener for int i i buffer listeners size i if buffer listeners get i listener listener buffer listeners remove i return 
 returns an array of registered buffer change listeners since j edit pre public  buffer listener get buffer listeners  buffer listener return value new  buffer listener buffer listeners size for int i i return value length i return value i buffer listeners get i listener return return value 
 adds a buffer undo listener param listener  the listener since j edit pre public void add buffer undo listener  buffer undo listener listener undo listeners add listener 
 removes a buffer undo listener param listener  the listener since j edit pre public void remove buffer undo listener  buffer undo listener listener undo listeners remove listener 
 set the undo limit of the  undo  manager param limit the new limit since j edit pre public void set undo limit int limit if undo mgr null undo mgr set limit limit 
 returns true if an undo operation can be performed since j edit pre public boolean can undo if undo mgr null return false return undo mgr can undo 
 returns true if a redo operation can be performed since j edit pre public boolean can redo if undo mgr null return false return undo mgr can redo 
protected void fire fold level changed int start int end for int i i buffer listeners size i  buffer listener listener get listener i try listener fold level changed this start end catch  throwable t  log log  log error this  exception while sending buffer event to listener  log log  log error this t 
protected void fire content inserted int start line int offset int num lines int length for int i i buffer listeners size i  buffer listener listener get listener i try listener content inserted this start line offset num lines length catch  throwable t  log log  log error this  exception while sending buffer event to listener  log log  log error this t 
protected void fire content removed int start line int offset int num lines int length for int i i buffer listeners size i  buffer listener listener get listener i try listener content removed this start line offset num lines length catch  throwable t  log log  log error this  exception while sending buffer event to listener  log log  log error this t 
protected void fire pre content inserted int start line int offset int num lines int length for int i i buffer listeners size i  buffer listener listener get listener i try listener pre content inserted this start line offset num lines length catch  throwable t  log log  log error this  exception while sending buffer event to listener  log log  log error this t 
protected void fire pre content removed int start line int offset int num lines int length for int i i buffer listeners size i  buffer listener listener get listener i try listener pre content removed this start line offset num lines length catch  throwable t  log log  log error this  exception while sending buffer event to listener  log log  log error this t 
protected void fire begin undo for  buffer undo listener listener undo listeners try listener begin undo this catch  throwable t  log log  log error this  exception while sending buffer undo event to listener  log log  log error this t 
protected void fire end undo for  buffer undo listener listener undo listeners try listener end undo this catch  throwable t  log log  log error this  exception while sending buffer undo event to listener  log log  log error this t 
protected void fire begin redo for  buffer undo listener listener undo listeners try listener begin redo this catch  throwable t  log log  log error this  exception while sending buffer begin redo event to listener  log log  log error this t 
protected void fire end redo for  buffer undo listener listener undo listeners try listener end redo this catch  throwable t  log log  log error this  exception while sending buffer end redo event to listener  log log  log error this t 
protected void fire transaction complete for int i i buffer listeners size i  buffer listener listener get listener i try listener transaction complete this catch  throwable t  log log  log error this  exception while sending buffer event to listener  log log  log error this t 
protected void fire fold handler changed for int i i buffer listeners size i  buffer listener listener get listener i try listener fold handler changed this catch  throwable t  log log  log error this  exception while sending buffer event to listener  log log  log error this t 
protected void fire buffer loaded for int i i buffer listeners size i  buffer listener listener get listener i try listener buffer loaded this catch  throwable t  log log  log error this  exception while sending buffer event to listener  log log  log error this t 
protected boolean is file read only return read only 
protected void set file read only boolean read only this read only read only 
protected void load text  segment seg  integer array end offsets if seg null seg new  segment new char if end offsets null end offsets new  integer array end offsets add try write lock  for reload command content mgr remove changes this int length get length fire pre content removed get line count length content mgr remove length line mgr content removed get line count length position mgr content removed length fire content removed get line count length fire pre content inserted end offsets get size seg count theoretically a segment could have seg offset but  segment buffer never does that content mgr  set content seg array seg count line mgr  content inserted end offsets position mgr content inserted seg count fire content inserted end offsets get size seg count finally write unlock 
protected void invalidate fold levels line mgr set first invalid fold level 
protected void parse buffer local properties int last line  math min get line count parse buffer local properties get segment get line end offset last line first line for last lines make sure not to overlap with the first int first line  math max last line get line count if first line get line count int length get line end offset get line count get line start offset first line parse buffer local properties get segment get line start offset first line length 
 prop value  object value boolean default value if value null throw new  null pointer exception this value value this default value default value 
 for debugging purposes public  string to string return value to string 
private  buffer listener get listener int index return buffer listeners get index listener 
private void content inserted int offset int length  integer array end offsets try transaction true int start line line mgr get line of offset offset int num lines end offsets get size if loading fire pre content inserted start line offset num lines length line mgr content inserted start line offset num lines length end offsets position mgr content inserted offset length set dirty true if loading fire content inserted start line offset num lines length if undo in progress inside compound edit fire transaction complete finally transaction false 
private void parse buffer local properties  char sequence prop  string builder buf new  string builder  string name null boolean escape false for int i i prop length i char c prop char at i switch c case if escape escape false buf append break if name null use the low level property setting code so that if we have a buffer local property with the same value as a default later changes in the default don t affect the buffer local property properties put name new  prop value buf to string false name null buf set length break case if escape escape false buf append break name buf to string buf set length break case if escape buf append escape escape break case n if escape buf append n escape false break case r if escape buf append r escape false break case t if escape buf append t escape false break default buf append c break 
private  list  indent rule get indent rules int line  string mode name null  token marker  line context ctx line mgr get line context line if ctx null ctx rules null mode name ctx rules get mode name if mode name null mode name token marker get main rule set get mode name return  mode provider instance get mode mode name get indent rules 
 instantiate a  text area public j edit embedded text area super j edit get property manager null init input handler  edit pane init painter get painter j edit buffer buffer new j edit buffer buffer set mode  mode provider instance get mode text set buffer buffer 
public  map  string  history model load  map  string  history model models  string settings directory j edit get settings directory if settings directory null return models history new  file  misc utilities construct path settings directory history if history exists return models history mod time history last modified  log log  log message  history model class  loading history if models null models  collections synchronized map new  hash map  string  history model  buffered reader in null try  try loading with utf and fallback to the system default encoding to load a history which was made by an old version as well try  pass the decoder explicitly to report a decode error as an exception instead of replacing with x fffd in new  buffered reader new  input stream reader new  file input stream history  charset for name utf new decoder models put all load from reader in catch  character coding exception e  it seems to be made by an old version of j edit in close  log log  log message  history model class  failed to load history with utf  fallbacking to the system default encoding in new  buffered reader new  file reader history models put all load from reader in catch  file not found exception fnf  log log  log debug  history model class fnf catch io exception io  log log  log error  history model class io finally io utilities close quietly in return models 
public boolean save  map  string  history model models  log log  log message  history model class  saving history  file file new  file  misc utilities construct path j edit get settings directory history save  file file new  file  misc utilities construct path j edit get settings directory history if file exists file last modified history mod time  log log  log warning  history model class file changed on disk will not save history return false j edit backup settings file file  string line sep  system get property line separator  buffered writer out null try out new  buffered writer new  output stream writer new  file output stream file utf if models null  collection  history model values models values for  history model model values if model get size continue out write out write  standard utilities chars to escapes model get name to escape out write out write line sep for int i i model get size i out write  standard utilities chars to escapes model get item i to escape out write line sep out close to avoid data loss only do this if the above completed successfully file delete file rename to file catch io exception io  log log  log error  history model class io finally io utilities close quietly out history mod time file last modified return true 
private static  map  string  history model load from reader  buffered reader in throws io exception  map  string  history model result new  hash map  string  history model  history model current model null  string line while line in read line null if line length line char at line char at line length if current model null result put current model get name current model  string model name  misc utilities escapes to chars line substring line length current model new  history model model name else if current model null throw new io exception  history data starts before model name else current model add element  misc utilities escapes to chars line if current model null result put current model get name current model return result 
j edit kill ring  string settings directory j edit get settings directory if settings directory null killring xml new  settings xml settings directory killring 
 override public void load if killring xml null return if killring xml file exists return  log log  log message  kill ring class  loading killring xml  kill ring handler handler new  kill ring handler try killring xml load handler catch io exception ioe  log log  log error this ioe reset handler list 
 override public void save if killring xml null return if killring xml has changed on disk  log log  log warning  kill ring class killring xml changed on disk will not save killring files return  log log  log message  kill ring class  saving killring xml  string line sep  system get property line separator  settings xml  saver out null try out killring xml open saver out write xml declaration out write doctype killring system killring dtd out write line sep out write killring out write line sep int size get size for int i size i i out write entry out write xml utilities chars to entities get element at i to string true out write entry out write line sep out write killring out write line sep out finish catch  exception e  log log  log error  kill ring class e finally io utilities close quietly out 
 override public  input source resolve entity  string public id  string system id return xml utilities find entity system id killring dtd get class 
 override public void start element  string uri  string local name  string q name  attributes attrs in entry q name equals entry 
 override public void end element  string uri  string local name  string name if name equals entry list add char data to string in entry false char data set length 
 override public void characters char ch int start int length if in entry char data append ch start length 
 override public void processing instruction  string target  string data if illegal xml character equals target char ch try ch char  integer parse int data trim catch  exception e  log log  log error this  failed to get character from pi target with data e return characters new char ch 
j edit mode  string name super name 
 returns a mode property param key  the property name since j edit pre  override public  object get property  string key  string prefix mode name if j edit get boolean property prefix custom settings  string property j edit get property prefix key if property null  object value try value new  integer property catch  number format exception nf value property return value  object value props get key if value null return value  string global j edit get property buffer key if global null try return new  integer global catch  number format exception nf return global else return null 
 loads the mode from disk if it hasn t been loaded already since j edit pre  override public void load if necessary if marker null j edit load mode this if marker null  log log  log error this  mode not correctly loaded token marker is still null 
j edit register saver  string settings directory j edit get settings directory if settings directory null registers xml new  settings xml settings directory registers 
public void load registers if registers xml null return if registers xml file exists return  log log  log message j edit class  loading registers xml  registers handler handler new  registers handler try  registers set loading true registers xml load handler catch io exception ioe  log log  log error  registers class ioe finally  registers set loading false 
public void save registers if registers xml null return if registers xml has changed on disk  log log  log warning  registers class registers xml changed on disk will not save registers return  log log  log message  registers class  saving registers xml  string line sep  system get property line separator  settings xml  saver out null try out registers xml open saver out write xml declaration out write doctype registers system registers dtd out write line sep out write registers out write line sep  registers  register registers  registers get registers for int i i registers length i  registers  register register registers i if register null i i register to string length continue out write register name if i out write quot else out write char i out write out write xml utilities chars to entities register to string false out write register out write line sep out write registers out write line sep out finish catch  exception e  log log  log error  registers class e finally io utilities close quietly out 
 override public  input source resolve entity  string public id  string system id return xml utilities find entity system id registers dtd get class 
 override public void start element  string uri  string local name  string q name  attributes attrs register name attrs get value name in register register equals q name 
 override public void end element  string uri  string local name  string name if register equals name if register name null register name length  log log  log error this  malformed name register name else  registers set register register name char at char data to string in register false char data set length 
 override public void characters char ch int start int length if in register char data append ch start length 
public void register changed char name  edit bus send new  register changed null name 
 creates a new j edit text area public j edit text area  view view super j edit get property manager view enable events awt event focus event mask awt event key event mask this view view 
 override public  fold painter get fold painter  fold painter fold painter  fold painter  service manager get service fold painter service get fold painter name if fold painter null fold painter  fold painter  service manager get service fold painter service default fold painter service return fold painter 
 on subsequent invocations first moves the caret to the first non whitespace character of the line then the beginning of the line then to the first visible line since j edit pre  override public void smart home boolean select  macros  recorder recorder view get macro recorder switch view get input handler get last action count case if recorder null recorder record text area go to start of white space select go to start of white space select break case if recorder null recorder record text area go to start of line select go to start of line select break default case if recorder null recorder record text area go to first visible line select go to first visible line select break 
 on subsequent invocations first moves the caret to the last non whitespace character of the line then the end of the line then to the last visible line since j edit pre  override public void smart end boolean select  macros  recorder recorder view get macro recorder switch view get input handler get last action count case if recorder null recorder record text area go to end of white space select go to end of white space select break case if recorder null recorder record text area go to end of line select go to end of line select break default case if recorder null recorder record text area go to last visible line select go to last visible line select break 
public void go to buffer end boolean select  edit bus send new  position changing this super go to buffer end select 
 moves the caret to the bracket matching the one before the caret  also sends  position changing if it goes somewhere since j edit pre public void go to matching bracket if get line length caret line int dot caret get line start offset caret line int bracket  text utilities find matching bracket buffer caret line  math max dot if bracket  edit bus send new  position changing this select none move caret position bracket false return get toolkit beep 
public void go to buffer start boolean select  edit bus send new  position changing this super go to buffer start select 
 override public int replace selection  string selected text  edit bus send new  position changing this return super replace selection selected text 
 displays the go to line dialog box and moves the caret to the specified line number since j edit pre public void show go to line dialog  string line gui utilities input view goto line null if line null return try int line number  integer parse int line  edit bus send new  position changing this set caret position get line start offset line number catch  exception e get toolkit beep 
 handles the insertion of the specified character  it performs the following operations in addition to  text area user input char ul li  inserting a space with automatic abbrev expansion enabled will try to expand the abbrev ul param ch  the character since j edit pre  override public void user input char ch if ch  abbrevs get expand on input  abbrevs expand abbrev view false return super user input ch 
 surrounds the selection with explicit fold markers since j edit pre  override public void add explicit fold try super add explicit fold catch  text area exception e gui utilities error view folding not explicit null 
 formats the paragraph containing the caret since j edit pre  override public void format paragraph try super format paragraph catch  text area exception e gui utilities error view format maxlinelen null 
protected static void do word count  view view  string text char chars text to char array int characters chars length int words int lines boolean word true for int i i chars length i switch chars i case r case n lines case case t word true break default if word words word false break  object args characters words lines gui utilities message view wordcount args 
 displays the word count dialog box since j edit pre public void show word count dialog  string selection get selected text if selection null do word count view selection return do word count view buffer get text buffer get length 
 returns this text area s view since j edit pre public  view get view return view 
deprecated  instead obtain a  selection instance using any means and call its code get start code method  deprecated public final int get selection start if get selection count return caret return get selection get start 
deprecated  instead obtain a  selection instance using any means and call its code get start int code method  deprecated public int get selection start int line if get selection count return caret return get selection get start buffer line 
deprecated  instead obtain a  selection instance using any means and call its code get start line code method  deprecated public final int get selection start line if get selection count return caret return get selection get start line 
deprecated  do not use  deprecated public final void set selection start int selection start int selection end get selection count get selection get end caret set selection new  selection  range selection start selection end move caret position selection end true 
deprecated  instead obtain a  selection instance using any means and call its code get end code method  deprecated public final int get selection end return get selection count get selection get end caret 
deprecated  instead obtain a  selection instance using any means and call its code get end int code method  deprecated public int get selection end int line if get selection count return caret return get selection get end buffer line 
deprecated  instead obtain a  selection instance using any means and call its code get end line code method  deprecated public final int get selection end line if get selection count return caret return get selection get end line 
deprecated  do not use  deprecated public final void set selection end int selection end int selection start get selection count get selection get start caret set selection new  selection  range selection start selection end move caret position selection end true 
deprecated  instead call either code add to selection code or code set selection code with a new  selection instance  deprecated public void select int start int end set selection new  selection  range start end move caret position end true 
deprecated  instead call either code add to selection code or code set selection code with a new  selection instance  deprecated public void select int start int end boolean do electric scroll select none int new start new end if start end new start start new end end else new start end new end start set selection new  selection  range new start new end move caret position end do electric scroll 
deprecated  instead check if the appropriate  selection is an instance of the  selection  rect class  deprecated public boolean is selection rectangular  selection s get selection at offset caret return s null s instanceof  selection  rect 
public static  string get fold painter name return j edit get property fold painter property default fold painter service 
 do the same thing as right clicking on the text area  the  gestures plugin uses this api since j edit pre  override public void handle popup trigger  mouse event evt if popup is visible popup set visible false else  rebuild popup menu every time the menu is requested create popup menu evt int x evt get x int y evt get y int drag start xy to offset x y painter is block caret enabled is overwrite enabled if get selection count multi move caret position drag start false gui utilities show popup menu popup painter x y 
 creates the popup menu since pre  override public void create popup menu  mouse event evt popup gui utilities load popup menu view context this evt j menu item customize new j menu item j edit get property view context customize customize add action listener new  action listener public void action performed  action event evt new  global options view context popup add separator popup add customize 
 shows the popup menu below the current caret position since pre  override public void show popup menu if popup is visible has focus  point caret pos offset to xy get caret position if caret pos null  open the context menu below the caret int char height get painter get font metrics get height gui utilities show popup menu popup painter caret pos x caret pos y char height true 
 visit a view param view the visited view public void visit  view view 
 visit an  edit pane param edit pane the visited edit pane public void visit  edit pane edit pane 
 visit a j edit text area param text area the visited text area public void visit j edit text area text area 
jjt parser state nodes new java util  stack marks new java util  stack sp mk 
boolean node created return node created 
void reset nodes remove all elements marks remove all elements sp mk 
 node root node return  node nodes element at 
void push node  node n nodes push n sp 
 node pop node if sp mk mk  integer marks pop int value return  node nodes pop 
 node peek node return  node nodes peek 
int node arity return sp mk 
void clear node scope  node n while sp mk pop node mk  integer marks pop int value 
void open node scope  node n marks push new  integer mk mk sp n jjt open 
void close node scope  node n int num mk  integer marks pop int value while num  node c pop node c jjt set parent n n jjt add child c num n jjt close push node n node created true 
void close node scope  node n boolean condition if condition int a node arity mk  integer marks pop int value while a  node c pop node c jjt set parent n n jjt add child c a n jjt close push node n node created true else mk  integer marks pop int value node created false 
j this  name space namespace  interpreter declaring interp super namespace declaring interp 
public  string to string return this reference j this to  bsh object namespace get name 
void event  string name  object event  call stack callstack new  call stack namespace  bsh method method null handle event gets all events try method namespace get method handle event new  class null catch  util eval error e squeltch if method null try method invoke new  object event declaring interpreter callstack null catch  eval error e declaring interpreter error local event hander method invocation error e send to specific event handler try method namespace get method name new  class null catch  util eval error e squeltch if method null try method invoke new  object event declaring interpreter callstack null catch  eval error e declaring interpreter error local event hander method invocation error e 
public void ancestor added  ancestor event e event ancestor added e 
public void ancestor removed  ancestor event e event ancestor removed e 
public void ancestor moved  ancestor event e event ancestor moved e 
public void caret update  caret event e event caret update e 
public void editing stopped  change event e event editing stopped e 
public void editing canceled  change event e event editing canceled e 
public void state changed  change event e event state changed e 
public void insert update  document event e event insert update e 
public void remove update  document event e event remove update e 
public void changed update  document event e event changed update e 
public void hyperlink update  hyperlink event e event internal frame opened e 
public void internal frame opened  internal frame event e event internal frame opened e 
public void internal frame closing  internal frame event e event internal frame closing e 
public void internal frame closed  internal frame event e event internal frame closed e 
public void internal frame iconified  internal frame event e event internal frame iconified e 
public void internal frame deiconified  internal frame event e event internal frame deiconified e 
public void internal frame activated  internal frame event e event internal frame activated e 
public void internal frame deactivated  internal frame event e event internal frame deactivated e 
public void interval added  list data event e event interval added e 
public void interval removed  list data event e event interval removed e 
public void contents changed  list data event e event contents changed e 
public void value changed  list selection event e event value changed e 
public void menu drag mouse entered  menu drag mouse event e event menu drag mouse entered e 
public void menu drag mouse exited  menu drag mouse event e event menu drag mouse exited e 
public void menu drag mouse dragged  menu drag mouse event e event menu drag mouse dragged e 
public void menu drag mouse released  menu drag mouse event e event menu drag mouse released e 
public void menu key typed  menu key event e event menu key typed e 
public void menu key pressed  menu key event e event menu key pressed e 
public void menu key released  menu key event e event menu key released e 
public void menu selected  menu event e event menu selected e 
public void menu deselected  menu event e event menu deselected e 
public void menu canceled  menu event e event menu canceled e 
public void popup menu will become visible  popup menu event e event popup menu will become visible e 
public void popup menu will become invisible  popup menu event e event popup menu will become invisible e 
public void popup menu canceled  popup menu event e event popup menu canceled e 
public void column added  table column model event e event column added e 
public void column removed  table column model event e event column removed e 
public void column moved  table column model event e event column moved e 
public void column margin changed  change event e event column margin changed e 
public void column selection changed  list selection event e event column selection changed e 
public void table changed  table model event e event table changed e 
public void tree expanded  tree expansion event e event tree expanded e 
public void tree collapsed  tree expansion event e event tree collapsed e 
public void tree nodes changed  tree model event e event tree nodes changed e 
public void tree nodes inserted  tree model event e event tree nodes inserted e 
public void tree nodes removed  tree model event e event tree nodes removed e 
public void tree structure changed  tree model event e event tree structure changed e 
public void value changed  tree selection event e event value changed e 
public void tree will expand  tree expansion event e event tree will expand e 
public void tree will collapse  tree expansion event e event tree will collapse e 
public void undoable edit happened  undoable edit event e event undoable edit happened e 
public void action performed  action event e event action performed e 
public void adjustment value changed  adjustment event e event adjustment value changed e 
public void component resized  component event e event component resized e 
public void component moved  component event e event component moved e 
public void component shown  component event e event component shown e 
public void component hidden  component event e event component hidden e 
public void component added  container event e event component added e 
public void component removed  container event e event component removed e 
public void focus gained  focus event e event focus gained e 
public void focus lost  focus event e event focus lost e 
public void item state changed  item event e event item state changed e 
public void key typed  key event e event key typed e 
public void key pressed  key event e event key pressed e 
public void key released  key event e event key released e 
public void mouse clicked  mouse event e event mouse clicked e 
public void mouse pressed  mouse event e event mouse pressed e 
public void mouse released  mouse event e event mouse released e 
public void mouse entered  mouse event e event mouse entered e 
public void mouse exited  mouse event e event mouse exited e 
public void mouse dragged  mouse event e event mouse dragged e 
public void mouse moved  mouse event e event mouse moved e 
public void text value changed  text event e event text value changed e 
public void window opened  window event e event window opened e 
public void window closing  window event e event window closing e 
public void window closed  window event e event window closed e 
public void window iconified  window event e event window iconified e 
public void window deiconified  window event e event window deiconified e 
public void window activated  window event e event window activated e 
public void window deactivated  window event e event window deactivated e 
public void property change  property change event e event property change e 
public void vetoable change  property change event e event vetoable change e 
public boolean image update java awt  image img int infoflags int x int y int width int height  bsh method method null try method namespace get method image update new  class null null null null null null catch  util eval error e squeltch if method null try  call stack callstack new  call stack namespace method invoke new  object img new  primitive infoflags new  primitive x new  primitive y new  primitive width new  primitive height declaring interpreter callstack null catch  eval error e declaring interpreter error local event handler image update method invocation error e return true 
 adds a keyboard translation param key  translate this key param key  into this key since j edit pre public static void add translation  key key  key key trans map put key key 
 pass this an event from link  key event workaround process key event java awt event  key event param evt the  key event to translate since j edit pre public static  key translate key event  key event evt  key key translate key event evt if key null if key is phantom key null return key 
 pass this an event from link  key event workaround process key event java awt event  key event param evt the  key event to translate since j edit pre public static  key translate key event  key event evt int modifiers evt get modifiers  key return value switch evt get id case  key event key pressed int key code evt get key code if key code  key event vk  key code  key event vk  key code  key event vk a key code  key event vk z if  debug alternative dispatcher return null else return value new  key modifiers to string modifiers  character to lower case char key code else if key code  key event vk tab evt consume return value new  key modifiers to string modifiers key code else if key code  key event vk space for space or s space we pass the key typed since international keyboards sometimes produce a key pressed space but not a key typed space eg if you have to do a space to insert if modifiers  input event shift mask return value null else return value new  key modifiers to string modifiers else return value new  key modifiers to string modifiers key code break case  key event key typed char ch evt get key char if  key event workaround is mac control evt ch x switch ch case n case t case b return null case if modifiers  input event shift mask return null int ignore mods if  debug alt key pressed disabled on  mac os a can be user input ignore mods  input event shift mask  input event alt graph mask  input event alt mask else on  mac os a can be user input ignore mods  input event shift mask  input event alt graph mask if modifiers  input event alt graph mask modifiers ignore mods if  debug alternative dispatcher return value new  key modifiers to string modifiers ch else return null else if ch return value new  key modifiers to string modifiers ch else return value new  key null ch break default return null i guess translated events do not have the evt field set so consuming won t work i don t think this is a problem as nothing uses translation anyway  key trans trans map get return value if trans null return return value else return trans 
 converts a string to a keystroke  the string should be of the form i modifiers i i shortcut i where i modifiers i is any combination of a for  alt c for  control s for  shift or m for  meta and i shortcut i is either a single character or a keycode name from the code  key event code class without the code vk  code prefix param key stroke a string description of the key stroke since j edit pre public static  key parse key  string key stroke if key stroke null return null int modifiers  string key int end of modifiers key stroke index of if end of modifiers not found or found at first key key stroke else for int i i end of modifiers i switch  character to upper case key stroke char at i case a modifiers a break case c modifiers c break case m modifiers m break case s modifiers s break key key stroke substring end of modifiers if key length return new  key modifiers to string modifiers key char at else if key length  log log  log error  key event translator class  invalid key stroke key stroke return null else if key equals space return new  key modifiers to string modifiers else int ch try ch  key event class get field vk  concat key get int null catch  exception e  log log  log error  key event translator class  invalid key stroke key stroke return null return new  key modifiers to string modifiers ch 
 changes the mapping between symbolic modifier key names code c code code a code code m code code s code and  java modifier flags  you can map more than one  java modifier to a symobolic modifier for example p code pre set modifier mapping  input event ctrl mask  input event alt mask  input event meta mask  input event shift mask pre code p  you cannot map a  java modifer to more than one symbolic modifier param c  the modifier s to map the code c code modifier to param a  the modifier s to map the code a code modifier to param m  the modifier s to map the code m code modifier to param s  the modifier s to map the code s code modifier to since j edit pre public static void set modifier mapping int c int a int m int s int duplicate mapping c a c m c s a m a s m s if duplicate mapping  input event ctrl mask throw new  illegal argument exception ctrl is mapped to more than one modifier if duplicate mapping  input event alt mask throw new  illegal argument exception alt is mapped to more than one modifier if duplicate mapping  input event meta mask throw new  illegal argument exception meta is mapped to more than one modifier if duplicate mapping  input event shift mask throw new  illegal argument exception shift is mapped to more than one modifier  key event translator c c  key event translator a a  key event translator m m  key event translator s s 
 returns a the symbolic modifier name for the specified  java modifier flag param mod a modifier constant from code  input event code since j edit pre public static char get symbolic modifier name int mod if mod c return c else if mod a return a else if mod m return m else if mod s return s else return 
public static  string modifiers to string int mods  string builder buf null for int i i mods length i if mods mods i buf lazy append buf get symbolic modifier name mods i if buf null return null else return buf to string 
 returns a string containing symbolic modifier names set in the specified event param evt  the event since j edit pre public static  string get modifier string  input event evt  string builder buf new  string builder if evt is control down buf append get symbolic modifier name  input event ctrl mask if evt is alt down buf append get symbolic modifier name  input event alt mask if evt is meta down buf append get symbolic modifier name  input event meta mask if evt is shift down buf append get symbolic modifier name  input event shift mask return buf length null buf to string 
private static  string builder lazy append  string builder buf char ch if buf null buf new  string builder if buf index of  string value of ch buf append ch return buf 
public  key  string modifiers int key char input this modifiers modifiers this key key this input input hash code key input 
 override public int hash code return hash code 
 override public boolean equals  object o if o instanceof  key  key k  key o if  standard utilities objects equal modifiers k modifiers key k key input k input return true return false 
 override public  string to string return modifiers null modifiers  integer to string key  integer to string input 
public void set is from global context boolean to is from global context to 
public boolean is from global context return is from global context 
public void set is phantom boolean to is phantom to 
public boolean is phantom return is phantom 
public static boolean is bindable int key code switch key code case  key event vk alt case  key event vk alt graph case  key event vk control case  key event vk shift case  key event vk meta case  key event vk dead grave case  key event vk dead acute case  key event vk dead circumflex case  key event vk dead tilde case  key event vk dead macron case  key event vk dead breve case  key event vk dead abovedot case  key event vk dead diaeresis case  key event vk dead abovering case  key event vk dead doubleacute case  key event vk dead caron case  key event vk dead cedilla case  key event vk dead ogonek case  key event vk dead iota case  key event vk dead voiced sound case  key event vk dead semivoiced sound return false default return true 
 we need to know if a keycode can potentially result in a keytyped since j edit pre public static boolean is printable int key code switch key code case  key event vk enter case  key event vk tab case  key event vk space case  key event vk comma case  key event vk minus case  key event vk period case  key event vk slash case  key event vk  case  key event vk  case  key event vk  case  key event vk  case  key event vk  case  key event vk  case  key event vk  case  key event vk  case  key event vk  case  key event vk  case  key event vk semicolon case  key event vk equals case  key event vk a case  key event vk b case  key event vk c case  key event vk d case  key event vk e case  key event vk f case  key event vk g case  key event vk h case  key event vk i case  key event vk j case  key event vk k case  key event vk l case  key event vk m case  key event vk n case  key event vk o case  key event vk p case  key event vk q case  key event vk r case  key event vk s case  key event vk t case  key event vk u case  key event vk v case  key event vk w case  key event vk x case  key event vk y case  key event vk z case  key event vk open bracket case  key event vk back slash case  key event vk close bracket case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk multiply case  key event vk add case  key event vk separator case  key event vk subtract case  key event vk decimal case  key event vk divide case  key event vk back quote case  key event vk quote case  key event vk dead grave case  key event vk dead acute case  key event vk dead circumflex case  key event vk dead tilde case  key event vk dead macron case  key event vk dead breve case  key event vk dead abovedot case  key event vk dead diaeresis case  key event vk dead abovering case  key event vk dead doubleacute case  key event vk dead caron case  key event vk dead cedilla case  key event vk dead ogonek case  key event vk dead iota case  key event vk dead voiced sound case  key event vk dead semivoiced sound case  key event vk ampersand case  key event vk asterisk case  key event vk quotedbl case  key event vk less case  key event vk greater case  key event vk braceleft case  key event vk braceright case  key event vk at case  key event vk colon case  key event vk circumflex case  key event vk dollar case  key event vk euro sign case  key event vk exclamation mark case  key event vk inverted exclamation mark case  key event vk left parenthesis case  key event vk number sign case  key event vk plus case  key event vk right parenthesis case  key event vk underscore return true default return false 
 apple sucks public static boolean is mac control  key event evt return  operating system is mac os evt get modifiers  input event ctrl mask evt get key char x b 
public static boolean is numeric keypad int key code switch key code case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk numpad case  key event vk multiply case  key event vk add case  key event vk separator case  key event vk subtract case  key event vk decimal case  key event vk divide return true default return false 
public static  key event process key event  key event evt int key code evt get key code char ch evt get key char int modifiers evt get modifiers switch evt get id key pressed case  key event key pressed get rid of keys we never need to handle switch key code case return null case  key event vk alt case  key event vk alt graph case  key event vk control case  key event vk shift case  key event vk meta break default if evt is meta down if evt is control down evt is alt down if is printable key code return null if  debug alt key pressed disabled we don t handle key pressed a they re too troublesome if modifiers  input event alt mask return null if is numeric keypad key code last last numkeypad else last last nothing break break key typed case  key event key typed need to let b through so that backspace will work in  history text fields if is mac control evt ch x ch x f ch xff ch b ch t ch n return null if  debug dump key events  log log  log debug ke wa  key event working around  abstract input handler to string evt last last if  debug alternative dispatcher if modifiers  input event ctrl mask modifiers  input event alt mask modifiers  input event meta mask return null if the last key was a numeric keypad key and  num lock is off filter it out if last last numkeypad last last nothing if ch ch ch ch ch ch ch return null  windows jdk workaround else if last last alt last last nothing switch ch case b case m case x case c case case case return null break key released case  key event key released switch key code case  key event vk alt we consume this to work around the bug where a tab window switching activates the menu bar on  windows evt consume break case  key event vk alt graph case  key event vk control case  key event vk shift case  key event vk meta break case  key event vk left case  key event vk right case  key event vk up case  key event vk down case  key event vk page up case  key event vk page down case  key event vk end case  key event vk home workaround for a keys producing garbage on  windows if modifiers  input event alt mask last last alt break break return evt 
a workaround for non working  num lock status in some  java versions since j edit pre public static void numeric keypad key last last nothing 
 creates a new code  keyword map code param ignore case  true if keys are case insensitive public  keyword map boolean ignore case this ignore case this ignore case ignore case no word sep new  string builder 
 creates a new code  keyword map code param ignore case  true if the keys are case insensitive param map length  the number of buckets to create a value of will give good performance for most maps public  keyword map boolean ignore case int map length this map length map length this ignore case ignore case map new  keyword map length 
 looks up a key param text  the text segment param offset  the offset of the substring within the text segment param length  the length of the substring public byte lookup  segment text int offset int length if length return  token null  keyword k map get segment map key text offset length while k null if length k keyword length k k next continue if  syntax utilities region matches ignore case text offset k keyword return k id k k next return  token null 
 adds a key value mapping param keyword  the key param id  the value public void add  string keyword byte id add keyword to char array id 
 adds a key value mapping param keyword  the key param id  the value since j edit pre public void add char keyword byte id int key get string map key keyword complete word command needs a list of all non alphanumeric characters used in a keyword map loop for int i i keyword length i char ch keyword i if  character is letter or digit ch for int j j no word sep length j if no word sep char at j ch continue loop no word sep append ch map key new  keyword keyword id map key 
 returns all non alphanumeric characters that appear in the keywords of this keyword map since j edit pre public  string get non alpha numeric chars return no word sep to string 
 returns an array containing all keywords in this keyword map since j edit pre public  string get keywords  list  string vector new  array list  string for int i i map length i  keyword keyword map i while keyword null vector add new  string keyword keyword keyword keyword next  string ret val new  string vector size vector to array ret val return ret val 
 returns true if the keyword map is set to be case insensitive false otherwise public boolean get ignore case return ignore case 
 sets if the keyword map should be case insensitive param ignore case  true if the keyword map should be case insensitive false otherwise public void set ignore case boolean ignore case this ignore case ignore case 
 adds the content of another keyword map to this one since j edit pre public void add  keyword map map for int i i map map length i  keyword k map map i while k null add k keyword k id k k next 
private int get string map key char s return  character to upper case s  character to upper case s s length map length 
protected int get segment map key  segment s int off int len return  character to upper case s array off  character to upper case s array off len map length 
 keyword char keyword byte id  keyword next this keyword keyword this id id this next next 
public static  kill ring get instance return kill ring 
public static void set instance  kill ring kill ring  kill ring kill ring kill ring 
public void properties changed int history size int new size  math max history size if ring null ring new  undo manager  removed content new size else if new size ring length  undo manager  removed content new ring new  undo manager  removed content new size int new count  math min get size new size for int i i new count i new ring i  undo manager  removed content get element at i ring new ring count new count wrap false if count ring length count wrap true 
public void load 
public void save 
 this method is made to be used by implementation of load method to initialize or reset the killring by a loaded sequence of objects  each element is converted to an element of the killring as followings  if it is a  string it is converted as if it is a result of get element at n to string  otherwise it is converted as if it is a  object which was obtained by get element at n since j edit pre protected void reset  list source  undo manager  removed content new ring new  undo manager  removed content source size int i for  object x source  undo manager  removed content element if x instanceof  string element new  undo manager  removed content  string x else element  undo manager  removed content x new ring i element ring new ring count wrap true 
public void add list data listener  list data listener listener 
public void remove list data listener  list data listener listener 
public  object get element at int index return ring virtual to physical index index 
public int get size if wrap return ring length else return count 
public boolean remove element  object value for int i i get size i if ring i equals value remove i return true return false 
public void insert element at  object value int index  this is not terribly efficient but this method is only called by the  paste  deleted dialog where the performance is not exactly vital remove index add  undo manager  removed content value 
void changed  undo manager  removed content rem if rem in kill ring compare existing entries hashcode with this int length wrap ring length count int kill for int i i length i if ring i rem ring i hashcode rem hashcode ring i str equals rem str we don t want duplicate entries in the kill ring kill i break if kill remove kill else add rem 
void add  undo manager  removed content rem compare existing entries hashcode with this int length wrap ring length count for int i i length i if ring i hashcode rem hashcode strings might be equal if ring i str equals rem str we don t want duplicate entries in the kill ring return no duplicates check for all whitespace string boolean all whitespace true for int i i rem str length i if  character is whitespace rem str char at i all whitespace false break if all whitespace return rem in kill ring true if ring count null ring count in kill ring false ring count rem if count ring length wrap true count 
void remove int i if wrap  undo manager  removed content new ring new  undo manager  removed content ring length int new count for int j j ring length j int index virtual to physical index j if i index ring index in kill ring false continue new ring new count ring index ring new ring count new count wrap false else  system arraycopy ring i ring i count i count 
 since the kill ring has a wrap around representation we need to convert user visible indices to actual indices in the array private int virtual to physical index int index if wrap if index count return count index else return count ring length index else return count index 
 constructs a new label public  label 
 puts a reference to this label in the bytecode of a method  if the position of the label is known the offset is computed and written directly  otherwise a null offset is written and a new forward reference is declared for this label param owner the code writer that calls this method param out the bytecode of the method param source the position of first byte of the bytecode instruction that contains this label param wide offset tt true tt if the reference must be stored in bytes or tt false tt if it must be stored with bytes throws  illegal argument exception if this label has not been created by the given code writer void put final  code writer owner final  byte vector out final int source final boolean wide offset if  code writer check if this owner null this owner owner else if this owner owner throw new  illegal argument exception if resolved if wide offset out put position source else out put position source else if wide offset add reference source out length out put else add reference source out length out put 
 adds a forward reference to this label  this method must be called only for a true forward reference i e only if this label is not resolved yet  for backward references the offset of the reference can be and must be computed and stored directly param source position the position of the referencing instruction  this position will be used to compute the offset of this forward reference param reference position the position where the offset for this forward reference must be stored private void add reference final int source position final int reference position if src and ref positions null src and ref positions new int if reference count src and ref positions length int a new int src and ref positions length  system arraycopy src and ref positions a src and ref positions length src and ref positions a src and ref positions reference count source position src and ref positions reference count reference position 
 resolves all forward references to this label  this method must be called when this label is added to the bytecode of the method i e when its position becomes known  this method fills in the blanks that where left in the bytecode by each forward reference previously added to this label param owner the code writer that calls this method param position the position of this label in the bytecode param data the bytecode of the method return tt true tt if a blank that was left for this label was to small to store the offset  in such a case the corresponding jump instruction is replaced with a pseudo instruction using unused opcodes using an unsigned two bytes offset  these pseudo instructions will need to be replaced with true instructions with wider offsets bytes instead of  this is done in link  code writer resize instructions throws  illegal argument exception if this label has already been resolved or if it has not been created by the given code writer boolean resolve final  code writer owner final int position final byte data if  code writer check if this owner null this owner owner if resolved this owner owner throw new  illegal argument exception boolean need update false this resolved true this position position int i while i reference count int source src and ref positions i int reference src and ref positions i int offset if source offset position source if offset  short min value offset  short max value changes the opcode of the jump instruction in order to be able to find it later see resize instructions in  code writer  these temporary opcodes are similar to jump instruction opcodes except that the bytes offset is unsigned and can therefore represent values from to which is sufficient since the size of a method is limited to bytes int opcode data reference x ff if opcode  constants jsr changes ifeq jsr to opcodes to inclusive data reference byte opcode else changes ifnull and ifnonnull to opcodes and inclusive data reference byte opcode need update true data reference byte offset data reference byte offset else offset position source data reference byte offset data reference byte offset data reference byte offset data reference byte offset return need update 
 variable lhs constructor lhs  name space name space  string var name throw new  error namespace lhs type variable this var name var name this name space name space 
param local var if true the variable is set directly in the  this reference s local scope  if false recursion to look for the variable definition in parent s scope is allowed e g the default case for undefined vars going to global lhs  name space name space  string var name boolean local var type variable this local var local var this var name var name this name space name space 
 static field lhs  constructor  this simply calls  object field constructor with null object lhs  field field type field this object null this field field 
 object field lhs  constructor lhs  object object  field field if object null throw new  null pointer exception constructed empty lhs type field this object object this field field 
 object property lhs  constructor lhs  object object  string prop name if object null throw new  null pointer exception constructed empty lhs type property this object object this prop name prop name 
 array index lhs  constructor lhs  object array int index if array null throw new  null pointer exception constructed empty lhs type index this object array this index index 
public  object get value throws  util eval error if type variable return name space get variable var name if type field try  object o field get object return  primitive wrap o field get type catch  illegal access exception e throw new  util eval error  can t read field field if type property try return  reflect get object property object prop name catch  reflect error e  interpreter debug e get message throw new  util eval error  no such property prop name if type index try return  reflect get index object index catch  exception e throw new  util eval error  array access e throw new  interpreter error lhs type 
 assign a value to the lhs public  object assign  object val boolean strict java throws  util eval error if type variable  set the variable in namespace according to local var flag if local var name space set local variable var name val strict java else name space set variable var name val strict java else if type field try  object field val val instanceof  primitive  primitive val get value val  this should probably be in  reflect java  reflect manager rm set accessible field field set object field val return val catch  null pointer exception e throw new  util eval error lhs field get name not a static field catch  illegal access exception e throw new  util eval error lhs field get name can t access field e catch  illegal argument exception e  string type val instanceof  primitive  primitive val get type get name val get class get name throw new  util eval error  argument type mismatch val null null type not assignable to field field get name else if type property if object instanceof  hashtable  hashtable object put prop name val  collection manager cm  collection manager get collection manager if cm is map object cm put in map object map prop name val else try  reflect set object property object prop name val catch  reflect error e  interpreter debug  assignment e get message throw new  util eval error  no such property prop name else if type index try  reflect set index object index val catch  util target error e pass along target error throw e catch  exception e throw new  util eval error  assignment e get message else throw new  interpreter error unknown lhs return val 
public  string to string return lhs field null field field to string var name null var name var name name space null name space name space to string 
public  line manager end offsets new int end offsets fold levels new short line context new  token marker  line context line count 
public final int get line count return line count 
public int get line of offset int offset int start int end line count for switch end start case if get line end offset start offset return start else return start case if get line end offset start offset if get line end offset end offset return end else return end else return start default int pivot end start int value get line end offset pivot if value offset return pivot else if value offset start pivot else end pivot break 
public final int get line end offset int line if gap line line gap line return end offsets line gap width else return end offsets line 
public final int get fold level int line return fold levels line 
public final void set fold level int line int level if level xffff limitations level xffff fold levels line short level 
public void set first invalid fold level int first invalid fold level this first invalid fold level first invalid fold level 
public int get first invalid fold level return first invalid fold level 
public final  token marker  line context get line context int line return line context line 
public final void set line context int line  token marker  line context context line context line context 
public void set first invalid line context int first invalid line context this first invalid line context first invalid line context 
public int get first invalid line context return first invalid line context 
public void  content inserted  integer array end offsets gap line gap width first invalid line context first invalid fold level line count end offsets get size this end offsets end offsets get array fold levels new short line count line context new  token marker  line context line count 
public void content inserted int start line int offset int num lines int length  integer array end offsets int end line start line num lines  update line info and line context arrays if num lines move gap content inserted line count num lines if this end offsets length line count int end offsets n new int line count  system arraycopy this end offsets end offsets n this end offsets length this end offsets end offsets n if fold levels length line count short fold levels n new short line count  system arraycopy fold levels fold levels n fold levels length fold levels fold levels n if line context length line count  token marker  line context line context n new  token marker  line context line count  system arraycopy line context line context n line context length line context line context n  system arraycopy this end offsets start line this end offsets end line line count end line  system arraycopy fold levels start line fold levels end line line count end line  system arraycopy line context start line line context end line line count end line if start line gap line gap line num lines else if gap line offset gap width if start line first invalid line context first invalid line context num lines for int i i num lines i this end offsets start line i offset end offsets get i fold levels start line i if first invalid fold level first invalid fold level start line first invalid fold level start line move gap end line length content inserted 
public void content removed int start line int offset int num lines int length int end line start line num lines  update line info and line context arrays if num lines move gap content removed if start line num lines gap line gap line num lines else if start line gap line gap line start line if start line num lines first invalid line context first invalid line context num lines else if start line first invalid line context first invalid line context start line line count num lines  system arraycopy end offsets end line end offsets start line line count start line  system arraycopy fold levels end line fold levels start line line count start line  system arraycopy line context end line line context start line line count start line if first invalid fold level first invalid fold level start line first invalid fold level start line move gap start line length content removed 
private final void set line end offset int line int end end offsets line end 
private final void move gap int new gap line int new gap width  string method if gap line gap width new gap width else if new gap line if gap width if  debug offset debug gap line line count  log log  log debug this method update from gap line to line count width gap width for int i gap line i line count i set line end offset i get line end offset i gap width new gap width else if new gap line gap line if gap width if  debug offset debug new gap line gap line  log log  log debug this method update from new gap line to gap line width gap width for int i new gap line i gap line i set line end offset i get line end offset i gap width gap width new gap width else if new gap line gap line if gap width if  debug offset debug gap line new gap line  log log  log debug this method update from gap line to new gap line width gap width for int i gap line i new gap line i set line end offset i get line end offset i gap width new gap width if new gap line line count gap line else gap line new gap line 
public  widget get widget  view view  widget line sep new  line sep widget view return line sep 
 line sep widget final  view view line sep new  tool tip label line sep set horizontal alignment  swing constants center line sep set tool tip text j edit get property view status linesep tooltip this view view line sep add mouse listener new  mouse adapter  override public void mouse clicked  mouse event evt view get buffer toggle line separator view 
public j component get component return line sep 
public void update  buffer buffer view get buffer  string line sep buffer get string property j edit buffer linesep if n equals line sep this line sep set text u else if r n equals line sep this line sep set text w else if r equals line sep this line sep set text m 
public void properties changed retarded gtk look and feel  font font new j label get font ui manager get font  label font  font metrics fm line sep get font metrics font  dimension dim new  dimension  math max  math max fm char width u fm char width w fm char width m fm get height line sep set preferred size dim line sep set maximum size dim 
public void open  default list model list model final  default table model table model create table model list model final j table table new j table table model table set tool tip text  move  pg up  pg down  edit  double  click or  insert  delete table add key listener new  key adapter public void key pressed  key event e int sel rows table get selected rows if sel rows length return int first selected row sel rows int key e get key code  list selection model selection model table get selection model switch key case  key event vk delete for int i sel rows length i i table model remove row sel rows i if first selected row first selected row table model get row count selection model add selection interval first selected row first selected row e consume avoid beep break case  key event vk insert table model insert row first selected row new  string e consume  dont edit cell break case  key event vk page up case  key event vk page down boolean is up key  key event vk page up int direction is up int min selection model get min selection index direction int max selection model get max selection index direction if min max table model get row count return avoid  array index out of bounds exception for int i i sel rows length i int row sel rows is up i sel rows length i int to row direction selection model remove selection interval row row selection model add selection interval to to table model move row row row to break int result j option pane show confirm dialog null table  change j edit get property history caption j option pane ok cancel option if result j option pane ok option updatelist model list model table model 
private  default table model create table model  default list model list model  object table row data new  string list model size for int i i list model size i table row data i list model get i return new  default table model table row data new  string 
private void updatelist model  default list model list model  default table model table model list model remove all elements for int i i table model get row count i  object cell text table model get value at i if cell text null cell text equals list model add element cell text 
 initializes the log param stdio  if true standard output and error will be sent to the log param level  messages with this log level or higher will be printed to the system console since j edit pre public static void init boolean stdio int level if stdio if  system out real out  system err real err  system set out create print stream notice null  system set err create print stream error null  log level level  log some stuff log message  log class  when reporting bugs please include the following information  string props java version java vm version java runtime version java vendor java compiler os name os version os arch user home java home java class path for int i i props length i log message  log class props i  system get property props i 
 writes all currently logged messages to this stream if there was no stream set previously and sets the stream to write future log messages to param stream  the writer since j edit pre public static void set log writer  writer stream if  log stream null stream null try if wrap for int i log line count i log length i stream write log i stream write line sep for int i i log line count i stream write log i stream write line sep stream flush catch  exception e do nothing who cares  log stream stream 
 flushes the log stream since j edit pre public static void flush stream if stream null try stream flush catch io exception io io print stack trace real err 
 closes the log stream  should be done before your program exits since j edit pre public static void close stream if stream null try stream close stream null catch io exception io io print stack trace real err 
 returns the list model for viewing the log contents since j edit pre public static  list model get log list model return list model 
 logs an exception with a message  if an exception is the cause of a call to link log then the exception should be explicitly provided so that it can be presented to the debugging user in a useful manner not just the exception message but also the exception stack trace since j edit pre public static void log int urgency  object source  object message  throwable exception  we can do nicer here but this is a start log urgency source message log urgency source exception 
 logs a message  this method is thread safe p  the following code sends a typical debugging message to the activity log pre  log log  log debug this counter counter pre  the corresponding activity log entry might read as follows pre debug  java parser counter pre param urgency  the urgency can be one of code  log debug code code  log message code code  log notice code code  log warning code or code  log error code param source  the source of the message either an object or a class instance  when writing log messages from macros set this parameter to code  bean shell class code to make macro errors easier to spot in the activity log param message  the message  this can either be a string or an exception since j edit pre public static void log int urgency  object source  object message  string  source if source null  source  thread current thread get name if  source null  source  thread current thread get class get name else if source instanceof  class  source  class source get name else  source source get class get name int index  source last index of if index  source  source substring index if message instanceof  throwable  log exception urgency source  throwable message else  string  message  string value of message  if multiple threads log stuff we don t want the output to get mixed up synchronized lock  string tokenizer st new  string tokenizer  message r n int line count boolean old wrap wrap while st has more tokens line count  log urgency  source st next token replace t list model update line count old wrap 
private static  print stream create print stream final int urgency final  object source return new  log print stream urgency source 
private static void  log exception final int urgency final  object source final  throwable message  print stream out create print stream urgency source if urgency level synchronized throwables if throwables size max throwables throwables remove throwables add message synchronized lock message print stack trace out 
private static void  log int urgency  string source  string message  string full message time format format new  date  thread current thread get name urgency to string urgency source message try log log line count full message if log line count log length wrap true log line count if stream null stream write full message stream write line sep catch  exception e e print stack trace real err if urgency level if urgency error real err println full message else real out println full message 
private static  string urgency to string int urgency switch urgency case debug return debug case message return message case notice return notice case warning return warning case error return error throw new  illegal argument exception  invalid urgency urgency 
private void fire interval added int index int index for int i i listeners size i  list data listener listener listeners get i listener interval added new  list data event this  list data event interval added index index 
private void fire interval removed int index int index for int i i listeners size i  list data listener listener listeners get i listener interval removed new  list data event this  list data event interval removed index index 
public void add list data listener  list data listener listener listeners add listener 
public void remove list data listener  list data listener listener listeners remove listener 
public  object get element at int index if wrap if index maxlines log line count return log index log line count else return log index maxlines log line count else return log index 
public int get size if wrap return maxlines else return log line count 
void update final int line count final boolean old wrap if line count listeners is empty return  swing utilities invoke later new  runnable public void run if wrap if old wrap fire interval removed line count else fire interval removed log line count fire interval added maxlines line count maxlines else fire interval added log line count line count log line count 
 log print stream int urgency  object source super new  log output stream urgency source buffer new  byte array output stream orig out 
 this is a hack to allow printf to not print weird stuff to the output  since printf doesn t seem to print the whole message in one shot our output stream above would break a line of log into several lines so we buffer the result of the printf call and print the whole thing in one shot a similar hack would be needed for the other printf method but i ll settle for the common case only public  print stream printf  string format  object args synchronized orig buffer reset out buffer super printf format args try byte data buffer to byte array orig write data data length out orig catch io exception ioe don t do anything finally buffer reset return this 
 log output stream int urgency  object source this urgency urgency this source source 
public synchronized void write int b byte barray byte b write barray 
public synchronized void write byte b int off int len  string str new  string b off len log urgency source str 
public  log viewer super new  border layout j panel caption new j panel caption set layout new  box layout caption  box layout x axis caption set border new  empty border  string settings directory j edit get settings directory if settings directory null  string args  misc utilities construct path settings directory activity log j label label new j label j edit get property log viewer caption args caption add label caption add  box create horizontal glue tail is on j edit get boolean property log viewer tail false tail new j check box j edit get property log viewer tail label tail is on tail add action listener new  action handler filter new j text field filter get document add document listener new  document listener public void changed update  document event e set filter public void insert update  document event e set filter public void remove update  document event e set filter caption add filter caption add tail caption add  box create horizontal strut copy new j button j edit get property log viewer copy copy add action listener new  action handler caption add copy  list model model  log get log list model list model new  my filtered list model model without this list model is held permanently in model  see add notify and remove notify and constructor of  filtered list model model remove list data listener list model list new  log list list model list model set list list add  border layout north caption j scroll pane scroller new j scroll pane list  dimension dim scroller get preferred size dim width  math min dim width scroller set preferred size dim add  border layout center scroller properties changed 
 override public void set bounds int x int y int width int height list set cell renderer new  colorizer cell renderer super set bounds x y width height scroll later if required 
public void handle message eb message msg if msg instanceof  properties changed properties changed 
 override public void add notify super add notify  list model model  log get log list model model add list data listener list model model add list data listener list handler new  list handler if tail is on scroll to tail  edit bus add to bus this 
 override public void remove notify super remove notify  list model model  log get log list model model remove list data listener list model model remove list data listener list handler list handler null  edit bus remove from bus this 
public void focus on default component list request focus 
private void set filter list model set filter filter get text scroll later if required 
private void properties changed list set font j edit get font property view font list set fixed cell height list get font metrics list get font get height 
 scroll to the tail of the logs private void scroll to tail int index list get model get size if index list ensure index is visible index 
private void scroll later if required if tail is on  swing utilities invoke later new  runnable public void run scroll to tail 
public void action performed  action event e  object src e get source if src tail tail is on tail is on j edit set boolean property log viewer tail tail is on if tail is on scroll to tail else if src copy  string builder buf new  string builder  object selected list get selected values if selected null selected length for int i i selected length i buf append selected i buf append n else  list model model list get model for int i i model get size i buf append model get element at i buf append n  registers set register buf to string 
public void interval added  list data event e contents changed e 
public void interval removed  list data event e contents changed e 
public void contents changed  list data event e scroll later if required 
 log list  list model model super model set visible row count get selection model set selection mode  list selection model single interval selection set autoscrolls true 
 override public void process mouse event  mouse event evt if evt get id  mouse event mouse pressed start index list location to index evt get point super process mouse event evt 
 override public void process mouse motion event  mouse event evt if evt get id  mouse event mouse dragged int row list location to index evt get point if row if start index list set selection interval row row start index row else list set selection interval start index row list ensure index is visible row evt consume else super process mouse motion event evt 
public  component get list cell renderer component j list list  object value value to display int index cell index boolean is selected is the cell selected boolean cell has focus the list and the cell have the focus  string s value to string set text s if is selected set background list get selection background set foreground list get selection foreground else set background list get background  color color list get foreground if s contains debug color  color blue else if s contains notice color  color green else if s contains warning color  color orange else if s contains error color  color red set foreground color set enabled list is enabled set font list get font set opaque true return this 
 my filtered list model  list model model super model 
 override public  string prepare filter  string filter return filter to lower case 
 override public boolean pass filter int row  string filter return delegated get element at row to string to lower case contains filter 
 prompts for one or more files to run as macros param view  the view since j edit pre public static void show run script dialog  view view  string paths gui utilities show vfs file dialog view null j file chooser open dialog true if paths null  buffer buffer view get buffer try buffer begin compound edit file loop for int i i paths length i run script view paths i false finally buffer end compound edit 
 runs the specified script  unlike the link  bean shell run script  view  string  reader boolean method this method can run scripts supported by any registered macro handler param view  the view param path  the vfs path of the script param ignore unknown  if true then unknown file types will be ignored otherwise a warning message will be printed and they will be evaluated as  bean shell scripts since j edit pre public static void run script  view view  string path boolean ignore unknown  handler handler get handler for path name path if handler null try  macro new macro handler create macro  misc utilities get file name path path new macro invoke view catch  exception e  log log  log error  macros class e return return only executed if above loop falls through ie there is no handler for this file if ignore unknown  log log  log notice  macros class path  cannot find a suitable macro handler else  log log  log error  macros class path  cannot find a suitable macro handler assuming  bean shell get handler beanshell create macro path path invoke view 
 utility method that can be used to display a message dialog in a macro param comp  the component to show the dialog on behalf of this will usually be a view instance param message  the message since j edit pre public static void message  component comp  string message gui utilities hide splash screen j option pane show message dialog comp message j edit get property macro message title j option pane information message 
 utility method that can be used to display an error dialog in a macro param comp  the component to show the dialog on behalf of this will usually be a view instance param message  the message since j edit pre public static void error  component comp  string message gui utilities hide splash screen j option pane show message dialog comp message j edit get property macro message title j option pane error message 
 utility method that can be used to prompt for input in a macro param comp  the component to show the dialog on behalf of this will usually be a view instance param prompt  the prompt string since j edit pre public static  string input  component comp  string prompt gui utilities hide splash screen return input comp prompt null 
 utility method that can be used to prompt for input in a macro param comp  the component to show the dialog on behalf of this will usually be a view instance param prompt  the prompt string since j edit final public static  string input  component comp  string prompt  string default value gui utilities hide splash screen return  string j option pane show input dialog comp prompt j edit get property macro input title j option pane question message null null default value 
 utility method that can be used to ask for confirmation in a macro param comp  the component to show the dialog on behalf of this will usually be a view instance param prompt  the prompt string param buttons  the buttons to display for example j option pane yes no cancel option since j edit pre public static int confirm  component comp  string prompt int buttons gui utilities hide splash screen return j option pane show confirm dialog comp prompt j edit get property macro confirm title buttons j option pane question message 
 utility method that can be used to ask for confirmation in a macro param comp  the component to show the dialog on behalf of this will usually be a view instance param prompt  the prompt string param buttons  the buttons to display for example j option pane yes no cancel option param type  the dialog type for example j option pane warning message public static int confirm  component comp  string prompt int buttons int type gui utilities hide splash screen return j option pane show confirm dialog comp prompt j edit get property macro confirm title buttons type 
 rebuilds the macros list and sends a  macros changed message views update their  macros menu upon receiving it since j edit pre public static void load macros macro action set remove all actions macro hierarchy remove all elements macro hash clear since subsequent macros with the same name are ignored load user macros first so that they override the system macros  string settings j edit get settings directory if settings null user macro path  misc utilities construct path settings macros load macros macro hierarchy new  file user macro path if j edit get j edit home null system macro path  misc utilities construct path j edit get j edit home macros load macros macro hierarchy new  file system macro path  edit bus send new  dynamic menu changed macros 
 adds a macro handler to the handlers list since j edit pre public static void register handler  handler handler if get handler handler get name null  log log  log error  macros class  cannot register more than one macro handler with the same name return  log log  log debug  macros class  registered handler get name macro handler macro handlers add handler 
 returns an array containing the list of registered macro handlers since j edit pre public static  handler get handlers  handler handlers new  handler macro handlers size return macro handlers to array handlers 
 returns the macro handler suitable for running the specified file name or null if there is no suitable handler since j edit pre public static  handler get handler for path name  string path name for int i i macro handlers size i  handler handler macro handlers get i if handler accept path name return handler return null 
 returns the macro handler with the specified name or null if there is no registered handler with that name since j edit pre public static  handler get handler  string name for int i i macro handlers size i  handler handler macro handlers get i if handler get name equals name return handler return null 
 returns a vector hierarchy with all known macros in it  each element of this vector is either a macro name string or another vector  if it is a vector the first element is a string label the rest are again either macro name strings or vectors since j edit pre public static  vector get macro hierarchy return macro hierarchy 
 returns an action set with all known macros in it since j edit pre public static  action set get macro action set return macro action set 
 returns the macro with the specified name param macro  the macro s name since j edit pre public static  macro get macro  string macro return macro hash get macro 
since j edit pre public static  macro get last macro return last macro 
since j edit pre public static void set last macro  macro macro last macro macro 
public  macro  handler handler  string name  string label  string path super name this handler handler this label label this path path 
public  handler get handler return handler 
public  string get path return path 
 override public void invoke  view view set last macro this if view null handler run macro null this else try view get buffer begin compound edit handler run macro view this finally view get buffer end compound edit 
 override public  string get code return  macros get macro get name invoke view 
public static  string macro name to label  string macro name int index macro name last index of return macro name substring index replace   
 starts recording a temporary macro param view  the view since j edit pre public static void record temporary macro  view view  string settings j edit get settings directory if settings null gui utilities error view no settings new  string return if view get macro recorder null gui utilities error view already recording new  string return  buffer buffer j edit open file  view null settings  file separator macros  temporary  macro bsh true null if buffer null return buffer remove buffer get length buffer insert j edit get property macro temp header record macro view buffer true 
 starts recording a macro param view  the view since j edit pre public static void record macro  view view  string settings j edit get settings directory if settings null gui utilities error view no settings new  string return if view get macro recorder null gui utilities error view already recording new  string return  string name gui utilities input view record null if name null return name name replace    buffer buffer j edit open file  view null null  misc utilities construct path settings macros name bsh true null if buffer null return buffer remove buffer get length buffer insert j edit get property macro header record macro view buffer false 
 stops a recording currently in progress param view  the view since j edit pre public static void stop recording  view view  recorder recorder view get macro recorder if recorder null gui utilities error view macro not recording null else view set macro recorder null if recorder temporary view set buffer recorder buffer recorder dispose 
 runs the temporary macro param view  the view since j edit pre public static void run temporary macro  view view  string settings j edit get settings directory if settings null gui utilities error view no settings null return  string path  misc utilities construct path j edit get settings directory macros  temporary  macro bsh if j edit get buffer path null gui utilities error view no temp macro null return  handler handler get handler beanshell  macro temp handler create macro path path  buffer buffer view get buffer try buffer begin compound edit temp invoke view finally i already wrote a comment expaining this in  macro invoke if buffer inside compound edit buffer end compound edit 
private static void load macros  list vector  string path  file directory last macro null  file macro files directory list files if macro files null macro files length return for int i i macro files length i  file file macro files i  string file name file get name if file is hidden do nothing else if file is directory  string submenu name file name replace    list submenu null try to merge with an existing menu first for int j j vector size j  object obj vector get j if obj instanceof  list  list vec  list obj if submenu name equals vec get submenu vec break if submenu null submenu new  vector submenu add submenu name vector add submenu load macros submenu path file name file else add macro file path vector 
private static void add macro  file file  string path  list vector  string file name file get name  handler handler get handler for path name file get path if handler null return try in case macro file name has a space in it spaces break the view tool bar property for instance since it uses spaces to delimit action names  string macro name path file name replace    macro new macro handler create macro macro name file get path ignore if already added see comment in load macros if macro hash get new macro get name null return vector add new macro get name j edit set temporary property new macro get name label new macro label j edit set temporary property new macro get name mouse over handler get label file get path macro action set add action new macro macro hash put new macro get name new macro catch  exception e  log log  log error  macros class e macro handlers remove handler 
 starts recording a macro param view  the view param buffer  the buffer to record to param temporary  true if this is a temporary macro since j edit pre private static void record macro  view view  buffer buffer boolean temporary view set macro recorder new  recorder view buffer temporary setting the message to null causes the status bar to check if a recording is in progress view get status set message null 
public  recorder  view view  buffer buffer boolean temporary this view view this buffer buffer this temporary temporary  edit bus add to bus this 
public void record  string code if  bean shell is script running return flush input append n append code 
public void record int repeat  string code if repeat record code else record for int i i repeat i n n code n 
since j edit pre public void record input int repeat char ch boolean overwrite record n and t on lines specially so that auto indent can take place if ch n record repeat text area user input n else if ch t record repeat text area user input t else  string builder buf new  string builder repeat for int i i repeat i buf append ch record input buf to string overwrite 
since j edit pre public void record input  string str boolean overwrite  string char str  standard utilities chars to escapes str if overwrite if last was overwrite overwrite count append char str else flush input overwrite count last was overwrite true append ntext area set selected text char str else if last was input append char str else flush input last was input true append ntext area set selected text char str 
public void handle message eb message msg if msg instanceof  buffer update  buffer update bmsg  buffer update msg if bmsg get what  buffer update closed if bmsg get buffer buffer stop recording view 
private void append  string str buffer insert buffer get length str 
private void dispose flush input for int i i buffer get line count i buffer indent line i true  edit bus remove from bus this setting the message to null causes the status bar to check if a recording is in progress view get status set message null 
 we try to merge consecutive inputs  this helper method is called when something other than input is to be recorded private void flush input if last was input last was input false append if last was overwrite last was overwrite false append n append offset buffer get line end offset text area get caret line n append buffer remove text area get caret position  math min overwrite count offset text area get caret position 
public  string get name return name 
public  string get label return label 
public boolean accept  string path return filter matcher  misc utilities get file name path matches 
 runs the specified macro  this method is optional it is called if the specified macro is a startup script  the default behavior is to simply call link run macro  view  macros  macro param view  the view may be null param macro  the macro param own namespace a hint indicating whenever functions and variables defined in the script are to be self contained or made available to other scripts  the macro handler may ignore this parameter since j edit pre public void run macro  view view  macro macro boolean own namespace run macro view macro 
protected  handler  string name this name name label j edit get property macro handler name label name try filter  pattern compile  standard utilities glob to re j edit get property macro handler name glob catch  exception e throw new  internal error  missing or invalid glob for handler name 
 bean shell handler super beanshell 
 override public  macro create macro  string macro name  string path  remove bsh macro name macro name substring macro name length return new  macro this macro name  macro macro name to label macro name path 
 override public void run macro  view view  macro macro  bean shell run script view macro get path null true 
 override public void run macro  view view  macro macro boolean own namespace  bean shell run script view macro get path null own namespace 
public boolean update every time return false 
public void update j menu menu  vector macro vector  macros get macro hierarchy int count menu get menu component count create macros menu menu macro vector if count menu get menu component count j menu item mi new j menu item j edit get property no macros label mi set enabled false menu add mi 
private void create macros menu j menu menu  vector vector int start  vector j menu item menu items new  vector j menu item for int i start i vector size i  object obj vector element at i if obj instanceof  string menu items add new  enhanced menu item j edit get property obj label  string obj j edit get action context else if obj instanceof  vector  vector subvector  vector obj  string name  string subvector element at j menu submenu new j menu name create macros menu submenu subvector if submenu get menu component count menu items add submenu  collections sort menu items new  menu item text comparator for int i i menu items size i menu add menu items get i 
public  manage panel  plugin manager window super new  border layout this window window set border new  empty border  box top box new  box  box layout x axis top box add hide libraries new  hide libraries button add  border layout north top box  create the plugin table table new j table plugin model new  plugin table model table set show grid false table set intercell spacing new  dimension table set row height table get row height table set preferred scrollable viewport size new  dimension table set default renderer  object class new  text renderer  default table cell renderer table get default renderer  object class table add focus listener new  table focus handler table get selection model add list selection listener new  table selection listener  input map table input map table get input map j component when focused  action map table action map table get action map table input map put  key stroke get key stroke  key event vk tab tab out forward table action map put tab out forward new  keyboard action  keyboard command tab out forward table input map put  key stroke get key stroke  key event vk tab  input event shift mask tab out back table action map put tab out back new  keyboard action  keyboard command tab out back table input map put  key stroke get key stroke  key event vk space edit plugin table action map put edit plugin new  keyboard action  keyboard command edit plugin table input map put  key stroke get key stroke  key event vk enter close plugin manager table action map put close plugin manager new  keyboard action  keyboard command close plugin manager  table column col table get column model get column  table column col table get column model get column  table column col table get column model get column  table column col table get column model get column col set preferred width col set min width col set max width col set resizable false col set preferred width col set preferred width col set preferred width j table header header table get table header header set reordering allowed false  header mouse handler mouse handler new  header mouse handler header add mouse listener mouse handler table add mouse listener mouse handler scrollpane new j scroll pane table scrollpane get viewport set background table get background plugin detail panel new  plugin detail panel scrollpane set preferred size new  dimension j split pane split new j split pane j split pane vertical split true scrollpane plugin detail panel add  border layout center split split set resize weight  create button panel  box buttons new  box  box layout x axis buttons add new  remove button buttons add new  save button buttons add new  restore button buttons add new  find orphan buttons add  box create glue buttons add new  help button add  border layout south buttons plugin model update 
public void update plugin model update 
 manage panel restore handler selected plugins new  hash set  string jar names new  hash set  string 
 override public void start element  string uri  string local name  string q name  attributes attrs throws sax exception if local name equals plugin  string jar name attrs get value jar  string name attrs get value name  entry e new  entry jar name e name name selected plugins add name jar names add jar name 
boolean load plugin set  string path vfs vfs vfs manager get vfs for path path  object session vfs create vfs session path this try  input stream is vfs  create input stream session path false this xml utilities parse xml is new  manage panel restore handler is close int row count plugin model get row count for int i i row count i  entry ent plugin model get entry i  string name ent name if name null plugin model set value at selected plugins contains name i else  string jar path ent jar  string jar name jar path substring jar path last index of  file separator char try plugin model set value at jar names contains jar name i catch  exception e  log log  log warning this  exception thrown loading jar name catch  exception e  log log  log error this  loading  pluginset  error e return false plugin model update return true 
 returns a collection of declared jars in the plugin  if the plugin is loaded use link org gjt sp jedit  plugin jar get required jars instead param jar name the jar name of the plugin return a collection containing jars path throws io exception if j edit cannot generate cache since j edit pre private static  collection  string get declared jars  string jar name throws io exception  collection  string jar list new  array list  string  plugin jar plugin jar new  plugin jar new  file jar name  plugin jar  plugin cache entry plugin cache entry  plugin jar get plugin cache plugin jar if plugin cache entry null plugin cache entry plugin jar generate cache  properties cached properties plugin cache entry cached properties  string jars cached properties get property plugin plugin cache entry plugin class jars if jars null  string dir  misc utilities get parent of path plugin jar get path  string tokenizer st new  string tokenizer jars while st has more tokens  string  jar path  misc utilities construct path dir st next token if new  file  jar path exists jar list add  jar path jar list add jar name return jar list 
 constructor used for jars that aren t loaded param jar jar file name  entry  string jar jars new  linked list  string this jar jar jars add this jar status not loaded 
 constructor used for loaded jars param jar the plugin jar  entry  plugin jar jar jars new  linked list  string this jar jar get path jars add this jar plugin jar get plugin if plugin null status plugin instanceof  edit plugin  broken error loaded clazz plugin get class name name j edit get property plugin clazz name version j edit get property plugin clazz version author j edit get property plugin clazz author docs j edit get property plugin clazz docs description j edit get property plugin clazz description  string jars prop j edit get property plugin clazz jars if jars prop null  string directory  misc utilities get parent of path this jar  string tokenizer st new  string tokenizer jars prop while st has more elements jars add  misc utilities construct path directory st next token  string files prop j edit get property plugin clazz files if files prop null  string directory  misc utilities get parent of path this jar  string tokenizer st new  string tokenizer files prop while st has more elements jars add  misc utilities construct path directory st next token else status loaded 
 plugin table model entries new  array list  entry 
public int get column count return 
 override public  class get column class int column index switch column index case return  boolean class default return  object class 
 override public  string get column name int column switch column case return case return j edit get property manage plugins info name case return j edit get property manage plugins info version case return j edit get property manage plugins info status case return j edit get property manage plugins info data default throw new  error  column out of range 
public  entry get entry int row index return entries get row index 
public int get row count return entries size 
public  object get value at int row index int column index  entry entry entries get row index switch column index case return  boolean value of entry status equals  entry not loaded case if entry name null return  misc utilities get file name entry jar else return entry name case return entry version case return j edit get property plugin manager status entry status case if entry data size null entry plugin null  file plugin directory entry plugin get plugin home if null plugin directory return null if plugin directory exists entry data size  misc utilities format file size io utilities file length plugin directory else if j edit get boolean property plugin entry clazz use plugin home entry data size  misc utilities format file size else entry data size j edit get property manage plugins data size unknown return entry data size default throw new  error  column out of range 
 override public boolean is cell editable int row index int column index return column index 
 override public void set value at  object value int row index int column index  entry entry entries get row index if column index  plugin jar jar j edit get plugin jar entry jar if jar null if value equals  boolean false return  plugin jar load entry jar true else if value equals  boolean true return unload plugin jar with dialog jar update 
public void set sort type int type sort type type sort type 
public void sort int type  list  string saved selection new  array list  string save selection saved selection  collections sort entries new  entry compare type fire table changed new  table model event this restore selection saved selection 
public void update  list  string saved selection new  array list  string save selection saved selection entries clear  string system jar dir  misc utilities construct path j edit get j edit home jars  string user jar dir  string settings directory j edit get settings directory if settings directory null user jar dir null else user jar dir  misc utilities construct path settings directory jars  plugin jar plugins j edit get plugin ja rs for int i i plugins length i  string path plugins i get path if path starts with system jar dir user jar dir null path starts with user jar dir  entry e new  entry plugins i if hide libraries is selected e clazz null entries add e  string new plugins j edit get not loaded plugin ja rs for int i i new plugins length i  entry e new  entry new plugins i entries add e sort sort type restore selection saved selection 
private void unload plugin jar with dialog  plugin jar jar unloaded new  hash set  string unloaded new  concurrent hash map  string  object  string dependents jar get dependent plugins if dependents length unload plugin jar jar else  list  string closure set new  linked list  string  plugin jar transitive closure dependents closure set  list  string list model new  array list  string list model add all closure set  collections sort list model new  standard utilities  string compare  string true int button gui utilities list confirm window plugin manager dependency new  string jar get file get name list model to array if button j option pane yes option unload plugin jar jar 
private void unload plugin jar  plugin jar jar  string dependents jar get dependent plugins for  string dependent dependents if unloaded contains key dependent unloaded put dependent  boolean true  plugin jar  jar j edit get plugin jar dependent if  jar null unload plugin jar  jar j edit remove plugin jar jar false j edit set boolean property plugin blacklist  misc utilities get file name jar get path true 
 save the selection in the given list  the list will be filled with the jar names of the selected entries param saved selection the list where to save the selection public void save selection  list  string saved selection if table null int rows table get selected rows for int i i rows length i saved selection add entries get rows i jar 
 restore the selection param saved selection the selection list that contains the jar names of the selected items public void restore selection  list  string saved selection if null table table set column selection interval if saved selection is empty int i int row count get row count for i row count i if saved selection contains entries get i jar table set row selection interval i i break  list selection model lsm table get selection model for i row count i if saved selection contains entries get i jar lsm add selection interval i i else if table get row count table set row selection interval j scroll bar scrollbar scrollpane get vertical scroll bar scrollbar set value scrollbar get minimum 
 text renderer  default table cell renderer tcr this tcr tcr 
 override public  component get table cell renderer component j table table  object value boolean is selected boolean has focus int row int column  entry entry plugin model get entry row if entry status equals  entry error tcr set foreground  color red else tcr set foreground ui manager get color  table foreground return tcr get table cell renderer component table value is selected false row column 
 hide libraries button super j edit get property plugin manager hide libraries set selected j edit get boolean property plugin manager hide libraries toggle add action listener this 
public void action performed  action event evt j edit set boolean property plugin manager hide libraries toggle is selected  manage panel this update 
 restore button set icon gui utilities load icon j edit get property manage plugins restore icon add action listener this set tool tip text  choose a  plugin set select deselect plugins based on set 
public void action performed  action event e  string path j edit get property  plugin manager property pluginset j edit get settings directory  file separator  string selected files gui utilities show vfs file dialog  manage panel this window j edit get active view path vfs browser open dialog false if selected files null selected files length return path selected files boolean success load plugin set path if success j edit set property  plugin manager property pluginset path  edit bus send new  properties changed  plugin manager get instance 
 save button set icon gui utilities load icon j edit get property manage plugins save icon set tool tip text  save  currently  checked  plugins  set add action listener this set enabled true 
void save state  string vfs url  list  entry plugin list  string builder sb new  string builder pluginset n for  entry entry plugin list  string jar name entry jar substring entry jar last index of  file separator char sb append plugin name append entry name append jar sb append jar name append n sb append pluginset n vfs vfs vfs manager get vfs for path vfs url  object session vfs create vfs session vfs url  manage panel this  writer writer null try  output stream os vfs  create output stream session vfs url  manage panel this writer new  buffered writer new  output stream writer os writer write sb to string catch  exception e  log log  log error this  saving  state  error e finally io utilities close quietly writer 
public void action performed  action event e  string path j edit get property plugin manager pluginset path j edit get settings directory  file separator vfs file chooser dialog file chooser new vfs file chooser dialog  manage panel this window j edit get active view path vfs browser save dialog false true  string fileselections file chooser get selected files  list  entry plugin selections new  array list  entry if fileselections null fileselections length return  plugin jar jars j edit get plugin ja rs for  plugin jar jar jars if jar get plugin null  entry entry new  entry jar plugin selections add entry save state fileselections plugin selections j edit set property plugin manager pluginset path fileselections  edit bus send new  properties changed  plugin manager get instance 
 remove button super j edit get property manage plugins remove table get selection model add list selection listener this add action listener this set enabled false 
public void action performed  action event evt int selected table get selected rows  list  string list model new  linked list  string  roster roster new  roster  set  string jars to remove new  hash set  string this one will contains the loaded jars to remove  they are the only one we need to check to unload plugins that depends on them  set  string loaded jars to remove new  hash set  string for int i i selected length i  entry entry plugin model get entry selected i if entry status equals  entry not loaded if entry jar null try  collection  string jar list get declared jars entry jar jars to remove add all jar list catch io exception e  log log  log error this e else jars to remove add all entry jars loaded jars to remove add all entry jars table get selection model remove selection interval selected i selected i for  string jar jars to remove list model add jar roster add remove jar int button gui utilities list confirm window plugin manager remove confirm null list model to array if button j option pane yes option  list  string closure set new  array list  string  plugin jar transitive closure loaded jars to remove to array new  string loaded jars to remove size closure set closure set remove all list model if closure set is empty button j option pane yes option else button gui utilities list confirm window plugin manager remove dependencies null closure set to array  collections sort closure set new  standard utilities  string compare  string true if button j option pane yes option for  string jar name closure set  plugin jar plugin jar j edit get plugin jar jar name j edit remove plugin jar plugin jar false roster perform operations in awt thread window plugin model update if table get row count table set row selection interval table set column selection interval j scroll bar scrollbar scrollpane get vertical scroll bar scrollbar set value scrollbar get minimum 
public void value changed  list selection event e if table get selected row count set enabled false else set enabled true 
private  find orphan super j edit get property plugin manager find orphan label add action listener this 
public void action performed  action event e  plugin jar plugin ja rs j edit get plugin ja rs  set  string needed jars new  hash set  string  map  string  string jarlibs new  hash map  string  string for  plugin jar plugin jar plugin ja rs  edit plugin plugin plugin jar get plugin if plugin null jarlibs put new  file plugin jar get path get name plugin jar get path else  set  string strings plugin get plugin jar get required jars for  string string strings needed jars add new  file string get name  string not loaded jars j edit get not loaded plugin ja rs for int i i not loaded jars length i  plugin jar plugin jar new  plugin jar new  file not loaded jars i  plugin jar  plugin cache entry plugin cache entry  plugin jar get plugin cache plugin jar try if plugin cache entry null plugin cache entry plugin jar generate cache if plugin cache entry plugin class null  not a plugin jarlibs put new  file not loaded jars i get name not loaded jars i continue  properties cached properties plugin cache entry cached properties  string jars cached properties get property plugin plugin cache entry plugin class jars if jars null  string tokenizer st new  string tokenizer jars while st has more tokens needed jars add st next token catch io exception e  log log  log error this e  list  string removing jars new  array list  string  set  string jarlibs keys jarlibs key set for  string jar jarlibs keys if needed jars contains jar removing jars add jar  log log  log message this  it seems that this jar do not belong to any plugin jar if removing jars is empty gui utilities message  manage panel this plugin manager no orphan null return  string strings removing jars to array new  string removing jars size  list  string must remove new  array list  string int ret gui utilities list confirm  manage panel this plugin manager find orphan null strings must remove if ret j option pane ok option must remove is empty return  roster roster new  roster for int i i must remove size i  string entry must remove get i roster add remove jarlibs get entry roster perform operations in awt thread window plugin model update if table get row count table set row selection interval table set column selection interval j scroll bar scrollbar scrollpane get vertical scroll bar scrollbar set value scrollbar get minimum table repaint 
 help button super j edit get property manage plugins help table get selection model add list selection listener this add action listener this set enabled false 
public void action performed  action event evt new  help viewer doc url 
public void value changed  list selection event e if table get selected row count try  entry entry plugin model get entry table get selected row  string label entry clazz  string docs entry docs if label null  edit plugin plug j edit get plugin label false  plugin jar jar null if plug null jar plug get plugin jar if jar null docs null url url jar get class loader get resource docs if url null doc url url set enabled true return catch  exception ex  log log  log error this  manage panel  help button  update ex set enabled false 
 entry compare int type this type type 
public int compare  entry e  entry e if type name return compare names e e else int result if result e status compare to ignore case e status return compare names e e return result 
private static int compare names  entry e  entry e  string s if e name null s  misc utilities get file name e jar else s e name  string s if e name null s  misc utilities get file name e jar else s e name return s compare to ignore case s 
 override public void mouse clicked  mouse event evt if evt get source table get table header switch table get table header column at point evt get point case plugin model set sort type  entry compare name break case plugin model set sort type  entry compare status break default break else if gui utilities is popup trigger evt int row table row at point evt get point if row table is row selected row table set row selection interval row row if popup null popup new j popup menu j menu item item gui utilities load menu item plugin manager cleanup item add action listener new  cleanup action listener popup add item gui utilities show popup menu popup table evt get x evt get y 
public void action performed  action event e int ints table get selected rows  list  string list new  array list  string ints length  list  entry entries new  array list  entry ints length for int i i ints length i  entry entry plugin model get entry ints i if entry plugin null list add entry name entries add entry  string strings list to array new  string list size int ret gui utilities list confirm  manage panel this plugin manager cleanup null strings if ret j option pane ok option return for int i i entries size i  entry entry entries get i  file path entry plugin get plugin home  log log  log notice this  removing data of plugin entry name home path  file vfs recursive delete path entry data size null table repaint 
 keyboard action  keyboard command command this command command 
public void action performed  action event evt switch command case tab out forward  keyboard focus manager get current keyboard focus manager focus next component break case tab out back  keyboard focus manager get current keyboard focus manager focus previous component break case edit plugin int rows table get selected rows for int i i rows length i  object st plugin model get value at rows i plugin model set value at st equals  boolean false rows i break case close plugin manager window ok break default throw new  internal error 
 override public void focus gained  focus event fe if table get selected row table set row selection interval j scroll bar scrollbar scrollpane get vertical scroll bar scrollbar set value scrollbar get minimum if table get selected column table set column selection interval 
public void value changed  list selection event e int row table get selected row if row  entry entry plugin model get entry row plugin detail panel set plugin entry 
 returns the marker s shortcut character since j edit pre public char get shortcut return shortcut 
 returns the position of this marker since j edit pre public int get position return position null pos position get offset 
 marker  buffer buffer char shortcut int position this buffer buffer this shortcut shortcut this pos position 
 sets the marker s shortcut param shortcut  the new shortcut since j edit pre void set shortcut char shortcut this shortcut shortcut 
void create position position buffer create position pos 
void remove position forget the cached  position instance if position null pos position get offset position null 
 sets the position of this marker since j edit pre void set position int pos this pos pos 
public boolean update every time return true 
public void update j menu menu final  view view gui utilities get view menu  buffer buffer view get buffer  list  marker markers buffer get markers if markers is empty j menu item mi new j menu item j edit get property no markers label mi set enabled false menu add mi return int max items j edit get integer property menu spillover j menu current menu for int i i markers size i final  marker marker markers get i int line no buffer get line of offset marker get position if current get item count max items i markers size current add separator j menu new current new j menu j edit get property common more current add new current current new current j menu item mi new  markers menu item buffer line no marker get shortcut mi add action listener new  action listener public void action performed  action event evt view get text area set caret position marker get position current add mi 
 markers menu item  buffer buffer int line no char shortcut  string text buffer get line text line no trim if text length text j edit get property markers blank line set text line no text shortcut prop goto marker shortcut  markers menu item this shortcut shortcut 
public  dimension get preferred size  dimension d super get preferred size  string shortcut get shortcut if shortcut null d width get font metrics accelerator font string width shortcut return d 
public void paint  graphics g super paint g  string shortcut get shortcut if shortcut null g set font accelerator font g set color get model is armed accelerator selection foreground accelerator foreground  font metrics fm g get font metrics  insets insets get insets g draw string shortcut get width fm string width shortcut insets right insets left get font get size insets top xxx magic number 
private  string get shortcut if shortcut return null else  string shortcut prefix j edit get property shortcut prop if shortcut prefix null return null else return shortcut prefix shortcut 
 creates a new i o request for markers param view  the view param buffer  the buffer param session  the vfs session param vfs  the vfs param path  the path public  markers save request  view view  buffer buffer  object session vfs vfs  string path this view view this buffer buffer this session session this vfs vfs this path path this markers path  buffer get markers path vfs path 
public void run  output stream out null try the entire save operation can be aborted set abortable true try  we only save markers to vfs s that support deletion  otherwise we will accumilate stale marks files if vfs get capabilities vfs delete cap if buffer get markers is empty vfs  delete session markers path view else  string args vfs get file name path set status j edit get property vfs status save markers args set value out vfs  create output stream session markers path view if out null write markers out catch io exception io  log log  log error this io buffer set boolean property error occurred true catch  work thread  abort a io utilities close quietly out buffer set boolean property error occurred true 
private void write markers  output stream out throws io exception  writer o new  buffered writer new  output stream writer out try  list  marker markers buffer get markers for int i i markers size i  marker marker markers get i o write o write marker get shortcut o write  string pos  string value of marker get position o write pos o write o write pos o write n finally o close 
public  marker viewer  view view super new  border layout this view view  box tool bar new  box  box layout x axis tool bar add new j label gui utilities prettify menu label j edit get property markers label tool bar add  box create glue  rollover button add marker new  rollover button gui utilities load icon  plus png add marker set tool tip text gui utilities prettify menu label j edit get property add marker label add marker add action listener this add marker set action command add marker tool bar add add marker previous new  rollover button gui utilities load icon  arrow l png previous set tool tip text gui utilities prettify menu label j edit get property prev marker label previous add action listener this previous set action command prev marker tool bar add previous next new  rollover button gui utilities load icon  arrow r png next set tool tip text gui utilities prettify menu label j edit get property next marker label next add action listener this next set action command next marker tool bar add next clear new  rollover button gui utilities load icon  clear png clear set tool tip text gui utilities prettify menu label j edit get property remove all markers label clear add action listener this clear set action command clear tool bar add clear add  border layout north tool bar marker list new j list marker list set selection mode  list selection model single selection marker list set cell renderer new  renderer marker list add mouse listener new  mouse handler add  border layout center new j scroll pane marker list refresh list 
public boolean request default focus marker list request focus return true 
public void action performed  action event evt  string cmd evt get action command if cmd equals clear view get buffer remove all markers else if cmd equals add marker view get edit pane add marker else if cmd equals next marker view get edit pane go to next marker false update selection else if cmd equals prev marker view get edit pane go to prev marker false update selection 
public void handle message eb message msg if msg instanceof  edit pane update  edit pane update epu  edit pane update msg if epu get edit pane get view equals view epu get what equals  edit pane update buffer changed refresh list if msg instanceof  view update  view update vu  view update msg if vu get view equals view vu get what equals  view update edit pane changed refresh list if msg instanceof  buffer update  buffer update bu  buffer update msg if view get buffer equals bu get buffer bu get what equals  buffer update markers changed bu get what equals  buffer update loaded refresh list 
public void add notify super add notify  edit bus add to bus this 
public void remove notify super remove notify  edit bus remove from bus this 
private void refresh list java util  vector markers view get buffer get markers if markers size marker list set list data markers marker list set enabled true next set enabled true previous set enabled true clear set enabled true else marker list set list data new  object j edit get property no markers label marker list set enabled false next set enabled false previous set enabled false clear set enabled false 
private void go to selected marker  object value marker list get selected value if value instanceof  marker return  marker mark  marker value view get text area set caret position mark get position view to front view request focus view get text area request focus 
private void update selection  list model model marker list get model int current line view get text area get caret line  buffer buffer view get buffer for int i i model get size i  object o model get element at i if o instanceof  marker  marker mark  marker model get element at i if buffer get line of offset mark get position current line marker list set selected index i break 
public  component get list cell renderer component j list list  object value int index boolean is selected boolean cell has focus super get list cell renderer component list value index is selected cell has focus if value instanceof  marker  marker mark  marker value j edit text area text area view get text area int pos text area get line of offset mark get position  string txt view get text area get line text pos if txt equals txt j edit get property markers blank line char shortcut char mark get shortcut  string shortcut if shortcut char shortcut shortcut char set text pos shortcut txt return this 
public void mouse pressed  mouse event evt if evt is consumed return int index marker list location to index evt get point marker list set selected index index go to selected marker 
public  widget get widget  view view  widget memory new  memory status widget view return memory 
public  memory status widget  view view memory status new  memory status view 
public j component get component return memory status 
public void update 
public void properties changed 
 memory status  view view this view view fucking gtk look and feel  font font new j label get font  font font ui manager get font  label font  memory status this set font font  font render context frc new  font render context null false false  rectangle d bounds font get string bounds memory test str frc  dimension dim new  dimension int bounds get width int bounds get height set preferred size dim set maximum size dim lm font get line metrics memory test str frc set foreground j edit get color property view status foreground set background j edit get color property view status background progress foreground j edit get color property view status memory foreground progress background j edit get color property view status memory background add mouse listener new  mouse handler 
 override public void add notify super add notify timer new  timer this timer start  tool tip manager shared instance register component this 
 override public void remove notify timer stop  tool tip manager shared instance unregister component this super remove notify 
 override public  string get tool tip text  runtime runtime  runtime get runtime long free runtime free memory long total runtime total memory long used total free args int used args int total return j edit get property view status memory tooltip args 
 override public  point get tool tip location  mouse event event return new  point event get x 
public void action performed  action event evt  memory status this repaint 
 override public void paint component  graphics g  insets insets new  insets  memory status this get border get border insets this  runtime runtime  runtime get runtime long free runtime free memory long total runtime total memory long used total free int width  memory status this get width insets left insets right int height  memory status this get height insets top insets bottom float fraction float used total g set color progress background g fill rect insets left insets top int width fraction height  string str used total  mb  font render context frc new  font render context null false false  rectangle d bounds g get font get string bounds str frc  graphics g g create g set clip insets left insets top int width fraction height g set color progress foreground g draw string str insets left int width bounds get width int insets top lm get ascent g dispose g g create g set clip insets left int width fraction insets top  memory status this get width insets left int width fraction height g set color  memory status this get foreground g draw string str insets left int width bounds get width int insets top lm get ascent g dispose 
 override public void mouse pressed  mouse event evt if evt get click count j edit show memory dialog view repaint 
public int compare j menu item obj j menu item obj int compare value boolean obj e obj instanceof  enhanced menu item boolean obj e obj instanceof  enhanced menu item if obj e obj e compare value else if obj e obj e compare value else compare value  standard utilities compare strings obj get text obj get text true return compare value 
public  mirror list boolean download  progress observer observer throws  exception mirrors new  array list  mirror  mirror none new  mirror none id  mirror none none description none location none country none continent mirrors add none  string path j edit get property plugin manager mirror url  mirror list handler handler new  mirror list handler this path if download  log log  log notice this  loading mirror list from internet download xml path else  log log  log notice this  loading mirror list from cache read xml observer set value  reader in new  buffered reader new  string reader xml  input source isrc new  input source in isrc set system id jedit jar xml reader parser xml reader factory create xml reader parser set content handler handler parser set dtd handler handler parser set entity resolver handler parser set error handler handler parser parse isrc observer set value 
 read and store the mirror list xml throws io exception exception if it was not possible to read the xml or if the url was invalid private void read xml throws io exception  string settings directory j edit get settings directory if settings directory null return  file mirror list new  file  misc utilities construct path settings directory mirror list xml if mirror list exists return  input stream input stream null try input stream new  buffered input stream new  file input stream mirror list  byte array output stream out new  byte array output stream io utilities copy stream null input stream out false xml out to string finally io utilities close quietly input stream 
 read and store the mirror list xml param path the url throws io exception exception if it was not possible to read the xml or if the url was invalid private void download xml  string path throws io exception  input stream input stream null try input stream new url path open stream  byte array output stream out new  byte array output stream io utilities copy stream null input stream out false xml out to string finally io utilities close quietly input stream 
void add  mirror mirror mirrors add mirror 
void finished  collections sort mirrors new  mirror compare 
public int compare  mirror m  mirror m int result if result m continent compare to ignore case m continent if result m country compare to ignore case m country if result m location compare to ignore case m location return m description compare to ignore case m description return result 
public boolean equals  object obj return obj instanceof  mirror compare 
 mirror list handler  mirror list mirrors  string path this mirrors mirrors this path path 
public  input source resolve entity  string public id  string system id return xml utilities find entity system id mirrors dtd  plugin options class 
public void characters char c int off int len  string tag peek element if tag description description append c off len else if tag location location append c off len else if tag country country append c off len else if tag continent continent append c off len 
public void start element  string uri  string local name  string tag  attributes attrs tag push element tag if tag equals mirror mirror new  mirror list  mirror id attrs get value id 
public void end element  string uri  string local name  string tag pop element if tag equals mirror mirror id id mirror description description to string mirror location location to string mirror country country to string mirror continent continent to string mirrors add mirror description set length location set length country set length continent set length 
public void start document try push element null catch  exception e  log log  log error this e 
public void end document mirrors finished 
private  string push element  string name name name null null name intern state stack push name return name 
private  string peek element return state stack peek 
private void pop element state stack pop 
return the canonical form of the specified path name  currently only expands a leading code code b  for local path names only b param path  the path name since j edit pre public static  string canon path  string path if path length return path if path starts with file path path substring file length else if path starts with file path path substring file length else if is url path return path if  file separator char get rid of mixed paths on  windows path path replace also get rid of trailing spaces on  windows int trim path length while path char at trim trim if path char at trim while trim path char at trim trim path path substring trim else if  operating system is mac os do the same on os x path path replace if path starts with  file separator path path substring  string home  system get property user home if home ends with  file separator return home path else return home  file separator path else if equals path return  system get property user home else if equals path return get parent of path j edit get active view get buffer get path else return path 
 accepts a string from the user which may contain variables of various syntaxes  the goal is to support the following varname varname  and expand each of these by looking at the system environment variables for possible expansions return a string which is either the unchanged input string or one with expanded variables since pre author ezust public static  string expand variables  string arg  pattern p var pattern  matcher m p matcher arg if m find p var pattern m p matcher arg if m find no variables to substitute return arg  string var name m group  string expansion  system getenv var name if expansion null try everything uppercase var name var name to upper case  string uparg arg to upper case m p matcher uparg expansion  system getenv var name if expansion null expansion expansion replace return m replace first expansion return arg 
returns an abbreviated path replacing values with variables if a prefix exists since j edit pre public static  string abbreviate  string path if svc null svc new  var compressor return svc compress path 
 resolves any symbolic links in the path name specified using code  file get canonical path code b  for local path names only b since j edit pre public static  string resolve symlinks  string path if is url path return path aug os  java has a broken get canonical path if  operating system is os return path nov calling this on a drive letter on  windows causes drive access if  operating system is dos derived if path length path length if path char at return path try return new  file path get canonical path catch io exception io return path 
 returns if the specified path name is an absolute path or url since j edit pre public static boolean is absolute path  string path if is url path return true else if path starts with path starts with  file separator equals path return true else if equals path return true else if  operating system is dos derived if path length path char at return true if path length path char at path char at path char at return true if path starts with path starts with return true not sure if this is correct for  open vms else if  operating system is unix  operating system is vms nice and simple if path length path char at return true return false 
 constructs an absolute path name from a directory and another path name  this method is vfs aware param parent  the directory param path  the path name public static  string construct path  string parent  string path if is absolute path path return canon path path if parent null parent  system get property user dir if path null path length return parent have to handle this case specially on windows insert between eg a and myfile txt if  operating system is dos derived if path length path char at return path else if path length path char at path char at path path substring path substring return canon path path  string dd  file separator  string d  file separator for if equals path return parent else if equals path return get parent of path parent else if path starts with dd path starts with parent get parent of path parent path path substring else if path starts with d path starts with path path substring else break if path length return parent if  operating system is dos derived is url parent path char at parent parent substring vfs vfs vfs manager get vfs for path parent return canon path vfs construct path parent path 
 constructs an absolute path name from three path components  this method is vfs aware param parent  the parent directory param path  the first path param path  the second path public static  string construct path  string parent  string path  string path return construct path construct path parent path path 
 like link construct path except code path code will be appended to code parent code even if it is absolute b  for local path names only b param parent the parent path param path the path to append to the parent public static  string concat path  string parent  string path parent canon path parent path canon path path  make all child paths relative if path starts with  file separator path path substring else if path length path char at path path replace  file separator char if parent null parent  system get property user dir if parent ends with  file separator return parent path else return parent  file separator path 
 return the first index of either or the os specific file separator param path  the path since j edit pre public static int get first separator index  string path int start get path start path int index path index of start if index index path index of  file separator char start return index 
 return the last index of either or the os specific file separator param path  the path since j edit pre public static int get last separator index  string path int start get path start path if start path path substring start int index  math max path last index of path last index of  file separator char if index return index else return index start 
 returns the extension of the specified filename or an empty string if there is none param path  the path public static  string get file extension  string path int fs index get last separator index path int index path last index of there could be a dot in the path and no file extension if index index fs index return else return path substring index 
 returns the last component of the specified path  this method is vfs aware param path  the path name public static  string get file name  string path return vfs manager get vfs for path path get file name path 
 returns the last component of the specified path name without the trailing extension if there is one param path  the path name since j edit pre public static  string get file name no extension  string path  string name get file name path int index name index of if index return name else return name substring index 
deprecated  call get parent of path instead  deprecated public static  string get file parent  string path return get parent of path path 
 returns the parent of the specified path  this method is vfs aware param path  the path name since j edit pre public static  string get parent of path  string path return vfs manager get vfs for path path get parent of path path 
deprecated  call get protocol of url instead  deprecated public static  string get file protocol  string url return get protocol of url url 
 returns the protocol specified by a url param url  the url since j edit pre public static  string get protocol of url  string url return url substring url index of 
 checks if the specified string is a url param str  the string to check return  true if the string is a url false otherwise public static boolean is url  string str int fs index get last separator index str if fs index etc passwd return false else if fs index c autoexec bat return false int c index str index of if c index d windows or doesn t contain at all return false  string protocol str substring c index vfs vfs vfs manager get vfs for protocol protocol if vfs null vfs instanceof  url vfs return true try new url str return true catch  malformed url exception mf return false 
 saves a backup optionally numbered of a file param file a local file param backups  the number of backups  must be  if backup files will be numbered param backup prefix  the backup file name prefix param backup suffix  the backup file name suffix param backup directory  the directory where to save backups if null they will be saved in the same directory as the file itself since j edit pre public static void save backup  file file int backups  string backup prefix  string backup suffix  string backup directory save backup file backups backup prefix backup suffix backup directory 
 saves a backup optionally numbered of a file param file a local file param backups  the number of backups  must be  if backup files will be numbered param backup prefix  the backup file name prefix param backup suffix  the backup file name suffix param backup directory  the directory where to save backups if null they will be saved in the same directory as the file itself param backup time distance  the minimum time in minutes when a backup version shall be moved into version if backups are always moved since j edit pre public static void save backup  file file int backups  string backup prefix  string backup suffix  string backup directory int backup time distance if backup prefix null backup prefix if backup suffix null backup suffix  string name file get name  if backups is create file if backups  file backup file new  file backup directory backup prefix name backup suffix long mod time backup file last modified if backup file was created less than backup time distance ago we do not create the backup if  system current time millis mod time backup time distance  log log  log debug  misc utilities class  saving backup of file file get absolute path to backup file get absolute path backup file delete if file rename to backup file io utilities move file file backup file  if backups move old n files create file else delete a backup created using above method new  file backup directory backup prefix name backup suffix backups backup suffix delete  file first backup new  file backup directory backup prefix name backup suffix backup suffix long mod time first backup last modified if backup file was created less than backup time distance ago we do not create the backup if  system current time millis mod time backup time distance for int i backups i i  file backup new  file backup directory backup prefix name backup suffix i backup suffix backup rename to new  file backup directory backup prefix name backup suffix i backup suffix  file backup file new  file backup directory backup prefix name backup suffix backup suffix  log log  log debug  misc utilities class  saving backup of file file get absolute path to backup file get absolute path if file rename to backup file io utilities move file file backup file 
 moves the source file to the destination  if the destination cannot be created or is a read only file the method returns code false code  otherwise the contents of the source are copied to the destination the source is deleted and code true code is returned param source  the source file to move param dest  the destination where to move the file return true on success false otherwise since j edit pre deprecated use link org gjt sp util io utilities move file java io  file java io  file  deprecated public static boolean move file  file source  file dest return io utilities move file source dest 
 copy an input stream to an output stream param buffer size the size of the buffer param progress the progress observer it could be null param in the input stream param out the output stream param can stop if true the copy can be stopped by interrupting the thread return code true code if the copy was done code false code if it was interrupted throws io exception io exception  if an i o error occurs since j edit pre deprecated use link io utilities copy stream int org gjt sp util  progress observer java io  input stream java io  output stream boolean  deprecated public static boolean copy stream int buffer size  progress observer progress  input stream in  output stream out boolean can stop throws io exception return io utilities copy stream buffer size progress in out can stop 
 copy an input stream to an output stream with a buffer of bytes param progress the progress observer it could be null param in the input stream param out the output stream param can stop if true the copy can be stopped by interrupting the thread return code true code if the copy was done code false code if it was interrupted throws io exception io exception  if an i o error occurs since j edit pre deprecated use link io utilities copy stream org gjt sp util  progress observer java io  input stream java io  output stream boolean  deprecated public static boolean copy stream  progress observer progress  input stream in  output stream out boolean can stop throws io exception return io utilities copy stream progress in out can stop 
 check if a  reader is binary deprecated  use is binary  input stream instead  deprecated public static boolean is binary  reader reader throws io exception return contains null character reader 
 check if an  input stream is binary  first this tries encoding auto detection  if an encoding is detected the stream should be a text stream  otherwise this will check the first characters j edit property vfs binary check length in the system default encoding  if more than j edit property vfs binary check count nul u was found the stream is declared binary  this is not because sometimes the autodetection could fail  this method will not close the stream  you have to do it yourself param in the stream return code true code if the stream was detected as binary throws io exception io exception  if an i o error occurs since j edit pre public static boolean is binary  input stream in throws io exception  auto detection  result detection new  auto detection  result in  if an encoding is detected this is a text stream if detection get detected encoding null return false  read the stream in system default encoding  the encoding might be wrong  but enough for binary detection try return contains null character new  input stream reader detection get rewinded stream catch  malformed input exception mie  this error probably means the input is binary return true 
 check if the filename is a backup file param filename the filename to check return true if this is a backup file since j edit pre public static boolean is backup  string filename if filename starts with return true if filename ends with return true if filename ends with bak return true return false 
 tries to detect if the stream is gzipped and if it has an encoding specified with an xml pi param in the input stream reader that must be autodetected param buffer a buffer  it can be null if you only want to autodetect the encoding of a file return a  reader using the detected encoding throws io exception io exception during read since j edit pre public static  reader autodetect  input stream in  buffer buffer throws io exception  string encoding if buffer null encoding  system get property file encoding else encoding buffer get string property j edit buffer encoding boolean gzipped false if buffer null buffer get boolean property  buffer encoding autodetect  auto detection  result detection new  auto detection  result in gzipped detection stream is gzipped if gzipped  log log  log debug  misc utilities class  stream is  gzipped  string detected detection get detected encoding if detected null encoding detected  log log  log debug  misc utilities class  stream encoding detected is detected in detection get rewinded stream else  make the stream buffered in the same way in  auto detection get marked stream in  reader result  encoding server get text reader in encoding if buffer null  store the successful properties if gzipped buffer set boolean property  buffer gzipped true buffer set property j edit buffer encoding encoding return result 
 method that will close an link  input stream ignoring it if it is null and ignoring exceptions param in the  input stream to close since j edit pre deprecated use link io utilities close quietly java io  input stream  deprecated public static void close quietly  input stream in io utilities close quietly in 
 method that will close an link  output stream ignoring it if it is null and ignoring exceptions param out the  output stream to close since j edit pre deprecated use link io utilities close quietly java io  output stream  deprecated public static void close quietly  output stream out io utilities close quietly out 
 converts a file name to a class name  all slash characters are replaced with periods and the trailing class is removed param name  the file name public static  string file to class  string name char cls name name to char array for int i cls name length i i if cls name i cls name i return new  string cls name cls name length 
 converts a class name to a file name  all periods are replaced with slashes and the class extension is added param name  the class name public static  string class to file  string name return name replace concat class 
param p a path name param p a path name return  true if both paths are equal ignoring trailing slashes as well as case insensitivity on  windows since j edit pre public static boolean paths equal  string p  string p vfs v vfs manager get vfs for path p vfs v vfs manager get vfs for path p if v v return false if p ends with p ends with  file separator p p substring p length if p ends with p ends with  file separator p p substring p length if v get capabilities vfs case insensitive cap return p equals ignore case p else return p equals p 
 returns the number of leading white space characters in the specified string param str  the string deprecated use link org gjt sp util  standard utilities get leading white space  string  deprecated public static int get leading white space  string str return  standard utilities get leading white space str 
 returns the number of trailing whitespace characters in the specified string param str  the string since j edit pre deprecated use link org gjt sp util  standard utilities get trailing white space  string  deprecated public static int get trailing white space  string str return  standard utilities get trailing white space str 
 returns the width of the leading white space in the specified string param str  the string param tab size  the tab size deprecated use link org gjt sp util  standard utilities get leading white space  string  deprecated public static int get leading white space width  string str int tab size return  standard utilities get leading white space width str tab size 
 returns the virtual column number taking tabs into account of the specified offset in the segment param seg  the segment param tab size  the tab size since j edit pre deprecated use link org gjt sp util  standard utilities get virtual width javax swing text  segment int  deprecated public static int get virtual width  segment seg int tab size return  standard utilities get virtual width seg tab size 
 returns the array offset of a virtual column number taking tabs into account in the segment param seg  the segment param tab size  the tab size param column  the virtual column number param total virtual width  if this array is non null the total virtual width will be stored in its first location if this method returns return if the column is out of bounds since j edit pre deprecated use link org gjt sp util  standard utilities get virtual width javax swing text  segment int  deprecated public static int get offset of virtual column  segment seg int tab size int column int total virtual width return  standard utilities get offset of virtual column seg tab size column total virtual width 
 creates a string of white space with the specified length p  to get a whitespace string tuned to the current buffer s settings call this method as follows pre my whitespace  misc utilities create white space my length buffer get boolean property no tabs buffer get tab size pre param len  the length param tab size  the tab size or if tabs are not to be used deprecated use link org gjt sp util  standard utilities create white space int int  deprecated public static  string create white space int len int tab size return  standard utilities create white space len tab size 
 creates a string of white space with the specified length p  to get a whitespace string tuned to the current buffer s settings call this method as follows pre my whitespace  misc utilities create white space my length buffer get boolean property no tabs buffer get tab size pre param len  the length param tab size  the tab size or if tabs are not to be used param start  the start offset for tab alignment since j edit pre deprecated use link org gjt sp util  standard utilities create white space int int int  deprecated public static  string create white space int len int tab size int start return  standard utilities create white space len tab size start 
 converts a  unix style glob to a regular expression p becomes becomes aa bb becomes aa bb param glob  the glob pattern deprecated  use link org gjt sp util  standard utilities glob to re  string  deprecated public static  string glob to re  string glob return  standard utilities glob to re glob 
 converts n and t escapes in the specified string to newlines and tabs param str  the string since j edit pre public static  string escapes to chars  string str  string builder buf new  string builder for int i i str length i char c str char at i switch c case if i str length buf append break c str char at i switch c case n buf append n break case t buf append t break default buf append c break break default buf append c return buf to string 
 escapes newlines tabs backslashes and quotes in the specified string param str  the string since j edit pre deprecated use link org gjt sp util  standard utilities chars to escapes  string  deprecated public static  string chars to escapes  string str return  standard utilities chars to escapes str 
 escapes the specified characters in the specified string param str  the string param to escape  any characters that require escaping since j edit pre deprecated use link org gjt sp util  standard utilities chars to escapes  string  deprecated public static  string chars to escapes  string str  string to escape return  standard utilities chars to escapes str to escape 
deprecated  call link  standard utilities compare strings  string  string boolean instead  deprecated public static int compare versions  string v  string v return  standard utilities compare strings v v false 
 compares two strings p  unlike function  string compare to function this method correctly recognizes and handles embedded numbers  for example it places  my file before  my file p param str  the first string param str  the second string param ignore case  if true case will be ignored return negative  if str lt str if both are the same positive if str gt str since j edit pre deprecated use link org gjt sp util  standard utilities compare strings  string  string boolean  deprecated public static int compare strings  string str  string str boolean ignore case return  standard utilities compare strings str str ignore case 
deprecated  call link  standard utilities objects equal  object  object instead  deprecated public static boolean strings equal  string s  string s return  standard utilities objects equal s s 
 returns if two strings are equal  this correctly handles null pointers as opposed to calling code o equals o code since j edit pre deprecated use link  standard utilities objects equal  object  object  deprecated public static boolean objects equal  object o  object o return  standard utilities objects equal o o 
 converts lt gt amp in the string to their html entity equivalents param str  the string since j edit pre deprecated  use link org gjt sp util xml utilities chars to entities  string boolean  deprecated public static  string chars to entities  string str return xml utilities chars to entities str false 
 formats the given file size into a nice string  bytes k b mb param length  the size since j edit pre public static  string format file size long length if length return length  bytes else if length return kb format format double length else return mb format format double length 
 returns the longest common prefix in the given set of strings param str  the strings param ignore case  if true case insensitive since j edit pre public static  string get longest prefix  list  string str boolean ignore case if str is empty return int prefix length loop for  string s str get if prefix length s length break loop char ch s char at prefix length for int i i str size i s str get i if prefix length s length break loop if compare chars s char at prefix length ch ignore case break loop prefix length return str get substring prefix length 
 returns the longest common prefix in the given set of strings param str  the strings param ignore case  if true case insensitive since j edit pre public static  string get longest prefix  string str boolean ignore case return get longest prefix  object str ignore case 
 returns the longest common prefix in the given set of strings param str  the strings calls code to string code on each object param ignore case  if true case insensitive since j edit pre public static  string get longest prefix  object str boolean ignore case if str length return int prefix length  string first str to string loop for if prefix length first length break loop char ch first char at prefix length for int i i str length i  string s str i to string if prefix length s length break loop if compare chars s char at prefix length ch ignore case break loop prefix length return first substring prefix length 
 sorts the specified array  equivalent to calling code  arrays sort code param obj  the array param compare  compares the objects since j edit pre deprecated use code  arrays sort code  deprecated public static void quicksort  object obj  comparator compare  arrays sort obj compare 
 sorts the specified vector param vector  the vector param compare  compares the objects since j edit pre deprecated code  collections sort code  deprecated public static void quicksort  vector vector  comparator compare  collections sort vector compare 
 sorts the specified list param list  the list param compare  compares the objects since j edit pre deprecated code  collections sort code  deprecated public static void quicksort  list list  comparator compare  collections sort list compare 
 sorts the specified array  equivalent to calling code  arrays sort code param obj  the array param compare  compares the objects deprecated use code  arrays sort code  deprecated public static void quicksort  object obj  compare compare  arrays sort obj compare 
 sorts the specified vector param vector  the vector param compare  compares the objects deprecated code  collections sort code  deprecated public static void quicksort  vector vector  compare compare  collections sort vector compare 
public int compare  object obj  object obj return  standard utilities compare strings obj to string obj to string false 
public int compare  object obj  object obj return  standard utilities compare strings obj to string obj to string true 
public int compare  object obj  object obj return comparator compare j menu item obj j menu item obj 
 converts an internal version number build into a human readable form param build  the build public static  string build to version  string build if build length return unknown version build  first chars are the major version number int major  integer parse int build substring  second are the minor number int minor  integer parse int build substring  then the pre release status int beta  integer parse int build substring  finally the bug fix release int bugfix  integer parse int build substring return major minor beta rc beta bugfix bugfix 
 if on jdk or higher make sure that tools jar is available  this method should be called by plugins requiring the classes in this library p tools jar is searched for in the following places ol li the classpath that was used when j edit was started li j edit s jars folder in the user s home li j edit s system jars folder li i java home i lib  in this case tools jar is added to j edit s list of known jars using j edit add plugin jar so that it gets loaded through jar class loader ol p  on older jdk s this method does not perform any checks and returns code true code even though there is no tools jar return code false code if and only if on jdk and tools jar could not be found  in this case it prints some warnings on  log too about the places where it was searched for since j edit public static boolean is tools jar available  log log  log debug  misc utilities class  searching for tools jar  collection  string paths new  linked list  string  check whether tools jar is in the system classpath paths add  system classpath  system get property java class path try  either class sun tools javac  main or com sun tools javac  main must be there try  class for name sun tools javac  main catch  class not found exception e  class for name com sun tools javac  main  log log  log debug  misc utilities class is in classpath  fine return true catch  class not found exception e  log log  log debug  misc utilities class is not in system classpath  check whether it is in the j edit user settings jars folder  string settings dir j edit get settings directory if settings dir null  string tools path construct path settings dir jars tools jar paths add tools path if new  file tools path exists  log log  log debug  misc utilities class is in the user s jars folder  fine j edit will load it automatically return true  check whether it is in j edit s system jars folder  string j edit dir j edit get j edit home if j edit dir null  string tools path construct path j edit dir jars tools jar paths add tools path if new  file tools path exists  log log  log debug  misc utilities class is in j edit s system jars folder  fine j edit will load it automatically return true  check whether it is in java home lib  string tools path  system get property java home if tools path to lower case ends with  file separator jre tools path tools path substring tools path length tools path construct path tools path lib tools jar paths add tools path if new  file tools path exists  log log  log warning  misc utilities class  could not find tools jar n i checked the following locations n paths to string return false  load it if not yet done  plugin jar jar j edit get plugin jar tools path if jar null  log log  log debug  misc utilities class adding tools path to j edit plugins j edit add plugin jar tools path else  log log  log debug  misc utilities class has been loaded before return true 
 parse a  unix style permission string rwxrwxrwx param s  the string must be characters long since j edit pre public static int parse permissions  string s int permissions if s length if s char at r permissions if s char at w permissions if s char at x permissions else if s char at s permissions else if s char at s permissions if s char at r permissions if s char at w permissions if s char at x permissions else if s char at s permissions else if s char at s permissions if s char at r permissions if s char at w permissions if s char at x permissions else if s char at t permissions else if s char at t permissions return permissions 
 returns a list of supported character encodings since j edit pre deprecated  see get encodings boolean  deprecated public static  string get encodings return get encodings false 
 returns a list of supported character encodings since j edit pre param get selected  whether to return just the selected encodings or all public static  string get encodings boolean get selected  set  string set if get selected set  encoding server get selected names else set  encoding server get available names return set to array new  string set size 
 returns a string containing the stack trace of the given throwable since j edit pre public static  string throwable to string  throwable t  string writer s new  string writer t print stack trace new  print writer s return s to string 
 convenience method for parsing an xml file return  whether any error occured during parsing since j edit pre deprecated  use link xml utilities parse xml  input stream  default handler  deprecated public static boolean parse xml  input stream in  default handler handler throws io exception return xml utilities parse xml in handler 
 tries to find the given system id in the context of the given class deprecated  use link xml utilities find entity  string  string  class  deprecated public static  input source find entity  string system id  string test  class where return xml utilities find entity system id test where 
private  misc utilities 
 compares two chars should this be public param ch the first char param ch the second char param ignore case true if you want to ignore case private static boolean compare chars char ch char ch boolean ignore case if ignore case return  character to upper case ch  character to upper case ch else return ch ch 
private static int get path start  string path if path starts with return else if  operating system is dos derived path length path char at path char at path char at return else return 
private static boolean contains null character  reader reader throws io exception int nb chars j edit get integer property vfs binary check length int authorized j edit get integer property vfs binary check count for long i l i nb chars i int c reader read if c return false if c authorized if authorized return true return false 
 var compressor  process builder pb new  process builder  map  string  string env pb environment if  operating system is unix prefix map put  system get property user home for  string k env key set if k equals ignore case pwd k equals ignore case oldpwd continue if  character is letter k char at continue  string v env get k only add possible candidates to the prefix map if can be path prefix v continue no need for trailing file separator if v ends with  file separator v v substring v length check if it is actually shorter if  operating system is windows if k length v length continue gets replaced by foo else if k length v length continue gets replaced by foo if  operating system is windows no case sensitivity might as well convert to lower case v v to lower case k k to lower case if prefix map contains key v  string other key prefix map get v if other key length k length continue prefix map put v k 
 string compress  string path  string original path if previous contains key path return previous get path  string best prefix  string verified prefix best prefix for  string try prefix prefix map key set if try prefix length best prefix length continue if  operating system is windows path to lower case starts with try prefix best prefix try prefix else if path starts with try prefix best prefix try prefix  only use prefix if it is a directory prefix of the path if best prefix equals verified prefix  string remainder original substring best prefix length if remainder length remainder starts with  file separator verified prefix best prefix else best prefix verified prefix if best prefix length  string remainder original substring best prefix length  string envvar prefix map get best prefix if envvar equals path envvar remainder else if  operating system is windows path envvar to upper case remainder else path envvar remainder previous put original path return path 
private boolean can be path prefix  string s  do not use  file is directory since it causes access to file system or network to check if the directory is actually exists return s contains  file path separator new  file s is absolute 
 creates a new edit mode param name  the name used in mode listings and to query mode properties see get property  string public  mode  string name this name name this ignore whitespace true props new  hashtable  string  object 
 initializes the edit mode  should be called after all properties are loaded and set public void init try  string filename glob  string get property filename glob if filename glob null filename glob length filename re  pattern compile  standard utilities glob to re filename glob  pattern case insensitive  string firstline glob  string get property firstline glob if firstline glob null firstline glob length firstline re  pattern compile  standard utilities glob to re firstline glob  pattern case insensitive catch  pattern syntax exception re  log log  log error this  invalid filename firstline globs in mode name  log log  log error this re  fix for this bug  put a mode into the user dir with the same name as one on the system dir  reload edit modes  old mode from system dir still used for highlighting until j edit restart marker null 
 returns the token marker for this mode public  token marker get token marker load if necessary return marker 
 sets the token marker for this mode param marker  the new token marker public void set token marker  token marker marker this marker marker 
 loads the mode from disk if it hasn t been loaded already since j edit pre public void load if necessary if marker null  mode provider instance load mode this if marker null  log log  log error this  mode not correctly loaded token marker is still null 
 returns a mode property param key  the property name since j edit pre public  object get property  string key  object value props get key if value null return value return null 
 returns the value of a boolean property param key  the property name since j edit pre public boolean get boolean property  string key  object value get property key return  standard utilities get boolean value false 
 sets a mode property param key  the property name param value  the property value public void set property  string key  object value props put key value 
 unsets a mode property param key  the property name since j edit pre public void unset property  string key props remove key 
 should only be called by code x mode handler code since j edit pre public void set properties  map props if props null props new  hashtable  string  object ignore whitespace false equals ignore case  string props get ignore whitespace need to carry over file name and first line globs because they are not given to us by the x mode handler but instead are filled in by the catalog loader  string filename glob  string this props get filename glob  string firstline glob  string this props get firstline glob  string filename  string this props get file this props props if filename glob null props put filename glob filename glob if firstline glob null props put firstline glob firstline glob if filename null props put file filename 
 returns true if the edit mode is suitable for editing the specified file  the buffer name and first line is checked against the file name and first line globs respectively param file name  the buffer s name param first line  the first line of the buffer since j edit pre public boolean accept  string file name  string first line return accept filename file name accept first line first line 
 returns true if the buffer name matches the file name glob param file name  the buffer s name return true if the file name matches the file name glob since j edit pre public boolean accept filename  string file name return filename re null filename re matcher file name matches 
 returns true if the first line matches the first line glob param first line  the first line of the buffer return true if the first line matches the first line glob since j edit pre public boolean accept first line  string first line return firstline re null firstline re matcher first line matches 
 returns the internal name of this edit mode public  string get name return name 
 returns a string representation of this edit mode public  string to string return name 
public boolean get ignore whitespace return ignore whitespace 
public synchronized  list  indent rule get indent rules if indent rules null init indent rules return indent rules 
public synchronized boolean is electric key char ch if electric keys null  string props indent open brackets indent close brackets electric keys  string builder buf new  string builder for int i i props length i  string prop  string get property props i if prop null buf append prop electric keys buf to string return electric keys index of ch 
private void init indent rules  list  indent rule rules new  linked list  indent rule  string regexp props indent next line indent next lines for int i i regexp props length i  indent rule rule create regexp indent rule regexp props i if rule null rules add rule  string bracket props indent open bracket indent close bracket unaligned open bracket unaligned close bracket for int i i bracket props length i create bracket indent rules bracket props i rules  string final props unindent this line unindent next lines for int i i final props length i  indent rule rule create regexp indent rule final props i if rule null rules add rule if get boolean property deep indent  string unaligned open brackets  string get property unaligned open brackets if unaligned open brackets null for int i i unaligned open brackets length i char open char unaligned open brackets char at i char close char  text utilities get complementary bracket open char null if close char rules add new  deep indent rule open char close char if get ignore whitespace rules add new  whitespace rule indent rules  collections unmodifiable list rules 
private  indent rule create regexp indent rule  string prop  string value  string get property prop try if value null  method m  indent rule factory class get method prop new  class  string class return  indent rule m invoke null value catch  exception e  log log  log error this  bad indent rule prop value  log log  log error this e return null 
private void create bracket indent rules  string prop  list  indent rule rules  string value  string get property prop s try if value null for int i i value length i char ch value char at i  method m  indent rule factory class get method prop new  class char class rules add  indent rule m invoke null ch catch  exception e  log log  log error this  bad indent rule prop value  log log  log error this e 
 mode catalog handler  string directory boolean resource this directory directory this resource resource 
public  input source resolve entity  string public id  string system id return xml utilities find entity system id catalog dtd get class 
public void start element  string uri  string local name  string q name  attributes attrs if q name equals mode  string mode name attrs get value name  string file attrs get value file if file null  log log  log error this directory catalog mode mode name doesn t have a file attribute  string filename glob attrs get value file name glob  string firstline glob attrs get value first line glob  mode mode  mode provider instance get mode mode name if mode null mode instantiate mode mode name  mode provider instance add mode mode  object path if resource path j edit class get resource directory file else path  misc utilities construct path directory file mode set property file path if filename glob null mode set property filename glob filename glob else mode unset property filename glob if firstline glob null mode set property firstline glob firstline glob else mode unset property firstline glob mode init 
protected  mode instantiate mode  string mode name return new  mode mode name 
public void remove all modes new  array list  mode 
 returns the edit mode with the specified name param name  the edit mode since j edit pre public  mode get mode  string name for int i i modes size i  mode mode modes get i if mode get name equals name return mode return null 
 get the appropriate mode that must be used for the file param filename the filename param first line the first line of the file return the edit mode or null if no mode match the file since j edit pre public  mode get mode for file  string filename  string first line  string nogz name filename substring filename length filename ends with gz  mode modes get modes this must be in reverse order so that modes from the user catalog get checked first for int i modes length i i if modes i accept nogz name first line return modes i return null 
 returns an array of installed edit modes since j edit pre public  mode get modes  mode array new  mode modes size modes to array array return array 
 do not call this method  it is only public so that classes in the org gjt sp jedit syntax package can access it since j edit pre param mode  the edit mode public void add mode  mode mode modes add mode 
public void load mode  mode mode x mode handler xmh  string file name  string mode get property file  log log  log notice this  loading edit mode file name xml reader parser try parser xml reader factory create xml reader catch sax exception saxe  log log  log error this saxe return mode set token marker xmh get token marker  input stream grammar try grammar new  buffered input stream new  file input stream file name catch  file not found exception e  input stream resource  mode provider class get resource as stream file name if resource null error file name e grammar new  buffered input stream resource try  input source isrc new  input source grammar isrc set system id jedit jar parser set content handler xmh parser set dtd handler xmh parser set entity resolver xmh parser set error handler xmh parser parse isrc mode set properties xmh get mode properties catch  throwable e error file name e finally io utilities close quietly grammar 
public void load mode  mode mode x mode handler xmh new x mode handler mode get name  override public void error  string what  object subst  log log  log error this subst  override public  token marker get token marker  string mode name  mode mode get mode mode name if mode null return null else return mode get token marker load mode mode xmh 
protected void error  string file  throwable e  log log  log error this e 
public  widget get widget  view view  mode widget mode new  mode widget view return mode 
public  mode widget final  view view mode new  tool tip label this view view mode set tool tip text j edit get property view status mode tooltip mode add mouse listener new  mouse adapter  override public void mouse clicked  mouse event evt if evt get click count new  buffer options view view get buffer 
public j component get component return mode 
public void update  buffer buffer view get buffer if buffer is loaded mode set text buffer get mode to string 
public void properties changed 
param context is method or field public void add modifier int context  string name if modifiers null modifiers new  hashtable  object existing modifiers put name  void type arbitrary flag if existing null throw new  illegal state exception  duplicate modifier name int count if has modifier private count if has modifier protected count if has modifier public count if count throw new  illegal state exception public private protected cannot be used in combination switch context case class validate for class break case method validate for method break case field validate for field break 
public boolean has modifier  string name if modifiers null modifiers new  hashtable return modifiers get name null 
private void validate for method insure no volatile  method insure no transient  method 
private void validate for field insure no synchronized  variable insure no native  variable insure no abstract  variable 
private void validate for class validate for method volatile transient insure no native  class insure no synchronized  class 
private void insure no  string modifier  string context if has modifier modifier throw new  illegal state exception context cannot be declared modifier 
public  string to string return  modifiers modifiers 
 mouse actions i property manager property manager  string name this property manager property manager this name name 
public  string get action for event  mouse event evt  string variant  string mod str  key event translator get modifier string evt if mod str null return property manager get property view name variant  click else return property manager get property view name  key event translator get modifier string evt variant  click 
public  mouse handler j edit text area text area super text area this text area text area 
 override public void mouse pressed  mouse event evt show cursor control  operating system is mac os evt is meta down  operating system is mac os evt is control down ctrl for rectangular selection text area is ctrl for rectangular selection so that  home mouse click  home is not the same as pressing  home twice in a row text area get input handler reset last action count quick copy drag text area is quick copy enabled is middle button evt get modifiers if quick copy drag text area request focus  text area focused component text area if text area get buffer is loading return  edit bus send new  position changing text area int x evt get x int y evt get y drag start text area xy to offset x y text area get painter is block caret enabled text area is overwrite enabled drag start line text area get line of offset drag start drag start offset drag start text area get line start offset drag start line if is popup trigger evt text area get right click popup null if text area is right click popup enabled text area handle popup trigger evt return dragged false text area blink true text area invalidate line text area get caret line click count evt get click count if text area is drag enabled text area selection manager inside selection x y click count evt is shift down maybe drag and drop true text area move caret position drag start false return maybe drag and drop false if quick copy drag ignore double clicks of middle button do single click evt else switch click count case do single click evt break case do double click break default case do triple click break 
 override public void mouse released  mouse event evt middle mouse button drag inserts selection at caret position  selection sel text area get selection at offset drag start if dragged sel null  registers set register text area get selected text sel if quick copy drag text area remove from selection sel  registers paste  text area focused component sel instanceof  selection  rect  text area focused component request focus else if dragged text area is quick copy enabled is middle button evt get modifiers text area request focus  text area focused component text area text area set caret position drag start false if text area is editable text area get toolkit beep else  registers paste text area control else if maybe drag and drop text area is multiple selection enabled text area select none maybe drag and drop false dragged false 
public  mouse option pane super mouse 
protected void  init  text drag and drop drag and drop new j check box j edit get property options mouse drag and drop drag and drop set selected j edit get boolean property view drag and drop add component drag and drop  non word character selection behavior join non word chars new j check box j edit get property options mouse join non word chars join non word chars set selected j edit get boolean property view join non word chars add component join non word chars  middle mouse button click pastes register middle mouse paste new j check box j edit get property options mouse middle mouse paste middle mouse paste set selected j edit get boolean property view middle mouse paste add component middle mouse paste  pressing  ctrl while mouse actions makes them as if selection mode were rectangular mode ctrl for rectangular selection new j check box j edit get property options mouse ctrl for rectangular selection ctrl for rectangular selection set selected j edit get boolean property view ctrl for rectangular selection add component ctrl for rectangular selection  gutter mouse actions int c click action keys length  string click action names new  string c for int i i c i click action names i j edit get property options mouse gutter click action keys i c click modifier keys length  string click modifier names new  string c for int i i c i click modifier names i j edit get property options mouse gutter click modifier keys i gutter click actions new j combo box c for int i i c i j combo box cb new j combo box click action names gutter click actions i cb  string val j edit get property view gutter click modifier keys i for int j j click action keys length j if val equals click action keys j cb set selected index j add component click modifier names i cb 
public void  save j edit set boolean property view drag and drop drag and drop is selected j edit set boolean property view join non word chars join non word chars is selected j edit set boolean property view middle mouse paste middle mouse paste is selected j edit set boolean property view ctrl for rectangular selection ctrl for rectangular selection is selected int c click modifier keys length for int i i c i int idx gutter click actions i get selected index j edit set property view gutter click modifier keys i click action keys idx 
public  widget get widget  view view  widget multi select new  multi select widget view return multi select 
 multi select widget final  view view multi select new  tool tip label multi select set horizontal alignment  swing constants center multi select set tool tip text j edit get property view status multi tooltip this view view multi select add mouse listener new  mouse adapter  override public void mouse clicked  mouse event e j edit text area text area view get text area if text area null text area toggle multiple selection enabled 
public j component get component return multi select 
public void update j edit text area text area view get text area if text area null multi select set text text area is multiple selection enabled m 
public void properties changed retarded gtk look and feel  font font new j label get font ui manager get font  label font  font metrics fm multi select get font metrics font  dimension dim new  dimension  math max fm char width fm char width m fm get height multi select set preferred size dim multi select set maximum size dim 
private void reset eval name value eval base object null callstack depth 
 this constructor should not be used in general  use  name space get name resolver which supports caching see  name space get name resolver i wish i could make this friendly to only  name space  name  name space namespace  string s this namespace namespace value s 
 resolve possibly complex name to an object value  throws  eval error on various failures a null object value is indicated by a  primitive null a return type of  primitive void comes from attempting to access an undefined variable  some cases my variable my variable foo my variable foo bar java awt  grid bag constraints both my package stuff  my class some field some field  interpreter reference is necessary to allow resolution of this interpreter magic field  call stack reference is necessary to allow resolution of this caller magic field this callstack magic field public  object to object  call stack callstack  interpreter interpreter throws  util eval error return to object callstack interpreter false 
see to object param force class if true then resolution will only produce a class  this is necessary to disambiguate in cases where the grammar knows that we want a class where in general the var path may be taken synchronized public  object to object  call stack callstack  interpreter interpreter boolean force class throws  util eval error reset  object obj null while eval name null obj consume next object field callstack interpreter force class false autoalloc if obj null throw new  interpreter error null value in to object return obj 
private  object complete round  string last eval name  string next eval name  object return object if return object null throw new  interpreter error last eval name last eval name this last eval name last eval name this eval name next eval name this eval base object return object return return object 
 get the next object by consuming one or more components of eval name  often this consumes just one component but if the name is a classname it will consume all of the components necessary to make the class identifier private  object consume next object field  call stack callstack  interpreter interpreter boolean force class boolean auto allocate this throws  util eval error  is it a simple variable name  doing this first gives the correct  java precedence for vars vs imported class names at least in the simple case see tests precedence bsh  it should also speed things up a bit if eval base object null is compound eval name force class  object obj resolve this field reference callstack namespace interpreter eval name false if obj  primitive void return complete round eval name finished obj  is it a bsh script variable reference  if we re just starting the eval of name no base object or we re evaluating relative to a  this type reference check  string var name prefix eval name if eval base object null eval base object instanceof  this force class if  interpreter debug  interpreter debug trying to resolve variable var name  object obj switch namespace and special var visibility if eval base object null obj resolve this field reference callstack namespace interpreter var name false else obj resolve this field reference callstack  this eval base object namespace interpreter var name true if obj  primitive void  resolved the variable if  interpreter debug  interpreter debug resolved variable var name in namespace namespace return complete round var name suffix eval name obj  is it a class name  if we re just starting eval of name try to make it else fail if eval base object null if  interpreter debug  interpreter debug trying class eval name  keep adding parts until we have a class  class clas null int i  string class name null for i count parts eval name i class name prefix eval name i if clas namespace get class class name null break if clas null return complete round class name suffix eval name count parts eval name i new  class identifier clas not a class or variable per above if  interpreter debug  interpreter debug not a class trying var prefix eval name  no variable or class found in this type ref if auto allocate this then create one a child this if eval base object null eval base object instanceof  this force class auto allocate this  name space target name space eval base object null namespace  this eval base object namespace  object obj new  name space target name space auto var name get this interpreter target name space set variable var name obj false return complete round var name suffix eval name obj  if we didn t find a class or variable name or prefix above there are two possibilities  if we are a simple name then we can pass as a void variable reference  if we are compound then we must fail at this point if eval base object null if is compound eval name return complete round eval name finished  primitive void else throw new  util eval error  class or variable not found eval name  after this point we re definitely evaluating relative to a base object  do some basic validity checks if eval base object  primitive null previous round produced null throw new  util target error new  null pointer exception  null  pointer while evaluating value if eval base object  primitive void previous round produced void throw new  util eval error  undefined variable or class name while evaluating value if eval base object instanceof  primitive throw new  util eval error  can t treat primitive like an object  error while evaluating value  resolve relative to a class type static field inner class if eval base object instanceof  class identifier  class clas  class identifier eval base object get target class  string field prefix eval name  class qualified this reference from inner class e g  my outer class this if field equals this find the enclosing class instance space of the class name  name space ns namespace while ns null get class instance throws exception if not there if ns class instance null ns class instance get class clas return complete round field suffix eval name ns class instance ns ns get parent throw new  util eval error  can t find enclosing this instance of class clas  object obj null static field try if  interpreter debug  interpreter debug  name call to get static field value class clas field field obj  reflect get static field value clas field catch  reflect error e if  interpreter debug  interpreter debug field reflect error e inner class if obj null  string iclass clas get name field  class c namespace get class iclass if c null obj new  class identifier c if obj null throw new  util eval error  no static field or inner class field of clas return complete round field suffix eval name obj  if we ve fallen through here we are no longer resolving to a class type if force class throw new  util eval error value does not resolve to a class name  some kind of field access  string field prefix eval name length access on array if field equals length eval base object get class is array  object obj new  primitive  array get length eval base object return complete round field suffix eval name obj  check for field on object  note could eliminate throwing the exception somehow try  object obj  reflect get object field value eval base object field return complete round field suffix eval name obj catch  reflect error e not a field if we get here we have failed throw new  util eval error  cannot access field field on object eval base object 
 resolve a variable relative to a  this reference  this is the general variable resolution method accomodating special fields from the  this context  together the namespace and interpreter comprise the  this context  the callstack if available allows for the this caller construct  optionally interpret special magic field names e g interpreter p param callstack may be null but this is only legitimate in special cases where we are sure resolution will not involve this caller param namespace the namespace of the this reference should be the same as the top of the stack  object resolve this field reference  call stack callstack  name space this name space  interpreter interpreter  string var name boolean special fields visible throws  util eval error if var name equals this  somewhat of a hack  if the special fields are visible we re operating relative to a this type already dissallow further this references to prevent user from skipping to things like super this caller if special fields visible throw new  util eval error  redundant to call this on  this type  allow get this to work through  block name space to the method namespace xxx re eval this do we need it  this ths this name space get this interpreter this name space ths get name space  object result ths  name space class name space get class name space this name space if class name space null if is compound eval name result class name space get this interpreter else result class name space get class instance return result  some duplication for super  see notes for this above  if we re in an enclsing class instance and have a superclass instance our super is the superclass instance if var name equals super if special fields visible throw new  util eval error  redundant to call this on  this type  allow get super to through  block name space to the method s super  this ths this name space get super interpreter this name space ths get name space super is now the closure s super or class instance xxxx re evaluate this can get super work by itself now  if we re a class instance and the parent is also a class instance then super means our parent if this name space get parent null this name space get parent is class ths this name space get parent get this interpreter return ths  object obj null if var name equals global obj this name space get global interpreter if obj null special fields visible if var name equals namespace obj this name space else if var name equals variables obj this name space get variable names else if var name equals methods obj this name space get method names else if var name equals interpreter if last eval name equals this obj interpreter else throw new  util eval error  can only call interpreter on literal this if obj null special fields visible var name equals caller if last eval name equals this last eval name equals caller get the previous context see notes for this class if callstack null throw new  interpreter error no callstack obj callstack get callstack depth get this interpreter else throw new  util eval error  can only call caller on literal this or literal caller early return return obj if obj null special fields visible var name equals callstack if last eval name equals this get the previous context see notes for this class if callstack null throw new  interpreter error no callstack obj callstack else throw new  util eval error  can only call callstack on literal this if obj null obj this name space get variable var name if obj null throw new  interpreter error null this field ref var name return obj 
return the enclosing class body namespace or null if not in a class static  name space get class name space  name space this name space is a class instance if this name space class instance null if this name space is class return this name space if this name space is method this name space get parent null this name space get parent class instance null this name space get parent is class return this name space get parent return null 
 check the cache else use to object to try to resolve to a class identifier throws  class not found exception on class not found throws  class path exception type of  eval error on special case of ambiguous unqualified name after super import synchronized public  class to class throws  class not found exception  util eval error if as class null return as class reset var means untyped return null class if eval name equals var return as class null  try straightforward class name first  class clas namespace get class eval name if clas null  try to object which knows how to work through inner classes and see what we end up with  object obj null try  null interpreter and callstack references class only resolution should not require them obj to object null null true catch  util eval error e couldn t resolve it if obj instanceof  class identifier clas  class identifier obj get target class if clas null throw new  class not found exception  class value not found in namespace as class clas return as class 
synchronized public lhs to lhs  call stack callstack  interpreter interpreter throws  util eval error  should clean this up to a single return statement reset lhs lhs  simple non compound variable assignment e g x if is compound eval name if eval name equals this throw new  util eval error  can t assign to this  interpreter debug  simple var lhs lhs new lhs namespace eval name false bubble up if allowed return lhs  field e g foo bar  object obj null try while eval name null is compound eval name obj consume next object field callstack interpreter false forcclass true autoallocthis catch  util eval error e throw new  util eval error lhs evaluation e get message  finished eval and its a class if eval name null obj instanceof  class identifier throw new  util eval error  can t assign to class value if obj null throw new  util eval error  error in lhs value e g this x or some this type x if obj instanceof  this dissallow assignment to magic fields if eval name equals namespace eval name equals variables eval name equals methods eval name equals caller throw new  util eval error  can t assign to special variable eval name  interpreter debug found  this reference evaluating lhs  if this was a literal super reference then we allow recursion in setting the variable to get the normal effect of finding the nearest definition starting at the super scope  on any other resolution qualified by a this type reference we want to set the variable directly in that scope e g this x or some this type x  in the old scoping rules super didn t do this boolean local var last eval name equals super return new lhs  this obj namespace eval name local var if eval name null try if obj instanceof  class identifier  class clas  class identifier obj get target class lhs  reflect get lhs static field clas eval name return lhs else lhs  reflect get lhs object field obj eval name return lhs catch  reflect error e throw new  util eval error  field access e throw new  interpreter error  internal error in lhs 
 invoke the method identified by this name  performs caching of method resolution using  signature key p  name contains a wholely unqualfied messy name resolve it to object static prefix method name and invoke p  the interpreter is necessary to support this interpreter references in the called code e g debug p pre  some cases dynamic local my variable foo my variable bar blah foo static java lang  integer get integer foo pre public  object invoke method  interpreter interpreter  object args  call stack callstack  simple node caller info throws  util eval error  eval error  reflect error  invocation target exception  string method name  name suffix value  bsh class manager bcm interpreter get class manager  name space namespace callstack top  optimization  if class of static method is set then we have already been here and determined that this is a static method invocation  note maybe factor this out with path below clean up if class of static method null return  reflect invoke static method bcm class of static method method name args if  name is compound value return invoke local method interpreter args callstack caller info  note if we want methods declared inside blocks to be accessible via this methodname inside the block we could handle it here as a special case  see also resolve this field reference special handling for  block name space case  they currently work via the direct name e g method name  string prefix  name prefix value  superclass method invocation e g super foo if prefix equals super  name count parts value  allow get this to work through block namespaces first  this ths namespace get this interpreter  name space this name space ths get name space  name space class name space get class name space this name space if class name space null  object instance class name space get class instance return  class generator get class generator invoke superclass method bcm instance method name args  find target object or class identifier  name target name namespace get name resolver prefix  object obj target name to object callstack interpreter if obj  primitive void throw new  util eval error  attempt to resolve method method name on undefined variable or class name target name if we ve got an object resolve the method if obj instanceof  class identifier if obj instanceof  primitive if obj  primitive null throw new  util target error new  null pointer exception  null  pointer in  method  invocation some other primitive should avoid calling methods on primitive as we do in  name can t treat primitive like an object message but the hole is useful right now if  interpreter debug interpreter debug  attempt to access method on primitive allowing bsh  primitive to peek through for debugging found an object and it s not an undefined variable return  reflect invoke object method obj method name args interpreter callstack caller info  it s a class try static method if  interpreter debug  interpreter debug invoke method trying static target name  class clas  class identifier obj get target class cache the fact that this is a static method invocation on this class class of static method clas if clas null return  reflect invoke static method bcm clas method name args return null throw new  util eval error invoke method unknown target target name 
 invoke a locally declared method or a bsh command  if the method is not already declared in the namespace then try to load it as a resource from the imported command path e g bsh commands  note the bsh command code should probably not be here we need to scope it by the namespace that imported the command so it probably needs to be integrated into  name space private  object invoke local method  interpreter interpreter  object args  call stack callstack  simple node caller info throws  eval error  reflect error  invocation target exception if  interpreter debug  interpreter debug invoke local method value if interpreter null throw new  interpreter error invoke local method interpreter null  string command name value  class arg types  types get types args  check for existing method  bsh method meth null try meth namespace get method command name arg types catch  util eval error e throw e to eval error  local method invocation caller info callstack  if defined invoke it if meth null return meth invoke args interpreter callstack caller info  bsh class manager bcm interpreter get class manager  look for a  bean shell command  object command object try command object namespace get command command name arg types interpreter catch  util eval error e throw e to eval error  error loading command caller info callstack should try to print usage here if nothing found if command object null  look for a default invoke handler method in the namespace  note this code duplicates that in  this java should it  call on  this can never be a command  bsh method invoke method null try invoke method namespace get method invoke new  class null null catch  util eval error e throw e to eval error  local method invocation caller info callstack if invoke method null return invoke method invoke new  object command name args interpreter callstack caller info throw new  eval error  command not found  string util method string command name arg types caller info callstack if command object instanceof  bsh method return  bsh method command object invoke args interpreter callstack caller info if command object instanceof  class try return  reflect invoke compiled command  class command object args interpreter callstack catch  util eval error e throw e to eval error  error invoking compiled command caller info callstack throw new  interpreter error invalid command type 
public static boolean is compound  string value return value index of return count parts value 
static int count parts  string value if value null return int count int index while index value index of index count return count 
static  string prefix  string value if is compound value return null return prefix value count parts value 
static  string prefix  string value int parts if parts return null int count int index while index value index of index count parts return index value value substring index 
static  string suffix  string name if is compound name return null return suffix name count parts name 
public static  string suffix  string value int parts if parts return null int count int index value length while index value last index of index count parts return index value value substring index 
public  string to string return value 
void set class static  class clas this class static clas import static clas 
void set class instance  object instance this class instance instance import object instance 
 object get class instance throws  util eval error if class instance null return class instance if class static null get parent null get parent class static null throw new  util eval error  can t refer to class instance from static context else throw new  interpreter error  can t resolve class instance this in this 
param parent the parent namespace of this namespace  child namespaces inherit all variables and methods of their parent and can of course override shadow them param name a name public  name space  name space parent  string name  note in this case parent must have a class manager this parent null name 
public  name space  bsh class manager class manager  string name this null class manager name 
public  name space  name space parent  bsh class manager class manager  string name  we might want to do this here rather than explicitly in  interpreter for global see also prune if class manager null parent null create our own class manager set name name set parent parent set class manager class manager  register for notification of classloader change if class manager null class manager add listener this 
public void set name  string name this ns name name 
 the name of this namespace  if the namespace is a method body namespace then this is the name of the method  if it s a class or class instance then it s the name of the class public  string get name return this ns name 
 set the node associated with the creation of this namespace  this is used in debugging and to support the get invocation line and get invocation text methods void set node  simple node node caller info node node 
 simple node get node if caller info node null return caller info node if parent null return parent get node else return null 
 resolve name to an object through this namespace public  object get  string name  interpreter interpreter throws  util eval error  call stack callstack new  call stack this return get name resolver name to object callstack interpreter 
 set the variable through this namespace  this method obeys the localscoping property to determine how variables are set p  note this method is primarily intended for use internally  if you use this method outside of the bsh package and wish to set variables with primitive values you will have to wrap them using bsh  primitive see org gjt sp jedit bsh  primitive p  setting a new variable which didn t exist before or removing a variable causes a namespace change param strict java specifies whether strict java rules are applied public void set variable  string name  object value boolean strict java throws  util eval error if localscoping switch follow strict java else recurse boolean recurse  interpreter localscoping strict java true set variable name value strict java recurse 
 set a variable explicitly in the local scope void set local variable  string name  object value boolean strict java throws  util eval error set variable name value strict java false recurse 
 set the value of a the variable name through this namespace  the variable may be an existing or non existing variable  it may live in this namespace or in a parent namespace if recurse is true p  note  this method is not public and does not know about localscoping  its caller methods must set recurse intelligently in all situations perhaps based on localscoping p  note this method is primarily intended for use internally  if you use this method outside of the bsh package and wish to set variables with primitive values you will have to wrap them using bsh  primitive see org gjt sp jedit bsh  primitive p  setting a new variable which didn t exist before or removing a variable causes a namespace change param strict java specifies whether strict java rules are applied param recurse determines whether we will search for the variable in our parent s scope before assigning locally void set variable  string name  object value boolean strict java boolean recurse throws  util eval error if variables null variables new  hashtable primitives should have been wrapped j edit change if value null throw new  interpreter error null variable value if value null don t break j edit core and plugins unset variable name return  locate the variable definition if it exists  variable existing get variable impl name recurse  found an existing variable here or above if recurse allowed if existing null try existing set value value  variable assignment catch  util eval error e throw new  util eval error  variable assignment name e get message else  no previous variable definition found here or above if recurse if strict java throw new  util eval error  strict  java mode  assignment to undeclared variable name  if recurse set global untyped var else set it here  name space var scope recurse get global this  this modification makes default allocation local  name space var scope this var scope variables put name new  variable name value null modifiers name space changed on new variable addition name space changed 
 remove the variable from the namespace public void unset variable  string name if variables null variables remove name name space changed 
 get the names of variables defined in this namespace  this does not show variables in parent namespaces public  string get variable names if variables null return new  string else return enumeration to string array variables keys 
 get the names of methods declared in this namespace  this does not include methods in parent namespaces public  string get method names if methods null return new  string else return enumeration to string array methods keys 
 get the methods defined in this namespace  this does not show methods in parent namespaces  note  this will probably be renamed get declared methods public  bsh method get methods if methods null return new  bsh method else return flatten method collection methods elements 
private  string enumeration to string array  enumeration e  vector v new  vector while e has more elements v add element e next element  string sa new  string v size v copy into sa return sa 
 flatten the vectors of overloaded methods to a single array see get methods private  bsh method flatten method collection  enumeration e  vector v new  vector while e has more elements  object o e next element if o instanceof  bsh method v add element o else  vector ov  vector o for int i i ov size i v add element ov element at i  bsh method bma new  bsh method v size v copy into bma return bma 
 get the parent namespace  note this isn t quite the same as get super get super returns this if we are at the root namespace public  name space get parent return parent 
 get the parent namespace  this reference or this namespace  this reference if we are the top public  this get super  interpreter declaring interpreter if parent null return parent get this declaring interpreter else return get this declaring interpreter 
 get the top level namespace or this namespace if we are the top  note this method should probably return type bsh  this to be consistent with get this public  this get global  interpreter declaring interpreter if parent null return parent get global declaring interpreter else return get this declaring interpreter 
a  this object is a thin layer over a namespace comprising a bsh object context  it handles things like the interface types the bsh object supports and aspects of method invocation on it p  the declaring interpreter is here to support callbacks from  java through generated proxies  the scripted object remembers who created it for things like printing messages and other per interpreter phenomenon when called externally from  java  note we need a singleton here so that things like this this work and probably a good idea for speed  caching a single instance here seems technically incorrect considering the declaring interpreter could be different under some circumstances  case a child interpreter running a source eval command  however the effect is just that the main interpreter that executes your script should be the one involved in call backs from  java i do not know if there are corner cases where a child interpreter would be the first to use a  this reference in a namespace or if that would even cause any problems if it did  we could do some experiments to find out and if necessary we could cache on a per interpreter basis if we had weak references  we might also look at skipping over child interpreters and going to the parent for the declaring interpreter so we d be sure to get the top interpreter  this get this  interpreter declaring interpreter if this reference null this reference  this get this this declaring interpreter return this reference 
public  bsh class manager get class manager if class manager null return class manager if parent null parent javacode return parent get class manager  system out println experiment creating class manager class manager  bsh class manager create class manager null interp  interpreter debug  no class manager namespace this return class manager 
void set class manager  bsh class manager class manager this class manager class manager 
 used for serialization public void prune  cut off from parent we must have our own class manager  can t do this in the run command needs to resolve stuff  should we do it by default when we create a namespace will no parent of class manager if this class manager null xxx if we keep the create class manager in get class manager then we can axe this set class manager  bsh class manager create class manager null interp set parent null 
public void set parent  name space parent this parent parent  if we are disconnected from root we need to handle the def imports if parent null load default imports 
 get the specified variable in this namespace or a parent namespace p  note this method is primarily intended for use internally  if you use this method outside of the bsh package you will have to use  primitive unwrap to get primitive values see  primitive unwrap  object return  the variable value or  primitive void if it is not defined public  object get variable  string name throws  util eval error return get variable name true 
 get the specified variable in this namespace param recurse  if recurse is true then we recursively search through parent namespaces for the variable p  note this method is primarily intended for use internally  if you use this method outside of the bsh package you will have to use  primitive unwrap to get primitive values see  primitive unwrap  object return  the variable value or  primitive void if it is not defined public  object get variable  string name boolean recurse throws  util eval error  variable var get variable impl name recurse return unwrap variable var 
 locate a variable and return the  variable object with optional recursion through parent name spaces p  if this namespace is static return only static variables return the  variable value or null if it is not defined protected  variable get variable impl  string name boolean recurse throws  util eval error  variable var null  change import precedence if we are a class body instance  get imported first if var null is class var get imported var name if var null variables null var  variable variables get name  change import precedence if we are a class body instance if var null is class var get imported var name try parent if recurse var null parent null var parent get variable impl name recurse return var 
public  variable get declared variables if variables null return new  variable  variable vars new  variable variables size int i for  enumeration e variables elements e has more elements vars i  variable e next element return vars 
 unwrap a variable to its value return return the variable value a null var is mapped to  primitive void protected  object unwrap variable  variable var throws  util eval error return var null  primitive void var get value 
deprecated  see set typed variable  string  class  object  modifiers public void set typed variable  string name  class type  object value boolean is final throws  util eval error  modifiers modifiers new  modifiers if is final modifiers add modifier  modifiers field final set typed variable name type value modifiers 
 declare a variable in the local scope and set its initial value  value may be null to indicate that we would like the default value for the variable type e g for integer types null for object types  an existing typed variable may only be set to the same type  if an untyped variable of the same name exists it will be overridden with the new typed var  the set will perform a  types get assignable form on the value if necessary p  note this method is primarily intended for use internally  if you use this method outside of the bsh package and wish to set variables with primitive values you will have to wrap them using bsh  primitive see org gjt sp jedit bsh  primitive param value  if value is null you ll get the default value for the type param modifiers may be null public void set typed variable  string name  class type  object value  modifiers modifiers throws  util eval error check variable modifiers name modifiers if variables null variables new  hashtable  setting a typed variable is always a local operation  variable existing get variable impl name false recurse  null value is just a declaration  note we might want to keep any existing value here instead of reset  moved to  variable if value null value  primitive get default value type does the variable already exist if existing null  is it typed if existing get type null  if it had a different type throw error  this allows declaring the same var again but not with a different even if assignable type if existing get type type throw new  util eval error  typed variable name was previously declared with type existing get type else else set it and return existing set value value  variable declaration return  careful here else fall through to override and install the new typed version  add the new typed var variables put name new  variable name type value modifiers 
 note this is primarily for internal use see  interpreter source  string see  interpreter eval  string public void set method  string name  bsh method method throws  util eval error check method modifiers method if methods null methods new  hashtable  object m methods get name j edit version properly handle methods with same signature if m null methods put name method else if m instanceof  bsh method is the new method overriding the old method if  arrays equals  bsh method m get parameter types method get parameter types methods put name method else  vector v new  vector v add element m v add element method methods put name v else  vector  methods  vector m for int i i  methods size i  check whether the new method overrides some old method in the list  bsh method  old m  bsh method  methods get i if  arrays equals  old m get parameter types method get parameter types  methods remove i break  methods add element method  original  bean shell code if m null methods put name method else if m instanceof  bsh method  vector v new  vector v add element m v add element method methods put name v else  vector  vector m add element method 
see get method  string  class boolean see get method  string  class public  bsh method get method  string name  class sig throws  util eval error return get method name sig false declared only 
 get the bsh method matching the specified signature declared in this name space or a parent p  note this method is primarily intended for use internally  if you use this method outside of the bsh package you will have to be familiar with  bean shell s use of the  primitive wrapper class see org gjt sp jedit bsh  primitive return the  bsh method or null if not found param declared only if true then only methods declared directly in this namespace will be found and no inherited or imported methods will be visible public  bsh method get method  string name  class sig boolean declared only throws  util eval error  bsh method method null  change import precedence if we are a class body instance  get import first if method null is class declared only method get imported method name sig  object m null if method null methods null m methods get name m contains either  bsh method or  vector of  bsh method if m null unwrap  bsh method ma if m instanceof  vector  vector vm  vector m ma new  bsh method vm size vm copy into ma else ma new  bsh method  bsh method m  apply most specific signature matching  class candidates new  class ma length for int i i ma length i candidates i ma i get parameter types int match  reflect find most specific signature sig candidates if match method ma match if method null is class declared only method get imported method name sig try parent if declared only method null parent null return parent get method name sig return method 
 import a class name  subsequent imports override earlier ones public void import class  string name if imported classes null imported classes new  hashtable imported classes put  name suffix name name name space changed 
subsequent imports override earlier ones public void import package  string name if imported packages null imported packages new  vector  if it exists remove it and add it at the end avoid memory leak if imported packages contains name imported packages remove name imported packages add element name name space changed 
 import scripted or compiled  bean shell commands in the following package in the classpath  you may use either path or package notation e g import commands bsh commands or import commands bsh commands are equivalent  if a relative path style specifier is used then it is made into an absolute path by prepending public void import commands  string name if imported commands null imported commands new  vector dots to slashes name name replace absolute if name starts with name name remove trailing but preserve case of simple if name length name ends with name name substring name length  if it exists remove it and add it at the end avoid memory leak if imported commands contains name imported commands remove name imported commands add element name name space changed 
a command is a scripted method or compiled command class implementing a specified method signature  commands are loaded from the classpath and may be imported using the import commands method p  this method searches the imported commands packages for a script or command object corresponding to the name of the method  if it is a script the script is sourced into this namespace and the  bsh method for the requested signature is returned  if it is a compiled class the class is returned  compiled command classes implement static invoke methods p  the imported packages are searched in reverse order so that later imports take priority  currently only the first object script or class with the appropriate name is checked  if another overloaded form is located in another package it will not currently be found  this could be fixed p return a  bsh method  class or null if no such command is found param name is the name of the desired command method param arg types is the signature of the desired command method throws  util eval error if load scripted command throws  util eval error i e on errors loading a script that was found j edit s get command public  object get command  string name  class arg types  interpreter interpreter throws  util eval error if  interpreter debug  interpreter debug get command name  bsh class manager bcm interpreter get class manager  input stream in get command name if in null return load scripted command in name arg types name interpreter  chop leading and change to  string class name if path equals class name name else class name path substring replace name  class clas bcm class for name class name if clas null return clas if parent null return parent get command name arg types interpreter else return null 
protected  bsh method get imported method  string name  class sig throws  util eval error  try object imports if imported objects null for int i i imported objects size i  object object imported objects element at i  class clas object get class  method method  reflect resolve java method get class manager clas name sig false only static if method null return new  bsh method method object  try static imports if imported static null for int i i imported static size i  class clas  class imported static element at i  method method  reflect resolve java method get class manager clas name sig true only static if method null return new  bsh method method null object return null 
protected  variable get imported var  string name throws  util eval error  try object imports if imported objects null for int i i imported objects size i  object object imported objects element at i  class clas object get class  field field  reflect resolve java field clas name false only static if field null return new  variable name field get type new lhs object field  try static imports if imported static null for int i i imported static size i  class clas  class imported static element at i  field field  reflect resolve java field clas name true only static if field null return new  variable name field get type new lhs field return null 
 load a command script from the input stream and find the  bsh method in the target namespace throws  util eval error on error in parsing the script or if the the method is not found after parsing the script  if we want to support multiple commands in the command path we need to change this to not throw the exception private  bsh method load scripted command  input stream in  string name  class arg types  string resource path  interpreter interpreter throws  util eval error try interpreter eval new  input stream reader in this resource path catch  eval error e  here we catch any  eval error from the interpreter because we are using it as a tool to load the command not as part of the execution path  interpreter debug e to string throw new  util eval error  error loading script e get message  look for the loaded command  bsh method meth get method name arg types if meth null throw new  util eval error  loaded resource resource path had an error or did not contain the correct method return meth 
 helper that caches class void cache class  string name  class c if class cache null class cache new  hashtable cache count debug class cache put name c 
 load a class through this namespace taking into account imports  the class search will proceed through the parent namespaces if necessary return null if not found public  class get class  string name throws  util eval error  class c get class impl name if c null return c else implement the recursion for get class impl if parent null return parent get class name else return null 
 implementation of get class  load a class through this namespace taking into account imports p  check the cache first  if an unqualified name look for imported class or package  else try to load absolute name p  this method implements caching of unqualified names normally imports  qualified names are cached by the  bsh class manager  unqualified absolute class names e g unpackaged  foo are cached too so that we don t go searching through the imports for them each time return null if not found private  class get class impl  string name throws  util eval error  class c null  check the cache if class cache null c  class class cache get name if c null return c  unqualified simple non compound name boolean unqualified name  name is compound name  unqualified name check imported if unqualified name  try imported class if c null c get imported class impl name if found as imported also cache it if c null cache class name c return c  try absolute c class for name name if c null  cache unqualified names to prevent import check again if unqualified name cache class name c return c  not found if  interpreter debug  interpreter debug get class name not found in this return null 
 try to make the name into an imported class  this method takes into account only imports class or package found directly in this  name space no parent chain private  class get imported class impl  string name throws  util eval error  try explicitly imported class e g import foo  bar  string fullname null if imported classes null fullname  string imported classes get name not sure if we should really recurse here for explicitly imported class in parent if fullname null  found the full name in imported classes  try to make the full imported name  class clas class for name fullname  handle imported inner class case if clas null  imported full name wasn t found as an absolute class  if it is compound try to resolve to an inner class maybe this should happen in the  bsh class manager if  name is compound fullname try clas get name resolver fullname to class catch  class not found exception e not a class else if  interpreter debug  interpreter debug imported unpackaged name not found fullname  if found cache the full name in the  bsh class manager if clas null should we cache info in not a class case too get class manager cache class info fullname clas return clas else return clas  it was explicitly imported but we don t know what it is should we throw an error here return null  try imported packages e g import foo bar in reverse order of import give later imports precedence if imported packages null for int i imported packages size i i  string s  string imported packages element at i name  class c class for name s if c null return c  bsh class manager bcm get class manager  try super import if available  note we do this last to allow explicitly imported classes and packages to take priority  this method will also throw an error indicating ambiguity if it exists if bcm has super import  string s bcm get class name by unq name name if s null return class for name s return null 
private  class class for name  string name return get class manager class for name name 
 implements  name source return all variable and method names in this and all parent namespaces public  string get all names  vector vec new  vector get all names aux vec  string names new  string vec size vec copy into names return names 
 helper for implementing  name source protected void get all names aux  vector vec  enumeration var names variables keys while var names has more elements vec add element var names next element  enumeration method names methods keys while method names has more elements vec add element method names next element if parent null parent get all names aux vec 
 implements  name source  add a listener who is notified upon changes to names in this space public void add name source listener  name source  listener listener if name source listeners null name source listeners new  vector name source listeners add element listener 
 perform import causing the entire classpath to be mapped  this can take a while public void do super import throws  util eval error get class manager do super import 
public  string to string return  name space ns name null super to string ns name super to string is class is class is method method class static null class static class instance null class instance 
private synchronized void write object java io  object output stream s throws io exception clear name resolvers don t know if this is necessary names null s default write object 
 invoke a method in this namespace with the specified args and interpreter reference  no caller information or call stack is required  the method will appear as if called externally from  java p see org gjt sp jedit bsh  this invoke method  string method name  object args  interpreter interpreter  call stack callstack  simple node caller info boolean invoke method public  object invoke method  string method name  object args  interpreter interpreter throws  eval error return invoke method method name args interpreter null null 
 this method simply delegates to  this invoke method p see org gjt sp jedit bsh  this invoke method  string method name  object args  interpreter interpreter  call stack callstack  simple node caller info boolean declared only invoke method public  object invoke method  string method name  object args  interpreter interpreter  call stack callstack  simple node caller info throws  eval error return get this interpreter invoke method method name args interpreter callstack caller info false declared only 
 clear all cached classes and names public void class loader changed name space changed 
 clear all cached classes and names public void name space changed class cache null names null 
 import standard packages  currently pre import class org gjt sp jedit bsh  eval error import class org gjt sp jedit bsh  interpreter import package javax swing event import package javax swing import package java awt event import package java awt import package java net import package java util import package java io import package java lang add command path org gjt sp jedit bsh commands get class pre public void load default imports  note the resolver looks through these in reverse order per precedence rules so for max efficiency put the most common ones later import class org gjt sp jedit bsh  eval error import class org gjt sp jedit bsh  interpreter import package javax swing event import package javax swing import package java awt event import package java awt import package java net import package java util import package java io import package java lang add command path org gjt sp jedit bsh commands get class 
 this is the factory for  name objects which resolve names within this namespace e g to object to class to lhs p  this was intended to support name resolver caching allowing  name objects to cache info about the resolution of names for performance reasons  however this not proven useful yet p  we ll leave the caching as it will at least minimize  name object creation p  this method would be called get name if it weren t already used for the simple name of the  name space p  this method was public for a time which was a mistake  use get instead  name get name resolver  string ambigname if names null names new  hashtable  name name  name names get ambigname if name null name new  name this ambigname names put ambigname name return name 
public int get invocation line  simple node node get node if node null return node get line number else return 
public  string get invocation text  simple node node get node if node null return node get text else return invoked from  java code 
 this is a helper method for working inside of bsh scripts and commands  in that context it is impossible to see a  class identifier object for what it is  attempting to access a method on a  class identifier will look like a static method invocation  this method is in  name space for convenience you don t have to import bsh  class identifier to use it public static  class identifier to class  class identifier ci return ci get target class 
 clear all variables methods and imports from this namespace  if this namespace is the root it will be reset to the default imports see load default imports public void clear variables null methods null imported classes null imported packages null imported commands null imported objects null if parent null load default imports class cache null names null 
 import a compiled  java object s methods and variables into this namespace  when no scripted method command or variable is found locally in this namespace method fields of the object will be checked  objects are checked in the order of import with later imports taking precedence p  note this impor pattern is becoming common could factor it out into an imported object  vector class public void import object  object obj if imported objects null imported objects new  vector  if it exists remove it and add it at the end avoid memory leak if imported objects contains obj imported objects remove obj imported objects add element obj name space changed 
public void import static  class clas if imported static null imported static new  vector  if it exists remove it and add it at the end avoid memory leak if imported static contains clas imported static remove clas imported static add element clas name space changed 
 set the package name for classes defined in this namespace  subsequent sets override the package void set package  string package name this package name package name 
 string get package if package name null return package name if parent null return parent get package return null 
public void set variable  string name  object value throws  util eval error set variable name value false 
 adds a url to the command path public void add command path  string path  class clas if imported commands null imported commands new  vector if path ends with path imported commands add element new  command path entry path clas 
 remove a ur lfrom the command path public void remove command path  string path  class clas if imported commands null return for int i i imported commands size i  command path entry entry  command path entry imported commands element at i if entry path equals path entry clas clas imported commands remove element at i return 
 looks up a command public  input stream get command  string name if imported commands null  string ext name name bsh for int i imported commands size i i  command path entry entry  command path entry imported commands element at i  input stream in entry clas get resource as stream entry path ext name if in null return in if parent null return null else return parent get command name 
 command path entry  string path  class clas this path path this clas clas 
public  numeric text field  string text this text false 
public  numeric text field  string text boolean positive only super text this positive only positive only 
 override protected void process key event  key event e if e get id  key event key typed if  character is digit e get key char positive only e get key char e consume super process key event e 
public  open bracket indent rule char open bracket boolean aligned super open bracket  text utilities get complementary bracket open bracket null this aligned aligned 
public void apply j edit buffer buffer int this line index int prev line index int prev prev line index  list  indent action indent actions int prev open bracket count get open bracket count buffer prev line index if prev open bracket count handle collapse indent actions true boolean multiple buffer get boolean property multiple bracket indent  indent action increase new  indent action  increase multiple prev open bracket count indent actions add increase else if get open bracket count buffer this line index handle collapse indent actions false 
private int get open bracket count j edit buffer buffer int line if line return else return get brackets buffer line open count 
private static void handle collapse  list  indent action indent actions boolean del prev prev collapse if indent actions contains  indent action  prev collapse indent actions clear return if del prev prev collapse indent actions contains  indent action  prev prev collapse indent actions clear return 
 returns the bounds of the default screen public static  rectangle get screen bounds int screen x int  toolkit get default toolkit get screen size get width int screen y int  toolkit get default toolkit get screen size get height int x y w h if is mac os x y w screen x h screen y y shadow size else if is windows x y w screen x x h screen y y else x y w screen x h screen y return new  rectangle x y w h 
 returns the bounds of the virtual screen that the window should be in param window  the bounds of the window to get the screen for public static  rectangle get screen bounds  rectangle window  graphics device gd  graphics environment get local graphics environment get screen devices  set  graphics configuration intersects new  hash set  graphics configuration  get available screens o n this is nasty but since we aren t dealling with many items it should be fine for int i i gd length i  graphics configuration gc gd i get default configuration  don t add duplicates if window intersects gc get bounds if intersects contains gc intersects add gc  graphics configuration choice null if intersects is empty  pick screen with largest intersection for  graphics configuration gcc intersects if choice null choice gcc else  rectangle int choice get bounds intersection window  rectangle int gcc get bounds intersection window int area int width int height int area int width int height if area area choice gcc else choice  graphics environment get local graphics environment get default screen device get default configuration  make adjustments for some os s int screen x choice get bounds x int screen y choice get bounds y int screen w choice get bounds width int screen h choice get bounds height int x y w h if is mac os x screen x y screen y w screen w h screen h y shadow size else x screen x y screen y w screen w h screen h  yay we re finally there return new  rectangle x y w h 
 returns if we re running  windows me nt xp or os public static boolean is dos derived return is windows is os 
 returns if we re running  windows me nt xp public static boolean is windows return os windows  x os windows nt 
 returns if we re running  windows me public static boolean is windows x return os windows  x 
 returns if we re running  windows nt xp public static boolean is windows nt return os windows nt 
 returns if we re running os public static boolean is os return os os 
 returns if we re running  unix this includes  mac os x public static boolean is unix return os unix os mac os x 
 returns if we re running  mac os x public static boolean is mac os return os mac os x 
 returns if this os is likely to be using x as the graphics system since j edit pre public static boolean is x return os unix 
 returns if we re running vms public static boolean is vms return os vms 
 returns if we re running  mac os x and using the native look and feel public static boolean is mac oslf return is mac os ui manager get look and feel is native look and feel 
 returns whether the screen menu bar on  mac os x is in use since j edit pre public static boolean has screen menu bar if is mac os return false else if has screen menu bar  string result  system get property apple laf use screen menu bar if result null result  system get property com apple macos use screen menu bar has screen menu bar true equals result return has screen menu bar 
 returns if  java version or  java version is in use  deprecated public static boolean has java j edit requires  java or later  however this method exists for two reasons  compatibility with plugins for j edit and in case somebody wants to borrow this class for their app return java 
 returns if  java version is in use  deprecated public static boolean has java return java 
 returns if  java version is in use since j edit pre public static boolean has java return java 
since j edit pre public static boolean is case insensitive fs return is dos derived is mac os 
 creates an option group param name  the internal name of the option group used to key a property code options i name i label code which is the label displayed in the options dialog see j edit get property  string public  option group  string name this name name label j edit get property options name label members new  vector  object 
 creates an option group param label  the label param options a whitespace separated list of option pane names since j edit pre public  option group  string name  string label  string options this name name this label label members new  vector  object  string tokenizer st new  string tokenizer options while st has more tokens  string pane st next token add option pane pane 
public  string get name return name 
 returns the option group s human readable label since j edit pre public  string get label return label 
public void add option group  option group group insertion sort group get label group 
public void add option pane  option pane pane  string label j edit get property options pane get name label no label property pane get name insertion sort label pane 
public void add option pane  string pane  string label j edit get property options pane label no label property pane insertion sort label pane 
public  enumeration  object get members return members elements 
public  object get member int index return index index members size members element at index null 
public int get member index  object member return members index of member 
public int get member count return members size 
 sets if the members of this group should be sorted since j edit pre public void set sort boolean sort this sort sort 
private void insertion sort  string new label  object new obj if sort for int i i members size i  object obj members element at i  string label if obj instanceof  option pane  string name  option pane obj get name label j edit get property options name label no label property name else if obj instanceof  string label j edit get property options obj label no label property obj else if obj instanceof  option group label  option group obj get label else throw new  internal error if new label compare to ignore case label members insert element at new obj i return members add element new obj 
param frame the parent frame for dialogs created param name the name of an option pane it must have a title and code property defined in order to instantiate param pane the initial pane to show when this is created protected  options dialog  frame frame  string name  string pane super frame j edit get property name title true init name pane 
protected  options dialog  dialog dialog  string name  string pane super dialog j edit get property name title true init name pane 
public void add option group  option group group get default group add option group group 
public void add option pane  option pane pane get default group add option pane pane 
public void ok if current pane null j edit set property name last current pane get name ok true 
public void cancel if current pane null j edit set property name last current pane get name dispose 
public void ok boolean dispose  option tree model m  option tree model pane tree get model save m get root  this will fire the properties changed event j edit properties changed  save settings to disk j edit save settings get rid of this dialog if necessary if dispose dispose 
public void dispose gui utilities save geometry this name j edit set integer property name splitter splitter get divider location super dispose 
public void action performed  action event evt  object source evt get source if source ok ok else if source cancel cancel else if source apply ok false 
public void value changed  tree selection event evt  tree path path evt get path if path null return  object last path component path get last path component if last path component instanceof  string last path component instanceof  option pane return  object nodes path get path  string builder buf new  string builder  option pane option pane null int last idx nodes length for int i pane tree is root visible i last idx i  string label  object node nodes i if node instanceof  option pane option pane  option pane node label j edit get property options option pane get name label else if node instanceof  option group label  option group node get label else if node instanceof  string label j edit get property options node label option pane deferred option panes get node if option pane null  string prop name options node code  string code j edit get property prop name if code null option pane  option pane  bean shell eval j edit get active view  bean shell get name space code if option pane null deferred option panes put node option pane else continue else  log log  log error this prop name not defined continue else continue buf append label if i last idx buf append if option pane null return set title j edit get property options title template new  object j edit get property name title buf to string try option pane init catch  throwable t  log log  log error this  error initializing options  log log  log error this t current pane option pane stage set viewport view current pane get component stage revalidate stage repaint if is showing add notify update size current pane option pane 
param name the name of this pane param pane a sub pane name to select  could someone please write better docs for this function  creates buttons adds listeners and makes the pane visible  this method is called automatically from the constructor and also calls init on each of the option panes since j edit pre was private before protected void init  string name  string pane this name name deferred option panes new  hash map  object  option pane j panel content new j panel new  border layout content set border new  empty border set content pane content stage new j scroll pane pane tree new j tree create option tree model pane tree set visible row count pane tree set cell renderer new  pane name renderer looks bad with the os x l f apparently if  operating system is mac oslf pane tree put client property j tree line style  angled pane tree set shows root handles true pane tree set root visible false j scroll pane scroller new j scroll pane pane tree  scroll pane constants vertical scrollbar always  scroll pane constants horizontal scrollbar as needed scroller set minimum size new  dimension splitter new j split pane j split pane horizontal split j edit get boolean property appearance continuous layout scroller stage content add splitter  border layout center  box buttons new  box  box layout x axis buttons add  box create glue ok new j button j edit get property common ok ok add action listener this buttons add ok buttons add  box create horizontal strut get root pane set default button ok cancel new j button j edit get property common cancel cancel add action listener this buttons add cancel buttons add  box create horizontal strut apply new j button j edit get property common apply apply add action listener this buttons add apply buttons add  box create glue content add buttons  border layout south register the  options dialog as a  tree selection listener this is done before the initial selection to ensure that the first selected  option pane is displayed on startup pane tree get selection model add tree selection listener this  option group root node  option group pane tree get model get root for int i i root node get member count i pane tree expand path new  tree path new  object root node root node get member i returns false if no such pane exists calling with null param selects first option pane found if select pane root node pane select pane root node null splitter set divider location pane tree get preferred size width scroller get vertical scroll bar get preferred size width gui utilities load geometry this name int divider location j edit get integer property name splitter if divider location splitter set divider location divider location in case saved geometry is too small update size set visible true 
private boolean select pane  option group node  string name return select pane node name new  array list  object 
private boolean select pane  option group node  string name  list  object path path add node  enumeration  object e node get members while e has more elements  object obj e next element if obj instanceof  option group  option group grp  option group obj if grp get name equals name path add grp path add grp get member  tree path tree path new  tree path path to array pane tree scroll path to visible tree path pane tree set selection path tree path return true else if select pane  option group obj name path return true else if obj instanceof  option pane  option pane pane  option pane obj if pane get name equals name name null path add pane  tree path tree path new  tree path path to array pane tree scroll path to visible tree path pane tree set selection path tree path return true else if obj instanceof  string  string pane  string obj if pane equals name name null path add pane  tree path tree path new  tree path path to array pane tree scroll path to visible tree path pane tree set selection path tree path return true path remove node return false 
private void save  object obj if obj instanceof  option group  option group grp  option group obj  enumeration  object members grp get members while members has more elements save members next element else if obj instanceof  option pane try  option pane obj save catch  throwable t  log log  log error this  error saving options  log log  log error this t else if obj instanceof  string save deferred option panes get obj 
private void update size  dimension current size get size  dimension requested size get preferred size  dimension new size new  dimension  math max current size width requested size width  math max current size height requested size height if new size width new size width if new size height new size height set size new size validate 
public  pane name renderer pane font ui manager get font  tree font if pane font null pane font j edit get font property metal secondary font group font pane font derive font  font bold 
public  component get tree cell renderer component j tree tree  object value boolean selected boolean expanded boolean leaf int row boolean has focus super get tree cell renderer component tree value selected expanded leaf row has focus  string name null if value instanceof  option group set text  option group value get label set font group font else if value instanceof  option pane name  option pane value get name set font pane font else if value instanceof  string name  string value set font pane font if name null  string label j edit get property options name label if label null set text no label property name else set text label set icon null return this 
public  option tree model this new  option group null 
public  option tree model  option group root this root root 
public void add tree model listener  tree model listener l listener list add  tree model listener class l 
public void remove tree model listener  tree model listener l listener list remove  tree model listener class l 
public  object get child  object parent int index if parent instanceof  option group return  option group parent get member index else return null 
public int get child count  object parent if parent instanceof  option group return  option group parent get member count else return 
public int get index of child  object parent  object child if parent instanceof  option group return  option group parent get member index child else return 
public  object get root return root 
public boolean is leaf  object node return node instanceof  option group 
public void value for path changed  tree path path  object new value this model may not be changed by the  table cell editor 
protected void fire nodes changed  object source  object path int child indices  object children  object listeners listener list get listener list  tree model event model event null for int i listeners length i i if listeners i  tree model listener class continue if model event null model event new  tree model event source path child indices children  tree model listener listeners i tree nodes changed model event 
protected void fire nodes inserted  object source  object path int child indices  object children  object listeners listener list get listener list  tree model event model event null for int i listeners length i i if listeners i  tree model listener class continue if model event null model event new  tree model event source path child indices children  tree model listener listeners i tree nodes inserted model event 
protected void fire nodes removed  object source  object path int child indices  object children  object listeners listener list get listener list  tree model event model event null for int i listeners length i i if listeners i  tree model listener class continue if model event null model event new  tree model event source path child indices children  tree model listener listeners i tree nodes removed model event 
protected void fire tree structure changed  object source  object path int child indices  object children  object listeners listener list get listener list  tree model event model event null for int i listeners length i i if listeners i  tree model listener class continue if model event null model event new  tree model event source path child indices children  tree model listener listeners i tree structure changed model event 
public  widget get widget  view view  widget overwrite new  overwrite widget view return overwrite 
 overwrite widget final  view view overwrite new  tool tip label overwrite set horizontal alignment  swing constants center overwrite set tool tip text j edit get property view status overwrite tooltip this view view overwrite add mouse listener new  mouse adapter  override public void mouse clicked  mouse event evt j edit text area text area view get text area if text area null text area toggle overwrite enabled 
public j component get component return overwrite 
public void update j edit text area text area view get text area if text area null overwrite set text text area is overwrite enabled o 
public void properties changed retarded gtk look and feel  font font new j label get font ui manager get font  label font  font metrics fm overwrite get font metrics font  dimension dim new  dimension  math max fm char width fm char width o fm get height overwrite set preferred size dim overwrite set maximum size dim 
public  panel window container  dockable window manager impl wm  string position int dimension this wm wm this position position  button box setup button panel new j panel new  button layout button panel set border new  empty border close box new j button gui utilities load icon closebox gif close box set request focus enabled false close box set tool tip text j edit get property view docking close tooltip if  operating system is mac oslf close box put client property j button button type toolbar close box set margin new  insets close box add action listener new  action handler menu btn new j button gui utilities load icon j edit get property dropdown arrow icon menu btn set request focus enabled false menu btn set tool tip text j edit get property view docking menu tooltip if  operating system is mac oslf menu btn put client property j button button type toolbar menu btn set margin new  insets menu btn add mouse listener new  menu mouse handler button group new  button group jdk workaround button group add null button new j toggle button dockables new  array list  dockable window manager impl  entry buttons new  array list  abstract button dockable panel new  dockable panel this this dimension dimension 
since j edit pre public  dockable window manager impl get dockable window manager return wm 
public void register  dockable window manager impl  entry entry dockables add entry  create button int rotation if position equals  dockable window manager impl top position equals  dockable window manager impl bottom rotation  rotated text icon none else if position equals  dockable window manager impl left rotation  rotated text icon ccw else if position equals  dockable window manager impl right rotation  rotated text icon cw else throw new  internal error  invalid position position j toggle button button new j toggle button button set margin new  insets button set request focus enabled false button set icon new  rotated text icon rotation button get font entry short title button set action command entry factory name button add action listener new  action handler button add mouse listener new  menu mouse handler if  operating system is mac oslf button put client property j button button type toolbar button group add button buttons add button entry btn button wm revalidate 
public void unregister  dockable window manager impl  entry entry if entry factory name equals most recent most recent null if entry btn null button panel remove entry btn buttons remove entry btn entry btn null dockables remove entry if entry win null dockable panel remove entry win if current entry current null show current else wm revalidate dockable panel repaint button panel repaint 
public void remove  dockable window manager impl  entry entry if entry factory name equals most recent most recent null if entry win null dockable panel remove entry win entry win null if current entry current null show current else wm revalidate dockable panel repaint 
public void show most recent if dockables is empty  toolkit get default toolkit beep return if most recent null most recent dockables get factory name wm show dockable window most recent 
public void show  dockable window manager impl  entry entry if current entry if entry null if entry win instanceof  default focus component  default focus component entry win focus on default component else entry win request default focus return if entry null if current null we didn t have a component previously so create a border dockable panel set border new  dock border position most recent entry factory name this current entry if entry win get parent dockable panel dockable panel add entry factory name entry win dockable panel show dockable entry factory name entry btn set selected true if entry win instanceof  default focus component  default focus component entry win focus on default component else entry win request default focus else if current null  object reason  dockable window update deactivated  edit bus send new  dockable window update wm reason current factory name current null null button set selected true removing last component so remove border dockable panel set border null wm get view get text area request focus wm revalidate dockable panel repaint 
public boolean is visible  dockable window manager impl  entry entry return current entry 
 returns the name of the dockable in this container since j edit pre public  string get current if current null return null else return current factory name 
 returns the width or height depending on position of the dockable window container since j edit pre public int get dimension return dimension 
since j edit pre public  string get position return position 
public  string get dockables  string ret val new  string dockables size for int i i dockables size i  dockable window manager impl  entry entry dockables get i ret val i entry factory name return ret val 
void save j edit set integer property view dock position dimension dimension if current null j edit unset property view dock position last else j edit set property view dock position last current factory name 
void set dimension int dimension if dimension splitter width this dimension dimension splitter width 
void sort dockables button panel remove all button panel add close box button panel add menu btn  collections sort buttons new  dockable window compare for int i i buttons size i button panel add buttons get i 
 returns the width or height of wrapped rows or columns int get wrapped dimension int dimension return  button layout button panel get layout get wrapped dimension button panel dimension 
public int compare  abstract button o  abstract button o  string name o get action command  string name o get action command return  standard utilities compare strings j edit get property name title j edit get property name title true 
public void action performed  action event evt if popup null popup is visible popup set visible false if evt get source close box show  dockable window manager impl  entry null else if wm is dockable window visible evt get action command show  dockable window manager impl  entry null else wm show dockable window evt get action command 
public void mouse pressed  mouse event evt if popup null popup is visible popup set visible false return  component comp  component evt get source  string dockable if comp instanceof j toggle button dockable j toggle button comp get action command else dockable get current if comp menu btn gui utilities is popup trigger evt if dockable null popup wm create popup menu  panel window container this null false else popup wm create popup menu  panel window container this dockable false int x y boolean point if comp menu btn x y menu btn get height point false else x evt get x y evt get y point true gui utilities show popup menu popup comp x y point 
 dock border  string position this position position insets new  insets position equals  dockable window manager impl bottom splitter width position equals  dockable window manager impl right splitter width position equals  dockable window manager impl top splitter width position equals  dockable window manager impl left splitter width 
public void paint border  component c  graphics g int x int y int width int height update colors if color null color null color null return if position equals  dockable window manager impl bottom paint horiz border g x y width else if position equals  dockable window manager impl right paint vert border g x y height else if position equals  dockable window manager impl top paint horiz border g x y height splitter width width else if position equals  dockable window manager impl left paint vert border g x width splitter width y height 
public  insets get border insets  component c return insets 
public boolean is border opaque return false 
private void paint horiz border  graphics g int x int y int width g set color color g fill rect x y width splitter width for int i i width i g set color color g draw line x i y x i y g set color color g draw line x i y x i y g set color color g draw line x i y x i y g set color color g draw line x i y x i y 
private void paint vert border  graphics g int x int y int height g set color color g fill rect x y splitter width height for int i i height i g set color color g draw line x y i x y i g set color color g draw line x y i x y i g set color color g draw line x y i x y i g set color color g draw line x y i x y i 
private void update colors if ui manager get look and feel instanceof  metal look and feel color  metal look and feel get control highlight color  metal look and feel get control dark shadow color  metal look and feel get control else color color color null 
public  rotated text icon int rotate  font font  string text this rotate rotate this font font  font render context font render context new  font render context null true true glyphs font create glyph vector font render context text width int glyphs get logical bounds get width height int glyphs get logical bounds get height  line metrics line metrics font get line metrics text font render context ascent line metrics get ascent height int line metrics get height render hints new  rendering hints  rendering hints key antialiasing  rendering hints value antialias on render hints put  rendering hints key fractionalmetrics  rendering hints value fractionalmetrics on render hints put  rendering hints key rendering  rendering hints value render quality 
public int get icon width return int rotate  rotated text icon cw rotate  rotated text icon ccw height width 
public int get icon height return int rotate  rotated text icon cw rotate  rotated text icon ccw width height 
public void paint icon  component c  graphics g int x int y  graphics d g d  graphics d g g d set font font  affine transform old transform g d get transform  rendering hints old hints g d get rendering hints g d set rendering hints render hints g d set color c get foreground  no rotation if rotate  rotated text icon none g d draw glyph vector glyphs x y ascent  clockwise rotation else if rotate  rotated text icon cw  affine transform trans new  affine transform trans concatenate old transform trans translate x y trans rotate  math pi height width g d set transform trans g d draw glyph vector glyphs height width width height ascent  counterclockwise rotation else if rotate  rotated text icon ccw  affine transform trans new  affine transform trans concatenate old transform trans translate x y trans rotate  math pi height width g d set transform trans g d draw glyph vector glyphs height width width height ascent g d set transform old transform g d set rendering hints old hints 
public void add layout component  string name  component comp 
public void remove layout component  component comp 
 returns the width or height of wrapped rows or columns int get wrapped dimension j component parent int dimension  insets insets parent get border get border insets parent  component comp parent get components if comp length return  dimension dim comp get preferred size if position equals  dockable window manager impl top position equals  dockable window manager impl bottom int width dimension insets right  dimension return value preferred layout size lr insets comp dim width return return value height else  dimension return value preferred layout size tb dimension insets comp dim return return value width 
public  dimension preferred layout size  container parent  insets insets j component parent get border get border insets parent  component comp parent get components if comp length nothing cept close box return new  dimension  dimension dim comp get preferred size if position equals  dockable window manager impl top position equals  dockable window manager impl bottom int width parent get width insets right  dimension return value preferred layout size lr insets comp dim width return return value else  dimension return value preferred layout size tb parent get height insets comp dim return return value 
public  dimension minimum layout size  container parent return preferred layout size parent 
public void layout container  container parent  insets insets j component parent get border get border insets parent  component comp parent get components if comp length for int i i comp length i comp i set visible false return comp set visible true comp set visible true  dimension dim comp get preferred size if position equals  dockable window manager impl top position equals  dockable window manager impl bottom int width parent get width insets right int row height  math max dim height close box get preferred size width int x row height insets left int y insets top close box set bounds insets left insets top row height row height menu btn set bounds insets left row height insets top row height row height for int i i comp length i int btn width comp i get preferred size width if btn width x width x insets left y row height comp i set bounds x y btn width row height x btn width if y row height parent get height parent set size parent get width y row height j component parent revalidate else int height parent get height insets bottom int col width  math max dim width close box get preferred size height int x insets left int y col width insets top close box set bounds insets left insets top col width col width menu btn set bounds insets left insets top col width col width col width for int i i comp length i int btn height comp i get preferred size height if btn height y height x col width y insets top comp i set bounds x y col width btn height y btn height if x col width parent get width parent set size x col width parent get height j component parent revalidate 
private  dimension preferred layout size lr  insets insets  component comp  dimension dim int width int row height  math max dim height close box get preferred size width int x row height insets left  dimension return value new  dimension row height insets top insets bottom for int i i comp length i int btn width comp i get preferred size width if btn width x width return value height row height x insets left x btn width return return value 
private  dimension preferred layout size tb int dimension  insets insets  component comp  dimension dim int height dimension insets bottom int col width  math max dim width close box get preferred size height int y col width insets top  dimension return value new  dimension col width insets left insets right for int i i comp length i int btn height comp i get preferred size height if btn height y height return value width col width y insets top y btn height return return value 
public void show  string name  dockable window manager impl  entry entry null if name null wm show dockable window name wm hide dockable window name show entry 
 used to add source file info to exception public void set error source file  string file this source file file 
public  string get error source file return source file 
 this constructor is used by the method generate parse exception in the generated parser  calling this constructor generates a new object of this type with the fields current token expected token sequences and token image set  the boolean flag special constructor is also set to true to indicate that this constructor was used to create this object  this constructor calls its super class with the empty string to force the to string method of parent class  throwable to print the error message in the form  parse exception result of get message public  parse exception  token current token val int expected token sequences val  string token image val  begin  bean shell  modification constructor this  end  bean shell  modification constructor special constructor true current token current token val expected token sequences expected token sequences val token image token image val 
 the following constructors are for use by you for whatever purpose you can think of  constructing the exception in this manner makes the exception behave in the normal way i e as documented in the class  throwable  the fields error token expected token sequences and token image do not contain relevant information  the  java cc generated code does not use these constructors public  parse exception  begin  bean shell  modification constructor this  end  bean shell  modification constructor special constructor false 
public  parse exception  string message  begin  bean shell  modification super constructor args null node null callstack  parse exception knows where the error is super message null null  end  bean shell  modification super constructor args special constructor false 
public  string get message return get message false 
 this method has the standard behavior when this object has been created using the standard constructors  otherwise it uses current token and expected token sequences to generate a parse error message and returns it  if this object has been created due to a parse error and you do not catch it it gets thrown from the parser then this method is called during the printing of the final stack trace and hence the correct error message gets displayed  begin  bean shell  modification added debug param public  string get message boolean debug  end  bean shell  modification added debug param if special constructor return super get message  string expected int max size for int i i expected token sequences length i if max size expected token sequences i length max size expected token sequences i length for int j j expected token sequences i length j expected token image expected token sequences i j if expected token sequences i expected token sequences i length expected expected eol  begin  bean shell  modification added source file info  string retval  in file source file  encountered  end  bean shell  modification added source file info  token tok current token next for int i i max size i if i retval if tok kind retval token image break retval add escapes tok image tok tok next retval at line current token next begin line column current token next begin column eol  begin  bean shell  modification made conditional on debug if debug if expected token sequences length retval  was expecting eol else retval  was expecting one of eol retval expected  end  bean shell  modification made conditional on debug return retval 
 used to convert raw characters to their escaped version when these raw version cannot be used as part of an ascii string literal protected  string add escapes  string str  string builder retval new  string builder char ch for int i i str length i switch str char at i case continue case b retval append b continue case t retval append t continue case n retval append n continue case f retval append f continue case r retval append r continue case retval append continue case retval append continue case retval append continue default if ch str char at i x ch x e  string s  integer to string ch retval append u s substring s length s length else retval append ch continue return retval to string 
public int get error line number return current token next begin line 
public  string get error text copied from generated get message int max size for int i i expected token sequences length i if max size expected token sequences i length max size expected token sequences i length  string retval  token tok current token next for int i i max size i if i retval if tok kind retval token image break retval add escapes tok image tok tok next return retval 
public  string to string return get message 
public void set retain comments boolean b retain comments b 
void jjtree open node scope  node n  simple node n first token get token 
void jjtree close node scope  node n  simple node n last token get token 
 re initialize the input stream and token source void re init input  reader in  re init in 
public  simple node pop node if jjtree node arity number of child nodes return  simple node jjtree pop node else return null 
 explicitly re initialize just the token reader  this seems to be necessary to avoid certain looping errors when reading bogus input  see  interpreter void re init token input  reader in jj input stream  re init in jj input stream get end line jj input stream get end column 
public static void main  string args throws io exception  parse exception boolean print false int i if args equals p i print true for i args length i  reader in new  file reader args i  parser parser new  parser in parser set retain comments true while parser  line eof if print  system out println parser pop node 
 lookahead for the enhanced for statement  expect for and then see whether we hit or a first boolean is regular for statement int cur tok  token tok tok get token cur tok if tok kind for return false tok get token cur tok if tok kind lparen return false while true tok get token cur tok switch tok kind case colon return false case semicolon return true case eof return false 
 generate a  parse exception with the specified message pointing to the current token  the auto generated  parser generate parse exception method does not provide line number info therefore we do this  parse exception create parse exception  string message  token errortok token int line errortok begin line column errortok begin column  string mess errortok kind token image errortok image return new  parse exception  parse error at line line column column message 
final public boolean  line throws  parse exception switch jj ntk jj ntk jj ntk case jj consume token  interpreter debug  end of  file if true return true break default if jj     block statement if true return false else jj consume token throw new  parse exception throw new  error  missing return statement in function 
the java language grammar starts here  gather modifiers for a class method or field i lookahead is true then we are being called as part of a lookahead and we should not enforce any rules  otherwise we validate based on context field method class final public  modifiers  modifiers int context boolean lookahead throws  parse exception  modifiers mods null label  while true switch jj ntk jj ntk jj ntk case abstract case final case native case private case protected case public case static case strictfp case synchronized case transient case volatile break default break label  switch jj ntk jj ntk jj ntk case private jj consume token private break case protected jj consume token protected break case public jj consume token public break case synchronized jj consume token synchronized break case final jj consume token final break case native jj consume token native break case transient jj consume token transient break case volatile jj consume token volatile break case abstract jj consume token abstract break case static jj consume token static break case strictfp jj consume token strictfp break default jj consume token throw new  parse exception if lookahead try if mods null mods new  modifiers mods add modifier context get token image catch  illegal state exception e if true throw create parse exception e get message if true return mods throw new  error  missing return statement in function 
final public void  class declaration throws  parse exception bgen jjtree  class declaration bsh class declaration jjtn new bsh class declaration jjtclassdeclaration boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  modifiers mods  token name int num interfaces try mods  modifiers  modifiers class false switch jj ntk jj ntk jj ntk case class jj consume token class break case interface jj consume token interface jjtn is interface true break default jj consume token throw new  parse exception name jj consume token identifier switch jj ntk jj ntk jj ntk case extends jj consume token extends  ambiguous name jjtn extend true break default switch jj ntk jj ntk jj ntk case implements jj consume token implements num interfaces  name list jjtn num interfaces num interfaces break default  block jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn modifiers mods jjtn name name image catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  method declaration throws  parse exception bgen jjtree  method declaration bsh method declaration jjtn new bsh method declaration jjtmethoddeclaration boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  token t null  modifiers mods int count try mods  modifiers  modifiers method false jjtn modifiers mods if jj    t jj consume token identifier jjtn name t image else switch jj ntk jj ntk jj ntk case boolean case byte case char case double case float case int case long case short case void case identifier  return type t jj consume token identifier jjtn name t image break default jj consume token throw new  parse exception  formal parameters switch jj ntk jj ntk jj ntk case throws jj consume token throws count  name list jjtn num throws count break default switch jj ntk jj ntk jj ntk case lbrace  block break case semicolon jj consume token semicolon break default jj consume token throw new  parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  package declaration throws  parse exception bgen jjtree  package declaration bsh package declaration jjtn new bsh package declaration jjtpackagedeclaration boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token package  ambiguous name catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  import declaration throws  parse exception bgen jjtree  import declaration bsh import declaration jjtn new bsh import declaration jjtimportdeclaration boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  token s null  token t null try if jj    switch jj ntk jj ntk jj ntk case static s jj consume token static break default jj consume token import  ambiguous name switch jj ntk jj ntk jj ntk case dot t jj consume token dot jj consume token star break default jj consume token semicolon jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn if s null jjtn static import true if t null jjtn import package true else switch jj ntk jj ntk jj ntk case import jj consume token import jj consume token star jj consume token semicolon jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn super import true break default jj consume token throw new  parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  variable declarator throws  parse exception bgen jjtree  variable declarator bsh variable declarator jjtn new bsh variable declarator jjtvariabledeclarator boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  token t try t jj consume token identifier switch jj ntk jj ntk jj ntk case assign jj consume token assign  variable initializer break default jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn name t image catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  variable initializer throws  parse exception switch jj ntk jj ntk jj ntk case lbrace  array initializer break case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen case bang case tilde case incr case decr case plus case minus  expression break default jj consume token throw new  parse exception 
final public void  array initializer throws  parse exception bgen jjtree  array initializer bsh array initializer jjtn new bsh array initializer jjtarrayinitializer boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token lbrace switch jj ntk jj ntk jj ntk case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen case lbrace case bang case tilde case incr case decr case plus case minus  variable initializer label  while true if jj    else break label  jj consume token comma  variable initializer break default switch jj ntk jj ntk jj ntk case comma jj consume token comma break default jj consume token rbrace catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  formal parameters throws  parse exception bgen jjtree  formal parameters bsh formal parameters jjtn new bsh formal parameters jjtformalparameters boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token lparen switch jj ntk jj ntk jj ntk case boolean case byte case char case double case float case int case long case short case identifier  formal parameter label  while true switch jj ntk jj ntk jj ntk case comma break default break label  jj consume token comma  formal parameter break default jj consume token rparen catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  formal parameter throws  parse exception bgen jjtree  formal parameter bsh formal parameter jjtn new bsh formal parameter jjtformalparameter boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  token t try if jj     type t jj consume token identifier jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn name t image else switch jj ntk jj ntk jj ntk case identifier t jj consume token identifier jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn name t image break default jj consume token throw new  parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  type throws  parse exception bgen jjtree  type bsh type jjtn new bsh type jjttype boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try switch jj ntk jj ntk jj ntk case boolean case byte case char case double case float case int case long case short  primitive type break case identifier  ambiguous name break default jj consume token throw new  parse exception label  while true if jj    else break label  jj consume token lbracket jj consume token rbracket jjtn add array dimension catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  return type throws  parse exception bgen jjtree  return type bsh return type jjtn new bsh return type jjtreturntype boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try switch jj ntk jj ntk jj ntk case void jj consume token void jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn is void true break case boolean case byte case char case double case float case int case long case short case identifier  type break default jj consume token throw new  parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  primitive type throws  parse exception bgen jjtree  primitive type bsh primitive type jjtn new bsh primitive type jjtprimitivetype boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try switch jj ntk jj ntk jj ntk case boolean jj consume token boolean jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn type  boolean type break case char jj consume token char jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn type  character type break case byte jj consume token byte jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn type  byte type break case short jj consume token short jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn type  short type break case int jj consume token int jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn type  integer type break case long jj consume token long jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn type  long type break case float jj consume token float jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn type  float type break case double jj consume token double jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn type  double type break default jj consume token throw new  parse exception finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  ambiguous name throws  parse exception bgen jjtree  ambiguous name bsh ambiguous name jjtn new bsh ambiguous name jjtambiguousname boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  token t  string builder s try t jj consume token identifier s new  string builder t image label  while true if jj    else break label  jj consume token dot t jj consume token identifier s append t image jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn text s to string finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public int  name list throws  parse exception int count  ambiguous name count label  while true switch jj ntk jj ntk jj ntk case comma break default break label  jj consume token comma  ambiguous name count if true return count throw new  error  missing return statement in function 
final public void  expression throws  parse exception if jj     assignment else switch jj ntk jj ntk jj ntk case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen case bang case tilde case incr case decr case plus case minus  conditional expression break default jj consume token throw new  parse exception 
final public void  assignment throws  parse exception bgen jjtree  assignment bsh assignment jjtn new bsh assignment jjtassignment boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn int op try  primary expression op  assignment operator jjtn operator op  expression catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public int  assignment operator throws  parse exception  token t switch jj ntk jj ntk jj ntk case assign jj consume token assign break case starassign jj consume token starassign break case slashassign jj consume token slashassign break case modassign jj consume token modassign break case plusassign jj consume token plusassign break case minusassign jj consume token minusassign break case andassign jj consume token andassign break case xorassign jj consume token xorassign break case orassign jj consume token orassign break case lshiftassign jj consume token lshiftassign break case lshiftassignx jj consume token lshiftassignx break case rsignedshiftassign jj consume token rsignedshiftassign break case rsignedshiftassignx jj consume token rsignedshiftassignx break case runsignedshiftassign jj consume token runsignedshiftassign break case runsignedshiftassignx jj consume token runsignedshiftassignx break default jj consume token throw new  parse exception t get token if true return t kind throw new  error  missing return statement in function 
final public void  conditional expression throws  parse exception  conditional or expression switch jj ntk jj ntk jj ntk case hook jj consume token hook  expression jj consume token colon bsh ternary expression jjtn new bsh ternary expression jjtternaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try  conditional expression catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn break default 
final public void  conditional or expression throws  parse exception  token t null  conditional and expression label  while true switch jj ntk jj ntk jj ntk case bool or case bool orx break default break label  switch jj ntk jj ntk jj ntk case bool or t jj consume token bool or break case bool orx t jj consume token bool orx break default jj consume token throw new  parse exception  conditional and expression bsh binary expression jjtn new bsh binary expression jjtbinaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  conditional and expression throws  parse exception  token t null  inclusive or expression label  while true switch jj ntk jj ntk jj ntk case bool and case bool andx break default break label  switch jj ntk jj ntk jj ntk case bool and t jj consume token bool and break case bool andx t jj consume token bool andx break default jj consume token throw new  parse exception  inclusive or expression bsh binary expression jjtn new bsh binary expression jjtbinaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  inclusive or expression throws  parse exception  token t null  exclusive or expression label  while true switch jj ntk jj ntk jj ntk case bit or case bit orx break default break label  switch jj ntk jj ntk jj ntk case bit or t jj consume token bit or break case bit orx t jj consume token bit orx break default jj consume token throw new  parse exception  exclusive or expression bsh binary expression jjtn new bsh binary expression jjtbinaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  exclusive or expression throws  parse exception  token t null  and expression label  while true switch jj ntk jj ntk jj ntk case xor break default break label  t jj consume token xor  and expression bsh binary expression jjtn new bsh binary expression jjtbinaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  and expression throws  parse exception  token t null  equality expression label  while true switch jj ntk jj ntk jj ntk case bit and case bit andx break default break label  switch jj ntk jj ntk jj ntk case bit and t jj consume token bit and break case bit andx t jj consume token bit andx break default jj consume token throw new  parse exception  equality expression bsh binary expression jjtn new bsh binary expression jjtbinaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  equality expression throws  parse exception  token t null  instance of expression label  while true switch jj ntk jj ntk jj ntk case eq case ne break default break label  switch jj ntk jj ntk jj ntk case eq t jj consume token eq break case ne t jj consume token ne break default jj consume token throw new  parse exception  instance of expression bsh binary expression jjtn new bsh binary expression jjtbinaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  instance of expression throws  parse exception  token t null  relational expression switch jj ntk jj ntk jj ntk case instanceof t jj consume token instanceof  type bsh binary expression jjtn new bsh binary expression jjtbinaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn break default 
final public void  relational expression throws  parse exception  token t null  shift expression label  while true switch jj ntk jj ntk jj ntk case gt case gtx case lt case ltx case le case lex case ge case gex break default break label  switch jj ntk jj ntk jj ntk case lt t jj consume token lt break case ltx t jj consume token ltx break case gt t jj consume token gt break case gtx t jj consume token gtx break case le t jj consume token le break case lex t jj consume token lex break case ge t jj consume token ge break case gex t jj consume token gex break default jj consume token throw new  parse exception  shift expression bsh binary expression jjtn new bsh binary expression jjtbinaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  shift expression throws  parse exception  token t null  additive expression label  while true switch jj ntk jj ntk jj ntk case lshift case lshiftx case rsignedshift case rsignedshiftx case runsignedshift case runsignedshiftx break default break label  switch jj ntk jj ntk jj ntk case lshift t jj consume token lshift break case lshiftx t jj consume token lshiftx break case rsignedshift t jj consume token rsignedshift break case rsignedshiftx t jj consume token rsignedshiftx break case runsignedshift t jj consume token runsignedshift break case runsignedshiftx t jj consume token runsignedshiftx break default jj consume token throw new  parse exception  additive expression bsh binary expression jjtn new bsh binary expression jjtbinaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  additive expression throws  parse exception  token t null  multiplicative expression label  while true switch jj ntk jj ntk jj ntk case plus case minus break default break label  switch jj ntk jj ntk jj ntk case plus t jj consume token plus break case minus t jj consume token minus break default jj consume token throw new  parse exception  multiplicative expression bsh binary expression jjtn new bsh binary expression jjtbinaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  multiplicative expression throws  parse exception  token t null  unary expression label  while true switch jj ntk jj ntk jj ntk case star case slash case mod break default break label  switch jj ntk jj ntk jj ntk case star t jj consume token star break case slash t jj consume token slash break case mod t jj consume token mod break default jj consume token throw new  parse exception  unary expression bsh binary expression jjtn new bsh binary expression jjtbinaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  unary expression throws  parse exception  token t null switch jj ntk jj ntk jj ntk case plus case minus switch jj ntk jj ntk jj ntk case plus t jj consume token plus break case minus t jj consume token minus break default jj consume token throw new  parse exception  unary expression bsh unary expression jjtn new bsh unary expression jjtunaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn break case incr  pre increment expression break case decr  pre decrement expression break case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen case bang case tilde  unary expression not plus minus break default jj consume token throw new  parse exception 
final public void  pre increment expression throws  parse exception  token t null t jj consume token incr  primary expression bsh unary expression jjtn new bsh unary expression jjtunaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  pre decrement expression throws  parse exception  token t null t jj consume token decr  primary expression bsh unary expression jjtn new bsh unary expression jjtunaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn 
final public void  unary expression not plus minus throws  parse exception  token t null switch jj ntk jj ntk jj ntk case bang case tilde switch jj ntk jj ntk jj ntk case tilde t jj consume token tilde break case bang t jj consume token bang break default jj consume token throw new  parse exception  unary expression bsh unary expression jjtn new bsh unary expression jjtunaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn break default if jj     cast expression else switch jj ntk jj ntk jj ntk case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen  postfix expression break default jj consume token throw new  parse exception 
final public void  cast lookahead throws  parse exception if jj    jj consume token lparen  primitive type else if jj    jj consume token lparen  ambiguous name jj consume token lbracket jj consume token rbracket else switch jj ntk jj ntk jj ntk case lparen jj consume token lparen  ambiguous name jj consume token rparen switch jj ntk jj ntk jj ntk case tilde jj consume token tilde break case bang jj consume token bang break case lparen jj consume token lparen break case identifier jj consume token identifier break case new jj consume token new break case false case null case true case void case integer literal case floating point literal case character literal case string literal  literal break default jj consume token throw new  parse exception break default jj consume token throw new  parse exception 
final public void  postfix expression throws  parse exception  token t null if jj     primary expression switch jj ntk jj ntk jj ntk case incr t jj consume token incr break case decr t jj consume token decr break default jj consume token throw new  parse exception bsh unary expression jjtn new bsh unary expression jjtunaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jjtree close node scope jjtn jjtc false jjtree close node scope jjtn jjtn kind t kind jjtn postfix true finally if jjtc jjtree close node scope jjtn jjtree close node scope jjtn else switch jj ntk jj ntk jj ntk case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen  primary expression break default jj consume token throw new  parse exception 
final public void  cast expression throws  parse exception bgen jjtree  cast expression bsh cast expression jjtn new bsh cast expression jjtcastexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try if jj    jj consume token lparen  type jj consume token rparen  unary expression else switch jj ntk jj ntk jj ntk case lparen jj consume token lparen  type jj consume token rparen  unary expression not plus minus break default jj consume token throw new  parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  primary expression throws  parse exception bgen jjtree  primary expression bsh primary expression jjtn new bsh primary expression jjtprimaryexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try  primary prefix label  while true switch jj ntk jj ntk jj ntk case lbrace case lbracket case dot break default break label   primary suffix catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  method invocation throws  parse exception bgen jjtree  method invocation bsh method invocation jjtn new bsh method invocation jjtmethodinvocation boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try  ambiguous name  arguments catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  primary prefix throws  parse exception switch jj ntk jj ntk jj ntk case false case null case true case void case integer literal case floating point literal case character literal case string literal  literal break case lparen jj consume token lparen  expression jj consume token rparen break case new  allocation expression break default if jj     method invocation else if jj     type else switch jj ntk jj ntk jj ntk case identifier  ambiguous name break default jj consume token throw new  parse exception 
final public void  primary suffix throws  parse exception bgen jjtree  primary suffix bsh primary suffix jjtn new bsh primary suffix jjtprimarysuffix boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  token t null try if jj    jj consume token dot jj consume token class jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn operation bsh primary suffix class else switch jj ntk jj ntk jj ntk case lbracket jj consume token lbracket  expression jj consume token rbracket jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn operation bsh primary suffix index break case dot jj consume token dot t jj consume token identifier switch jj ntk jj ntk jj ntk case lparen  arguments break default jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn operation bsh primary suffix name jjtn field t image break case lbrace jj consume token lbrace  expression jj consume token rbrace jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn operation bsh primary suffix property break default jj consume token throw new  parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  literal throws  parse exception bgen jjtree  literal bsh literal jjtn new bsh literal jjtliteral boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  token x boolean b  string literal char ch try switch jj ntk jj ntk jj ntk case integer literal x jj consume token integer literal jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn literal x image ch literal char at literal length if ch l ch l literal literal substring literal length  this really should be  long decode but there isn t one  as a result hex and octal literals ending in l or l don t work jjtn value new  primitive new  long literal long value else try jjtn value new  primitive  integer decode literal int value catch  number format exception e if true throw create parse exception  error or number too big for integer type literal break case floating point literal x jj consume token floating point literal jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn literal x image ch literal char at literal length if ch f ch f literal literal substring literal length jjtn value new  primitive new  float literal float value else if ch d ch d literal literal substring literal length jjtn value new  primitive new  double literal double value break case character literal x jj consume token character literal jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn try jjtn char setup x image substring x image length catch  exception e if true throw create parse exception  error parsing character x image break case string literal x jj consume token string literal jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn try jjtn string setup x image substring x image length catch  exception e if true throw create parse exception  error parsing string x image break case false case true b  boolean literal jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn value new  primitive b break case null  null literal jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn value  primitive null break case void  void literal jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn value  primitive void break default jj consume token throw new  parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public boolean  boolean literal throws  parse exception switch jj ntk jj ntk jj ntk case true jj consume token true if true return true break case false jj consume token false if true return false break default jj consume token throw new  parse exception throw new  error  missing return statement in function 
final public void  null literal throws  parse exception jj consume token null 
final public void  void literal throws  parse exception jj consume token void 
final public void  arguments throws  parse exception bgen jjtree  arguments bsh arguments jjtn new bsh arguments jjtarguments boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token lparen switch jj ntk jj ntk jj ntk case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen case bang case tilde case incr case decr case plus case minus  argument list break default jj consume token rparen catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  argument list throws  parse exception  expression label  while true switch jj ntk jj ntk jj ntk case comma break default break label  jj consume token comma  expression 
final public void  allocation expression throws  parse exception bgen jjtree  allocation expression bsh allocation expression jjtn new bsh allocation expression jjtallocationexpression boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try if jj    jj consume token new  primitive type  array dimensions else switch jj ntk jj ntk jj ntk case new jj consume token new  ambiguous name switch jj ntk jj ntk jj ntk case lbracket  array dimensions break case lparen  arguments if jj     block else break default jj consume token throw new  parse exception break default jj consume token throw new  parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  array dimensions throws  parse exception bgen jjtree  array dimensions bsh array dimensions jjtn new bsh array dimensions jjtarraydimensions boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try if jj    label  while true jj consume token lbracket  expression jj consume token rbracket jjtn add defined dimension if jj    else break label  label  while true if jj    else break label  jj consume token lbracket jj consume token rbracket jjtn add undefined dimension else switch jj ntk jj ntk jj ntk case lbracket label  while true jj consume token lbracket jj consume token rbracket jjtn add undefined dimension switch jj ntk jj ntk jj ntk case lbracket break default break label   array initializer break default jj consume token throw new  parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  statement throws  parse exception if jj     labeled statement else switch jj ntk jj ntk jj ntk case lbrace  block break case semicolon  empty statement break case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen case bang case tilde case incr case decr case plus case minus  statement expression jj consume token semicolon break case switch  switch statement break case if  if statement break case while  while statement break case do  do statement break default if is regular for statement  for statement else switch jj ntk jj ntk jj ntk case for  enhanced for statement break case break  break statement break case continue  continue statement break case return  return statement break case synchronized  synchronized statement break case throw  throw statement break case try  try statement break default jj consume token throw new  parse exception 
final public void  labeled statement throws  parse exception jj consume token identifier jj consume token colon  statement 
final public void  block throws  parse exception bgen jjtree  block bsh block jjtn new bsh block jjtblock boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token lbrace label  while true if jj    else break label   block statement jj consume token rbrace catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  block statement throws  parse exception if jj     class declaration else if jj     method declaration else if jj     method declaration else if jj     typed variable declaration jj consume token semicolon else if jj     statement else switch jj ntk jj ntk jj ntk case import case static  import declaration break case package  package declaration break case formal comment  formal comment break default jj consume token throw new  parse exception 
final public void  formal comment throws  parse exception bgen jjtree  formal comment retain comments bsh formal comment jjtn new bsh formal comment jjtformalcomment boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  token t try t jj consume token formal comment jjtree close node scope jjtn retain comments jjtc false jjtree close node scope jjtn jjtn text t image finally if jjtc jjtree close node scope jjtn retain comments jjtree close node scope jjtn 
final public void  empty statement throws  parse exception jj consume token semicolon 
final public void  statement expression throws  parse exception  expression 
final public void  switch statement throws  parse exception bgen jjtree  switch statement bsh switch statement jjtn new bsh switch statement jjtswitchstatement boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token switch jj consume token lparen  expression jj consume token rparen jj consume token lbrace label  while true switch jj ntk jj ntk jj ntk case case case  default break default break label   switch label label  while true if jj    else break label   block statement jj consume token rbrace catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  switch label throws  parse exception bgen jjtree  switch label bsh switch label jjtn new bsh switch label jjtswitchlabel boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try switch jj ntk jj ntk jj ntk case case jj consume token case  expression jj consume token colon break case  default jj consume token  default jj consume token colon jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn is default true break default jj consume token throw new  parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  if statement throws  parse exception bgen jjtree  if statement bsh if statement jjtn new bsh if statement jjtifstatement boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token if jj consume token lparen  expression jj consume token rparen  statement switch jj ntk jj ntk jj ntk case else jj consume token else  statement break default catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  while statement throws  parse exception bgen jjtree  while statement bsh while statement jjtn new bsh while statement jjtwhilestatement boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token while jj consume token lparen  expression jj consume token rparen  statement catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  do statement throws  parse exception bgen jjtree  while statement bsh while statement jjtn new bsh while statement jjtwhilestatement boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token do  statement jj consume token while jj consume token lparen  expression jj consume token rparen jj consume token semicolon jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn is do statement true catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  for statement throws  parse exception bgen jjtree  for statement bsh for statement jjtn new bsh for statement jjtforstatement boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  token t null try jj consume token for jj consume token lparen switch jj ntk jj ntk jj ntk case abstract case boolean case byte case char case double case false case final case float case int case long case native case new case null case private case protected case public case short case static case strictfp case synchronized case transient case true case void case volatile case integer literal case floating point literal case character literal case string literal case identifier case lparen case bang case tilde case incr case decr case plus case minus  for init jjtn has for init true break default jj consume token semicolon switch jj ntk jj ntk jj ntk case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen case bang case tilde case incr case decr case plus case minus  expression jjtn has expression true break default jj consume token semicolon switch jj ntk jj ntk jj ntk case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen case bang case tilde case incr case decr case plus case minus  for update jjtn has for update true break default jj consume token rparen  statement catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  enhanced for statement throws  parse exception bgen jjtree  enhanced for statement bsh enhanced for statement jjtn new bsh enhanced for statement jjtenhancedforstatement boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  token t null try if jj    jj consume token for jj consume token lparen t jj consume token identifier jj consume token colon  expression jj consume token rparen  statement jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn var name t image else switch jj ntk jj ntk jj ntk case for jj consume token for jj consume token lparen  type t jj consume token identifier jj consume token colon  expression jj consume token rparen  statement jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn var name t image break default jj consume token throw new  parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  for init throws  parse exception  token t null if jj     typed variable declaration else switch jj ntk jj ntk jj ntk case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen case bang case tilde case incr case decr case plus case minus  statement expression list break default jj consume token throw new  parse exception 
 declared a typed variable  untyped variables are not declared per se but are handled by the part of the grammar that deals with assignments final public void  typed variable declaration throws  parse exception bgen jjtree  typed variable declaration bsh typed variable declaration jjtn new bsh typed variable declaration jjttypedvariabledeclaration boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn  token t null  modifiers mods try mods  modifiers  modifiers field false  type  variable declarator label  while true switch jj ntk jj ntk jj ntk case comma break default break label  jj consume token comma  variable declarator jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn modifiers mods catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  statement expression list throws  parse exception bgen jjtree  statement expression list bsh statement expression list jjtn new bsh statement expression list jjtstatementexpressionlist boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try  statement expression label  while true switch jj ntk jj ntk jj ntk case comma break default break label  jj consume token comma  statement expression catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  for update throws  parse exception  statement expression list 
final public void  break statement throws  parse exception bgen jjtree  return statement bsh return statement jjtn new bsh return statement jjtreturnstatement boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token break switch jj ntk jj ntk jj ntk case identifier jj consume token identifier break default jj consume token semicolon jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn kind break finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  continue statement throws  parse exception bgen jjtree  return statement bsh return statement jjtn new bsh return statement jjtreturnstatement boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token continue switch jj ntk jj ntk jj ntk case identifier jj consume token identifier break default jj consume token semicolon jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn kind continue finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  return statement throws  parse exception bgen jjtree  return statement bsh return statement jjtn new bsh return statement jjtreturnstatement boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token return switch jj ntk jj ntk jj ntk case boolean case byte case char case double case false case float case int case long case new case null case short case true case void case integer literal case floating point literal case character literal case string literal case identifier case lparen case bang case tilde case incr case decr case plus case minus  expression break default jj consume token semicolon jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn kind return catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  synchronized statement throws  parse exception bgen jjtree  block bsh block jjtn new bsh block jjtblock boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token synchronized jj consume token lparen  expression jj consume token rparen  block jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn jjtn is synchronized true catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  throw statement throws  parse exception bgen jjtree  throw statement bsh throw statement jjtn new bsh throw statement jjtthrowstatement boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn try jj consume token throw  expression jj consume token semicolon catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final public void  try statement throws  parse exception bgen jjtree  try statement bsh try statement jjtn new bsh try statement jjttrystatement boolean jjtc true jjtree open node scope jjtn jjtree open node scope jjtn boolean closed false try jj consume token try  block label  while true switch jj ntk jj ntk jj ntk case catch break default break label  jj consume token catch jj consume token lparen  formal parameter jj consume token rparen  block closed true switch jj ntk jj ntk jj ntk case finally jj consume token finally  block closed true break default jjtree close node scope jjtn true jjtc false jjtree close node scope jjtn if closed if true throw generate parse exception catch  throwable jjte if jjtc jjtree clear node scope jjtn jjtc false else jjtree pop node if jjte instanceof  runtime exception if true throw  runtime exception jjte if jjte instanceof  parse exception if true throw  parse exception jjte if true throw  error jjte finally if jjtc jjtree close node scope jjtn true jjtree close node scope jjtn 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj    int xla jj la xla jj lastpos jj scanpos token try return jj    catch  lookahead success ls return true 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj    jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj    if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj scan token lbrace return true  token xsp while true xsp jj scanpos if jj    jj scanpos xsp break if jj scan token rbrace return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj scan token identifier return true if jj scan token colon return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token hook return true if jj  r  return true if jj scan token colon return true if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true if jj scan token semicolon return true return false 
final private boolean jj    if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj    jj scanpos xsp if jj  r  jj scanpos xsp if jj scan token jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp looking ahead true jj sem la is regular for statement looking ahead false if jj sem la jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj    if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token return true return false 
final private boolean jj  r  if jj scan token comma return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token lbracket return true if jj scan token rbracket return true return false 
final private boolean jj  r  if jj  r  return true  token xsp xsp jj scanpos if jj    jj scanpos xsp return false 
final private boolean jj  r   token xsp if jj  r  return true while true xsp jj scanpos if jj  r  jj scanpos xsp break if jj  r  return true return false 
final private boolean jj    if jj  r  return true if jj  r  return true return false 
final private boolean jj    if jj scan token lbracket return true if jj scan token rbracket return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj    if jj scan token lbracket return true if jj  r  return true if jj scan token rbracket return true return false 
final private boolean jj  r  if jj  r  return true if jj  r  return true if jj  r  return true return false 
final private boolean jj     token xsp if jj    return true while true xsp jj scanpos if jj    jj scanpos xsp break while true xsp jj scanpos if jj    jj scanpos xsp break return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj    jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj scan token new return true if jj  r  return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj    if jj scan token new return true if jj  r  return true if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj    jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj scan token comma return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj    if jj scan token dot return true if jj scan token identifier return true return false 
final private boolean jj  r  if jj scan token lparen return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj scan token rparen return true return false 
final private boolean jj  r  if jj scan token identifier return true  token xsp while true xsp jj scanpos if jj    jj scanpos xsp break return false 
final private boolean jj  r  if jj scan token double return true return false 
final private boolean jj  r  if jj scan token float return true return false 
final private boolean jj  r  if jj scan token false return true return false 
final private boolean jj  r  if jj scan token long return true return false 
final private boolean jj  r  if jj scan token int return true return false 
final private boolean jj  r  if jj scan token true return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj scan token short return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj scan token byte return true return false 
final private boolean jj  r  if jj scan token char return true return false 
final private boolean jj  r  if jj scan token boolean return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj scan token return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj scan token void return true return false 
final private boolean jj  r  if jj scan token return true return false 
final private boolean jj    if jj scan token lbracket return true if jj scan token rbracket return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj scan token comma return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token string literal return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true while true xsp jj scanpos if jj    jj scanpos xsp break return false 
final private boolean jj  r  if jj scan token character literal return true return false 
final private boolean jj  r  if jj scan token finally return true if jj  r  return true return false 
final private boolean jj    if jj scan token comma return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token catch return true if jj scan token lparen return true if jj  r  return true if jj scan token rparen return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token identifier return true return false 
final private boolean jj    if jj  r  return true if jj scan token identifier return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj    jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj scan token try return true if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break xsp jj scanpos if jj  r  jj scanpos xsp return false 
final private boolean jj  r  if jj scan token lparen return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj scan token rparen return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj    jj scanpos xsp break return false 
final private boolean jj  r  if jj scan token floating point literal return true return false 
final private boolean jj  r  if jj scan token lbrace return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token rbrace return true return false 
final private boolean jj  r  if jj scan token dot return true if jj scan token star return true return false 
final private boolean jj  r  if jj scan token throw return true if jj  r  return true if jj scan token semicolon return true return false 
final private boolean jj  r  if jj scan token assign return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj scan token synchronized return true if jj scan token lparen return true if jj  r  return true if jj scan token rparen return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token comma return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token comma return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token return return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj scan token semicolon return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj scan token integer literal return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj scan token identifier return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj scan token continue return true  token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token semicolon return true return false 
final private boolean jj  r  if jj scan token break return true  token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token semicolon return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj scan token import return true if jj scan token star return true if jj scan token semicolon return true return false 
final private boolean jj  r  if jj scan token lbrace return true if jj  r  return true if jj scan token rbrace return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj scan token dot return true if jj scan token identifier return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp return false 
final private boolean jj     token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token import return true if jj  r  return true xsp jj scanpos if jj  r  jj scanpos xsp if jj scan token semicolon return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj    jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true if jj  r  return true if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj scan token lbracket return true if jj  r  return true if jj scan token rbracket return true return false 
final private boolean jj  r  if jj scan token package return true if jj  r  return true return false 
final private boolean jj    if jj scan token identifier return true if jj scan token lparen return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj    if jj scan token dot return true if jj scan token class return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj    jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj scan token throws return true if jj  r  return true return false 
final private boolean jj    if jj  r  return true if jj scan token dot return true if jj scan token class return true return false 
final private boolean jj    if jj  r  return true if jj  r  return true if jj scan token identifier return true return false 
final private boolean jj    if jj  r  return true return false 
final private boolean jj  r  if jj scan token identifier return true return false 
final private boolean jj  r  if jj  r  return true if jj scan token identifier return true return false 
final private boolean jj  r  if jj  r  return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true if jj  r  return true xsp jj scanpos if jj  r  jj scanpos xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj scan token return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj scan token interface return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj scan token lparen return true if jj  r  return true if jj scan token rparen return true return false 
final private boolean jj  r  if jj scan token for return true if jj scan token lparen return true if jj  r  return true if jj scan token identifier return true if jj scan token colon return true if jj  r  return true if jj scan token rparen return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token else return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token implements return true if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj scan token extends return true if jj  r  return true return false 
final private boolean jj    if jj scan token for return true if jj scan token lparen return true if jj scan token identifier return true if jj scan token colon return true if jj  r  return true if jj scan token rparen return true if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj    jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj  r  return true if jj scan token identifier return true xsp jj scanpos if jj  r  jj scanpos xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj    if jj scan token lparen return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj scan token lparen return true if jj  r  return true if jj scan token rparen return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token lparen return true if jj  r  return true if jj scan token rparen return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token for return true if jj scan token lparen return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj scan token semicolon return true xsp jj scanpos if jj  r  jj scanpos xsp if jj scan token semicolon return true xsp jj scanpos if jj  r  jj scanpos xsp if jj scan token rparen return true if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj    if jj  r  return true  token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj scan token do return true if jj  r  return true if jj scan token while return true if jj scan token lparen return true if jj  r  return true if jj scan token rparen return true if jj scan token semicolon return true return false 
final private boolean jj    if jj scan token lparen return true if jj  r  return true if jj scan token lbracket return true return false 
final private boolean jj  r  if jj  r  return true  token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token return true return false 
final private boolean jj  r  if jj scan token while return true if jj scan token lparen return true if jj  r  return true if jj scan token rparen return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token lparen return true if jj  r  return true if jj scan token rparen return true  token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj scan token lparen return true if jj  r  return true if jj scan token lbracket return true if jj scan token rbracket return true return false 
final private boolean jj    if jj  r  return true return false 
final private boolean jj    if jj  r  return true return false 
final private boolean jj  r  if jj scan token if return true if jj scan token lparen return true if jj  r  return true if jj scan token rparen return true if jj  r  return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp return false 
final private boolean jj  r   token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj    jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj    if jj scan token lparen return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj scan token  default return true if jj scan token colon return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token return true if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj scan token case return true if jj  r  return true if jj scan token colon return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj    jj scanpos xsp break return false 
final private boolean jj  r  if jj scan token decr return true if jj  r  return true return false 
final private boolean jj    if jj  r  return true return false 
final private boolean jj  r  if jj scan token switch return true if jj scan token lparen return true if jj  r  return true if jj scan token rparen return true if jj scan token lbrace return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break if jj scan token rbrace return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token return true if jj  r  return true return false 
final private boolean jj  r  if jj scan token incr return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token return true if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  jj scanpos xsp if jj  r  return true return false 
final private boolean jj  r  if jj scan token throws return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj scan token formal comment return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token return true if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token jj scanpos xsp if jj scan token return true if jj  r  return true return false 
final private boolean jj    if jj  r  return true if jj  r  return true if jj scan token identifier return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj    if jj  r  return true if jj scan token identifier return true if jj  r  return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp if jj scan token lbrace return true return false 
final private boolean jj  r  if jj scan token instanceof return true if jj  r  return true return false 
final private boolean jj    if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp xsp jj scanpos if jj  r  jj scanpos xsp return false 
final private boolean jj    if jj  r  return true if jj  r  return true if jj scan token identifier return true if jj scan token lparen return true return false 
final private boolean jj  r  if jj  r  return true if jj scan token semicolon return true return false 
final private boolean jj    if jj  r  return true  token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token return true return false 
final private boolean jj  r  if jj scan token xor return true if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r  if jj  r  return true  token xsp while true xsp jj scanpos if jj  r  jj scanpos xsp break return false 
final private boolean jj  r  if jj  r  return true return false 
final private boolean jj  r   token xsp xsp jj scanpos if jj scan token jj scanpos xsp if jj scan token return true if jj  r  return true return false 
public  parser java io  input stream stream jj input stream new  java char stream stream token source new  parser token manager jj input stream token new  token jj ntk 
public void  re init java io  input stream stream jj input stream  re init stream token source  re init jj input stream token new  token jj ntk jjtree reset 
public  parser java io  reader stream jj input stream new  java char stream stream token source new  parser token manager jj input stream token new  token jj ntk 
public void  re init java io  reader stream jj input stream  re init stream token source  re init jj input stream token new  token jj ntk jjtree reset 
public  parser  parser token manager tm token source tm token new  token jj ntk 
public void  re init  parser token manager tm token source tm token new  token jj ntk jjtree reset 
final private  token jj consume token int kind throws  parse exception  token old token if old token token next null token token next else token token next token source get next token jj ntk if token kind kind return token token old token throw generate parse exception 
final private boolean jj scan token int kind if jj scanpos jj lastpos jj la if jj scanpos next null jj lastpos jj scanpos jj scanpos next token source get next token else jj lastpos jj scanpos jj scanpos next else jj scanpos jj scanpos next if jj scanpos kind kind return true if jj la jj scanpos jj lastpos throw jj ls return false 
final public  token get next token if token next null token token next else token token next token source get next token jj ntk return token 
final public  token get token int index  token t looking ahead jj scanpos token for int i i index i if t next null t t next else t t next token source get next token return t 
final private int jj ntk if jj nt token next null return jj ntk token next token source get next token kind else return jj ntk jj nt kind 
public  parse exception generate parse exception  token errortok token next int line errortok begin line column errortok begin column  string mess errortok kind token image errortok image return new  parse exception  parse error at line line column column  encountered mess 
final public void enable tracing 
final public void disable tracing 
public static final  parser rule create sequence rule int pos match  string seq  parser rule set delegate byte id return new  parser rule seq seq substring pos match seq to char array null null delegate id match type context null 
deprecated  use link create regexp sequence rule  string int  string  parser rule set byte boolean instead public static final  parser rule create regexp sequence rule char hash char int pos match  string seq  parser rule set delegate byte id boolean ignore case throws  pattern syntax exception return create regexp sequence rule  string value of hash char pos match seq delegate id ignore case 
public static final  parser rule create regexp sequence rule  string hash char int pos match  string seq  parser rule set delegate byte id boolean ignore case throws  pattern syntax exception return new  parser rule seq regexp hash char pos match null  pattern compile seq ignore case  pattern case insensitive null delegate id match type context null 
public static final  parser rule create regexp sequence rule int pos match char hash chars  string seq  parser rule set delegate byte id boolean ignore case throws  pattern syntax exception return new  parser rule hash chars seq regexp pos match null  pattern compile seq ignore case  pattern case insensitive null delegate id match type context null 
public static final  parser rule create span rule int start pos match  string start int end pos match  string end  parser rule set delegate byte id byte match type boolean no line break boolean no word break  string escape int rule action span no line break no line break no word break no word break return new  parser rule rule action start substring start pos match start to char array null end pos match end to char array delegate id match type escape 
public static final  parser rule create regexp span rule  string hash char int start pos match  string start int end pos match  string end  parser rule set delegate byte id byte match type boolean no line break boolean no word break boolean ignore case  string escape throws  pattern syntax exception int rule action span regexp no line break no line break no word break no word break return new  parser rule rule action hash char start pos match null  pattern compile start ignore case  pattern case insensitive end pos match end to char array delegate id match type escape 
public static final  parser rule create regexp span rule int start pos match char hash chars  string start int end pos match  string end  parser rule set delegate byte id byte match type boolean no line break boolean no word break boolean ignore case  string escape throws  pattern syntax exception int rule action span regexp no line break no line break no word break no word break return new  parser rule hash chars rule action start pos match null  pattern compile start ignore case  pattern case insensitive end pos match end to char array delegate id match type escape 
public static final  parser rule create eol span rule int pos match  string seq  parser rule set delegate byte id byte match type int rule action eol span no line break return new  parser rule rule action seq substring pos match seq to char array null null delegate id match type null 
deprecated  use link create regexp eol span rule  string int  string  parser rule set byte byte boolean instead public static final  parser rule create regexp eol span rule char hash char int pos match  string seq  parser rule set delegate byte id byte match type boolean ignore case throws  pattern syntax exception return create regexp eol span rule  string value of hash char pos match seq delegate id match type ignore case 
public static final  parser rule create regexp eol span rule  string hash char int pos match  string seq  parser rule set delegate byte id byte match type boolean ignore case throws  pattern syntax exception int rule action eol span regexp no line break return new  parser rule rule action hash char pos match null  pattern compile seq ignore case  pattern case insensitive null delegate id match type null 
public static final  parser rule create regexp eol span rule int pos match char hash chars  string seq  parser rule set delegate byte id byte match type boolean ignore case throws  pattern syntax exception int rule action eol span regexp no line break return new  parser rule hash chars rule action pos match null  pattern compile seq ignore case  pattern case insensitive null delegate id match type null 
public static final  parser rule create mark following rule int pos match  string seq byte id byte match type int rule action mark following return new  parser rule rule action seq substring pos match seq to char array null null null id match type null 
public static final  parser rule create mark previous rule int pos match  string seq byte id byte match type int rule action mark previous return new  parser rule rule action seq substring pos match seq to char array null null null id match type null 
public static final  parser rule create escape rule  string seq int rule action is escape return new  parser rule rule action seq substring seq to char array null null null  token null match type context null 
public  string to string  string builder result new  string builder result append get class get name append action switch action major actions case seq result append seq break case span result append span break case mark previous result append mark previous break case mark following result append mark following break case eol span result append eol span break default result append unknown break int action hints action action hints result append match type append match type match type context match type context match type match type rule match type rule  token token to string match type result append no line break append action hints no line break result append no word break append action hints no word break result append is escape append action hints is escape result append regexp append action hints regexp result append up hash char append up hash char result append up hash chars append  arrays to string up hash chars result append start pos match result append at line start append start pos match at line start result append at whitespace end append start pos match at whitespace end result append at word start append start pos match at word start result append start append null start null  string value of start result append start regexp append start regexp result append end pos match result append at line start append end pos match at line start result append at whitespace end append end pos match at whitespace end result append at word start append end pos match at word start result append end append null end null  string value of end result append delegate append delegate result append escape rule append escape rule result append token append  token token to string token append return result to string 
private  parser rule int action  string hash char int start pos match char start  pattern start regexp int end pos match char end  parser rule set delegate byte token byte match type  string escape this action action this up hash char null hash char null hash char to upper case this up hash chars null this start pos match start pos match this start start this start regexp start regexp this end pos match end pos match this end end this delegate delegate this token token this match type match type this escape rule escape null escape length create escape rule escape null if this delegate null if action major actions seq this delegate  parser rule set get standard rule set token 
private  parser rule char hash chars int action int start pos match char start  pattern start regexp int end pos match char end  parser rule set delegate byte token byte match type  string escape this action action this up hash char null  set  character hash chars set new  hash set  character for char c hash chars hash chars set add  character to upper case c this up hash chars new char hash chars set size int i for  character c hash chars set this up hash chars i c  arrays sort this up hash chars this start pos match start pos match this start start this start regexp start regexp this end pos match end pos match this end end this delegate delegate this token token this match type match type this escape rule escape null escape length create escape rule escape null if this delegate null if action major actions seq this delegate  parser rule set get standard rule set token 
 returns a parser rule set that highlights everything with the specified token type param id  the token type public static  parser rule set get standard rule set byte id return standard id 
public  parser rule set  string mode name  string set name this mode name mode name this set name set name rule map new  hash map  character  list  parser rule imports new  array list  parser rule set 
public  string get mode name return mode name 
public  string get set name return set name 
public  string get name return mode name set name 
public  hashtable  string  string get properties return props 
public void set properties  hashtable  string  string props this props props  no word sep null 
 resolves all rulesets added with link add rule set  parser rule set since j edit pre public void resolve imports for  parser rule set ruleset imports if ruleset imports is empty prevent infinite recursion ruleset imports remove this ruleset resolve imports for  list  parser rule rules ruleset rule map values for  parser rule rule rules add rule rule if ruleset keywords null if keywords null keywords new  keyword map ignore case keywords add ruleset keywords imports clear 
 adds all rules contained in the given ruleset param ruleset  the ruleset since j edit pre public void add rule set  parser rule set ruleset imports add ruleset 
public void add rule  parser rule r rule count  character keys if null r up hash chars keys new  character if null r up hash char r up hash char length keys null else keys  character value of r up hash char char at else keys new  character r up hash chars length int i for char up hash char r up hash chars keys i up hash char for  character key keys  list  parser rule rules rule map get key if null rules rules new  array list  parser rule rule map put key rules int rule amount rules size rules add r fill the deprecated  parser rule next pointer if rule amount rules get rule amount next r 
deprecated  as the linking between rules is not anymore done within the rule use link get rules  character instead  deprecated public  parser rule get rules char ch  list  parser rule rules get rules  character value of ch return rules get 
public  list  parser rule get rules  character key  list  parser rule rules for null rule map get null boolean empty for null rules for null null rules for null size  character upper key null key null  character value of  character to upper case key char value  list  parser rule rules for key null upper key null rule map get upper key boolean empty for key rules for key null rules for key size if empty for null empty for key return  collections empty list else if empty for key return rules for null else if empty for null return rules for key else int size rules for null size rules for key size  array list  parser rule mixed new  array list  parser rule size mixed add all rules for key mixed add all rules for null fill the deprecated  parser rule next pointer rules for key get rules for key size next rules for null get return mixed 
public int get rule count return rule count 
 returns the number of chars that can be read before the rule parsing stops return a number of chars or default value if there is no limit public int get terminate char return terminate char 
public void set terminate char int at char terminate char at char at char 
public boolean get ignore case return ignore case 
public void set ignore case boolean b ignore case b 
public  keyword map get keywords return keywords 
public void set keywords  keyword map km keywords km  no word sep null 
public boolean get highlight digits return highlight digits 
public void set highlight digits boolean highlight digits this highlight digits highlight digits 
public  pattern get digit regexp return digit re 
public void set digit regexp  pattern digit re this digit re digit re 
public  parser rule get escape rule return escape rule 
public void set escape rule  parser rule escape rule this escape rule escape rule 
public byte get default return default token 
public void set default byte def default token def 
public  string get no word sep if  no word sep null  no word sep no word sep if no word sep null no word sep if keywords null no word sep keywords get non alpha numeric chars return no word sep 
public void set no word sep  string no word sep this no word sep no word sep  no word sep null 
 returns if this is a built in ruleset since j edit pre public boolean is built in return built in 
 override public  string to string return get class get name mode name set name 
public void set debug stream java io  print stream ds debug stream ds 
private final int jj stop string literal dfa  int pos long active long active long active switch pos case if active x l l return if active x e l l return if active x l l return if active xffffffffffffc l l jjmatched kind return return case if active x l l return if active xffffffeff ffc l l if jjmatched pos jjmatched kind jjmatched pos return return case if active xefffecebfdffc l l if jjmatched pos jjmatched kind jjmatched pos return if active x l l return return case if active xc ffcae e d c l l if jjmatched pos jjmatched kind jjmatched pos return if active x c l l return return case if active x c l l return if active x f cae c l l if jjmatched pos jjmatched kind jjmatched pos return return case if active x a c a c l l jjmatched kind jjmatched pos return if active x l l return return case if active x a a l l jjmatched kind jjmatched pos return if active xc l l return return case if active x l l return if active x a l l jjmatched kind jjmatched pos return return case if active x a l l jjmatched kind jjmatched pos return if active x l l return return case if active x l l jjmatched kind jjmatched pos return if active xa l l return return case if active x l l if jjmatched pos jjmatched kind jjmatched pos return return case if active x l l return return default return 
private final int jj start nfa  int pos long active long active long active return jj move nfa  jj stop string literal dfa  pos active active active pos 
private final int jj stop at pos int pos int kind jjmatched kind kind jjmatched pos pos return pos 
private final int jj start nfa with states  int pos int kind int state jjmatched kind kind jjmatched pos pos try cur char input stream read char catch java io io exception e return pos return jj move nfa  state pos 
private final int jj move string literal dfa   switch cur char case return jj start nfa with states  case return jj start nfa with states  case return jj start nfa with states  case return jj start nfa with states  case return jj start nfa with states  case jjmatched kind return jj move string literal dfa   x l x l x l case jjmatched kind return jj move string literal dfa   x l x l x l case jjmatched kind return jj move string literal dfa   x l x l x l case return jj stop at pos case return jj stop at pos case jjmatched kind return jj move string literal dfa   x l x l x l case jjmatched kind return jj move string literal dfa   x l x l x l case return jj stop at pos case jjmatched kind return jj move string literal dfa   x l x l x l case return jj start nfa with states  case jjmatched kind return jj move string literal dfa   x l x l x l case return jj stop at pos case return jj stop at pos case jjmatched kind return jj move string literal dfa   x l x l x l case jjmatched kind return jj move string literal dfa   x l x l x l case jjmatched kind return jj move string literal dfa   x l x l x l case return jj stop at pos case return jj move string literal dfa   x l x a a l x a l case return jj stop at pos case return jj stop at pos case jjmatched kind return jj move string literal dfa   x l x l x l case return jj move string literal dfa   x l x l x l case return jj move string literal dfa   x l x l x l case return jj move string literal dfa   xfa l x l x l case return jj move string literal dfa   x l x l x l case return jj move string literal dfa   x l x l x l case return jj move string literal dfa   x c l x l x l case return jj move string literal dfa   x l x l x l case return jj move string literal dfa   x f l x l x l case return jj move string literal dfa   x l x l x l case return jj move string literal dfa   x l x l x l case return jj move string literal dfa   x c l x l x l case return jj move string literal dfa   x l x l x l case return jj move string literal dfa   xf l x l x l case return jj move string literal dfa   x f l x l x l case return jj move string literal dfa   x l x l x l case return jj move string literal dfa   x l x l x l case return jj stop at pos case jjmatched kind return jj move string literal dfa   x l x l x l case return jj stop at pos case return jj stop at pos default return jj move nfa  
private final int jj move string literal dfa   long active long active long active try cur char input stream read char catch java io io exception e jj stop string literal dfa  active active active return switch cur char case if active x l l return jj stop at pos break case if active x l l return jj stop at pos break case if active x l l return jj stop at pos break case if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active l active l active x l case if active x l l return jj stop at pos else if active x l l return jj stop at pos else if active x l l return jj stop at pos else if active x l l return jj stop at pos else if active x l l return jj stop at pos else if active x l l return jj stop at pos else if active x l l return jj stop at pos else if active x l l return jj stop at pos else if active x l l return jj stop at pos else if active x l l return jj stop at pos else if active x l l return jj stop at pos else if active x l l return jj stop at pos break case if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active l active x l active x l case return jj move string literal dfa   active x l active x l active l case return jj move string literal dfa   active x l active x l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  break case return jj move string literal dfa   active l active x l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active x l active x l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active x c c l active x l active l case return jj move string literal dfa   active x l active x l active x l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj stop at pos break default break return jj start nfa  active active active 
private final int jj move string literal dfa   long old long active long old long active long old long active if active old active old active old l return jj start nfa  old old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  active active active return switch cur char case if active x l l return jj stop at pos else if active x l l return jj stop at pos break case if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active l active l active x l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active x l active x l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active xa l active x l active x l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x c l active x l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  else if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active x l active x l active l case return jj move string literal dfa   active x l active l active l case if active x l l jjmatched kind jjmatched pos else if active x l l jjmatched kind jjmatched pos else if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active x a l active x l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  break case if active x l l return jj start nfa with states  break default break return jj start nfa  active active active 
private final int jj move string literal dfa   long old long active long old long active long old long active if active old active old active old l return jj start nfa  old old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  active active active return switch cur char case if active x l l return jj stop at pos break case return jj move string literal dfa   active l active x l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  else if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active l active x l active l case if active x l l return jj start nfa with states  else if active x l l return jj start nfa with states  else if active x l l return jj start nfa with states  else if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active x l active l case return jj move string literal dfa   active l active x l active x l case if active x l l return jj start nfa with states  return jj move string literal dfa   active l active x l active x l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  break case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active x l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l default break return jj start nfa  active active active 
private final int jj move string literal dfa   long old long active long old long active long old long active if active old active old active old l return jj start nfa  old old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  active active active return switch cur char case return jj move string literal dfa   active l active x l active l case return jj move string literal dfa   active xc l active x l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  else if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active x l active x l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  break case if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj stop at pos else if active x l l return jj stop at pos break case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  else if active x l l return jj start nfa with states  else if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active x l active x l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active x l active x l active l default break return jj start nfa  active active active 
private final int jj move string literal dfa   long old long active long old long active long old long active if active old active old active old l return jj start nfa  old old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  active active active return switch cur char case return jj move string literal dfa   active l active x l active x l case return jj move string literal dfa   active xc l active x l active l case if active x l l return jj start nfa with states  else if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  else if active x l l return jj start nfa with states  break case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  break case return jj move string literal dfa   active x l active x l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active l active x l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active x l active x l default break return jj start nfa  active active active 
private final int jj move string literal dfa   long old long active long old long active long old long active if active old active old active old l return jj start nfa  old old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  active active active return switch cur char case return jj move string literal dfa   active l active x l active x l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  else if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  break case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active l active x l active x l case if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  break default break return jj start nfa  active active active 
private final int jj move string literal dfa   long old long active long old long active long old long active if active old active old active old l return jj start nfa  old old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  active active active return switch cur char case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  else if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active x l active l case return jj move string literal dfa   active l active x l active x l case return jj move string literal dfa   active l active x l active l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  break case return jj move string literal dfa   active l active x l active x l case if active x l l return jj start nfa with states  break case return jj move string literal dfa   active l active x l active x l default break return jj start nfa  active active active 
private final int jj move string literal dfa   long old long active long old long active long old long active if active old active old active old l return jj start nfa  old old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  active active active return switch cur char case return jj move string literal dfa   active l active x l active l case if active x l l return jj start nfa with states  break case if active x l l return jj start nfa with states  break case return jj move string literal dfa   active l active x l active l case return jj move string literal dfa   active l active x l active x l case return jj move string literal dfa   active x l active x l active x l case return jj move string literal dfa   active l active x l active x l case return jj move string literal dfa   active x l active l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active x l active l active l default break return jj start nfa  active active active 
private final int jj move string literal dfa   long old long active long old long active long old long active if active old active old active old l return jj start nfa  old old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  active active active return switch cur char case return jj move string literal dfa   active l active x l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active l active x l active x l case return jj move string literal dfa   active l active x l active l case return jj move string literal dfa   active l active x l active x l case if active x l l return jj stop at pos break case return jj move string literal dfa   active l active x l active l case if active x l l return jj start nfa with states  return jj move string literal dfa   active l active x l active x l case return jj move string literal dfa   active x l active l active l default break return jj start nfa  active active active 
private final int jj move string literal dfa   long old long active long old long active long old long active if active old active old active old l return jj start nfa  old old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  active active active return switch cur char case return jj move string literal dfa   active x l active l active l case return jj move string literal dfa   active l active x l active x l case return jj move string literal dfa   active l active x l active x l case if active x l l return jj stop at pos return jj move string literal dfa   active l active x l active l case if active x l l return jj stop at pos break case if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active l active l active x l default break return jj start nfa  active active active 
private final int jj move string literal dfa   long old long active long old long active long old long active if active old active old active old l return jj start nfa  old old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  active active active return switch cur char case return jj move string literal dfa   active l active l active x l case if active x l l return jj start nfa with states  else if active x l l return jj stop at pos break case return jj move string literal dfa   active l active x l active x l case if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active l active l active x l default break return jj start nfa  active active active 
private final int jj move string literal dfa   long old long active long old long active long old long active if active old active old active old l return jj start nfa  old old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l active active return switch cur char case return jj move string literal dfa   active l active x l case return jj move string literal dfa   active l active x l case return jj move string literal dfa   active x l active x l default break return jj start nfa  l active active 
private final int jj move string literal dfa   long old long active long old long active if active old active old l return jj start nfa  l old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l active active return switch cur char case return jj move string literal dfa   active l active x l case return jj move string literal dfa   active x l active x l case return jj move string literal dfa   active l active x l default break return jj start nfa  l active active 
private final int jj move string literal dfa   long old long active long old long active if active old active old l return jj start nfa  l old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l active active return switch cur char case return jj move string literal dfa   active x l active x l case return jj move string literal dfa   active l active xa l default break return jj start nfa  l active active 
private final int jj move string literal dfa   long old long active long old long active if active old active old l return jj start nfa  l old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l active active return switch cur char case return jj move string literal dfa   active x l active x l case return jj move string literal dfa   active l active x l case return jj move string literal dfa   active l active x l default break return jj start nfa  l active active 
private final int jj move string literal dfa   long old long active long old long active if active old active old l return jj start nfa  l old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l active active return switch cur char case return jj move string literal dfa   active l active x l case return jj move string literal dfa   active l active x l case return jj move string literal dfa   active x l active x l default break return jj start nfa  l active active 
private final int jj move string literal dfa   long old long active long old long active if active old active old l return jj start nfa  l old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l active active return switch cur char case return jj move string literal dfa   active l active x l case return jj move string literal dfa   active x l active x l case if active x l l return jj stop at pos break default break return jj start nfa  l active active 
private final int jj move string literal dfa   long old long active long old long active if active old active old l return jj start nfa  l old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l active active return switch cur char case return jj move string literal dfa   active x l active x l case if active x l l return jj stop at pos break default break return jj start nfa  l active active 
private final int jj move string literal dfa   long old long active long old long active if active old active old l return jj start nfa  l old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l active active return switch cur char case return jj move string literal dfa   active x l active x l default break return jj start nfa  l active active 
private final int jj move string literal dfa   long old long active long old long active if active old active old l return jj start nfa  l old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l active active return switch cur char case if active x l l jjmatched kind jjmatched pos return jj move string literal dfa   active l active x l default break return jj start nfa  l active active 
private final int jj move string literal dfa   long old long active long old long active if active old active old l return jj start nfa  l old old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l l active return switch cur char case return jj move string literal dfa   active x l default break return jj start nfa  l l active 
private final int jj move string literal dfa   long old long active if active old l return jj start nfa  l l old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l l active return switch cur char case return jj move string literal dfa   active x l default break return jj start nfa  l l active 
private final int jj move string literal dfa   long old long active if active old l return jj start nfa  l l old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l l active return switch cur char case return jj move string literal dfa   active x l default break return jj start nfa  l l active 
private final int jj move string literal dfa   long old long active if active old l return jj start nfa  l l old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l l active return switch cur char case return jj move string literal dfa   active x l default break return jj start nfa  l l active 
private final int jj move string literal dfa   long old long active if active old l return jj start nfa  l l old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l l active return switch cur char case return jj move string literal dfa   active x l default break return jj start nfa  l l active 
private final int jj move string literal dfa   long old long active if active old l return jj start nfa  l l old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l l active return switch cur char case return jj move string literal dfa   active x l default break return jj start nfa  l l active 
private final int jj move string literal dfa   long old long active if active old l return jj start nfa  l l old try cur char input stream read char catch java io io exception e jj stop string literal dfa  l l active return switch cur char case if active x l l return jj stop at pos break default break return jj start nfa  l l active 
private final void jj check n add int state if jjrounds state jjround jjstate set jjnew state cnt state jjrounds state jjround 
private final void jj add states int start int end do jjstate set jjnew state cnt jjnext states start while start end 
private final void jj check n add two states int state int state jj check n add state jj check n add state 
private final void jj check n add states int start int end do jj check n add jjnext states start while start end 
private final void jj check n add states int start jj check n add jjnext states start jj check n add jjnext states start 
private final int jj move nfa  int start state int cur pos int next states int starts at jjnew state cnt int i jjstate set start state int j kind x fffffff for if jjround x fffffff  re init rounds if cur char long l l cur char  match loop do switch jjstate set i case if x ffffffff l l l if kind kind jj check n add else if x ff l l l jj check n add states else if cur char jj add states else if cur char if kind kind jj check n add else if cur char jj check n add states else if cur char jj add states else if cur char jj check n add else if cur char jjstate set jjnew state cnt if x fe l l l if kind kind jj check n add two states else if cur char if kind kind jj check n add states break case if cur char jjstate set jjnew state cnt else if cur char if kind kind jj check n add states if cur char jj check n add break case if x ffffffff l l l break if kind kind jj check n add break case if cur char jj check n add states break case if xffffffffffffdbff l l l jj check n add states break case if x l l l kind kind break case if cur char kind kind break case if cur char jjstate set jjnew state cnt break case if x fe l l l break if kind kind jj check n add two states break case if x ff l l l break if kind kind jj check n add two states break case if cur char jj check n add break case if x ff l l l break if kind kind jj check n add states break case if x l l l jj check n add break case if x ff l l l break if kind kind jj check n add two states break case if cur char jj add states break case if xffffff fffffdbff l l l jj check n add break case if cur char kind kind break case if x l l l jj check n add break case if xff l l l jj check n add two states break case if xff l l l jj check n add break case if xf l l l jjstate set jjnew state cnt break case if xff l l l jj check n add break case if cur char jj check n add states break case if xfffffffbffffdbff l l l jj check n add states break case if x l l l jj check n add states break case if cur char kind kind break case if xff l l l jj check n add states break case if xff l l l jj check n add states break case if xf l l l jjstate set jjnew state cnt break case if xff l l l jj check n add break case if cur char break if kind kind jj check n add break case if x ff l l l break if kind kind jj check n add break case if x ff l l l jj check n add states break case if x ff l l l jj check n add two states break case if cur char break if kind kind jj check n add states break case if x ff l l l break if kind kind jj check n add states break case if x l l l jj check n add break case if x ff l l l break if kind kind jj check n add two states break case if x ff l l l jj check n add two states break case if x l l l jj check n add break case if x ff l l l break if kind kind jj check n add two states break case if x ff l l l jj check n add states break case if x l l l jj check n add break case if x ff l l l jj check n add two states break case if cur char break if kind kind jj check n add states break case if x ff l l l break if kind kind jj check n add two states break case if xff l l l break if kind kind jj check n add two states break case if cur char jj add states break case if xffffffffffffdbff l l l break if kind kind jj check n add states break case if x l l l kind kind break case if cur char kind kind break case if cur char jjstate set jjnew state cnt break case if cur char jj check n add break case if xfffffbffffffffff l l l jj check n add two states break case if cur char jj check n add states break case if xffff bffffffffff l l l jj check n add two states break case if xfffffbffffffffff l l l jj check n add two states break case if cur char kind kind break case if cur char jj check n add two states break case if xfffffbffffffffff l l l jj check n add two states break case if cur char jj check n add states break case if xffff bffffffffff l l l jj check n add two states break case if xfffffbffffffffff l l l jj check n add two states break case if cur char kind kind break case if cur char jjstate set jjnew state cnt break default break while i starts at else if cur char long l l cur char  match loop do switch jjstate set i case case if x fffffe fffffe l l l break if kind kind jj check n add break case jj add states break case if x l l l kind kind break case if x l l l jj add states break case if x l l l kind kind break case if xffffffffefffffff l l l jj check n add break case if cur char jj add states break case if x l l l jj check n add break case if xffffffffefffffff l l l jj check n add states break case if cur char jj add states break case if x l l l jj check n add states break case if x l l l jj add states break case if x l l l jj add states break case if x l l l jj add states break case if x l l l jj check n add break case if x e e l l l break if kind kind jj check n add two states break case if kind kind jj add states break case jj check n add two states break case case jj check n add two states break case jj check n add two states break case case jj check n add two states break default break while i starts at else int hi byte int cur char int i hi byte long l l hi byte int i cur char xff long l l cur char  match loop do switch jjstate set i case if jj can move  hi byte i i l l if kind kind jj check n add if jj can move  hi byte i i l l if kind kind jj check n add break case if jj can move  hi byte i i l l break if kind kind jj check n add break case if jj can move  hi byte i i l l jj add states break case if jj can move  hi byte i i l l jjstate set jjnew state cnt break case if jj can move  hi byte i i l l jj add states break case case if jj can move  hi byte i i l l break if kind kind jj check n add break case if jj can move  hi byte i i l l break if kind kind jj add states break case if jj can move  hi byte i i l l jj check n add two states break case case if jj can move  hi byte i i l l jj check n add two states break case if jj can move  hi byte i i l l jj check n add two states break case case if jj can move  hi byte i i l l jj check n add two states break default break while i starts at if kind x fffffff jjmatched kind kind jjmatched pos cur pos kind x fffffff cur pos if i jjnew state cnt starts at jjnew state cnt starts at return cur pos try cur char input stream read char catch java io io exception e return cur pos 
private static final boolean jj can move  int hi byte int i int i long l long l switch hi byte case return jjbit vec i l l default return false 
private static final boolean jj can move  int hi byte int i int i long l long l switch hi byte case return jjbit vec i l l default if jjbit vec i l l return true return false 
private static final boolean jj can move  int hi byte int i int i long l long l switch hi byte case return jjbit vec i l l case return jjbit vec i l l case return jjbit vec i l l case return jjbit vec i l l case return jjbit vec i l l default if jjbit vec i l l return true return false 
public  parser token manager  java char stream stream if  java char stream static flag throw new  error error  cannot use a static  char stream class with a non static lexical analyzer input stream stream 
public  parser token manager  java char stream stream int lex state this stream  switch to lex state 
public void  re init  java char stream stream jjmatched pos jjnew state cnt cur lex state default lex state input stream stream  re init rounds 
private final void  re init rounds int i jjround x for i i jjrounds i x 
public void  re init  java char stream stream int lex state  re init stream  switch to lex state 
public void  switch to int lex state if lex state lex state throw new  token mgr error  error  ignoring invalid lexical state lex state  state unchanged  token mgr error invalid lexical state else cur lex state lex state 
protected  token jj fill token  token t  token new token jjmatched kind t kind jjmatched kind  string im jjstr literal images jjmatched kind t image im null input stream  get image im t begin line input stream get begin line t begin column input stream get begin column t end line input stream get end line t end column input stream get end column return t 
public  token get next token int kind  token special token null  token matched token int cur pos eof loop for try cur char input stream  begin token catch java io io exception e jjmatched kind matched token jj fill token matched token special token special token return matched token jjmatched kind x fffffff jjmatched pos cur pos jj move string literal dfa   if jjmatched kind x fffffff if jjmatched pos cur pos input stream backup cur pos jjmatched pos if jjto token jjmatched kind l jjmatched kind l matched token jj fill token matched token special token special token return matched token else if jjto special jjmatched kind l jjmatched kind l matched token jj fill token if special token null special token matched token else matched token special token special token special token special token next matched token continue eof loop int error line input stream get end line int error column input stream get end column  string error after null boolean eof seen false try input stream read char input stream backup catch java io io exception e eof seen true error after cur pos input stream  get image if cur char n cur char r error line error column else error column if eof seen input stream backup error after cur pos input stream  get image throw new  token mgr error eof seen cur lex state error line error column error after cur char  token mgr error lexical error 
public  paste from list dialog  string name  view view  mutable list model model super view j edit get property name title true this view view this list model model j panel content new j panel new  border layout content set border new  empty border set content pane content j panel center new j panel new  grid layout clips new j list model clips set cell renderer new  renderer clips set visible row count clips add mouse listener new  mouse handler clips add list selection listener new  list handler insert new j button j edit get property common insert cancel new j button j edit get property common cancel j label label new j label j edit get property name caption label set border new  empty border content add  border layout north label j scroll pane scroller new j scroll pane clips scroller set preferred size new  dimension center add scroller clip text new j text area clip text set editable false scroller new j scroll pane clip text scroller set preferred size new  dimension center add scroller content add center  border layout center j panel panel new j panel panel set layout new  box layout panel  box layout x axis panel set border new  empty border panel add  box create glue panel add insert panel add  box create horizontal strut panel add cancel panel add  box create glue content add panel  border layout south if model get size clips set selected index update buttons get root pane set default button insert insert add action listener new  action handler cancel add action listener new  action handler gui utilities request focus this clips pack set location relative to view set visible true 
public void ok  object selected clips get selected values if selected null selected length get toolkit beep return  string text get selected clip text  for each selected clip we remove it then add it back to the model  this has the effect of moving it to the top of the list for int i i selected length i list model remove element selected i list model insert element at selected i view get text area set selected text text dispose 
public void cancel dispose 
private  string get selected clip text  object selected clips get selected values  string builder clip new  string builder for int i i selected length i if i clip append n clip append selected i return clip to string 
private void update buttons int selected clips get selected index insert set enabled selected 
private void show clip text  object selected clips get selected values if selected null selected length clip text set text else clip text set text get selected clip text clip text set caret position 
 string shorten  string item  string builder buf new  string builder workaround for  swing rendering labels starting with html using the html engine if item to lower case starts with html buf append boolean ws true for int i i item length i char ch item char at i if  character is whitespace ch if ws do nothing else buf append ws true else ws false buf append ch if buf length return j edit get property paste from list whitespace return buf to string 
public  component get list cell renderer component j list list  object value int index boolean is selected boolean cell has focus super get list cell renderer component list value index is selected cell has focus set text shorten value to string return this 
public void action performed  action event evt  object source evt get source if source insert ok else if source cancel cancel 
public void value changed  list selection event evt show clip text update buttons 
public void mouse clicked  mouse event evt if evt get click count ok 
 creates a new regular expression string matcher see java util regex  pattern param search the search pattern param ignore case code true code if you want to ignore case since j edit pre public  pattern search matcher  string search boolean ignore case pattern search flags get flag ignore case 
 creates a new regular expression already compiled see java util regex  pattern param re the compiled regex param ignore case code true code if you want to ignore case since j edit pre public  pattern search matcher  pattern re boolean ignore case this re pattern ignore case this re re 
 returns the offset of the first match of the specified text within this matcher param text  the text to search in param start  true if the start of the segment is the beginning of the buffer param end  true if the end of the segment is the end of the buffer param first time  if false and the search string matched at the start offset with length zero automatically find next match param reverse  if true find match prior to current match this is done by searching from the beginning to just prior to the current match so will be inefficient for large buffers return a link  search matcher  match object since j edit pre  override public  search matcher  match next match  char sequence text boolean start boolean end boolean first time boolean reverse  for the mean time there is no way to automatically generate a sexeger http japhy perlmonk org sexeger sexeger html  so for reverse regex searches we will search the string in the forward direction and return the last match  since we search the  string in the forward direction even for reverse searches un reverse the  reverse char sequence if text instanceof  reverse char sequence text  reverse char sequence text base sequence if re null re  pattern compile pattern flags  matcher match re matcher text if match find return null if we re not at the start of the buffer and the pattern begins with and matched the beginning of the region being matched ignore the match and try the next one if start match start re pattern char at match find return null  special care for zero width matches  without this care the caller will fall into an infinite loop for non reverse search if reverse first time match start match end if match find return null  match previous null while true if we re not at the end of the buffer and we match the end of the text and the pattern ends with a ignore the match  the match at the end the buffer which immediately follows the final newline is also ignored because it is generally not expected as an eol if end text char at text length n match end text length pattern char at pattern length if previous null return value start previous start return value end previous end return value substitutions previous substitutions break else return null return value substitutions new  string match group count for int i i return value substitutions length i return value substitutions i match group i int  start match start int  end match end return value start  start return value end  end  for non reversed searches we break immediately to return the first match  for reversed searches we continue until no more matches are found if reverse match find  for reverse search check for zero width match at the end of text if reverse first time return value start text length return value end text length if previous null return value start previous start return value end previous end return value substitutions previous substitutions else return null break  save the result for reverse zero width match if previous null previous new  match previous start return value start previous end return value end previous substitutions return value substitutions if reverse  the caller assumes we are searching a reversed  char segment so we need to reverse the indices before returning int len return value end return value start return value start text length return value end return value end return value start len return return value 
 override public  string to string boolean ignore case flags  pattern case insensitive return  pattern search matcher pattern ignore case 
static int get flag boolean ignore case int flags  pattern multiline if ignore case flags  pattern case insensitive return flags 
 we only autosave the perspective if it has changed to avoid spinning up the disk on laptops since j edit pre public static boolean is perspective dirty return dirty 
 we only autosave the perspective if it has changed to avoid spinning up the disk on laptops since j edit pre public static void set perspective dirty boolean dirty  perspective manager dirty dirty 
 we disable saving of the perspective while the close all dialog is showing since j edit pre public static boolean is perspective enabled return enabled 
 we disable saving of the perspective while the close all dialog is showing since j edit pre public static void set perspective enabled boolean enabled  perspective manager enabled enabled 
public static  view load perspective boolean restore files if perspective xml null return null if perspective xml file exists return null  log log  log message  perspective manager class  loading perspective xml  perspective handler handler new  perspective handler restore files try perspective xml load handler catch io exception e  log log  log error  perspective manager class e return handler view 
public static void save perspective boolean autosave if is perspective enabled j edit is startup done return if perspective xml null return backgrounded if j edit get buffer count return  buffer buffers j edit get buffers  collection  buffer saved buffers new  linked list  buffer for  buffer buffer buffers if buffer is new file saved buffers add buffer if autosave  log log  log message  perspective manager class  saving perspective xml  string line sep  system get property line separator  settings xml  saver out null try out perspective xml open saver out write xml declaration out write doctype perspective system perspective dtd out write line sep out write perspective out write line sep for  buffer buffer saved buffers out write buffer autoreload out write buffer get auto reload true false out write autoreload dialog out write buffer get auto reload dialog true false out write out write xml utilities chars to entities buffer get path false out write buffer out write line sep  view views j edit get views for int i i views length i  view view views i ensures that active view is saved last ie created last on next load ie in front on next load if view j edit get active view i views length  view last views views length views i last views views length view view last  view  view config config views i get view config out write view plain out write config plain view true false out write out write panes out write line sep out write xml utilities chars to entities config split config false out write line sep out write panes out write line sep out write geometry x out write  string value of config x out write y out write  string value of config y out write width out write  string value of config width out write height out write  string value of config height out write ext state out write  string value of config ext state out write out write line sep if config docking null config docking save layout perspective filename i out write view out write line sep out write perspective out write line sep out finish catch io exception io  log log  log error  perspective manager class  error saving perspective xml  log log  log error  perspective manager class io finally io utilities close quietly out 
 perspective handler boolean restore files this restore files restore files config new  view  view config char data new  string builder config docking  view get docking framework provider create docking layout 
 override public  input source resolve entity  string public id  string system id return xml utilities find entity system id perspective dtd get class 
 override public void start element  string uri  string local name  string q name  attributes attrs char data set length for int i i attrs get length i  string name attrs get q name i  string value attrs get value i attribute name value 
private void attribute  string aname  string value if aname equals x config x  integer parse int value else if aname equals y config y  integer parse int value else if aname equals width config width  integer parse int value else if aname equals height config height  integer parse int value else if aname equals ext state config ext state  integer parse int value else if aname equals plain config plain view true equals value else if aname equals autoreload auto reload value else if aname equals autoreload dialog auto reload dialog value 
return true if the uri points to a remote file public static boolean skip remote  string uri if j edit get boolean property restore remote return false if  misc utilities is url uri  string protocol  misc utilities get protocol of url uri if protocol equals file return true return false 
 override public void end element  string uri  string local name  string name if name equals buffer if restore files skip remote char data to string  buffer restored j edit open temporary null null char data to string false if the auto reload attributes are not present don t set anything it s sufficient to check whether they are present on the first buffer element if restored null if auto reload null restored set auto reload true equals auto reload if auto reload dialog null restored set auto reload dialog true equals auto reload dialog j edit commit temporary restored else if name equals panes config split config char data to string else if name equals view if config docking null config docking load layout perspective filename j edit get view count view j edit new view view null config config new  view  view config config docking  view get docking framework provider create docking layout 
 override public void characters char ch int start int length char data append ch start length 
 plugin detail panel set layout new  border layout plugin detail new j editor pane plugin detail set editable false plugin detail set content type text html plugin detail set background j edit get color property view bg color plugin detail set foreground j edit get color property view fg color plugin detail put client property j editor pane honor display properties true title new j label add title  border layout north j scroll pane scroll new j scroll pane plugin detail scroll set horizontal scroll bar policy j scroll pane horizontal scrollbar never add scroll 
void set plugin  entry entry if entry this entry if entry status equals  entry loaded title set text html b entry name b html  string builder builder new  string builder builder append b  version b append entry version append br builder append b  author b append entry author append br if entry description null builder append br append entry description plugin detail set text builder to string else title set text html b entry jar b html plugin detail set text null this entry entry 
 loads a plugin and its dependent plugins if necessary since j edit pre public static  plugin jar load  string path boolean load dependents  plugin jar jar j edit get plugin jar path if jar null jar get plugin null return jar j edit add plugin jar path jar j edit get plugin jar path  edit plugin plugin jar get plugin if plugin null  no plugin maybe it is a library return jar  string class name plugin get class name if load dependents  set  string plugin load list get dependency set class name for  string jar name plugin load list  string jar path find plugin jar name load jar path false  load extra jars that are part of this plugin  string jars j edit get property plugin class name jars if jars null  string dir  misc utilities get parent of path path  string tokenizer st new  string tokenizer jars while st has more tokens  string  jar path  misc utilities construct path dir st next token  plugin jar  jar j edit get plugin jar  jar path if  jar null j edit add plugin jar  jar path jar check dependencies jar activate plugin if necessary return jar 
 returns the full path name of this plugin s jar file public  string get path return path 
 unlike get plugin will return a  plugin jar that is not yet loaded given its classname param class name a class name return the ja rpath of the first  plugin jar it can find which contains this class name or null if not found since pre public static  string find plugin  string class name  edit plugin ep j edit get plugin class name if ep null return ep get plugin jar get path for  string ja rpath j edit get not loaded plugin ja rs  plugin jar pjar new  plugin jar new  file ja rpath if pjar contains class class name return ja rpath return null 
param class name a class name return true if this jar contains a class with that classname since jedit pre boolean contains class  string class name try get zip file catch io exception ioe throw new  runtime exception ioe  enumeration extends  zip entry itr zip file entries while itr has more elements  string entry itr next element to string if entry ends with class  string name entry substring entry length replace if name equals class name return true return false 
 returns the full path name of this plugin s summary file  the summary file is used to store certain information which allows loading of the plugin s resources and core class to be deferred until the plugin is first used  as long as a plugin is using the j edit plugin api no extra effort is required to take advantage of the summary cache public  string get cache path return cache path 
param class name of a plugin that we wish to load return an ordered set of ja rpaths that contains the plugins that need to be re loaded in the correct order public static  set  string get dependency set  string class name  string dep  set  string retval new  linked hash set  string int i while dep j edit get property plugin class name depend i null  plugin depends plugin depends try plugin depends get plugin depends dep catch  illegal argument exception e  log log  log error  plugin jar class class name has an invalid dependency dep continue if plugin depends what equals plugin int index plugin depends arg index of if index  log log  log error  plugin jar class class name has an invalid dependency dep version is missing continue  string plugin name plugin depends arg substring index  string need version plugin depends arg substring index todo check version  set  string load these first get dependency set plugin name load these first add plugin name load these first add all retval retval load these first return retval 
 returns a file pointing to the plugin jar public  file get file return file 
 returns the plugin s class loader public jar class loader get class loader return class loader 
 returns the plugin s jar file opening it if necessary since j edit pre public synchronized  zip file get zip file throws io exception if zip file null  log log  log debug this  opening path zip file new  zip file path return zip file 
deprecated  call get action set instead public  action set get actions return get action set 
 returns the plugin s action set for the j edit action context link j edit get action context  these actions are loaded from the code actions xml code file see link  action set since j edit pre public  action set get action set return actions 
 returns the plugin s action set for the file system browser action context link org gjt sp jedit browser vfs browser get action context  these actions are loaded from the code browser actions xml code file see link  action set since j edit pre public  action set get browser action set return browser actions 
 returns true if all dependencies are satisified false otherwise  also if dependencies are not satisfied the plugin is marked as broken public boolean check dependencies if plugin null return true int i boolean ok true  string name plugin get class name  string dep while dep j edit get property plugin name depend i null  plugin depends plugin depends try plugin depends get plugin depends dep catch  illegal argument exception e  log log  log error this name has an invalid dependency dep ok false continue if plugin depends what equals jdk if plugin depends optional  standard utilities compare strings  system get property java version plugin depends arg false  string args plugin depends arg  system get property java version j edit plugin error path plugin error dep jdk args ok false else if plugin depends what equals jedit if plugin depends arg length  log log  log error this  invalid j edit version number plugin depends arg ok false if plugin depends optional  standard utilities compare strings j edit get build plugin depends arg false  string needs  misc utilities build to version plugin depends arg  string args needs j edit get version j edit plugin error path plugin error dep jedit args ok false else if plugin depends what equals plugin int index plugin depends arg index of if index  log log  log error this name has an invalid dependency dep version is missing ok false continue  string plugin name plugin depends arg substring index  string need version plugin depends arg substring index  string curr version j edit get property plugin plugin name version  edit plugin edit plugin j edit get plugin plugin name false if edit plugin null if plugin depends optional  string args need version plugin name j edit plugin error path plugin error dep plugin no version args ok false else if  standard utilities compare strings curr version need version false if plugin depends optional  string args need version plugin name curr version j edit plugin error path plugin error dep plugin args ok false else if edit plugin instanceof  edit plugin  broken if plugin depends optional  string args plugin name j edit plugin error path plugin error dep plugin broken args ok false else  plugin jar jar edit plugin get plugin jar if plugin depends optional jar these use me add path we use these add jar get path else jar these require me add path we require these add jar get path else if plugin depends what equals class if plugin depends optional try class loader load class plugin depends arg false catch  exception e  string args plugin depends arg j edit plugin error path plugin error dep class args ok false else  log log  log error this name has unknown dependency dep ok false each jar file listed in the plugin s jars property needs to know that we need them  string jars j edit get property plugin plugin get class name jars if jars null  string dir  misc utilities get parent of path path  string tokenizer st new  string tokenizer jars while st has more tokens  string jar path  misc utilities construct path dir st next token  plugin jar jar j edit get plugin jar jar path if jar null  string args jar path j edit plugin error path plugin error missing jar args ok false else we require these add jar path jar these require me add path if ok break plugin return ok 
 returns the required jars of this plugin return the required jars of this plugin since j edit pre public  set  string get required jars return we require these 
private static  plugin depends get plugin depends  string dep throws  illegal argument exception boolean optional if dep starts with optional optional true dep dep substring optional length else optional false int index dep index of if index throw new  illegal argument exception wrong dependency  string what dep substring index  string arg dep substring index  plugin depends depends new  plugin depends depends what what depends arg arg depends optional optional return depends 
 if plugin a is needed by b and b is needed by c we want to tell the user that a is needed by b and c when they try to unload a param dependents a set of plugins which we wish to disable param list model a set of plugins which will be affected and will need to be disabled also public static void transitive closure  string dependents  list  string list model for int i i dependents length i  string jar path dependents i if list model contains jar path list model add jar path  plugin jar jar j edit get plugin jar jar path transitive closure jar get dependent plugins list model 
public  string get dependent plugins return these require me to array new  string these require me size 
 returns the plugin core class for this jar file  note that if the plugin has not been activated this will return an instance of link  edit plugin  deferred  if you need the actual plugin core class instance call link activate plugin first  if the plugin is not yet loaded returns null since j edit pre public  edit plugin get plugin return plugin 
 loads the plugin core class  does nothing if the plugin core class has already been loaded  this method might be called on startup depending on what properties are set  see link  edit plugin start  this method is thread safe since j edit pre public void activate plugin synchronized this if activated recursive call return activated true if plugin instanceof  edit plugin  deferred return  string class name plugin get class name try  class clazz class loader load class class name false int modifiers clazz get modifiers if  modifier is interface modifiers  modifier is abstract modifiers  edit plugin class is assignable from clazz  log log  log error this  plugin has properties but does not extend  edit plugin class name break plugin return plugin  edit plugin clazz new instance plugin jar this catch  throwable t break plugin  log log  log error this  error while starting plugin class name  log log  log error this t  string args t to string j edit plugin error path plugin error start error args return if j edit is main thread  swing utilities is event dispatch thread start plugin else for thread safety start plugin later  edit bus send new  plugin update this  plugin update activated false 
 should be called after a new plugin is installed since j edit pre public void activate plugin if necessary  string filename  misc utilities get file name get path j edit set boolean property plugin blacklist filename false if plugin instanceof  edit plugin  deferred plugin null return  string class name plugin get class name default for plugins that don t specify this property ie style plugins is to load them on startup  string activate j edit get property plugin class name activate if activate null plugin if j edit is main thread break plugin j edit plugin error path plugin error not null else activate plugin else plugin if at least one property listed here is true load the plugin boolean load false  string tokenizer st new  string tokenizer activate while st has more tokens  string prop st next token boolean value j edit get boolean property prop if value  log log  log debug this  activating class name because of prop load true break if load activate plugin 
 unloads the plugin core class  does nothing if the plugin core class has not been loaded  this method can only be called from the awt event dispatch thread see  edit plugin stop since j edit pre public void deactivate plugin boolean exit if activated return if exit buffers retain a reference to the fold handler in question and the easiest way to handle fold handler unloading is this  buffer buffer j edit get first buffer while buffer null if buffer get fold handler null buffer get fold handler get class get class loader class loader buffer set fold handler new  dummy fold handler buffer buffer get next if plugin null plugin instanceof  edit plugin  broken if plugin instanceof eb plugin  edit bus remove from bus eb component plugin try plugin stop catch  throwable t  log log  log error this  error while stopping plugin  log log  log error this t plugin new  edit plugin  deferred this plugin get class name  edit bus send new  plugin update this  plugin update deactivated exit if exit see if this is a style plugin  string activate j edit get property plugin plugin get class name activate if activate null break plugin j edit plugin error path plugin error not null activated false 
 returns the location of the plugin s code dockables xml code file since j edit pre public url get dockables uri return dockables uri 
 returns the location of the plugin s code services xml code file since j edit pre public url get services uri return services uri 
 override public  string to string if plugin null return path else return path class plugin get class name 
public static  plugin cache entry get plugin cache  plugin jar plugin  string jar cache path plugin get cache path if jar cache path null return null  data input stream din null try  plugin cache entry cache new  plugin cache entry cache plugin plugin cache mod time plugin get file last modified din new  data input stream new  buffered input stream new  file input stream jar cache path if cache read din return cache else returns false with outdated cache return null catch  file not found exception fnf return null catch io exception io  log log  log error  plugin jar class io return null finally io utilities close quietly din 
static void set plugin cache  plugin jar plugin  plugin cache entry cache  string jar cache path plugin get cache path if jar cache path null return  log log  log debug  plugin jar class  writing jar cache path  data output stream dout null try dout new  data output stream new  buffered output stream new  file output stream jar cache path cache write dout dout close catch io exception io  log log  log error  plugin jar class io io utilities close quietly dout new  file jar cache path delete 
 creates a  plugin jar object which is not necessarily loaded but can be later see load  string boolean public  plugin jar  file file path file get path  string jar cache dir j edit get jar cache directory if jar cache dir null cache path  misc utilities construct path jar cache dir file get name summary this file file class loader new jar class loader this actions new  action set 
void init  plugin cache entry cache get plugin cache this if cache null load cache cache class loader activate else try cache generate cache if cache null set plugin cache this cache class loader activate catch io exception io  log log  log error this  cannot load plugin path  log log  log error this io  string args io to string j edit plugin error path plugin error load error args uninit false 
void uninit boolean exit deactivate plugin exit if exit for  string path we require these  plugin jar jar j edit get plugin jar path if jar null jar these require me remove this path for  string path we use these  plugin jar jar j edit get plugin jar path if jar null jar these use me remove this path class loader deactivate  bean shell reset class manager if actions null j edit remove action set actions if browser actions null vfs browser get action context remove action set browser actions  dockable window factory get instance unload dockable windows this  service manager unload services this j edit remove plugin props properties try if zip file null zip file close zip file null catch io exception io  log log  log error this io 
 string get classes return classes 
public  string get resources return resources 
private void actions present but not core class  log log  log warning this get path has an actions xml but no plugin core class actions set label missing plugin core class 
private void load cache  plugin cache entry cache classes cache classes resources cache resources this should be before dockables are initialized if cache cached properties null properties cache cached properties j edit add plugin props cache cached properties if cache actions uri null cache cached action names null actions new  action set this cache cached action names cache cached action toggle flags cache actions uri if cache browser actions uri null cache cached browser action names null browser actions new  action set this cache cached browser action names cache cached browser action toggle flags cache browser actions uri vfs browser get action context add action set browser actions if cache dockables uri null cache cached dockable names null cache cached dockable action flags null cache cached dockable movable flags null dockables uri cache dockables uri  dockable window factory get instance cache dockable windows this cache cached dockable names cache cached dockable action flags cache cached dockable movable flags if actions size j edit add action set actions if cache services uri null cache cached services null services uri cache services uri for int i i cache cached services length i  service manager  descriptor d cache cached services i  service manager register service d if cache plugin class null  check if a plugin with the same name is already loaded if j edit get plugin cache plugin class null j edit plugin error path plugin error already loaded null uninit false else  string label j edit get property plugin cache plugin class name actions set label j edit get property action set plugin new  string label plugin new  edit plugin  deferred this cache plugin class else if actions size actions present but not core class 
public  plugin cache entry generate cache throws io exception properties new  properties  list  string classes new  linked list  string  list  string resources new  linked list  string  zip file zip file get zip file  list  string plugins new  linked list  string  plugin cache entry cache new  plugin cache entry cache mod time file last modified cache cached properties new  properties  enumeration extends  zip entry entries zip file entries while entries has more elements  zip entry entry entries next element  string name entry get name  string lname name to lower case if lname equals actions xml cache actions uri class loader get resource name else if lname equals browser actions xml cache browser actions uri class loader get resource name else if lname equals dockables xml dockables uri class loader get resource name cache dockables uri dockables uri else if lname equals services xml services uri class loader get resource name cache services uri services uri else if lname ends with props  input stream in class loader get resource as stream name properties load in in close else if name ends with class  string class name  misc utilities file to class name if class name ends with  plugin plugins add class name classes add class name else resources add name cache cached properties properties j edit add plugin props properties this classes cache classes classes to array new  string classes size this resources cache resources resources to array new  string resources size  string label null for  string class name plugins  string  label j edit get property plugin class name name  string version j edit get property plugin class name version if  label null version null  log log  log warning this  ignoring class name else cache plugin class class name  check if a plugin with the same name is already loaded if j edit get plugin class name null j edit plugin error path plugin error already loaded null return null plugin new  edit plugin  deferred this class name label  label break if cache actions uri null actions new  action set this null null cache actions uri actions load cache cached action names actions get cacheable action names cache cached action toggle flags new boolean cache cached action names length for int i i cache cached action names length i cache cached action toggle flags i j edit get boolean property cache cached action names i toggle if cache browser actions uri null browser actions new  action set this null null cache browser actions uri browser actions load vfs browser get action context add action set browser actions cache cached browser action names browser actions get cacheable action names cache cached browser action toggle flags new boolean cache cached browser action names length for int i i cache cached browser action names length i cache cached browser action toggle flags i j edit get boolean property cache cached browser action names i toggle if dockables uri null  dockable window factory get instance load dockable windows this dockables uri cache if actions size if label null actions set label j edit get property action set plugin new  string label else actions present but not core class j edit add action set actions if services uri null  service manager load services this services uri cache return cache 
private void start plugin try plugin start catch  throwable t break plugin  log log  log error  plugin jar this  error while starting plugin plugin get class name  log log  log error  plugin jar this t  string args t to string j edit plugin error path plugin error start error args if plugin instanceof eb plugin if j edit get property plugin plugin get class name activate null old plugins expected j edit style behavior where a  properties changed was sent after plugins were started eb component plugin handle message new org gjt sp jedit msg  properties changed null  edit bus add to bus eb component plugin buffers retain a reference to the fold handler in question and the easiest way to handle fold handler loading is this  buffer buffer j edit get first buffer while buffer null  fold handler handler  fold handler get fold handler buffer get string property folding null before loaded if buffer get fold handler null handler null handler buffer get fold handler buffer set fold handler handler buffer buffer get next 
private void start plugin later  swing utilities invoke later new  runnable public void run if activated return start plugin 
private void break plugin plugin new  edit plugin  broken this plugin get class name remove action sets dockables etc so that user doesn t see the broken plugin uninit false but we want properties to hang around j edit add plugin props properties 
public boolean read  data input stream din throws io exception int cache magic din read int if cache magic magic return false  string cache build read string din if cache build equals j edit get build return false long cache mod time din read long if cache mod time mod time return false actions uri read uri din cached action names read string array din cached action toggle flags read boolean array din browser actions uri read uri din cached browser action names read string array din cached browser action toggle flags read boolean array din dockables uri read uri din cached dockable names read string array din cached dockable action flags read boolean array din cached dockable movable flags read boolean array din services uri read uri din int len din read int if len cached services null else cached services new  service manager  descriptor len for int i i len i  service manager  descriptor d new  service manager  descriptor read string din read string din null plugin cached services i d classes read string array din resources read string array din cached properties read map din plugin class read string din return true 
public void write  data output stream dout throws io exception dout write int magic write string dout j edit get build dout write long mod time write string dout actions uri write string array dout cached action names write boolean array dout cached action toggle flags write string dout browser actions uri write string array dout cached browser action names write boolean array dout cached browser action toggle flags write string dout dockables uri write string array dout cached dockable names write boolean array dout cached dockable action flags write boolean array dout cached dockable movable flags write string dout services uri if cached services null dout write int else dout write int cached services length for int i i cached services length i write string dout cached services i clazz write string dout cached services i name write string array dout classes write string array dout resources write map dout cached properties write string dout plugin class 
private static  string read string  data input stream din throws io exception int len din read int if len return null char str new char len for int i i len i str i din read char return new  string str 
private static url read uri  data input stream din throws io exception  string str read string din if str null return null else return new url str 
private static  string read string array  data input stream din throws io exception int len din read int if len return null  string str new  string len for int i i len i str i read string din return str 
private static boolean read boolean array  data input stream din throws io exception int len din read int if len return null boolean bools new boolean len for int i i len i bools i din read boolean return bools 
private static  properties read map  data input stream din throws io exception  properties return value new  properties int count din read int for int i i count i  string key read string din  string value read string din if value null value return value put key value return return value 
private static void write string  data output stream dout  object obj throws io exception if obj null dout write int else  string str obj to string dout write int str length dout write chars str 
private static void write string array  data output stream dout  string str throws io exception if str null dout write int else dout write int str length for int i i str length i write string dout str i 
private static void write boolean array  data output stream dout boolean bools throws io exception if bools null dout write int else dout write int bools length for int i i bools length i dout write boolean bools i 
private static void write map  data output stream dout  map map throws io exception dout write int map size  set  map  entry  object  object set map entry set for  map  entry  object  object entry set write string dout entry get key write string dout entry get value 
 plugin list  work request work request id j edit get property plugin manager mirror id this work request work request read plugin list true 
void read plugin list boolean allow retry gzip url j edit get property plugin manager export url if id equals  mirror list  mirror none gzip url mirror id  string path null if j edit get settings directory null cached url gzip url else path j edit get settings directory  file separator plugin mgr  cached xml gz cached url file path boolean download it id equals j edit get property plugin manager mirror cached id if path null try  file f new  file path if f can read download it true long current time  system current time millis long age current time f last modified  by default only download plugin lists every minutes long interval j edit get integer property plugin manager list cache minutes if age interval  log log  log message this  plugin list cached copy too old  downloading from mirror download it true catch  exception e  log log  log message this  no cached copy  downloading from mirror download it true if download it cached url gzip url download plugin list  input stream in null input stream null try if cached url gzip url  log log  log message this  using cached pluginlist input stream new url cached url open stream xml reader parser xml reader factory create xml reader  plugin list handler handler new  plugin list handler this cached url in new  buffered input stream input stream if in mark supported in mark int b in read int b in read in reset if b gzip magic  b gzip magic  in new gzip input stream in  input source isrc new  input source new  input stream reader in utf isrc set system id jedit jar parser set content handler handler parser set dtd handler handler parser set entity resolver handler parser set error handler handler parser parse isrc catch  exception e  log log  log error this readpluginlist error e if cached url starts with file  log log  log debug this  unable to read plugin list deleting cached file and try again new  file cached url substring delete if allow retry plugins clear plugin hash clear plugin sets clear read plugin list false finally io utilities close quietly in io utilities close quietly input stream 
 caches it locally void download plugin list  buffered input stream is null  buffered output stream out null try work request set status j edit get property plugin manager list download  input stream input stream new url gzip url open stream  string file name cached url replace first file out new  buffered output stream new  file output stream file name long start  system current time millis is new  buffered input stream input stream io utilities copy stream null is out false j edit set property plugin manager mirror cached id id  log log  log message this  updated cached pluginlist  system current time millis start catch  exception e  log log  log error this  cache remote plugin list error e finally io utilities close quietly out io utilities close quietly is 
void add plugin  plugin plugin plugin check if installed plugins add plugin plugin hash put plugin name plugin 
void add plugin set  plugin set set plugin sets add set 
void finished after the entire list is loaded fill out plugin field in dependencies for int i i plugins size i  plugin plugin plugins get i for int j j plugin branches size j  branch branch plugin branches get j for int k k branch deps size k  dependency dep branch deps get k if dep what equals plugin dep plugin plugin hash get dep plugin name 
void dump for int i i plugins size i  system err println plugins get i  system err println 
 returns the mirror id return the mirror id since j edit pre  string get mirror id return id 
public  string to string return plugins to string 
void check if installed check if the plugin is already installed this is a bit of hack  plugin jar jars j edit get plugin ja rs for int i i jars length i  string path jars i get path if new  file path exists continue if  misc utilities get file name path equals jar installed path  edit plugin plugin jars i get plugin if plugin null installed version j edit get property plugin plugin get class name version break  string not loaded j edit get not loaded plugin ja rs for int i i not loaded length i  string path not loaded i if  misc utilities get file name path equals jar installed path break 
 string get installed version  plugin jar jars j edit get plugin ja rs for int i i jars length i  string path jars i get path if  misc utilities get file name path equals jar  edit plugin plugin jars i get plugin if plugin null return j edit get property plugin plugin get class name version else return null return null 
 string get installed path  plugin jar jars j edit get plugin ja rs for int i i jars length i  string path jars i get path if  misc utilities get file name path equals jar return path return null 
 find the first branch compatible with the running j edit release  branch get compatible branch for int i i branches size i  branch branch branches get i if branch can satisfy dependencies return branch return null 
boolean can be installed  branch branch get compatible branch return branch null branch obsolete branch can satisfy dependencies 
void install  roster roster  string install directory boolean download source  string installed get installed path  branch branch get compatible branch if branch obsolete if installed null roster add remove installed return branch satisfy dependencies roster install directory download source if installed null install directory  misc utilities get parent of path installed roster add install installed download source branch download source branch download install directory download source branch download source size branch download size 
public  string to string return name 
boolean can satisfy dependencies for int i i deps size i  dependency dep deps get i if dep can satisfy return false return true 
void satisfy dependencies  roster roster  string install directory boolean download source for int i i deps size i  dependency dep deps get i dep satisfy roster install directory download source 
public  string to string return version version download download obsolete obsolete deps deps 
 dependency  string what  string from  string to  string plugin name this what what this from from this to to this plugin name plugin name 
boolean is satisfied if what equals plugin for int i i plugin branches size i  string installed version plugin get installed version if installed version null from null  standard utilities compare strings installed version from false to null  standard utilities compare strings installed version to false return true return false else if what equals jdk  string java version  system get property java version substring if from null  standard utilities compare strings java version from false to null  standard utilities compare strings java version to false return true else return false else if what equals jedit  string build j edit get build if from null  standard utilities compare strings build from false to null  standard utilities compare strings build to false return true else return false else  log log  log error this  invalid dependency what return false 
boolean can satisfy if is satisfied return true if what equals plugin return plugin can be installed return false 
void satisfy  roster roster  string install directory boolean download source if what equals plugin  string installed version plugin get installed version for int i i plugin branches size i  branch branch plugin branches get i if installed version null  standard utilities compare strings installed version branch version false from null  standard utilities compare strings branch version from false to null  standard utilities compare strings branch version to false plugin install roster install directory download source return 
public  string to string return what what from from to to plugin plugin 
 plugin list handler  plugin list plugin list  string path this plugin list plugin list this path path author new  string builder description new  string builder plugin set entry new  string builder download new  string builder download source new  string builder 
public  input source resolve entity  string public id  string system id return xml utilities find entity system id plugins dtd get class 
public void attribute  string aname  string value boolean is specified if aname name name value else if aname jar jar value else if aname version version value else if aname date date value else if aname obsolete obsolete true equals value else if aname what dep what value else if aname from dep from value else if aname to dep to value else if aname plugin dep plugin value else if aname size size  integer parse int value if size  log log  log warning this size 
public void characters char c int off int len  string tag peek element if tag equals description description append c off len else if tag equals plugin set entry plugin set entry append c off len else if tag equals author if author length author append author append c off len else if tag equals download download append c off len else if tag equals download source download source append c off len 
public void start element  string uri  string local name  string tag  attributes attrs for int i i attrs get length i  string a name attrs get q name i  string a value attrs get value i attribute a name a value true tag push element tag if tag equals plugin set description set length plugin set new  plugin list  plugin set plugin set name name else if tag equals plugin description set length author set length branch null plugin new  plugin list  plugin else if tag equals branch download set length branch new  plugin list  branch else if tag equals download download size size else if tag equals download source download source size size 
public void end element  string uri  string local name  string tag pop element if tag equals plugin set plugin list add plugin set plugin set plugin set null plugin set entry set length else if tag equals plugin set entry plugin set plugins add plugin set entry to string plugin set entry set length else if tag equals plugin plugin jar jar plugin name name plugin author author to string plugin description description to string plugin list add plugin plugin jar null name null author set length description set length else if tag equals branch branch version version branch date date branch download download to string branch download size download size branch download source download source to string branch download source size download source size branch obsolete obsolete plugin branches add branch version null download set length download source set length obsolete false else if tag equals depend  plugin list  dependency dep new  plugin list  dependency dep what dep from dep to dep plugin branch deps add dep dep what null dep from null dep to null dep plugin null 
public void start document try push element null catch  exception e  log log  log error this e 
public void end document plugin list finished 
private  string push element  string name state stack push name return name 
private  string peek element return state stack peek 
private  string pop element return state stack pop 
 returns the currently visible plugin manager window or null since j edit pre public static  plugin manager get instance return instance 
public void dispose instance null  edit bus remove from bus this  edit bus remove from bus installer super dispose 
public void handle message eb message message if message instanceof  properties changed if should update plugin list plugin list null update plugin list if tab pane get selected index installer update model updater update model else if message instanceof  plugin update if queued update  swing utilities invoke later new  runnable public void run queued update false manager update queued update true 
public static void show plugin manager  frame parent if instance null instance new  plugin manager parent else instance to front 
public void ok dispose 
public void cancel dispose 
 plugin list get plugin list return plugin list 
private  plugin manager  frame parent super j edit get property plugin manager title this parent parent init 
private void init  edit bus add to bus this  setup panes j panel content new j panel new  border layout content set border new  empty border set content pane content tab pane new j tabbed pane tab pane add tab j edit get property manage plugins title manager new  manage panel this tab pane add tab j edit get property update plugins title updater new  install panel this true tab pane add tab j edit get property install plugins title installer new  install panel this false  edit bus add to bus installer content add  border layout center tab pane tab pane add change listener new  list updater  create the buttons  box buttons new  box  box layout x axis  action listener al new  action handler mgr options new j button j edit get property plugin manager mgr options mgr options add action listener al plugin options new j button j edit get property plugin manager plugin options plugin options add action listener al done new j button j edit get property plugin manager done done add action listener al buttons add  box create glue buttons add mgr options buttons add  box create horizontal strut buttons add plugin options buttons add  box create horizontal strut buttons add done buttons add  box create glue get root pane set default button done content add  border layout south buttons set default close operation dispose on close set icon image gui utilities get plugin icon pack gui utilities load geometry this parent plugin manager gui utilities add size saver this parent plugin manager set visible true 
 check if the plugin list should be updated  it will return code true code if the plugin list is code null code or if the mirror id of the current plugin list is not the current preffered mirror id and will return always false if the plugin list is currently downloading return true if the plugin list should be updated private boolean should update plugin list return plugin list null plugin list get mirror id equals j edit get property plugin manager mirror id downloading plugin list 
private void update plugin list if j edit get settings directory null j edit get j edit home null gui utilities error this no settings null return if should update plugin list return final  exception exception new  exception vfs manager run in work thread new  work request public void run try downloading plugin list true set status j edit get property plugin manager list download connect plugin list new  plugin list this catch  exception e exception e finally downloading plugin list false vfs manager run in awt thread new  runnable public void run if exception instanceof sax parse exception sax parse exception se sax parse exception exception int line se get line number  string path j edit get property plugin manager export url  string message se get message  log log  log error this path line message  string pp path  string value of line message gui utilities error  plugin manager this plugin list xmlerror pp else if exception null  exception e exception  log log  log error this e  string pp e to string  string ok j edit get property common ok  string proxy button j edit get property plugin list ioerror proxy servers int ret val j option pane show option dialog  plugin manager this j edit get property plugin list ioerror message pp j edit get property plugin list ioerror title j option pane yes no option j option pane error message null new  object proxy button ok ok if ret val new  global options  plugin manager this firewall 
public void process key events  key event ke if ke get id  key event key pressed ke get key code  key event vk escape cancel ke consume 
public void action performed  action event evt  object source evt get source if source done ok else if source mgr options new  global options  plugin manager this plugin manager else if source plugin options new  plugin options  plugin manager this 
public void state changed  change event e  component selected tab pane get selected component if selected installer selected updater update plugin list installer update model updater update model else if selected manager manager update 
public  plugin manager option pane super plugin manager 
protected void  init set layout new  border layout mirror label new j label update mirror label j panel button panel new j panel button panel set layout new  box layout button panel  box layout y axis j panel spinner panel null if j edit get settings directory null settings dir new j radio button j edit get property options plugin manager settings dir settings dir set tool tip text  misc utilities construct path j edit get settings directory jars int delay j edit get integer property plugin manager list cache minutes spinner model new  spinner number model delay cache for spinner new j spinner spinner model spinner panel new j panel spinner panel set layout new  box layout spinner panel  box layout x axis spinner panel add new j label  cache plugin list for minutes spinner panel add cache for spinner spinner panel add  box create glue j radio button app dir new j radio button j edit get property options plugin manager app dir app dir set tool tip text  misc utilities construct path j edit get j edit home jars mira list new j list mira model new  mirror model mira list set selection model new  single selection model  download mirror add  border layout north mirror label add  border layout center new j scroll pane mira list button panel add  box create vertical strut  update mirror list update mirrors new j button j edit get property options plugin manager update mirrors update mirrors add action listener new  action handler update mirrors set enabled false vfs manager run in work thread new  update mirrors thread false j panel panel new j panel new  flow layout  flow layout left panel add update mirrors if spinner panel null panel add spinner panel panel add update status panel set alignment x  component left alignment button panel add panel button panel add  box create vertical strut  download source download source new j check box j edit get property options plugin manager download source download source set selected j edit get boolean property plugin manager download source download source set alignment x  component left alignment button panel add download source button panel add  box create vertical strut  delete downloaded files delete downloads new j check box j edit get property options plugin manager delete downloads delete downloads set selected j edit get boolean property plugin manager delete downloads delete downloads set alignment x  component left alignment button panel add delete downloads button panel add  box create vertical strut  install location  button group loc grp new  button group if j edit get settings directory null loc grp add settings dir loc grp add app dir j panel loc panel new j panel loc panel set layout new  box layout loc panel  box layout y axis if j edit get settings directory null loc panel add settings dir loc panel add  box create vertical strut loc panel set border new  titled border j edit get property options plugin manager location loc panel add app dir loc panel set alignment x  component left alignment button panel add loc panel button panel add  box create glue add  border layout south button panel if j edit get boolean property plugin manager install user j edit get settings directory null settings dir set selected true else app dir set selected true 
protected void  save j edit set boolean property plugin manager install user settings dir null settings dir is selected j edit set boolean property plugin manager download source download source is selected j edit set boolean property plugin manager delete downloads delete downloads is selected j edit set integer property plugin manager list cache minutes spinner model get number int value if mira list get selected index  string current mirror mira model get id mira list get selected index  string previous mirror j edit get property plugin manager mirror id if previous mirror equals current mirror j edit set property plugin manager mirror id current mirror j edit set property plugin manager mirror name  string mira model get element at mira list get selected index update mirror label  insert code to update the plugin managers list here later 
private void update mirror label  string current mirror j edit get property plugin manager mirror id  string mirror name if current mirror equals  mirror list  mirror none mirror name  plugin  central default else mirror name j edit get property plugin manager mirror name if mirror name null mirror name current mirror mirror label set text j edit get property options plugin manager mirror mirror name 
 mirror model mirrors new  array list  mirror list  mirror 
public  string get id int index return mirrors get index id 
public int get size return mirrors size 
public  object get element at int index  mirror list  mirror mirror mirrors get index if mirror id equals  mirror list  mirror none return j edit get property options plugin manager none else return mirror continent mirror description mirror location 
public void set list  list  mirror list  mirror mirrors this mirrors mirrors fire contents changed this mirrors size 
 single selection model set selection mode single selection 
public void remove selection interval int index int index 
public void action performed  action event evt update mirrors set enabled false update status set text j edit get property options plugin manager workthread vfs manager run in work thread new  update mirrors thread true 
 update mirrors thread boolean download this download download 
public void run try set status j edit get property options plugin manager workthread set maximum set value final  list  mirror list  mirror mirrors new  array list  mirror list  mirror try  mirror list mirror list new  mirror list download this if download save mirror list mirror list xml mirrors add all mirror list mirrors catch  exception ex if download  log log  log error this ex gui utilities error  plugin manager option pane this ioerror new  string ex to string  swing utilities invoke later new  runnable public void run mira model set list mirrors  string id j edit get property plugin manager mirror id int size mira model get size for int i i size i if size mira model get id i equals id mira list set selected index i break set value finally update mirrors set enabled true update status set text null 
private void save mirror list  string xml  string settings directory j edit get settings directory if settings directory null return  file mirror list new  file  misc utilities construct path settings directory mirror list xml  output stream out null try out new  buffered output stream new  file output stream mirror list io utilities copy stream null new  byte array input stream xml get bytes out false catch io exception e  log log  log error this  unable to write cached mirror list mirror list finally io utilities close quietly out 
public  plugin manager progress  plugin manager dialog  roster roster super dialog j edit get property plugin manager progress true this roster roster j panel content new j panel new  border layout content set border new  empty border set content pane content progress new j progress bar progress set string painted true progress set string j edit get property plugin manager progress int maximum count roster get operation count for int i i count i maximum roster get operation i get maximum progress set maximum maximum content add  border layout north progress stop new j button j edit get property plugin manager progress stop stop add action listener new  action handler j panel panel new j panel new  flow layout  flow layout center panel add stop content add  border layout center panel add window listener new  window handler pack set location relative to dialog set visible true 
param value the new value deprecated  use link set value long public void set value final int value  swing utilities invoke later new  runnable public void run progress set value value so far value 
 update the progress value param value the new value since j edit pre public void set value final long value  swing utilities invoke later new  runnable public void run progress set value value so far int value 
 this method is unused with the plugin manager param value the new max value it will be ignored since j edit pre public void set maximum long value 
 this method is unused with the plugin manager param status the new status it will be ignored since j edit pre public void set status  string status set title status progress set string status 
public void done try if done count  swing utilities invoke and wait new  runnable public void run dispose else  swing utilities invoke and wait new  runnable public void run value so far roster get operation done get maximum progress set value value so far done catch  exception e 
public void action performed  action event evt if evt get source stop thread stop dispose 
public void window opened  window event evt if done return done true thread new  roster thread thread start 
public void window closing  window event evt thread stop dispose 
 roster thread super  plugin manager thread 
public void run roster perform operations in work thread  plugin manager progress this 
public  plugin options  frame frame super frame plugin options j edit get property plugin options last 
public  plugin options  frame frame  string pane super frame plugin options pane 
public  plugin options  dialog dialog super dialog plugin options j edit get property plugin options last 
public  plugin options  dialog dialog  string pane super dialog plugin options pane 
protected  option tree model create option tree model  option tree model pane tree model new  option tree model  option group root group  option group pane tree model get root initialize the  plugins branch of the options tree plugins group new  option group plugins plugins group set sort true  query plugins for option panes  edit plugin plugins j edit get plugins for int i i plugins length i  edit plugin ep plugins i if ep instanceof  edit plugin  broken continue  string class name ep get class name if j edit get property plugin class name activate null  old api try ep create option panes this catch  throwable t  log log  log error ep  error creating option pane  log log  log error ep t else  string option pane j edit get property plugin class name option pane if option pane null plugins group add option pane option pane else  string options j edit get property plugin class name option group if options null plugins group add option group new  option group plugin class name j edit get property plugin class name name options only add the  plugins branch if there are  option panes if plugins group get member count plugins group add option pane new  no plugins pane root group add option group plugins group return pane tree model 
protected  option group get default group return plugins group 
public  no plugins pane super no plugins 
public  plugin res url connection url url throws io exception super url  string file url get file int index file index of if index plugin null resource file else int start if file char at start else start plugin file substring start index resource file substring index if plugin null resource starts with resource resource substring 
public void connect throws io exception if connected if plugin null in j edit class get resource as stream resource else  plugin jar plugins j edit get plugin ja rs for int i i plugins length i  plugin jar jar plugins i  string jar name  misc utilities get file name jar get path to lower case if plugin equals ignore case jar name in jar get class loader get resource as stream resource break if in null throw new io exception  resource not found plugin resource connected true 
public  input stream get input stream throws io exception connect return in 
public  string get header field  string name if name equals content type  string lc resource resource to lower case if lc resource ends with html return text html else if lc resource ends with txt return text plain else if lc resource ends with rtf return text rtf else if lc resource ends with gif return image gif else if lc resource ends with jpg lc resource ends with jpeg return image jpeg else return null else return null 
public boolean update every time return false 
public void update j menu menu  we build a set of lists each list contains plugin menu items that begin with a given letter int count  list j menu item letters  list j menu item new  list for int i i letters length i letters i new  array list j menu item  vector j menu item plugin menu items new  vector j menu item  plugin jar plugin array j edit get plugin ja rs for int i i plugin array length i  plugin jar jar plugin array i  edit plugin plugin jar get plugin if plugin null continue j menu item menu item plugin create menu items if menu item null add to letter map letters menu item count old api else if j edit get property plugin plugin get class name activate null try plugin menu items clear plugin create menu items plugin menu items  iterator j menu item iter plugin menu items iterator while iter has next add to letter map letters iter next count catch  throwable t  log log  log error this  error creating menu items for plugin  log log  log error this t if count j menu item menu item new j menu item j edit get property no plugins label menu item set enabled false menu add menu item return  sort each letter for int i i letters length i  collections sort letters i new  menu item text comparator int max items j edit get integer property menu spillover if less than items put them directly in the menu if count max items for int i i letters length i  iterator j menu item iter letters i iterator while iter has next menu add iter next return  collect blocks of up to max items of consecutive letters count char first a j menu submenu new j menu menu add submenu for int i i letters length i  list j menu item letter letters i if count letter size max items count char last char i a if last first submenu set text  string value of first else submenu set text first last first char i a count submenu null  iterator j menu item iter letter iterator while iter has next if submenu null submenu new j menu menu add submenu submenu add iter next count letter size if submenu null char last z if last first submenu set text  string value of first else submenu set text first last 
private void add to letter map  list j menu item letters j menu item item char ch item get text char at ch  character to upper case ch if ch a ch z  log log  log error this  plugin menu item label must begin with a z or a z item get text else letters ch a add item 
 creates a new plugin update message param jar  the plugin param what  what happened param exit  is the editor exiting since j edit pre public  plugin update  plugin jar jar  object what boolean exit super jar if what null throw new  null pointer exception  what must be non null this what what this exit exit 
 returns what caused this plugin update public  object get what return what 
 returns true if this plugin is being unloaded as part of the shutdown process in which case some components like the help viewer and plugin manager ignore the event since j edit pre public boolean is exiting return exit 
 returns the plugin involved public  plugin jar get plugin jar return  plugin jar get source 
public  string param string return what what exit exit super param string 
protected  position changing  edit pane edit pane  object whatt super edit pane whatt 
public  position changing  text area text area super  edit pane get text area  edit pane update position changing 
public  position changing  edit pane edit pane super edit pane  edit pane update position changing 
public  position manager j edit buffer buffer this buffer buffer 
public synchronized  position create position int offset  pos bottom half bh new  pos bottom half offset  pos bottom half existing positions get bh if existing null positions put bh bh existing bh return new  pos top half existing 
public synchronized void content inserted int offset int length if positions is empty return get all positions from offset to the end inclusive  iterator  pos bottom half iter positions tail map new  pos bottom half offset key set iterator iteration true while iter has next iter next content inserted offset length iteration false 
public synchronized void content removed int offset int length if positions is empty return get all positions from offset to the end inclusive  iterator  pos bottom half iter positions tail map new  pos bottom half offset key set iterator iteration true while iter has next iter next content removed offset length iteration false 
 pos top half  pos bottom half bh this bh bh bh ref 
public int get offset return bh offset 
 override protected void finalize synchronized  position manager this bh unref 
 pos bottom half int offset this offset offset 
void ref ref 
void unref if ref positions remove this 
void content inserted int offset int length if offset this offset throw new  array index out of bounds exception this offset length check invariants 
void content removed int offset int length if offset this offset throw new  array index out of bounds exception if this offset offset length this offset offset else this offset length check invariants 
 override public boolean equals  object o if o instanceof  pos bottom half return false return  pos bottom half o offset offset 
public int compare to  pos bottom half pos bottom half if iteration  log log  log error this  consistency failure return offset pos bottom half offset 
private void check invariants if offset offset buffer get length throw new  array index out of bounds exception 
private  special 
public  primitive  object value if value null throw new  interpreter error  use  primitve null instead of  primitive null if value  special null value value  special void type is wrapper type value get class throw new  interpreter error  not a wrapper type value this value value 
public  primitive boolean value this new  boolean value 
public  primitive byte value this new  byte value 
public  primitive short value this new  short value 
public  primitive char value this new  character value 
public  primitive int value this new  integer value 
public  primitive long value this new  long value 
public  primitive float value this new  float value 
public  primitive double value this new  double value 
 return the primitive value stored in its java lang wrapper class public  object get value if value  special null value return null else if value  special void type throw new  interpreter error attempt to unwrap void type else return value 
public  string to string if value  special null value return null else if value  special void type return void else return value to string 
 get the corresponding  java primitive type class for this  primitive return the primitive type class type of the value or  void type for  primitive void or null value for type of  primitive null public  class get type if this  primitive void return  void type null return null as type we currently use null type to indicate loose typing throughout bsh if this  primitive null return null return unbox type value get class 
 perform a binary operation on two  primitives or wrapper types  if both original args were  primitives return a  primitive result else it was mixed wrapper primitive return the wrapper type  the exception is for boolean operations where we will return the primitive type either way public static  object binary operation  object obj  object obj int kind throws  util eval error special primitive types if obj null obj null throw new  util eval error  null value or null literal in binary operation if obj void obj void throw new  util eval error  undefined variable class or void literal in binary operation keep track of the original types  class lhs org type obj get class  class rhs org type obj get class  unwrap primitives if obj instanceof  primitive obj  primitive obj get value if obj instanceof  primitive obj  primitive obj get value  object operands promote primitives obj obj  object lhs operands  object rhs operands if lhs get class rhs get class throw new  util eval error  type mismatch in operator lhs get class cannot be used with rhs get class  object result try result binary operation impl lhs rhs kind catch  arithmetic exception e throw new  util target error  arithemetic  exception in binary op e  if both original args were  primitives return a  primitive result else it was mixed wrapper primitive return the wrapper type  exception is for boolean result return the primitive if lhs org type  primitive class rhs org type  primitive class result instanceof  boolean return new  primitive result else return result 
static  object binary operation impl  object lhs  object rhs int kind throws  util eval error if lhs instanceof  boolean return boolean binary operation  boolean lhs  boolean rhs kind else if lhs instanceof  integer return int binary operation  integer lhs  integer rhs kind else if lhs instanceof  long return long binary operation  long lhs  long rhs kind else if lhs instanceof  float return float binary operation  float lhs  float rhs kind else if lhs instanceof  double return double binary operation  double lhs  double rhs kind else throw new  util eval error  invalid types in binary operator 
static  boolean boolean binary operation  boolean b  boolean b int kind boolean lhs b boolean value boolean rhs b boolean value switch kind case eq return new  boolean lhs rhs case ne return new  boolean lhs rhs case bool or case bool orx return new  boolean lhs rhs case bool and case bool andx return new  boolean lhs rhs default throw new  interpreter error unimplemented binary operator 
static  object long binary operation  long l  long l int kind long lhs l long value long rhs l long value switch kind boolean case lt case ltx return new  boolean lhs rhs case gt case gtx return new  boolean lhs rhs case eq return new  boolean lhs rhs case le case lex return new  boolean lhs rhs case ge case gex return new  boolean lhs rhs case ne return new  boolean lhs rhs arithmetic case plus return new  long lhs rhs case minus return new  long lhs rhs case star return new  long lhs rhs case slash return new  long lhs rhs case mod return new  long lhs rhs bitwise case lshift case lshiftx return new  long lhs rhs case rsignedshift case rsignedshiftx return new  long lhs rhs case runsignedshift case runsignedshiftx return new  long lhs rhs case bit and case bit andx return new  long lhs rhs case bit or case bit orx return new  long lhs rhs case xor return new  long lhs rhs default throw new  interpreter error  unimplemented binary long operator 
static  object int binary operation  integer i  integer i int kind int lhs i int value int rhs i int value switch kind boolean case lt case ltx return new  boolean lhs rhs case gt case gtx return new  boolean lhs rhs case eq return new  boolean lhs rhs case le case lex return new  boolean lhs rhs case ge case gex return new  boolean lhs rhs case ne return new  boolean lhs rhs arithmetic case plus return new  integer lhs rhs case minus return new  integer lhs rhs case star return new  integer lhs rhs case slash return new  integer lhs rhs case mod return new  integer lhs rhs bitwise case lshift case lshiftx return new  integer lhs rhs case rsignedshift case rsignedshiftx return new  integer lhs rhs case runsignedshift case runsignedshiftx return new  integer lhs rhs case bit and case bit andx return new  integer lhs rhs case bit or case bit orx return new  integer lhs rhs case xor return new  integer lhs rhs default throw new  interpreter error  unimplemented binary integer operator 
static  object double binary operation  double d  double d int kind throws  util eval error double lhs d double value double rhs d double value switch kind boolean case lt case ltx return new  boolean lhs rhs case gt case gtx return new  boolean lhs rhs case eq return new  boolean lhs rhs case le case lex return new  boolean lhs rhs case ge case gex return new  boolean lhs rhs case ne return new  boolean lhs rhs arithmetic case plus return new  double lhs rhs case minus return new  double lhs rhs case star return new  double lhs rhs case slash return new  double lhs rhs case mod return new  double lhs rhs can t shift floating point values case lshift case lshiftx case rsignedshift case rsignedshiftx case runsignedshift case runsignedshiftx throw new  util eval error  can t shift doubles default throw new  interpreter error  unimplemented binary double operator 
static  object float binary operation  float f  float f int kind throws  util eval error float lhs f float value float rhs f float value switch kind boolean case lt case ltx return new  boolean lhs rhs case gt case gtx return new  boolean lhs rhs case eq return new  boolean lhs rhs case le case lex return new  boolean lhs rhs case ge case gex return new  boolean lhs rhs case ne return new  boolean lhs rhs arithmetic case plus return new  float lhs rhs case minus return new  float lhs rhs case star return new  float lhs rhs case slash return new  float lhs rhs case mod return new  float lhs rhs can t shift floats case lshift case lshiftx case rsignedshift case rsignedshiftx case runsignedshift case runsignedshiftx throw new  util eval error  can t shift floats default throw new  interpreter error  unimplemented binary float operator 
 promote primitive wrapper type to to  integer wrapper type static  object promote to integer  object wrapper if wrapper instanceof  character return new  integer  character wrapper char value else if wrapper instanceof  byte wrapper instanceof  short return new  integer  number wrapper int value return wrapper 
 promote the pair of primitives to the maximum type of the two e g int long long long static  object promote primitives  object lhs  object rhs lhs promote to integer lhs rhs promote to integer rhs if lhs instanceof  number rhs instanceof  number  number lnum  number lhs  number rnum  number rhs boolean b if b lnum instanceof  double rnum instanceof  double if b rhs new  double rnum double value else lhs new  double lnum double value else if b lnum instanceof  float rnum instanceof  float if b rhs new  float rnum float value else lhs new  float lnum float value else if b lnum instanceof  long rnum instanceof  long if b rhs new  long rnum long value else lhs new  long lnum long value return new  object lhs rhs 
public static  primitive unary operation  primitive val int kind throws  util eval error if val null throw new  util eval error illegal use of null object or null literal if val void throw new  util eval error illegal use of undefined object or void literal  class operand type val get type  object operand promote to integer val get value if operand instanceof  boolean return new  primitive boolean unary operation  boolean operand kind else if operand instanceof  integer int result int unary operation  integer operand kind and must be cast back the original type if kind incr kind decr if operand type  byte type return new  primitive byte result if operand type  short type return new  primitive short result if operand type  character type return new  primitive char result return new  primitive result else if operand instanceof  long return new  primitive long unary operation  long operand kind else if operand instanceof  float return new  primitive float unary operation  float operand kind else if operand instanceof  double return new  primitive double unary operation  double operand kind else throw new  interpreter error  an error occurred  please call technical support 
static boolean boolean unary operation  boolean b int kind throws  util eval error boolean operand b boolean value switch kind case bang return operand default throw new  util eval error  operator inappropriate for boolean 
static int int unary operation  integer i int kind int operand i int value switch kind case plus return operand case minus return operand case tilde return operand case incr return operand case decr return operand default throw new  interpreter error bad integer unary operation 
static long long unary operation  long l int kind long operand l long value switch kind case plus return operand case minus return operand case tilde return operand case incr return operand case decr return operand default throw new  interpreter error bad long unary operation 
static float float unary operation  float f int kind float operand f float value switch kind case plus return operand case minus return operand default throw new  interpreter error bad float unary operation 
static double double unary operation  double d int kind double operand d double value switch kind case plus return operand case minus return operand default throw new  interpreter error bad double unary operation 
public int int value throws  util eval error if value instanceof  number return  number value int value else throw new  util eval error  primitive not a number 
public boolean boolean value throws  util eval error if value instanceof  boolean return  boolean value boolean value else throw new  util eval error  primitive not a boolean 
 determine if this primitive is a numeric type i e not boolean null or void but including char public boolean is number return value instanceof  boolean this null this void 
public  number number value throws  util eval error  object value this value  promote character to  number type for these purposes if value instanceof  character value new  integer  character value char value if value instanceof  number return  number value else throw new  util eval error  primitive not a number 
 primitives compare equal with other  primitives containing an equal wrapped value public boolean equals  object obj if obj instanceof  primitive return  primitive obj value equals this value else return false 
 the hash of the  primitive is tied to the hash of the wrapped value but shifted so that they are not the same public int hash code return this value hash code arbitrary 
 unwrap primitive values and map voids to nulls  non  primitive types remain unchanged param obj object type which may be bsh  primitive return corresponding normal  java type unwrapping any bsh  primitive types to their wrapper types public static  object unwrap  object obj map voids to nulls for the outside world if obj  primitive void return null unwrap primitives if obj instanceof  primitive return  primitive obj get value else return obj 
public static  object unwrap  object args  object oa new  object args length for int i i args length i oa i unwrap args i return oa 
public static  object wrap  object args  class param types if args null return null  object oa new  object args length for int i i args length i oa i wrap args i param types i return oa 
 wrap primitive values as indicated by type param and nulls in the  primitive class  values not primitive or null are left unchanged  primitive values are represented by their wrapped values in param value p  the value null is mapped to  primitive null  any value specified with type  void type is mapped to  primitive void public static  object wrap  object value  class type if type  void type return  primitive void if value null return  primitive null if type is primitive return new  primitive value return value 
 get the appropriate default value per jls public static  primitive get default value  class type if type null type is primitive return  primitive null if type  boolean type return new  primitive false non boolean primitive get appropriate flavor of zero try return new  primitive int cast to type type  types cast catch  util eval error e throw new  interpreter error bad cast 
 get the corresponding java lang wrapper class for the primitive type class e g  integer type  integer class public static  class box type  class primitive type  class c  class wrapper map get primitive type if c null return c throw new  interpreter error  not a primitive type primitive type 
 get the corresponding primitive type class for the java lang wrapper class type e g  integer class  integer type public static  class unbox type  class wrapper type  class c  class wrapper map get wrapper type if c null return c throw new  interpreter error  not a primitive wrapper type wrapper type 
 cast this bsh  primitive value to a new bsh  primitive value  this is usually a numeric type cast  other cases include a boolean can be cast to boolen null can be cast to any object type and remains null  attempting to cast a void causes an exception param to type is the java object or primitive type class public  primitive cast to type  class to type int operation throws  util eval error return cast primitive to type get type from type this from value false check only operation 
static  primitive cast primitive  class to type  class from type  primitive from value boolean check only int operation throws  util eval error  lots of preconditions checked here  once things are running smoothly we might comment these out  that s what assertions are for if check only from value null throw new  interpreter error bad cast param if check only from value null throw new  interpreter error bad cast param if from type null from type is primitive throw new  interpreter error bad from type from type if from value  primitive null from type null throw new  interpreter error inconsistent args if from value  primitive void from type  void type throw new  interpreter error inconsistent args can t cast void to anything if from type  void type if check only return  types invalid cast else throw  types cast error  reflect normalize class name to type void value operation unwrap  primitive from value to its wrapper value etc  object value null if from value null value from value get value if to type is primitive  trying to cast null to primitive type if from type null if check only return  types invalid cast else throw  types cast error primitive type to type  null value operation fall through else  trying to cast primitive to an object type  primitive null can be cast to any object type if from type null return check only  types valid cast  primitive null if check only return  types invalid cast else throw  types cast error object type to type primitive value operation can only cast boolean to boolean if from type  boolean type if to type  boolean type if check only return  types invalid cast else throw  types cast error to type from type operation return check only  types valid cast from value  do numeric cast  only allow legal  java assignment unless we re a cast operation if operation  types assignment  types is java assignable to type from type if check only return  types invalid cast else throw  types cast error to type from type operation return check only  types valid cast new  primitive cast wrapper to type value 
public static boolean is wrapper type  class type return wrapper map get type null type is primitive 
 cast a primitive value represented by its java lang wrapper type to the specified java lang wrapper type e g  byte to  integer or  integer to  byte param to type is the java type type param value is the value in java lang wrapper value may not be null static  object cast wrapper  class to type  object value if to type is primitive throw new  interpreter error invalid type in cast wrapper to type if value null throw new  interpreter error null value in cast wrapper guard if value instanceof  boolean if to type  boolean type throw new  interpreter error bad wrapper cast of boolean else return value first promote char to  number type to avoid duplicating code if value instanceof  character value new  integer  character value char value if value instanceof  number throw new  interpreter error bad type in cast  number number  number value if to type  byte type return new  byte number byte value if to type  short type return new  short number short value if to type  character type return new  character char number int value if to type  integer type return new  integer number int value if to type  long type return new  long number long value if to type  float type return new  float number float value if to type  double type return new  double number double value throw new  interpreter error error in wrapper cast 
public  print option pane super print 
protected void  init  font font new  font selector j edit get font property print font add component j edit get property options print font font  header print header new j check box j edit get property options print header print header set selected j edit get boolean property print header add component print header  footer print footer new j check box j edit get property options print footer print footer set selected j edit get boolean property print footer add component print footer  line numbering print line numbers new j check box j edit get property options print line numbers print line numbers set selected j edit get boolean property print line numbers add component print line numbers  color color new j check box j edit get property options print color color set selected j edit get boolean property print color add component color  tab size  string tab sizes tab size new j combo box tab sizes tab size set editable true tab size set selected item j edit get property print tab size add component j edit get property options print tab size tab size  print  folds print folds new j check box j edit get property options print folds print folds set selected j edit get boolean property print folds true add component print folds add separator options print workarounds  spacing workaround glyph vector new j check box j edit get property options print glyph vector glyph vector set selected j edit get boolean property print glyph vector add component glyph vector  force print dialog force new j check box j edit get property options print force force set selected j edit get boolean property print force add component force 
protected void  save j edit set font property print font font get font j edit set boolean property print header print header is selected j edit set boolean property print footer print footer is selected j edit set boolean property print line numbers print line numbers is selected j edit set boolean property print color color is selected j edit set property print tab size  string tab size get selected item j edit set boolean property print glyph vector glyph vector is selected j edit set boolean property print force force is selected j edit set boolean property print folds print folds is selected 
 creates a new instance with the given root and the default array separator char param root a non null string that will be the root of the serialized properties protected  properties bean  string root this root 
 creates a new instance with the given root and the given array separator character param root a non null string that will be the root of the serialized properties param arraysep a character that will be used to define the separator of elements of an array property protected  properties bean  string root char arraysep if root null throw new  illegal argument exception root cannot be null this root root this arraysep arraysep 
 loads the bean s properties from the given object public void load  properties p try  property descriptor  props get property descriptors for int i i  props length i if class equals  props i get name continue  method  set  props i get write method if  set null  string  pname root  props i get name  object  val p get property  pname if  val null  val parse  string  val  props i get property type try  set invoke this  val catch  illegal argument exception iae  ignore these catch  exception e  these exceptions shouldn t occur during normal runtime so we catch them and print an error message  users of this class should fix these before releasing the code  log log  log error this e 
 saves the bean s properties into the given object public void save  properties p try  property descriptor  props get property descriptors for int i i  props length i if class equals  props i get name continue  method  get  props i get read method if  get null  object  val  get invoke this  string  pname root  props i get name if  val null p set property  pname encode  val else p remove  pname catch  exception e  these exceptions shouldn t occur during normal runtime so we catch them and print an error message  users of this class should fix these before releasing the code  log log  log error this e 
 cleans the entries related to this object from the given object public void clean  properties p try  property descriptor  props get property descriptors for int i i  props length i if class equals  props i get name continue  string  pname root  props i get name p remove  pname catch  exception e  these exceptions shouldn t occur during normal runtime so we catch them and print an error message  users of this class should fix these before releasing the code  log log  log error this e 
private  property descriptor get property descriptors throws  introspection exception  bean info  info  introspector get bean info get class return  info get property descriptors 
private  string encode  object value  class  class value get class if  class is array  string builder  val new  string builder int  len  array get length value for int i i  len i  string  str encode  array get value i if  str null return null  val append  str if i  len  val append arraysep return  val to string else just make sure it s a supported type if  class  boolean class  class  boolean type  class  character class  class  character type  class  double class  class  double type  class  float class  class  float type  class  integer class  class  integer type  class  long class  class  long type  class  short class  class  short type  class  string class  log log  log warning this unsupported type  class get name return null return value to string 
private  object parse  string value  class  class  object  ret null if  class is array  string tokenizer st new  string tokenizer value  string value of arraysep  class  type  class get component type  ret  array new instance  type st count tokens int  cnt st count tokens for int i i  cnt i  object  val parse st next token  type if  val null return null  array set  ret i  val else if  class  boolean class  class  boolean type  ret  boolean value of value else if  class  character class  class  character type  ret  character value of value char at else if  class  double class  class  double type  ret  double value of value else if  class  float class  class  float type  ret  float value of value else if  class  integer class  class  integer type  ret  integer value of value else if  class  long class  class  long type  ret  long value of value else if  class  short class  class  short type  ret  short value of value else if  class  string class  ret value else  log log  log warning this unsupported type  class get name return  ret 
 creates a new properties changed message param source  the message source public  properties changed eb component source super source 
 creates a new properties changing message param source  the message source param state  an enum describing what is happening public  properties changing eb component source  state state super source assert state null state shouldn t be null this state state 
public  state get state return state 
 properties get properties  properties total new  properties total put all system for  properties plugin plugins total put all plugin total put all site total put all user return total 
void load system props  input stream in throws io exception load props system in 
void load site props  input stream in throws io exception load props site in 
void load user props  input stream in throws io exception load props user in 
void save user props  output stream out throws io exception user store out j edit properties 
 properties load plugin props  input stream in throws io exception  properties plugin new  properties load props plugin in plugins add plugin return plugin 
void add plugin props  properties props plugins add props 
void remove plugin props  properties props plugins remove props 
 string get property  string name  string value user get property name if value null return value else return get default property name 
void set property  string name  string value  string prop get default property name if value is null if default is null unset user prop else set user prop to else if default equals value ignore if default doesn t equal value set user if value null if prop null prop length user remove name else user set property name else if value equals prop user remove name else user set property name value 
public void set temporary property  string name  string value user remove name system set property name value 
void unset property  string name if get default property name null user set property name else user remove name 
public void reset property  string name user remove name 
private  string get default property  string name  string value site get property name if value null return value for  properties plugin plugins value plugin get property name if value null return value return system get property name 
private static void load props  properties into  input stream in throws io exception try into load in finally in close 
 range map fvm new int lastfvmget 
 range map  range map copy this fvm copy fvm clone this fvmcount copy fvmcount 
void reset int lines lastfvmget fvmcount fvm fvm lines 
int first return fvm 
int last return fvm fvmcount 
int lookup int index return fvm index 
 returns the fold visibility map index for the given line int search int line if line fvm return if line fvm fvmcount return fvmcount if lastfvmget if line fvm lastfvmget if lastfvmget fvmcount line fvm lastfvmget return lastfvmget int start int end fvmcount loop for switch end start case lastfvmget start break loop case int value fvm end if value line lastfvmget end else lastfvmget start break loop default int pivot end start value fvm pivot if value line lastfvmget pivot break loop else if value line start pivot else end pivot break return lastfvmget 
 replaces from code start code to code end code inclusive with code put code  update code fvmcount code void put int start int end int put if  debug fold vis debug  string builder buf new  string builder buf append fvmput append start append buf append end append buf append if put null for int i i put length i if i buf append buf append put i buf append  log log  log debug this buf to string int putl put null put length int delta putl end start if fvmcount delta fvm length int newfvm new int fvm length  system arraycopy fvm newfvm fvmcount fvm newfvm if delta  system arraycopy fvm end fvm start putl fvmcount end if putl  system arraycopy put fvm start put length fvmcount delta dump if fvmcount throw new  internal error 
 merge previous and next entry if necessary void put int starti int endi int start int end if  debug fold vis debug  log log  log debug this fvmput starti endi start end if starti fvm starti start if endi fvmcount fvm endi end put starti endi null else put starti endi new int end else if endi fvmcount fvm endi end put starti endi new int start else put starti endi new int start end 
int next int line int index search line in collapsed range if index beyond last visible line if fvmcount index return start of next expanded range else return fvm index last in expanded range else if line fvm index equal to last visible line if fvmcount index return start of next expanded range else return fvm index next in expanded range else return line 
int prev int line int index search line before first visible line if index return in collapsed range else if index end of prev expanded range return fvm index first in expanded range else if line fvm index equal to first visible line if index return end of prev expanded range else return fvm index prev in expanded range else return line 
void show int start int end int starti search start int endi search end if starti if endi put starti endi null else if endi fvmcount fvm endi end put starti endi null else put starti endi null fvm starti end else if endi if starti fvm starti start put starti endi null else put starti endi null fvm starti start else put starti endi start end lastfvmget 
void hide int start int end int starti search start int endi search end if starti if endi put starti endi start end else if start fvm put starti endi null else put starti endi null fvm starti start else if endi if end fvm fvmcount put starti endi null else put starti endi null fvm starti end else put starti endi null lastfvmget 
int count return fvmcount 
void dump if  debug fold vis debug  string builder buf new  string builder for int i i fvmcount i if i buf append buf append fvm i buf append  log log  log debug this fvm buf 
void content inserted int start line int num lines if num lines int index search start line int start index for int i start i fvmcount i fvm i num lines lastfvmget dump 
return  if the anchors should be reset boolean pre content removed int start line int num lines boolean return value false int end line start line num lines update fold visibility map int starti search start line int endi search end line both have same visibility just remove anything in between if  math abs starti  math abs endi if endi starti fvmcount we re removing from before the first visible to after the last visible return value true starti else put starti endi null starti collapse else if starti fvm starti start line if endi starti fvmcount we re removing from the first visible to after the last visible return value true starti else put starti endi null shift else put starti endi null fvm starti start line starti update for int i starti i fvmcount i fvm i num lines lastfvmget dump return return value 
public void read lock body read lock lock 
public void read unlock body read lock unlock 
public void write lock body write lock lock 
public void write unlock body write lock unlock 
public boolean is write locked return body is write locked 
public boolean update every time return true 
public void update j menu menu final  view view gui utilities get view menu  action listener  action listener action listener new  action listener public void action performed  action event evt vfs browser browse directory view evt get action command view get status set message null  mouse listener  mouse listener mouse listener new  mouse adapter public void mouse entered  mouse event evt view get status set message j menu item evt get source get action command public void mouse exited  mouse event evt view get status set message null  history model model  history model get model vfs browser path if model get size j menu item menu item new j menu item j edit get property no recent dirs label menu item set enabled false menu add menu item return boolean sort j edit get boolean property sort recent int max items j edit get integer property menu spillover  vector j menu item menu items new  vector j menu item for int i i model get size i  string path model get item i j menu item menu item new j menu item  misc utilities get file name path menu item set action command path menu item add action listener action listener menu item add mouse listener mouse listener menu item set icon  file cell renderer dir icon if sort menu items add element menu item else if menu get menu component count max items i model get size j menu new menu new j menu j edit get property common more menu add new menu menu new menu menu add menu item if sort  collections sort menu items new  menu item text comparator for int i i menu items size i if menu get menu component count max items i j menu new menu new j menu j edit get property common more menu add new menu menu new menu menu add menu items element at i 
public boolean update every time return false 
public void update j menu menu final  view view gui utilities get view menu  action listener  action listener action listener new  action listener public void action performed  action event evt j edit open file view evt get action command view get status set message null  mouse listener  mouse listener mouse listener new  mouse adapter public void mouse entered  mouse event evt view get status set message j menu item evt get source get action command public void mouse exited  mouse event evt view get status set message null  change listener  change listener change listener new  change listener public void state changed  change event e j menu item menu item j menu item e get source view get status set message menu item is armed menu item get action command null  list  buffer history  entry recent vector  buffer history get history if recent vector is empty j menu item menu item new j menu item j edit get property no recent files label menu item set enabled false menu add menu item return final  list j menu item menu items new  array list j menu item final j text field text new j text field text set tool tip text j edit get property recent files textfield tooltip menu add text text add key listener new  key adapter public void key released  key event e  string typed text text get text for j menu item temp menu item menu items if typed text length temp menu item set enabled true else  string file name temp menu item get text boolean matches start file name to lower case starts with typed text to lower case temp menu item set enabled matches start boolean sort j edit get boolean property sort recent int max items j edit get integer property menu spillover  iterator  buffer history  entry iter recent vector iterator while iter has next  string path iter next path j menu item menu item new j menu item  misc utilities get file name path menu item set action command path menu item add action listener action listener menu item add mouse listener mouse listener menu item add change listener change listener menu item set icon  file cell renderer file icon menu items add menu item if sort if menu get menu component count max items iter has next j menu new menu new j menu j edit get property common more menu add new menu menu new menu menu add menu item if sort  collections sort menu items new  menu item text comparator for int i i menu items size i if menu get menu component count max items i j menu new menu new j menu j edit get property common more menu add new menu menu new menu menu add menu items get i j menu item menu item new j menu item j edit get property clear recent files label menu item add action listener new  action listener public void action performed  action event e  buffer history clear menu add separator menu add menu item 
public  widget get widget  view view  widget rect new  rect select widget view return rect 
 rect select widget final  view view rect select new  tool tip label rect select set horizontal alignment  swing constants center rect select set tool tip text j edit get property view status rect tooltip this view view rect select add mouse listener new  mouse adapter  override public void mouse clicked  mouse event evt j edit text area text area view get text area if text area null text area toggle rectangular selection enabled 
public j component get component return rect select 
public void update j edit text area text area view get text area if text area null rect select set text text area is rectangular selection enabled r 
public void properties changed retarded gtk look and feel  font font new j label get font ui manager get font  label font  font metrics fm rect select get font metrics font  dimension dim new  dimension  math max fm char width fm char width r fm get height rect select set preferred size dim rect select set maximum size dim 
 invoke method on arbitrary object instance invocation may be static through the object instance or dynamic  object may be a bsh scripted object bsh  this type return the result of the method call public static  object invoke object method  object object  string method name  object args  interpreter interpreter  call stack callstack  simple node caller info throws  reflect error  eval error  invocation target exception  bsh scripted object if object instanceof  this  this is exposed this method method name return  this object invoke method method name args interpreter callstack caller info false delcared only  plain  java object find the java method try  bsh class manager bcm interpreter null null interpreter get class manager  class clas object get class  method method resolve expected java method bcm clas object method name args false return invoke method method object args catch  util eval error e throw e to eval error caller info callstack 
 invoke a method known to be static  no object instance is needed and there is no possibility of the method being a bsh scripted method public static  object invoke static method  bsh class manager bcm  class clas  string method name  object args throws  reflect error  util eval error  invocation target exception  interpreter debug invoke static  method  method method resolve expected java method bcm clas null method name args true return invoke method method null args 
 invoke the  java method on the specified object performing needed type mappings on arguments and return values param args may be null static  object invoke method  method method  object object  object args throws  reflect error  invocation target exception if args null args new  object log invoke method  invoking method entry method args  map types to assignable forms need to keep this fast  object tmp args new  object args length  class types method get parameter types try for int i i args length i tmp args i  types cast object args i rhs types i lhs type  types assignment catch  util eval error e throw new  interpreter error illegal argument type in method invocation e unwrap any primitives tmp args  primitive unwrap tmp args log invoke method  invoking method after massaging values method tmp args try  object return value method invoke object tmp args if return value null return value  primitive null  class return type method get return type return  primitive wrap return value return type catch  illegal access exception e throw new  reflect error  cannot access method  string util method string method get name method get parameter types in method get declaring class e 
public static  object get index  object array int index throws  reflect error  util target error if  interpreter debug  interpreter debug get index array index index try  object val  array get array index return  primitive wrap val array get class get component type catch  array index out of bounds exception e throw new  util target error e catch  exception e throw new  reflect error  array access e 
public static void set index  object array int index  object val throws  reflect error  util target error try val  primitive unwrap val  array set array index val catch  array store exception e throw new  util target error e catch  illegal argument exception e throw new  util target error new  array store exception e to string catch  exception e throw new  reflect error  array access e 
public static  object get static field value  class clas  string field name throws  util eval error  reflect error return get field value clas null field name true onlystatic 
public static  object get object field value  object object  string field name throws  util eval error  reflect error if object instanceof  this return  this object namespace get variable field name else try return get field value object get class object field name false onlystatic catch  reflect error e no field try property acces if has object property getter object get class field name return get object property object field name else throw e 
static lhs get lhs static field  class clas  string field name throws  util eval error  reflect error  field f resolve expected java field clas field name true onlystatic return new lhs f 
 get an lhs reference to an object field  this method also deals with the field style property access  in the field does not exist we check for a property setter static lhs get lhs object field  object object  string field name throws  util eval error  reflect error if object instanceof  this i guess this is when we pass it as an argument  setting locally boolean recurse false return new lhs  this object namespace field name recurse try  field f resolve expected java field object get class field name false static only return new lhs object f catch  reflect error e not a field try property access if has object property setter object get class field name return new lhs object field name else throw e 
private static  object get field value  class clas  object object  string field name boolean static only throws  util eval error  reflect error try  field f resolve expected java field clas field name static only  object value f get object  class return type f get type return  primitive wrap value return type catch  null pointer exception e shouldn t happen throw new  reflect error field name is not a static field catch  illegal access exception e throw new  reflect error  can t access field field name 
protected static  field resolve java field  class clas  string field name boolean static only throws  util eval error try return resolve expected java field clas field name static only catch  reflect error e return null 
throws  reflect error if the field is not found  note this should really just throw  no such field exception need to change related signatures and code protected static  field resolve expected java field  class clas  string field name boolean static only throws  util eval error  reflect error  field field try if  capabilities have accessibility field find accessible field clas field name else  class get field finds only public and in interfaces etc field clas get field field name catch  no such field exception e throw new  reflect error  no such field field name catch  security exception e throw new  util target error  security  exception while searching fields of clas e if static only  modifier is static field get modifiers throw new  util eval error  can t reach instance field field name from static context clas get name return field 
 used when accessibility capability is available to locate an occurrance of the field in the most derived class or superclass and set its accessibility flag  note that this method is not needed in the simple non accessible case because we don t have to hunt for fields  note that classes may declare overlapping private fields so the distinction about the most derived is important  java doesn t normally allow this kind of access super won t show private variables so there is no real syntax for specifying which class scope to use return the  field or throws  no such field exception throws  no such field exception if the field is not found  this method should be rewritten to use get fields and avoid catching exceptions during the search private static  field find accessible field  class clas  string field name throws  util eval error  no such field exception  field field  quick check catches public fields include those in interfaces try field clas get field field name  reflect manager rm set accessible field return field catch  no such field exception e  now on with the hunt while clas null try field clas get declared field field name  reflect manager rm set accessible field return field  not found fall through to next class catch  no such field exception e clas clas get superclass throw new  no such field exception field name 
 this method wraps resolve java method and expects a non null method result  if the method is not found it throws a descriptive  reflect error protected static  method resolve expected java method  bsh class manager bcm  class clas  object object  string name  object args boolean static only throws  reflect error  util eval error if object  primitive null throw new  util target error new  null pointer exception  attempt to invoke method name on null value  class types  types get types args  method method resolve java method bcm clas name types static only if method null throw new  reflect error static only  static method  method  string util method string name types not found in class clas get name return method 
 the full blown resolver method  all other method invocation methods delegate to this  the method may be static or dynamic unless static only is set in which case object may be null  if static only is set then only static methods will be located p  this method performs caching caches discovered methods through the class manager and utilizes cached methods p  this method determines whether to attempt to use non public methods based on  capabilities have accessibility and will set the accessibilty flag on the method as necessary p  if when directed to find a static method this method locates a more specific matching instance method it will throw a descriptive exception analogous to the error that the  java compiler would produce  note as of x this is a problem because there is no way to work around this with a cast p param static only  the method located must be static the object param may be null return the method or null if no matching method was found protected static  method resolve java method  bsh class manager bcm  class clas  string name  class types boolean static only throws  util eval error if clas null throw new  interpreter error null class  lookup previously cached method  method method null if bcm null  interpreter debug resolve java method unoptimized lookup else method bcm get resolved method clas name types static only if method null boolean public only  capabilities have accessibility  searching for the method may itself be a priviledged action try method find overloaded method clas name types public only catch  security exception e throw new  util target error  security  exception while searching methods of clas e check found static method method static only clas  this is the first time we ve seen this method set accessibility  note even if it s a public method we may have found it in a non public class if method null public only try  reflect manager rm set accessible method catch  util eval error e ignore  if succeeded cache the resolved method if method null bcm null bcm cache resolved method clas types method return method 
 get the candidate methods by searching the class and interface graph of base class and resolve the most specific return the method or null for not found private static  method find overloaded method  class base class  string method name  class types boolean public only if  interpreter debug  interpreter debug  searching for method  string util method string method name types in base class get name  method methods get candidate methods base class method name types length public only if  interpreter debug  interpreter debug  looking for most specific method method name  method method find most specific method types methods return method 
 climb the class and interface inheritence graph of the type and collect all methods matching the specified name and criterion  if public only is true then only public methods in public classes or interfaces will be returned  in the normal non accessible case this addresses the problem that arises when a package private class or private inner class implements a public interface or derives from a public type p  this method primarily just delegates to gather methods recursive see gather methods recursive  class  string int boolean java util  vector static  method get candidate methods  class base class  string method name int num args boolean public only  vector candidates gather methods recursive base class method name num args public only null candidates return the methods in an array  method ma new  method candidates size candidates copy into ma return ma 
 accumulate all methods optionally including non public methods class and interface in the inheritence tree of base class  this method is analogous to  class get methods which returns all public methods in the inheritence tree  in the normal non accessible case this also addresses the problem that arises when a package private class or private inner class implements a public interface or derives from a public type  in other words sometimes we ll find public methods that we can t use directly and we have to find the same public method in a parent class or interface return the candidate methods vector private static  vector gather methods recursive  class base class  string method name int num args boolean public only  vector candidates if candidates null candidates new  vector  add methods of the current class to the vector  in public case be careful to only add methods from a public class and to use get methods instead of get declared methods  this addresses secure environments if public only if is public base class add candidates base class get methods method name num args public only candidates else add candidates base class get declared methods method name num args public only candidates  does the class or interface implement interfaces  class intfs base class get interfaces for int i i intfs length i gather methods recursive intfs i method name num args public only candidates  do we have a superclass interfaces don t etc  class superclass base class get superclass if superclass null gather methods recursive superclass method name num args public only candidates return candidates 
private static  vector add candidates  method methods  string method name int num args boolean public only  vector candidates for int i i methods length i  method m methods i if m get name equals method name m get parameter types length num args public only is public m candidates add m return candidates 
 primary object constructor  this method is simpler than those that must resolve general method invocation because constructors are not inherited p  this method determines whether to attempt to use non public constructors based on  capabilities have accessibility and will set the accessibilty flag on the method as necessary p static  object construct object  class clas  object args throws  reflect error  invocation target exception if clas is interface throw new  reflect error  can t create instance of an interface clas  object obj null  class types  types get types args  constructor con null  find the constructor there are no inherited constructors to worry about  constructor constructors  capabilities have accessibility clas get declared constructors clas get constructors if  interpreter debug  interpreter debug  looking for most specific constructor clas con find most specific constructor types constructors if con null throw cant find constructor clas types if is public con try  reflect manager rm set accessible con catch  util eval error e ignore args  primitive unwrap args try obj con new instance args catch  instantiation exception e throw new  reflect error  the class clas is abstract catch  illegal access exception e throw new  reflect error  we don t have permission to create an instance  use set accessibility true to enable access catch  illegal argument exception e throw new  reflect error  the number of arguments was wrong if obj null throw new  reflect error  couldn t construct the object return obj 
static  constructor find most specific constructor  class ideal match  constructor constructors int match find most specific constructor index ideal match constructors return match null constructors match 
static int find most specific constructor index  class ideal match  constructor constructors  class candidates new  class constructors length for int i i candidates length i candidates i constructors i get parameter types return find most specific signature ideal match candidates 
 find the best match for signature ideal match  it is assumed that the methods array holds only valid candidates e g method name and number of args already matched  this method currently does not take into account  java covariant return types which i think will require that we find the most derived return type of otherwise identical best matches see find most specific signature  class  class param methods the set of candidate method which differ only in the types of their arguments static  method find most specific method  class ideal match  method methods copy signatures into array for find most specific method  class candidate sigs new  class methods length for int i i methods length i candidate sigs i methods i get parameter types int match find most specific signature ideal match candidate sigs return match null methods match 
 implement jls  return the index of the most specific arguments match or if no match is found  this method is used by both methods and constructors which unfortunately don t share a common interface for signature info return the index of the most specific candidate  note  two methods which are equally specific should not be allowed by the  java compiler  in this case  bean shell currently chooses the first one it finds  we could add a test for this case here i believe by adding another is signature assignable in the other direction between the target and best match  if the assignment works both ways then neither is more specific and they are ambiguous i ll leave this test out for now because i m not sure how much another test would impact performance  method selection is now cached at a high level so a few friendly extraneous tests shouldn t be a problem static int find most specific signature  class ideal match  class candidates for int round  types first round assignable round  types last round assignable round  class best match null int best match index for int i i candidates length i  class target match candidates i  if ideal match fits target match and this is the first match or target match is more specific than the best match make it the new best match if  types is signature assignable ideal match target match round best match null  types is signature assignable target match best match  types java base assignable best match target match best match index i if best match null return best match index return 
private static  string accessor name  string getorset  string prop name return getorset  string value of  character to upper case prop name char at prop name substring 
public static boolean has object property getter  class clas  string prop name  string getter name accessor name get prop name try clas get method getter name new  class return true catch  no such method exception e fall through getter name accessor name is prop name try  method m clas get method getter name new  class return m get return type  boolean type catch  no such method exception e return false 
public static boolean has object property setter  class clas  string prop name  string setter name accessor name set prop name  method methods clas get methods we don t know the right hand side of the assignment yet has at least one setter of the right name for int i i methods length i if methods i get name equals setter name return true return false 
public static  object get object property  object obj  string prop name throws  util eval error  reflect error  object args new  object  interpreter debug property access  method method null  exception e null e null try  string accessor name accessor name get prop name method resolve expected java method null bcm obj get class obj accessor name args false catch  exception e e e if method null try  string accessor name accessor name is prop name method resolve expected java method null bcm obj get class obj accessor name args false if method get return type  boolean type method null catch  exception e e e if method null throw new  reflect error  error in property getter e e null e try return invoke method method obj args catch  invocation target exception e throw new  util eval error  property accessor threw exception e get target exception 
public static void set object property  object obj  string prop name  object value throws  reflect error  util eval error  string accessor name accessor name set prop name  object args new  object value  interpreter debug property access try  method method resolve expected java method null bcm obj get class obj accessor name args false invoke method method obj args catch  invocation target exception e throw new  util eval error  property accessor threw exception e get target exception 
 return a more human readable version of the type name  specifically array types are returned with postfix dimensions e g return int for integer array instead of class i as would be returned by  class get name in that case public static  string normalize class name  class type if type is array return type get name  string builder class name new  string builder try class name append get array base type type get name for int i i get array dimensions type i class name append catch  reflect error e shouldn t happen return class name to string 
returns the dimensionality of the  class returns if the  class is not an array class public static int get array dimensions  class array class if array class is array return return array class get name last index of why so cute 
 returns the base type of an array  class throws  reflect error if the  class is not an array class public static  class get array base type  class array class throws  reflect error if array class is array throw new  reflect error  the class is not an array return array class get component type 
a command may be implemented as a compiled  java class containing one or more static invoke methods of the correct signature  the invoke methods must accept two additional leading arguments of the interpreter and callstack respectively e g invoke interpreter callstack  this method adds the arguments and invokes the static method returning the result public static  object invoke compiled command  class command class  object args  interpreter interpreter  call stack callstack throws  util eval error add interpereter and namespace to args list  object invoke args new  object args length invoke args interpreter invoke args callstack  system arraycopy args invoke args args length  bsh class manager bcm interpreter get class manager try return  reflect invoke static method bcm command class invoke invoke args catch  invocation target exception e throw new  util eval error  error in compiled command e get target exception catch  reflect error e throw new  util eval error  error invoking compiled command e 
private static void log invoke method  string msg  method method  object args if  interpreter debug  interpreter debug msg method with args for int i i args length i  interpreter debug args i args i type args i get class 
private static void check found static method  method method boolean static only  class clas throws  util eval error  we re looking for a static method but found an instance method if method null static only is static method throw new  util eval error  cannot reach instance method  string util method string method get name method get parameter types from static context clas get name 
private static  reflect error cant find constructor  class clas  class types if types length return new  reflect error  can t find default constructor for clas else return new  reflect error  can t find constructor  string util method string clas get name types in class clas get name 
private static boolean is public  class c return  modifier is public c get modifiers 
private static boolean is public  method m return  modifier is public m get modifiers 
private static boolean is public  constructor c return  modifier is public c get modifiers 
private static boolean is static  method m return  modifier is static m get modifiers 
public  reflect error super 
public  reflect error  string s super s 
 return the singleton bsh  reflect manager throws  unavailable public static  reflect manager get reflect manager throws  unavailable if rfm null  class clas try clas  class for name org gjt sp jedit bsh reflect  reflect manager impl rfm  reflect manager clas new instance catch  exception e throw new  unavailable  reflect  manager unavailable e return rfm 
 reflect  manager  set  accessible  convenience method to invoke the reflect manager throws  unavailable public static boolean rm set accessible  object obj throws  unavailable return get reflect manager set accessible obj 
 set a java lang reflect  field  method  constructor or  array of accessible objects to accessible mode  if the object is not an  accessible object then do nothing return true if the object was accessible or false if it was not  arrays incomplete need to use the array setter public boolean set accessible  object obj if obj instanceof  accessible object  accessible object obj set accessible true return true else return false 
public  regex encoding detector  string pattern  string replacement this pattern  pattern compile pattern this replacement replacement 
public  string detect encoding  input stream sample throws io exception  input stream reader reader new  input stream reader sample final int buffer size char buffer new char buffer size int read size reader read buffer buffer size if read size  matcher matcher pattern matcher  char buffer wrap buffer read size while matcher find  string extracted extract replacement matcher replacement if  encoding server has encoding extracted return extracted return null 
 returns a replaced string for a  matcher which has been matched by find method private static  string extract replacement  matcher found  string replacement  it doesn t make sense to read before start but append replacement requires to to it int found start found start int found end found end int source length found end found start  string buffer replaced new  string buffer found start source length found append replacement replaced replacement return replaced substring found start 
param collapse  if true then if the next indent rule is an opening bracket this rule will not increase indent public  regexp indent rule  string regexp  indent action prev prev  indent action prev  indent action this line boolean collapse throws  pattern syntax exception prev prev action prev prev prev action prev this action this line this regexp  pattern compile regexp  pattern case insensitive this collapse collapse 
public void apply j edit buffer buffer int this line index int prev line index int prev prev line index  list  indent action indent actions if this action null line matches buffer this line index indent actions add this action if prev action null prev line index line matches buffer prev line index indent actions add prev action if collapse indent actions add  indent action  prev collapse if prev prev action null prev prev line index line matches buffer prev prev line index indent actions add prev prev action if collapse indent actions add  indent action  prev prev collapse 
deprecated  do not use this  this is here only for compatibility  deprecated public boolean is match  string line  matcher m regexp matcher line return regexp is match line return m matches 
public  string to string return get class get name regexp 
public  token filter int original length result new  string builder original length 
public void handle token  segment seg byte id int offset int length  token marker  line context context  avoid replacing an empty token into a non empty string if length return switch id case  token comment case  token comment case  token comment case  token comment  replace any comments to a white space so that they are simply ignored result append break case  token literal case  token literal case  token literal case  token literal  replace any literals to a which means a simple integer literal in most programming languages result append break default result append seg array seg offset offset length break 
public void set line context  token marker  line context line context 
private boolean line matches j edit buffer buffer int line index  token filter filter new  token filter buffer get line length line index buffer mark tokens line index filter return regexp matcher filter result matches 
 creates a new registers changed message param source  the message source public  register changed eb component source char name super source register name name 
public char get register name return register name 
public  string get register value return  registers get register register name to string 
public  string param string return register register name super param string 
 copies the text selected in the text area into the specified register  this will replace the existing contents of the designated register param text area  the text area param register  the register since j edit pre public static void copy  text area text area char register  string selection text area get selected text if selection null return set register register selection  history model get model clipboard add item selection 
 copies the text selected in the text area into the specified register and then removes it from the buffer param text area  the text area param register  the register since j edit pre public static void cut  text area text area char register if text area is editable  string selection text area get selected text if selection null return set register register selection  history model get model clipboard add item selection text area set selected text else text area get toolkit beep 
 appends the text selected in the text area to the specified register with a newline between the old and new text param text area  the text area param register  the register public static void append  text area text area char register append text area register n false 
 appends the text selected in the text area to the specified register param text area  the text area param register  the register param separator  the separator to insert between the old and new text public static void append  text area text area char register  string separator append text area register separator false 
 appends the text selected in the text area to the specified register param text area  the text area param register  the register param separator  the text to insert between the old and new text param cut  should the current selection be removed since j edit pre public static void append  text area text area char register  string separator boolean cut if cut text area is editable text area get toolkit beep return  string selection text area get selected text if selection null return  register reg get register register if reg null  string register contents reg to string if register contents null if register contents ends with separator selection register contents selection else selection register contents separator selection set register register selection  history model get model clipboard add item selection if cut text area set selected text 
 insets the contents of the specified register into the text area param text area  the text area param register  the register since j edit pre public static void paste  text area text area char register paste text area register false 
 inserts the contents of the specified register into the text area param text area  the text area param register  the register param vertical  vertical columnar paste since j edit pre public static void paste  text area text area char register boolean vertical if text area is editable text area get toolkit beep return  register reg get register register if reg null text area get toolkit beep return  string selection reg to string if selection null text area get toolkit beep return j edit buffer buffer text area get buffer try buffer begin compound edit vertical paste if vertical text area get selection count int caret text area get caret position int caret line text area get caret line  selection  rect rect new  selection  rect caret line caret caret line caret text area set selected text rect selection caret line text area get caret line if caret line text area get line count int start column rect get start column buffer int offset buffer get offset of virtual column caret line start column null if offset buffer insert at column caret line start column text area set caret position buffer get line end offset caret line else text area set caret position buffer get line start offset caret line offset else  regular paste text area replace selection selection finally buffer end compound edit  history model get model clipboard add item selection 
 returns the specified register param name  the name public static  register get register char name if name name if loaded load registers if registers null name registers length return null else return registers name 
 sets the specified register param name  the name param new register  the new value public static void set register char name  register new register touch register name if name registers length  register new registers new  register  math min name  system arraycopy registers new registers registers length registers new registers registers name new register if listener null listener register changed name 
 sets the specified register param name  the name param value  the new value public static void set register char name  string value touch register name  register register get register name if register null register set value value if listener null listener register changed name else set register name new  string register value 
 sets the value of the specified register to code null code param name  the register name public static void clear register char name if name registers length return  register register registers name if name name register set value else registers name null modified true if listener null listener register changed name 
 returns an array of all available registers  some of the elements of this array might be code null code public static  register get registers if loaded load registers return registers 
 returns a string of all defined registers used by the status bar eg a b since j edit pre public static  string get register name string if loaded load registers  string builder buf new  string builder registers length for int i i registers length i if registers i null if buf length buf append buf append char i if buf length return null else return buf to string 
public static void save registers if loaded modified return if saver null saver save registers modified false 
public static void set listener  registers listener listener  registers listener listener 
public static void set saver  register saver saver  registers saver saver 
public static boolean is loading return loading 
public static void set loading boolean loading  registers loading loading 
private  registers 
private static void touch register char name if name name return if loaded load registers if loading modified true 
private static void load registers if saver null loaded true saver load registers 
public  clipboard register  clipboard clipboard this clipboard clipboard 
 sets the clipboard contents public void set value  string value  string selection selection new  string selection value clipboard set contents selection null 
 returns the clipboard contents  override public  string to string try if false  this is to debug clipboard problems  apparently j edit is unable to copy text from clipbard into the current text buffer if the clipboard was filles using the command echo test xselection clipboard under  linux  however it seems that  java does not offer any data flavor for this clipboard content under j re   b  thus copying from clipboard seems to be plainly impossible  log log  log debug this clipboard get contents this clipboard get contents this debug list data flavors clipboard get contents this  string selection  string clipboard get contents this get transfer data  data flavor string flavor boolean trailing eol selection ends with n selection ends with  system get property line separator  some  java versions return the clipboard contents using the native line separator so have to convert it here  buffered reader in new  buffered reader new  string reader selection  string builder buf new  string builder  string line while line in read line null broken  eclipse workaround  febuary if line ends with line line substring line length buf append line buf append n remove trailing n if trailing eol buf length buf set length buf length return buf to string catch  exception e  log log  log notice this e return null 
protected static void debug list data flavors  transferable transferable  data flavor data flavors transferable get transfer data flavors for int i i data flavors length i  data flavor data flavor data flavors i  log log  log debug  registers class debug list data flavors data flavor data flavor if data flavors length  log log  log debug  registers class debug list data flavors no data flavor supported 
 creates a new string register param value  the contents public  string register  string value this value value 
 sets the register contents public void set value  string value this value value 
 converts to a string  override public  string to string return value 
 called when this register is no longer available  this implementation does nothing public void dispose 
public  register viewer  view view  string position super new  border layout this view view  box tool bar new  box  box layout x axis j label label new j label j edit get property view registers title label set border new  empty border tool bar add label tool bar add  box create glue  rollover button paste register new  rollover button gui utilities load icon  paste png paste register set tool tip text gui utilities prettify menu label j edit get property paste string register label paste register add action listener this paste register set action command paste string register tool bar add paste register  rollover button clear register new  rollover button gui utilities load icon  clear png clear register set tool tip text gui utilities prettify menu label j edit get property clear string register label clear register add action listener this clear register set action command clear string register tool bar add clear register add  border layout north tool bar  default list model register model new  default list model register list new j list register model register list set selection mode  list selection model single selection register list set cell renderer new  renderer register list add list selection listener new  list handler register list add mouse listener new  mouse handler content text area new j text area content text area set editable true document handler new  document handler content text area get document add document listener document handler content text area add focus listener new  focus handler int orientation j split pane horizontal split if position equals  dockable window manager left position equals  dockable window manager right orientation j split pane vertical split add  border layout center split pane new j split pane orientation j edit get boolean property appearance continuous layout new j scroll pane register list new j scroll pane content text area refresh list 
public void action performed  action event evt  string cmd evt get action command if cmd equals paste string register insert register else if cmd equals clear string register clear selected index 
public void handle message eb message msg if msg instanceof  register changed if  register changed msg get register name refresh list else if msg instanceof  properties changed gui utilities init continuous layout split pane 
 override public void add notify super add notify  edit bus add to bus this 
 override public void remove notify super remove notify  edit bus remove from bus this 
public void move  string new position int orientation j split pane horizontal split if new position equals  dockable window manager left new position equals  dockable window manager right orientation j split pane vertical split split pane set orientation orientation revalidate 
private void clear selected index  object o register list get selected value if o null o instanceof  character  registers clear register  character o char value refresh list 
private void refresh list  default list model register model  default list model register list get model  object o register list get selected value int selected if o null o instanceof  character selected  character o char value register model remove all elements  registers  register registers  registers get registers int index for int i i registers length i  registers  register reg registers i if reg null continue if i continue  string value reg to string if value null value length continue if i selected index register model size register model add element  character value of char i if register model get size register model add element j edit get property view registers none register list set enabled false else register list set enabled true register list set selected index index 
private void insert register  object o register list get selected value if o null o instanceof  character return  registers  register reg  registers get register  character o char value view get text area set selected text reg to string view get text area request focus 
 override public  component get list cell renderer component j list list  object value int index boolean is selected boolean cell has focus super get list cell renderer component list value index is selected cell has focus if value instanceof  character char name  character value char value  string label if name n label n else if name t label t else if name label j edit get property view registers clipboard else if name label j edit get property view registers selection else label  string value of name  register register  registers get register name  string register value if register null  the register is not defined anymore it has been removed before the painting event register value j edit get property view registers undefined else register value register to string if register value length register value register value substring register value register value replace all n register value register value replace all t set text label register value return this 
public void value changed  list selection event evt  object value register list get selected value if value instanceof  character if editing content text area set text content text area set editable false return char name  character value char value  registers  register reg  registers get register name if reg null if editing content text area set text content text area set editable false return if editing content text area set text reg to string content text area set editable true content text area set caret position 
 override public void mouse clicked  mouse event evt int i register list location to index evt get point if i register list set selected index i if gui utilities is popup trigger evt if popup null popup new j popup menu j menu item item gui utilities load menu item paste popup add item item new j menu item j edit get property clear string register label item add action listener new  action listener public void action performed  action event e clear selected index popup add item gui utilities show popup menu popup register list evt get x evt get y false else if evt get click count insert register 
public void changed update  document event e update register safely 
public void insert update  document event e update register safely 
public void remove update  document event e update register safely 
private void update register safely try editing true update register finally editing false 
private void update register  object value register list get selected value if value instanceof  character return char name  character value char value  registers set register name content text area get text 
public void focus gained  focus event e content text area get document add document listener document handler 
public void focus lost  focus event e content text area get document remove document listener document handler 
public boolean update every time return false 
public void update j menu menu view gui utilities get view menu auto detect j menu item auto new j menu item j edit get property vfs browser commands encoding auto detect auto set action command auto detect auto add action listener this menu add auto menu add separator all the enabled encodings the system encoding  string encodings  misc utilities get encodings true  string system encoding  system get property file encoding if  arrays binary search encodings system encoding  string tmp a new  string encodings length  system arraycopy encodings tmp a encodings length tmp a encodings length system encoding encodings tmp a  arrays sort encodings int max items j edit get integer property menu spillover for int i i encodings length i j menu item mi new j menu item encodings i mi set action command encoding encodings i mi add action listener this if menu get menu component count max items i encodings length j menu new menu new j menu j edit get property common more menu add new menu menu new menu menu add mi menu add separator option to prompt for the encoding j menu item other new j menu item j edit get property vfs browser other encoding label other set action command other encoding other add action listener this menu add other 
public void action performed  action event ae j menu item mi j menu item ae get source  string action mi get action command  string encoding null  hashtable props null if action starts with encoding encoding action substring else if action equals other encoding encoding j option pane show input dialog view j edit get property encoding prompt message j edit get property encoding prompt title j option pane question message if encoding null return if  encoding server has encoding encoding  string msg j edit get property reload encoding error new  object encoding j option pane show message dialog view msg j edit get property common error j option pane error message return if encoding null props new  hashtable props put  buffer encoding encoding  disable auto detect because user explicitly specify an encoding props put  buffer encoding autodetect false  string path view get buffer get path j edit close buffer view view get buffer j edit open file view null path false props 
public static void main  string args throws  exception if args length  system out println usage  remote url http bsh file file  system exit  string url args  string text get file args int ret eval url text  system exit ret 
 evaluate text in the interpreter at url returning a possible integer return value public static int eval  string url  string text throws io exception  string return value null if url starts with http return value do http url text else if url starts with bsh return value do bsh url text else throw new io exception  unrecognized url type  scheme must be http or bsh try return  integer parse int return value catch  exception e this convention may change return 
static  string do bsh  string url  string text  output stream out  input stream in  string host  string port  string return value  string org url url  need some format checking here try url url substring remove the bsh get the index of the between the host and the port is located int index url index of host url substring index port url substring index url length catch  exception ex  system err println  bad url org url ex return return value try  system out println  connecting to host host at port port  socket s new  socket host  integer parse int port out s get output stream in s get input stream send line text out  buffered reader bin new  buffered reader new  input stream reader in  string line while line bin read line null  system out println line  need to scrape a value from the last line return value return return value catch  exception ex  system err println  error communicating with server ex return return value 
private static void send line  string line  output stream out pipe throws io exception out pipe write line get bytes out pipe flush 
static  string do http  string post url  string text  string return value null  string builder sb new  string builder sb append bsh client  remote sb append bsh script sb append url encoder encode text  this requires  java try sb append url encoder encode text   catch  unsupported encoding exception e e print stack trace  string form data sb to string try url url new url post url  http url connection urlcon  http url connection url open connection urlcon set request method post urlcon set request property  content type application x www form urlencoded urlcon set do output true urlcon set do input true  print writer pout new  print writer new  output stream writer urlcon get output stream   true pout print form data pout flush read results int rc urlcon get response code if rc  http url connection http ok  system out println  error http response rc return value urlcon get header field  bsh  return  buffered reader bin new  buffered reader new  input stream reader urlcon get input stream  string line while line bin read line null  system out println line  system out println  return  value return value catch  malformed url exception e  system out println e bad post url catch io exception e  system out println e i o error return return value 
static  string get file  string name throws  file not found exception io exception  string builder sb new  string builder  buffered reader bin new  buffered reader new  file reader name  string line while line bin read line null sb append line append n return sb to string 
public  return control int kind  object value  simple node return point this kind kind this value value this return point return point 
public  reverse char sequence  char sequence base this base base 
public  char sequence base sequence return base 
public char char at int index return base char at base length index 
public int length return base length 
public  char sequence sub sequence int start int end int base length base length return new  reverse char sequence base sub sequence base length end base length start 
public  string to string int base length base length  string builder builder new  string builder base length for int i base length i i builder append base char at i return builder to string 
 setup the border invisible initially public  rollover button set content area filled true add mouse listener new  mouse over handler 
 setup the border invisible initially param icon the icon of this button public  rollover button  icon icon this set icon icon 
public void update ui super update ui set border original border set border painted false set request focus enabled false set margin new  insets 
public void set enabled boolean b super set enabled b set border painted false repaint 
public void set border painted boolean b try revalidate blocked true super set border painted b set content area filled b finally revalidate blocked false 
 we block calls to revalidate from a set border painted for performance reasons public void revalidate if revalidate blocked super revalidate 
public void paint  graphics g if is enabled super paint g else  graphics d g  graphics d g g set composite c super paint g 
public void mouse entered  mouse event e set content area filled true set border painted is enabled 
public void mouse exited  mouse event e set content area filled false set border painted false 
 roster operations new  array list  operation to load new  array list  string 
 add a remove operation for the given jar param jar the jar name void add remove  string jar add operation new  remove jar 
void add install  string installed  string url  string install directory int size add operation new  install installed url install directory size 
public  operation get operation int i return operations get i 
int get operation count return operations size 
boolean is empty return operations is empty 
void perform operations in work thread  plugin manager progress progress for int i i operations size i  operation op operations get i op run in work thread progress progress done if  thread interrupted return 
void perform operations in awt thread  component comp for int i i operations size i  operation op operations get i op run in awt thread comp add the ja rs before checking deps since dep check might require all ja rs to be present for int i i to load size i  string plugin name to load get i if j edit get plugin jar plugin name null  log log  log warning this  already loaded plugin name else j edit add plugin jar plugin name for int i i to load size i  string plugin name to load get i  plugin jar plugin j edit get plugin jar plugin name if plugin null plugin check dependencies now activate the plugins for int i i to load size i  string plugin name to load get i  plugin jar plugin j edit get plugin jar plugin name if plugin null plugin activate plugin if necessary 
private void add operation  operation op for int i i operations size i if operations get i equals op return operations add op 
private static  string get download dir if download dir null  string settings j edit get settings directory if settings null settings  system get property user home download dir new  file  misc utilities construct path settings  plugin manager download download dir mkdirs return download dir get path 
public void run in work thread  plugin manager progress progress 
public void run in awt thread  component comp 
public int get maximum return 
 remove  string jar this jar jar 
public void run in awt thread  component comp close jar file and all ja rs that depend on this  plugin jar jar j edit get plugin jar this jar if jar null unload plugin jar jar to load remove this jar remove cache file move jar first  file jar file new  file this jar  file src file new  file this jar substring this jar length  log log  log notice this  deleting jar file boolean ok jar file delete if src file exists ok recursive delete src file if ok  string args this jar gui utilities error comp plugin manager remove failed args 
 this should go into a public method somewhere param jar the jar of the plugin private void unload plugin jar  plugin jar jar  string dependents jar get dependent plugins for  string path dependents  plugin jar  jar j edit get plugin jar path if  jar null to load add path unload plugin jar  jar clear cache file  string cache path jar get cache path if cache path null new  file cache path delete j edit remove plugin jar jar false 
public boolean equals  object o return o instanceof  remove  remove o jar equals jar 
 install  string installed  string url  string install directory int size catch those hooligans passing null urls if url null throw new  null pointer exception this installed installed this url url this install directory install directory this size size 
public int get maximum return size 
public void run in work thread  plugin manager progress progress  string file name  misc utilities get file name url path download progress file name url 
public void run in awt thread  component comp check if download failed if path null return if download ok remove existing version if installed null new  remove installed run in awt thread comp  zip file zip file null try zip file new  zip file path  enumeration extends  zip entry e zip file entries while e has more elements  zip entry entry e next element  string name entry get name replace  file separator char  file file new  file install directory name if entry is directory file mkdirs else new  file file get parent mkdirs  input stream in null  file output stream out null try in zip file get input stream entry out new  file output stream file io utilities copy stream null in out false finally io utilities close quietly in io utilities close quietly out if file get name to lower case ends with jar to load add file get path catch  interrupted io exception iio catch  zip exception e  log log  log error this e gui utilities error null plugin error download new  object catch io exception io  log log  log error this io  string args io get message gui utilities error null ioerror args catch  exception e  log log  log error this e finally try if zip file null zip file close catch io exception io  log log  log error this io if j edit get boolean property plugin manager delete downloads new  file path delete 
public boolean equals  object o return o instanceof  install  install o url equals url 
private  string download  plugin manager progress progress  string file name  string url try  string host j edit get property plugin manager mirror id if host null host equals  mirror list  mirror none host default  string path  misc utilities construct path get download dir file name url connection conn new url url open connection progress set status j edit get property plugin manager progress new  string file name host  input stream in null  file output stream out null try in conn get input stream out new  file output stream path if io utilities copy stream progress in out true return null finally io utilities close quietly in io utilities close quietly out return path catch  interrupted io exception iio do nothing user clicked  stop return null catch  file not found exception e  log log  log error this e  swing utilities invoke later new  runnable public void run gui utilities error null plugin error download new  object return null catch final io exception io  log log  log error this io  swing utilities invoke later new  runnable public void run  string args io get message gui utilities error null plugin error download args return null catch  exception e  log log  log error this e return null 
public  save backup option pane super save back 
 override protected void  init  two stage save two stage save new j check box j edit get property options save back two stage save two stage save set selected j edit get boolean property two stage save two stage save set tool tip text j edit get property options save back two stage save tooltip add component two stage save  confirm save all confirm save all new j check box j edit get property options save back confirm save all confirm save all set selected j edit get boolean property confirm save all add component confirm save all  autosave interval autosave new  numeric text field j edit get property autosave true add component j edit get property options save back autosave autosave  autosave untitled buffers autosave untitled new j check box j edit get property options save back autosave untitled autosave untitled set selected j edit get boolean property autosave untitled add component autosave untitled suppress not saved confirm untitled new j check box j edit get property options save back suppress not saved confirm untitled suppress not saved confirm untitled set selected j edit get boolean property suppress not saved confirm untitled add component suppress not saved confirm untitled use md for dirty calculation new j check box j edit get property options save back use md for dirty calculation use md for dirty calculation set tool tip text j edit get property options save back use md for dirty calculation tooltip use md for dirty calculation set selected j edit get boolean property use md for dirty calculation add component use md for dirty calculation  backup count backups new  numeric text field j edit get property backups true add component j edit get property options save back backups backups  backup directory backup directory new j text field j edit get property backup directory j button browse backup directory new j button browse backup directory add action listener new  my action listener j panel panel new j panel new  border layout panel add backup directory panel add browse backup directory  border layout east add component j edit get property options save back backup directory panel  backup filename prefix backup prefix new j text field j edit get property backup prefix add component j edit get property options save back backup prefix backup prefix  backup suffix backup suffix new j text field j edit get property backup suffix add component j edit get property options save back backup suffix backup suffix  backup on every save backup every save new j check box j edit get property options save back backup every save backup every save set selected j edit get boolean property backup every save add component backup every save 
 override protected void  save j edit set boolean property two stage save two stage save is selected j edit set boolean property confirm save all confirm save all is selected j edit set property autosave this autosave get text j edit set property backups backups get text j edit set property backup directory backup directory get text j edit set property backup prefix backup prefix get text j edit set property backup suffix backup suffix get text j edit set boolean property backup every save backup every save is selected boolean new autosave autosave untitled is selected boolean old autosave j edit get boolean property autosave untitled j edit set boolean property autosave untitled new autosave j edit set boolean property suppress not saved confirm untitled suppress not saved confirm untitled is selected j edit set boolean property use md for dirty calculation use md for dirty calculation is selected if new autosave j edit get integer property autosave old autosave  buffer buffers j edit get buffers for  buffer buffer buffers if buffer is untitled buffer remove autosave file 
public void action performed  action event e  string choosen folder gui utilities show vfs file dialog null backup directory get text vfs browser choose directory dialog false if choosen folder null backup directory set text choosen folder 
 override public void visit  edit pane edit pane edit pane save caret info 
 screen line manager j edit buffer buffer this buffer buffer if buffer is loading reset 
boolean is screen line count valid int line return screen lines line screen lines valid mask 
 returns how many screen lines contains the given physical line  it can be greater than when using soft wrap param line the physical line return the screen line count int get screen line count int line return screen lines line screen lines shift 
 sets the number of screen lines that the specified physical line is split into param line the line number param count the line count if no wrap void set screen line count int line int count if count  short max value limitations count  short max value if  debug screen lines debug  log log  log debug this new  exception set screen line count line count screen lines line short count screen lines shift screen lines valid mask 
void invalidate screen line counts int line count buffer get line count for int i i line count i screen lines i screen lines valid mask 
void reset screen lines new short buffer get line count 
public void content inserted int start line int num lines int end line start line num lines screen lines start line screen lines valid mask int line count buffer get line count if num lines if screen lines length line count short screen lines n new short line count  system arraycopy screen lines screen lines n screen lines length screen lines screen lines n  system arraycopy screen lines start line screen lines end line line count end line for int i i num lines i screen lines start line i 
public void content removed int start line int num lines int end line start line num lines screen lines start line screen lines valid mask if num lines end line screen lines length  system arraycopy screen lines end line screen lines start line screen lines length end line 
public void add layout component  string name  component comp if name equals center center comp else if name equals right right comp else if name equals left left comp else if name equals bottom bottom comp else if name equals top top comp 
public void remove layout component  component comp if center comp center null else if right comp right null else if left comp left null else if bottom comp bottom null else if top comp top null 
public  dimension preferred layout size  container parent  dimension dim new  dimension  insets insets get insets parent dim width insets left insets right dim height insets top insets bottom  dimension left pref left get preferred size dim width left pref width  dimension center pref center get preferred size dim width center pref width dim height center pref height  dimension right pref right get preferred size dim width right pref width  dimension bottom pref bottom get preferred size dim height bottom pref height if top null  dimension top pref top get preferred size dim height top pref height return dim 
public  dimension minimum layout size  container parent  dimension dim new  dimension  insets insets get insets parent dim width insets left insets right dim height insets top insets bottom  dimension left pref left get minimum size dim width left pref width  dimension center pref center get minimum size dim width center pref width dim height center pref height  dimension right pref right get minimum size dim width right pref width  dimension bottom pref bottom get minimum size dim height bottom pref height if top null  dimension top pref top get minimum size dim height top pref height return dim 
public void layout container  container parent  dimension size parent get size  insets insets get insets parent int itop insets top int ileft insets left int ibottom insets bottom int iright insets right int right width right get preferred size width int left width left get preferred size width int top height if top null top height top get preferred size height else top height int bottom height bottom get preferred size height int center width  math max size width left width right width ileft iright int center height  math max size height top height bottom height itop ibottom left set bounds ileft itop top height left width center height center set bounds ileft left width itop top height center width center height right set bounds ileft left width center width itop top height right width center height bottom set bounds ileft itop top height center height  math max size width bottom get height ileft iright bottom height if top null top set bounds ileft itop left width center width right width top height 
private  insets get insets  component parent  border border j component parent get border if border null return new  insets else return border get border insets parent 
 scroll line count  display manager display manager  text area text area super display manager text area 
 override public void changed 
 override public void reset if  debug scroll debug  log log  log debug this reset physical line display manager get first visible line int scroll line while physical line scroll line display manager get screen line count physical line physical line display manager get next visible line physical line this scroll line scroll line physical line display manager get buffer get line count 
 sets the current search string param search  the new search string public static void set search string  string search if search equals  search and replace search return  search and replace search search matcher null  edit bus send new  search settings changed null 
 returns the current search string public static  string get search string return search 
 sets the current replacement string param replace  the new replacement string public static void set replace string  string replace if replace equals  search and replace replace return  search and replace replace replace  edit bus send new  search settings changed null 
 returns the current replacement string public static  string get replace string return replace 
 sets the ignore case flag param ignore case  true if searches should be case insensitive false otherwise public static void set ignore case boolean ignore case if ignore case  search and replace ignore case return  search and replace ignore case ignore case matcher null  edit bus send new  search settings changed null 
 returns the state of the ignore case flag return  true if searches should be case insensitive false otherwise public static boolean get ignore case return ignore case 
 sets the state of the regular expression flag param regexp  true if regular expression searches should be performed public static void set regexp boolean regexp if regexp  search and replace regexp return  search and replace regexp regexp if regexp reverse reverse false matcher null  edit bus send new  search settings changed null 
 returns the state of the regular expression flag return  true if regular expression searches should be performed public static boolean get regexp return regexp 
 determines whether a reverse search will conducted from the current position to the beginning of a buffer  note that reverse search and regular expression search is mutually exclusive enabling one will disable the other param reverse  true if searches should go backwards false otherwise public static void set reverse search boolean reverse if reverse  search and replace reverse return  search and replace reverse reverse  edit bus send new  search settings changed null 
 returns the state of the reverse search flag return  true if searches should go backwards false otherwise public static boolean get reverse search return reverse 
 sets the state of the  bean shell replace flag param beanshell  true if the replace string is a  bean shell expression since j edit pre public static void set bean shell replace boolean beanshell if beanshell  search and replace beanshell return  search and replace beanshell beanshell  edit bus send new  search settings changed null 
 returns the state of the  bean shell replace flag return  true if the replace string is a  bean shell expression since j edit pre public static boolean get bean shell replace return beanshell 
 sets the state of the auto wrap around flag param wrap  if true the continue search from start dialog will not be displayed since j edit pre public static void set auto wrap around boolean wrap if wrap  search and replace wrap return  search and replace wrap wrap  edit bus send new  search settings changed null 
 returns the state of the auto wrap around flag since j edit pre public static boolean get auto wrap around return wrap 
 sets a custom search string matcher  note that calling link set search string  string link set ignore case boolean or link set regexp boolean will reset the matcher to the default public static void set search matcher  search matcher matcher  search and replace matcher matcher  edit bus send new  search settings changed null 
 returns the current search string matcher return a  search matcher or null if there is no search or if the matcher can match empty  string exception  illegal argument exception if regular expression search is enabled the search string or replacement string is invalid since j edit pre public static  search matcher get search matcher throws  exception if matcher null return matcher if search null equals search return null if regexp  pattern re  pattern compile search  pattern search matcher get flag ignore case matcher new  pattern search matcher re ignore case else matcher new  boyer moore search matcher search ignore case return matcher 
 sets the current search file set param fileset  the file set to perform searches in see  all buffer set see  current buffer set see  directory list set public static void set search file set  search file set fileset  search and replace fileset fileset  edit bus send new  search settings changed null 
 returns the current search file set public static  search file set get search file set return fileset 
 returns if the replacement string will assume the same case as each specific occurrence of the search string since j edit pre public static boolean get smart case replace return replace null  text utilities get string case replace  text utilities lower case 
 performs a  hyper search param view  the view since j edit pre public static boolean hyper search  view view return hyper search view false 
 performs a  hyper search param view  the view param selection  if true will only search in the current selection  note that the file set must be the current buffer file set for this to work since j edit pre public static boolean hyper search  view view boolean selection component that will parent any dialog boxes  component comp  search dialog get search dialog view if comp null comp view record view hyper search view selection false selection view get dockable window manager add dockable window  hyper search results name  hyper search results results  hyper search results view get dockable window manager get dockable  hyper search results name results search started try  search matcher matcher get search matcher if matcher null view get toolkit beep results search failed return false  selection s if selection s view get text area get selection if s null results search failed return false else s null vfs manager run in work thread new  hyper search request view matcher results s return true catch  exception e results search failed handle error comp e return false 
 finds the next occurrence of the search string param view  the view return  true if the operation was successful false otherwise public static boolean find  view view component that will parent any dialog boxes  component comp  search dialog get search dialog view if comp null comp is showing comp view  string path fileset get next file view null if path null gui utilities error comp empty fileset null return false boolean  reverse reverse fileset instanceof  current buffer set try view show wait cursor  search matcher matcher get search matcher if matcher null view get toolkit beep return false record view find view false true boolean repeat false loop for while path null  buffer buffer j edit open temporary view null path false this is stupid and misleading but path is not used anywhere except the above line and if this is done after the continue then we will either hang or be forced to duplicate it inside the buffer null or add a finally clause you decide which one s worse path fileset get next file view path if buffer null continue loop  wait for the buffer to load if buffer is loaded vfs manager wait for requests int start if view get buffer buffer repeat j edit text area text area view get text area  selection s text area get selection at offset text area get caret position if s null start text area get caret position else if  reverse start s get start else start s get end else if  reverse start buffer get length else start if find view buffer start repeat  reverse return true if repeat if  bean shell is script running view get status set message and clear j edit get property view status search not found view get toolkit beep return false boolean restart if auto wrap is on always restart search if auto wrap is off and we re called from a macro stop search  if we re called interactively ask the user what to do if wrap if  bean shell is script running view get status set message and clear j edit get property view status auto wrap beep if beep property set if j edit get boolean property search beep on search auto wrap view get toolkit beep restart true else if  bean shell is script running restart false else  integer args  integer value of  reverse int result gui utilities confirm comp keepsearching args j option pane yes no option j option pane question message restart result j option pane yes option if restart start search from beginning path fileset get first file view repeat true else break loop catch  exception e handle error comp e finally view hide wait cursor return false 
 finds the next instance of the search string in the specified buffer param view  the view param buffer  the buffer param start  location where to start the search public static boolean find  view view  buffer buffer int start throws  exception return find view buffer start false false 
 finds the next instance of the search string in the specified buffer param view  the view param buffer  the buffer param start  location where to start the search param first time  see link  search matcher next match  char sequence boolean boolean boolean boolean since j edit pre public static boolean find  view view  buffer buffer int start boolean first time boolean reverse throws  exception  edit bus send new  position changing view get edit pane  search matcher matcher get search matcher if matcher null view get toolkit beep return false  char sequence text boolean start of buffer boolean end of buffer if reverse text new  reverse char sequence buffer get segment start start of buffer true end of buffer start buffer get length else text buffer get segment start buffer get length start start of buffer start end of buffer true  search matcher  match match matcher next match text start of buffer end of buffer first time reverse if match null j edit commit temporary buffer view set buffer buffer true j edit text area text area view get text area if reverse text area set selection new  selection  range start match end start match start make sure end of match is visible text area scroll to start match start false text area move caret position start match end else text area set selection new  selection  range start match start start match end text area move caret position start match end make sure start of match is visible text area scroll to start match start false return true else return false 
 replaces the current selection with the replacement string param view  the view return  true if the operation was successful false otherwise public static boolean replace  view view component that will parent any dialog boxes  component comp  search dialog get search dialog view if comp null comp view j edit text area text area view get text area  buffer buffer view get buffer if buffer is editable return false boolean smart case replace get smart case replace  selection selection text area get selection if selection length view get toolkit beep return false record view replace view true false a little hack for reverse replace and find int caret text area get caret position  selection s text area get selection at offset caret if s null caret s get start try buffer begin compound edit  search matcher matcher get search matcher if matcher null return false init replace int ret val for int i i selection length i s selection i ret val replace in selection view text area buffer matcher smart case replace s boolean  reverse regexp reverse fileset instanceof  current buffer set if  reverse so that  replace and  find continues from the right location text area move caret position caret else s text area get selection at offset text area get caret position if s null text area move caret position s get end if  bean shell is script running  object args  integer value of ret val  integer value of view get status set message and clear j edit get property view status replace all args if ret val view get toolkit beep return false return true catch  exception e handle error comp e finally buffer end compound edit return false 
 replaces text in the specified range with the replacement string param view  the view param buffer  the buffer param start  the start offset param end  the end offset return  true if the operation was successful false otherwise public static boolean replace  view view  buffer buffer int start int end if buffer is editable return false component that will parent any dialog boxes  component comp  search dialog get search dialog view if comp null comp view boolean smart case replace get smart case replace try buffer begin compound edit  search matcher matcher get search matcher if matcher null return false init replace int ret val ret val  replace view buffer matcher start end smart case replace if ret val return true catch  exception e handle error comp e finally buffer end compound edit return false 
 replaces all occurrences of the search string with the replacement string param view  the view return the number of modified files public static boolean replace all  view view return replace all view false 
 replaces all occurrences of the search string with the replacement string param view  the view param dont open changed files  whether to open changed files or to autosave them quietly return the number of modified files public static boolean replace all  view view boolean dont open changed files component that will parent any dialog boxes  component comp  search dialog get search dialog view if comp null comp view if fileset get file count view gui utilities error comp empty fileset null return false record view replace all view true true view show wait cursor boolean smart case replace replace null  text utilities get string case replace  text utilities lower case int file count int occur count try  search matcher matcher get search matcher if matcher null return false init replace  string path fileset get first file view loop while path null  buffer buffer j edit open temporary view null path false this is stupid and misleading but path is not used anywhere except the above line and if this is done after the continue then we will either hang or be forced to duplicate it inside the buffer null or add a finally clause you decide which one s worse path fileset get next file view path if buffer null continue loop  wait for buffer to finish loading if buffer is performing io vfs manager wait for requests if buffer is editable continue loop  leave buffer in a consistent state if an error occurs int ret val try buffer begin compound edit ret val  replace view buffer matcher buffer get length smart case replace finally buffer end compound edit if ret val file count occur count ret val if dont open changed files buffer save null null else j edit commit temporary buffer j edit get buffer set manager add buffer view buffer catch  exception e handle error comp e finally view hide wait cursor  don t do this when playing a macro cos it s annoying if  bean shell is script running  object args  integer value of occur count  integer value of file count view get status set message and clear j edit get property view status replace all args if occur count view get toolkit beep return file count 
 escapes characters with special meaning in a regexp param str the string to escape param multiline  should n be escaped return the string with escaped characters since j edit pre public static  string escape regexp  string str boolean multiline return  standard utilities chars to escapes str r t multiline n 
 loads search and replace state from the properties public static void load search j edit get property search find value replace j edit get property search replace value ignore case j edit get boolean property search ignore case toggle regexp j edit get boolean property search regexp toggle beanshell j edit get boolean property search beanshell toggle wrap j edit get boolean property search wrap toggle fileset new  current buffer set  tags plugin likes to call this method at times other than startup so we need to fire a  search settings changed to notify the search bar and so on matcher null  edit bus send new  search settings changed null 
 saves search and replace state to the properties public static void save j edit set property search find value search j edit set property search replace value replace j edit set boolean property search ignore case toggle ignore case j edit set boolean property search regexp toggle regexp j edit set boolean property search beanshell toggle beanshell j edit set boolean property search wrap toggle wrap 
static void handle error  component comp  exception e  log log  log error  search and replace class e if comp instanceof  dialog new  text area dialog  dialog comp beanshell searcherror bsh searcherror e else new  text area dialog  frame comp beanshell searcherror bsh searcherror e 
 set up  bean shell replace if necessary private static void init replace throws  exception if beanshell replace length replace method  bean shell cache block replace return replace true else replace method null 
private static void record  view view  string action boolean replace action boolean record file set  macros  recorder recorder view get macro recorder if recorder null recorder record  search and replace set search string  standard utilities chars to escapes search if replace action recorder record  search and replace set replace string  standard utilities chars to escapes replace recorder record  search and replace set bean shell replace beanshell else only record this if doing a find next recorder record  search and replace set auto wrap around wrap recorder record  search and replace set reverse search reverse recorder record  search and replace set ignore case ignore case recorder record  search and replace set regexp regexp if record file set recorder record  search and replace set search file set fileset get code recorder record  search and replace action 
private static int replace in selection  view view  text area text area  buffer buffer  search matcher matcher boolean smart case replace  selection s throws  exception if an occurence occurs at the beginning of the selection the selection start will get moved this sucks so we hack to avoid it int start s get start int return value if s instanceof  selection  range return value  replace view buffer matcher s get start s get end smart case replace text area remove from selection s text area add to selection new  selection  range start s get end else if s instanceof  selection  rect  selection  rect rect  selection  rect s int start col rect get start column buffer int end col rect get end column buffer return value for int j s get start line j s get end line j return value  replace view buffer matcher get column on other line buffer j start col get column on other line buffer j end col smart case replace text area add to selection new  selection  rect start s get end else throw new  runtime exception  unsupported s return return value 
 replaces all occurrences of the search string with the replacement string param view  the view param buffer  the buffer param start  the start offset param end  the end offset param matcher  the search matcher to use param smart case replace  see user s guide return  the number of occurrences replaced private static int  replace  view view j edit buffer buffer  search matcher matcher int start int end boolean smart case replace throws  exception int occur count boolean end of line buffer get line end offset buffer get line of offset end end int offset start loop for int counter counter boolean start of line buffer get line start offset buffer get line of offset offset offset  char sequence text buffer get segment offset end offset  search matcher  match occur matcher next match text start of line end of line counter false if occur null break loop  string found text sub sequence occur start occur end to string int length replace one view buffer occur offset found smart case replace if length offset occur end else offset occur start length end length found length occur count return occur count 
 replace one occurrence of the search string with the replacement string private static int replace one  view view j edit buffer buffer  search matcher  match occur int offset  string found boolean smart case replace throws  exception  string subst replace one view occur found if smart case replace ignore case int str case  text utilities get string case found if str case  text utilities lower case subst subst to lower case else if str case  text utilities upper case subst subst to upper case else if str case  text utilities title case subst  text utilities to title case subst if subst null int start offset occur start int end offset occur end if end start buffer remove start end start buffer insert start subst return subst length else return 
private static  string replace one  view view  search matcher  match occur  string found throws  exception if regexp if replace method null return regexp bean shell replace view occur else return regexp replace occur found else if replace method null return literal bean shell replace view found else return replace 
private static  string regexp bean shell replace  view view  search matcher  match occur throws  exception for int i i occur substitutions length i replace ns set variable   i occur substitutions i  object obj  bean shell run cached block replace method view replace ns if obj null return else return obj to string 
private static  string regexp replace  search matcher  match occur  string found throws  exception  string builder buf new  string builder for int i i replace length i char ch replace char at i switch ch case if i replace length last character of the replace string it is not a capturing group buf append ch break ch replace char at i if ch  it was so it is an escaped buf append else if ch meaning the first capturing group the found value buf append found else if  character is digit ch int n ch while i replace length ch replace char at i if  character is digit ch n n ch else  the character is not a digit going back and end loop i break if n occur substitutions length  string subs occur substitutions n if subs null buf append subs break case if i replace length buf append break ch replace char at i switch ch case n buf append n break case t buf append t break default buf append ch break break default buf append ch break return buf to string 
private static  string literal bean shell replace  view view  string found throws  exception replace ns set variable   found  object obj  bean shell run cached block replace method view replace ns if obj null return else return obj to string 
 should be somewhere else private static int get column on other line  buffer buffer int line int col int return value buffer get offset of virtual column line col null if return value return buffer get line end offset line else return buffer get line start offset line return value 
public  search bar final  view view boolean temp this view view set layout new  box layout this  box layout x axis set floatable false add  box create horizontal strut j label label new j label j edit get property view search find add label add  box create horizontal strut add find new  history text field find find set select all on focus true  syntax style style gui utilities parse style j edit get property view style invalid  dialog error background style get background color error foreground style get foreground color default background find get background default foreground find get foreground  dimension max find get preferred size max width  integer max value find set maximum size max  action handler action handler new  action handler find add key listener new  key handler find add action listener action handler find get document add document listener new  document handler  insets margin new  insets add separator new  dimension add ignore case new j check box j edit get property search case ignore case add action listener action handler ignore case set margin margin ignore case set opaque false ignore case set request focus enabled false add  box create horizontal strut add regexp new j check box j edit get property search regexp regexp add action listener action handler regexp set margin margin regexp set opaque false regexp set request focus enabled false add  box create horizontal strut add hyper search new j check box j edit get property search hypersearch hyper search add action listener action handler hyper search set margin margin hyper search set opaque false hyper search set request focus enabled false update  create the timer used by incremental search timer new  timer new  action listener public void action performed  action event evt if incremental search search start search reverse if incremental search search reverse view get buffer get length search reverse not found at all view get status set message and clear j edit get property view status search not found if temp is true hide search bar after user is done with it this is removable temp set close button visibility 
public  history text field get field return find 
public void set hyper search boolean hyper search j edit set boolean property view search hypersearch toggle hyper search this hyper search set selected hyper search 
public void update ignore case set selected  search and replace get ignore case regexp set selected  search and replace get regexp hyper search set selected j edit get boolean property view search hypersearch toggle 
public void properties changed  option may have been changed is removable j edit get boolean property view show searchbar  log log  log debug this in  search bar properties changed is removable is removable set close button visibility 
private void find boolean reverse timer stop  string text find get text  if nothing entered show search and replace dialog box if text length j edit set boolean property search hypersearch toggle hyper search is selected  search dialog show search dialog view null  search dialog current buffer  hyper search else if hyper search is selected if is removable view remove tool bar  search bar this else find set text null  search and replace set search string text  search and replace set search file set new  current buffer set  search and replace hyper search view  incremental search else on enter start search from end of current match to find next one int start j edit text area text area view get text area  selection s text area get selection at offset text area get caret position if s null start text area get caret position else if reverse start s get start else start s get end if incremental search start reverse not found start from beginning if incremental search reverse view get buffer get length reverse not found at all view get status set message and clear j edit get property view status search not found else inform user search restarted view get status set message and clear j edit get property view status auto wrap beep if beep property set if j edit get boolean property search beep on search auto wrap get toolkit beep 
private boolean incremental search int start boolean reverse  for example if the current fileset is a directory c g will find the next match within that fileset  this can be annoying if you have just done an incremental search and want the next occurrence in the current buffer  search and replace set search file set new  current buffer set  search and replace set search string find get text  search and replace set reverse search reverse boolean ret false try if  search and replace find view view get buffer start false reverse ret true catch  exception e  log log  log debug this e invalid regexp ignore return true to avoid annoying beeping while typing a re ret true if ret if was error find set foreground default foreground find set background default background was error false else if was error find set foreground error foreground find set background error background was error true return ret 
private void timer incremental search int start boolean reverse search start start search reverse reverse timer stop timer set repeats false timer set initial delay timer start 
private void set close button visibility if is removable if close null close new  rollover button gui utilities load icon closebox gif close add action listener new  action handler close set tool tip text j edit get property view search close tooltip add close else if close null remove close 
public void action performed  action event evt  object source evt get source if source find find false else if source hyper search j edit set boolean property view search hypersearch toggle hyper search is selected update else if source ignore case  search and replace set ignore case ignore case is selected else if source regexp  search and replace set regexp regexp is selected else if source close view remove tool bar  search bar this view get edit pane focus on text area 
public void insert update  document event evt on insert start search from beginning of current match  this will continue to highlight the current match until another match is found if hyper search is selected int start j edit text area text area view get text area  selection s text area get selection at offset text area get caret position if s null start text area get caret position else start s get start timer incremental search start false 
public void remove update  document event evt on backspace restart from beginning if hyper search is selected  string text find get text if text length don t beep if not found subsequent beeps are very annoying when backspacing an invalid search string if regexp is selected reverse regexp search not supported yet so simulate with restart timer incremental search false else int start j edit text area text area view get text area  selection s text area get selection at offset text area get caret position if s null start text area get caret position else start s get start timer incremental search start true 
public void changed update  document event evt 
public void key pressed  key event evt switch evt get key code case  key event vk escape if is removable view remove tool bar  search bar this evt consume view get edit pane focus on text area break case  key event vk enter if evt is shift down evt consume find true break 
public void focus lost  focus event e get field add current to history 
public static  search dialog get search dialog  view view if  debug disable search dialog pool return new  search dialog view else  search dialog search dialog view hash get view if search dialog null search dialog new  search dialog view view hash put view search dialog return search dialog 
 displays a search and replace dialog box reusing an existing one if necessary param view  the view param search string  the search string param search in  one of current buffer all buffers or directory since j edit pre public static void show search dialog  view view  string search string int search in final  search dialog dialog get search dialog view dialog set search string search string search in ugly workaround if  operating system is unix  operating system is mac os dialog set visible false i m not sure if calling request focus is strictly necessary focus looks fine without this on  linux at least but it doesn t hurt to leave it here  swing utilities invoke later new  runnable public void run dialog to front dialog request focus  ensure that the dialog gets the focus  just bringing it to front just not necessarily give it the focus dialog find request focus  given that the dialog has the focus set the focus to the find field dialog set visible true 
 sets the search string param search string  the search string param search in  one of link current buffer link all buffers or link directory since j edit pre public void set search string  string search string int search in find set text null replace set text null if search string null search current buffer set selected true  history model model find get model if model is empty find set text model get item find select all else if search string index of n if  search and replace get regexp find set text  search and replace escape regexp search string true else find set text search string find select all search current buffer set selected true else if search in current buffer search selection set selected true hyper search set selected true if search in current buffer if search selection is selected might be already selected see above search current buffer set selected true this property is only loaded and saved if the current buffer file set is selected otherwise it defaults to on hyper search set selected j edit get boolean property search hypersearch toggle else if search in all buffers search all buffers set selected true hyper search set selected true else if search in directory  search file set fileset  search and replace get search file set if fileset instanceof  directory list set filter set text  directory list set fileset get file filter directory set text  directory list set fileset get directory search sub directories set selected  directory list set fileset is recursive hyper search set selected true search directory set selected true update enabled 
public void ok try set cursor  cursor get predefined cursor  cursor wait cursor if save false return if search selection is selected view get text area get selection count gui utilities error view search no selection null return if hyper search is selected search selection is selected if  search and replace hyper search view search selection is selected close or keep dialog else if  search and replace find view close or keep dialog else to front request focus find request focus finally set cursor  cursor get predefined cursor  cursor default cursor 
public void cancel save true gui utilities save geometry this search set visible false 
public void handle message eb message msg if msg instanceof  search settings changed if saving load 
 override public void dispose  edit bus remove from bus this view hash remove view super dispose 
 creates a new search and replace dialog box param view  the view private  search dialog  view view super view j edit get property search title false this view view j panel content new j panel new  border layout content set border new  empty border set content pane content j panel center panel new j panel new  border layout center panel add  border layout center create field panel center panel add  border layout south create search settings panel content add  border layout center center panel content add  border layout south create multi file panel content add  border layout east create buttons panel pack j edit unset property search width j edit unset property search d width j edit unset property search height j edit unset property search d height gui utilities load geometry this search load  edit bus add to bus this 
private void create find label and field j panel field panel  grid bag constraints cons j label label new j label j edit get property search find label set displayed mnemonic j edit get property search find mnemonic char at find new  history text area find find set name find find set columns find set tool tip text j edit get property search find tooltip label set tool tip text j edit get property search find tooltip label set label for find label set border new  empty border cons gridx cons weightx cons weighty field panel add label cons cons gridy cons weightx cons weighty field panel add new j scroll pane find cons cons gridy 
private void create replace label and field j panel field panel  grid bag constraints cons j label label new j label j edit get property search replace label set displayed mnemonic j edit get property search replace mnemonic char at label set border new  empty border cons gridx cons weightx cons weighty field panel add label cons cons gridy  button group grp new  button group  replace action handler replace action handler new  replace action handler we use a custom j radio button subclass that returns false for is focus traversable so that the user can tab from the search field to the replace field with one keystroke string replace new  my j radio button j edit get property search string replace btn string replace add action listener replace action handler grp add string replace cons gridwidth field panel add string replace cons cons gridx cons insets new  insets bean shell replace new  my j radio button j edit get property search beanshell replace btn bean shell replace add action listener replace action handler grp add bean shell replace field panel add bean shell replace cons cons gridx cons gridwidth cons insets new  insets replace new  history text area replace replace set name replace replace set tool tip text j edit get property search find tooltip label set label for replace cons gridx cons gridy cons weightx cons weighty field panel add new j scroll pane replace cons cons gridy 
private j panel create field panel j panel field panel new j panel new  grid bag layout field panel set border new  empty border  grid bag constraints cons new  grid bag constraints cons fill  grid bag constraints both cons gridy cons gridwidth create find label and field field panel cons create replace label and field field panel cons return field panel 
private j panel create search settings panel j panel search settings new j panel new  variable grid layout  variable grid layout fixed num columns search settings set border new  empty border  settings action handler action handler new  settings action handler  button group fileset new  button group  button group direction new  button group search settings add new j label j edit get property search fileset search settings add new j label j edit get property search settings search settings add new j label j edit get property search direction search selection new j radio button j edit get property search selection search selection set mnemonic j edit get property search selection mnemonic char at fileset add search selection search settings add search selection search selection add action listener action handler keep dialog new j check box j edit get property search keep keep dialog set mnemonic j edit get property search keep mnemonic char at search settings add keep dialog search back new j radio button j edit get property search back search back set mnemonic j edit get property search back mnemonic char at direction add search back search settings add search back search back add action listener action handler search current buffer new j radio button j edit get property search current search current buffer set mnemonic j edit get property search current mnemonic char at fileset add search current buffer search settings add search current buffer search current buffer add action listener action handler ignore case new j check box j edit get property search case ignore case set mnemonic j edit get property search case mnemonic char at search settings add ignore case ignore case add action listener action handler search forward new j radio button j edit get property search forward search forward set mnemonic j edit get property search forward mnemonic char at direction add search forward search settings add search forward search forward add action listener action handler search all buffers new j radio button j edit get property search all search all buffers set mnemonic j edit get property search all mnemonic char at fileset add search all buffers search settings add search all buffers search all buffers add action listener action handler regexp new j check box j edit get property search regexp regexp set mnemonic j edit get property search regexp mnemonic char at search settings add regexp regexp add action listener action handler wrap new j check box j edit get property search wrap wrap set mnemonic j edit get property search wrap mnemonic char at search settings add wrap wrap add action listener action handler search directory new j radio button j edit get property search directory search directory set mnemonic j edit get property search directory mnemonic char at fileset add search directory search settings add search directory search directory add action listener action handler hyper search new j check box j edit get property search hypersearch hyper search set mnemonic j edit get property search hypersearch mnemonic char at search settings add hyper search hyper search add action listener action handler return search settings 
private j panel create multi file panel j panel multifile new j panel  grid bag layout layout new  grid bag layout multifile set layout layout  grid bag constraints cons new  grid bag constraints cons gridy cons gridwidth cons gridheight cons anchor  grid bag constraints west cons fill  grid bag constraints horizontal  multi file action handler action listener new  multi file action handler filter new  history text field search filter filter set tool tip text j edit get property glob tooltip filter add action listener action listener cons insets new  insets j label label new j label j edit get property search filter field  swing constants right label set border new  empty border label set displayed mnemonic j edit get property search filter field mnemonic char at label set label for filter cons weightx layout set constraints label cons multifile add label cons gridwidth cons insets new  insets cons weightx layout set constraints filter cons multifile add filter cons gridwidth cons weightx cons insets new  insets synchronize new j button j edit get property search synchronize synchronize set tool tip text j edit get property search synchronize tooltip synchronize set mnemonic j edit get property search synchronize mnemonic char at synchronize add action listener action listener layout set constraints synchronize cons multifile add synchronize cons gridy directory new  history text field search directory directory set columns directory add action listener action listener label new j label j edit get property search directory field  swing constants right label set border new  empty border label set displayed mnemonic j edit get property search directory field mnemonic char at label set label for directory cons insets new  insets cons weightx layout set constraints label cons multifile add label cons insets new  insets cons weightx cons gridwidth layout set constraints directory cons multifile add directory choose new j button j edit get property search choose choose set mnemonic j edit get property search choose mnemonic char at cons insets new  insets cons weightx cons gridwidth layout set constraints choose cons multifile add choose choose add action listener action listener cons insets new  insets cons gridy cons gridwidth j panel dir check box panel new j panel search sub directories new j check box j edit get property search subdirs  string mnemonic j edit get property search subdirs mnemonic search sub directories set mnemonic mnemonic char at search sub directories set selected j edit get boolean property search subdirs toggle skip hidden new j check box j edit get property search skip hidden skip hidden set selected j edit get boolean property search skip hidden toggle true skip binary files new j check box j edit get property search skip binary skip binary files set selected j edit get boolean property search skip binary toggle true dir check box panel add search sub directories dir check box panel add skip hidden dir check box panel add skip binary files cons insets new  insets cons gridy cons gridwidth layout set constraints dir check box panel cons multifile add dir check box panel return multifile 
private  box create buttons panel  box box new  box  box layout y axis  button action handler action handler new  button action handler box add  box create vertical strut j panel grid new j panel new  grid layout find btn new j button j edit get property search find btn find btn set mnemonic j edit get property search find btn mnemonic char at get root pane set default button find btn grid add find btn find btn add action listener action handler replace btn new j button j edit get property search replace btn replace btn set mnemonic j edit get property search replace btn mnemonic char at grid add replace btn replace btn add action listener action handler replace and find btn new j button j edit get property search replace and find btn replace and find btn set mnemonic j edit get property search replace and find btn mnemonic char at grid add replace and find btn replace and find btn add action listener action handler replace all btn new j button j edit get property search replace all btn replace all btn set mnemonic j edit get property search replace all btn mnemonic char at grid add replace all btn replace all btn add action listener action handler close btn new j button j edit get property common close grid add close btn close btn add action listener action handler grid set maximum size grid get preferred size box add grid box add  box create glue return box 
private void update enabled wrap set enabled hyper search is selected search selection is selected boolean reverse enabled hyper search is selected search current buffer is selected search back set enabled reverse enabled search forward set enabled reverse enabled if reverse enabled search forward set selected true filter set enabled search all buffers is selected search directory is selected boolean search dirs search directory is selected directory set enabled search dirs choose set enabled search dirs search sub directories set enabled search dirs skip hidden set enabled search dirs skip binary files set enabled search dirs synchronize set enabled search all buffers is selected search directory is selected find btn set enabled search selection is selected hyper search is selected replace and find btn set enabled hyper search is selected search selection is selected 
param cancel  if true we don t bother the user with warning messages private boolean save boolean cancel try prevents us from handling  search settings changed as a result of below saving true  search and replace set ignore case ignore case is selected  search and replace set regexp regexp is selected  search and replace set reverse search search back is selected  search and replace set auto wrap around wrap is selected j edit set boolean property search subdirs toggle search sub directories is selected j edit set boolean property search skip hidden toggle skip hidden is selected j edit set boolean property search skip binary toggle skip binary files is selected  string filter this filter get text this filter add current to history if filter length filter  search file set fileset  search and replace get search file set boolean recurse search sub directories is selected if search selection is selected fileset new  current buffer set else if search current buffer is selected fileset new  current buffer set j edit set boolean property search hypersearch toggle hyper search is selected else if search all buffers is selected fileset new  all buffer set filter else if search directory is selected  string directory this directory get text this directory add current to history directory  misc utilities construct path view get buffer get directory directory if vfs manager get vfs for path directory get capabilities vfs low latency cap if cancel return false int ret val gui utilities confirm this remote dir search null j option pane yes no option j option pane warning message if ret val j option pane yes option return false if fileset instanceof  directory list set  directory list set dset  directory list set fileset dset set directory directory dset set file filter filter dset set recursive recurse  edit bus send new  search settings changed null else fileset new  directory list set directory filter recurse else can t happen fileset null j edit set boolean property search subdirs toggle recurse j edit set boolean property search keep dialog toggle keep dialog is selected  search and replace set search file set fileset replace add current to history  search and replace set replace string replace get text if find get text length if cancel get toolkit beep return false find add current to history  search and replace set search string find get text return true finally saving false 
private void close or keep dialog if keep dialog is selected  windows bug workaround in case a yes no confirm was shown but if  hyper search results window is floating the workaround causes problems if hyper search is selected to front request focus find request focus else gui utilities save geometry this search set visible false 
private void load ignore case set selected  search and replace get ignore case regexp set selected  search and replace get regexp wrap set selected  search and replace get auto wrap around if  search and replace get reverse search search back set selected true else search forward set selected true if  search and replace get bean shell replace replace set model replace script bean shell replace set selected true else replace set model replace string replace set selected true  search file set fileset  search and replace get search file set  history model model filter get model if model get size filter set text model get item else filter set text  misc utilities get file extension view get buffer get name model directory get model if model get size directory set text model get item else directory set text view get buffer get directory search sub directories set selected j edit get boolean property search subdirs toggle if fileset instanceof  directory list set filter set text  directory list set fileset get file filter directory set text  directory list set fileset get directory search sub directories set selected  directory list set fileset is recursive else if fileset instanceof  all buffer set filter set text  all buffer set fileset get file filter directory add current to history keep dialog set selected j edit get boolean property search keep dialog toggle 
 my j radio button  string label super label 
 override public boolean is focusable return false 
public void action performed  action event evt replace set model bean shell replace is selected replace script replace  search and replace set bean shell replace bean shell replace is selected 
public void action performed  action event evt  object source evt get source if source search current buffer hyper search set selected false else if source search selection source search all buffers source search directory hyper search set selected true save true update enabled 
public void action performed  action event evt if evt get source choose  string dirs gui utilities show vfs file dialog  search dialog this view directory get text vfs browser choose directory dialog false if dirs null directory set text dirs else if evt get source synchronize synchronize multi file settings else source is directory or filter field just as if  enter was pressed in another text field ok 
private void synchronize multi file settings directory set text view get buffer get directory  search file set fileset  search and replace get search file set if fileset instanceof  all buffer set filter set text  all buffer set fileset get file filter else filter set text  misc utilities get file extension view get buffer get name 
public void action performed  action event evt  object source evt get source if source close btn cancel else if source find btn source find source replace ok else if source replace and find btn save false if  search and replace replace view ok else get toolkit beep else if source replace all btn if search selection is selected view get text area get selection count gui utilities error view search no selection null return set cursor  cursor get predefined cursor  cursor wait cursor if save false set cursor  cursor get predefined cursor  cursor default cursor get toolkit beep return if search selection is selected if  search and replace replace view close or keep dialog else get toolkit beep else if  search and replace replace all view close or keep dialog else get toolkit beep set cursor  cursor get predefined cursor  cursor default cursor 
public  search matcher return value new  match 
 creates a new search and replace settings changed message param source  the message source public  search settings changed eb component source super source 
public  segment buffer int capacity ensure capacity capacity 
public void append char ch ensure capacity count array offset count ch count 
public void append char text int off int len ensure capacity count len  system arraycopy text off array count len count len 
private void ensure capacity int capacity if array null array new char capacity else if capacity array length char array n new char capacity  system arraycopy array array n count array array n 
public  segment char sequence  segment seg this seg false 
deprecated  use  reverse char sequence to get reverse view of this class or any other  char sequence  this class doesn t support sub sequence and to string for reversed instance  deprecated public  segment char sequence  segment seg boolean reverse this seg seg count this reverse reverse 
public  segment char sequence  segment seg int off int len this offset off this length len this seg seg 
public char char at int index if reverse index length index return seg array seg offset offset index 
public int length return length 
public  char sequence sub sequence int start int end if reverse throw new  illegal state exception reverse sub sequences are not supported return new  segment char sequence seg offset start end start 
public  string to string return new  string seg array offset seg offset length 
 returns the start offset of this selection public int get start return start 
 returns the end offset of this selection public int get end return end 
 returns the starting line number of this selection public int get start line return start line 
 returns the ending line number of this selection public int get end line return end line 
 returns if this selection and the specified selection overlap param s  the other selection since j edit pre public boolean overlaps  selection s if start s start start s end end s start end s end return true else return false 
 override public  string to string return get class get name start start end end start line start line end line end line 
 override public  object clone try return super clone catch  clone not supported exception e throw new  internal error i just drank a whole bottle of cough syrup and i feel funny 
protected  selection 
protected  selection  selection sel this start sel start this end sel end 
protected  selection int start int end this start start this end end 
public  range 
public  range  selection sel super sel 
public  range int start int end super start end 
 override public int get start j edit buffer buffer int line if line start line return start else return buffer get line start offset line 
 override public int get end j edit buffer buffer int line if line end line return end else return buffer get line end offset line 
 override void get text j edit buffer buffer  string builder buf buf append buffer get text start end start 
 replace the selection with the given text param buffer the buffer param text the text return the offset at the end of the inserted text  override int set text j edit buffer buffer  string text buffer remove start end start if text null text length buffer insert start text return start text length else return start 
 override boolean content inserted j edit buffer buffer int start line int start int num lines int length boolean changed false if this start start this start length if num lines this start line buffer get line of offset this start changed true if this end start this end length if num lines this end line buffer get line of offset this end changed true return changed 
 override boolean content removed j edit buffer buffer int start line int start int num lines int length int end start length boolean changed false if this start start this start end this start start changed true else if this start end this start length changed true if this end start this end end this end start changed true else if this end end this end length changed true if changed num lines this start line buffer get line of offset this start this end line buffer get line of offset this end return changed 
public  rect 
public  rect  selection sel super sel 
public  rect int start int end super start end 
public  rect int start line int start int end line int end this start line start line this start start this end line end line this end end 
public  rect j edit buffer buffer int start line int start column int end line int end column this start line start line this end line end line int width new int int start offset buffer get offset of virtual column start line start column width if start offset extra start virt start column width start offset buffer get line end offset start line else start offset buffer get line start offset start line int end offset buffer get offset of virtual column end line end column width if end offset extra end virt end column width end offset buffer get line end offset end line else end offset buffer get line start offset end line 
public int get start column j edit buffer buffer int virt col start buffer get virtual width start line start buffer get line start offset start line extra start virt int virt col end buffer get virtual width end line end buffer get line start offset end line extra end virt return  math min virt col start virt col end 
public int get end column j edit buffer buffer int virt col start buffer get virtual width start line start buffer get line start offset start line extra start virt int virt col end buffer get virtual width end line end buffer get line start offset end line extra end virt return  math max virt col start virt col end 
 override public int get start j edit buffer buffer int line return get column on other line buffer line get start column buffer 
 override public int get end j edit buffer buffer int line return get column on other line buffer line get end column buffer 
 override void get text j edit buffer buffer  string builder buf int start get start column buffer int end get end column buffer for int i start line i end line i int line start buffer get line start offset i int line len buffer get line length i int rect start buffer get offset of virtual column i start null if rect start rect start line len int rect end buffer get offset of virtual column i end null if rect end rect end line len if rect end rect start  system err println i start end rect start rect end buf append buffer get text line start rect start rect end rect start if i end line buf append n 
 replace the selection with the given text param buffer the buffer param text the text return the offset at the end of the inserted text  override int set text j edit buffer buffer  string text int start column get start column buffer int end column get end column buffer int tab size buffer get tab size int max width int total lines  this list will contains  strings and  integer  list  object lines new  array list  object  split the text into lines if text null int last newline int current width start column for int i i text length i char ch text char at i if ch n total lines lines add text substring last newline i last newline i max width  math max max width current width lines add current width current width start column else if ch t current width tab size current width tab size else current width if last newline text length total lines lines add text substring last newline lines add current width max width  math max max width current width  insert the lines into the buffer int end offset int total new int int last line  math max start line total lines end line for int i start line i last line i if i buffer get line count buffer insert buffer get length n int line start buffer get line start offset i int line len buffer get line length i int rect start buffer get offset of virtual column i start column total int start whitespace if rect start start whitespace start column total rect start line len else start whitespace int rect end buffer get offset of virtual column i end column null if rect end rect end line len buffer remove rect start line start rect end rect start if start whitespace buffer insert rect start line start  standard utilities create white space start whitespace int end whitespace if total lines if rect end line len end whitespace else end whitespace max width start column else int index i start line total lines  string str  string lines get index buffer insert rect start line start start whitespace str if rect end line len end whitespace else end whitespace max width  integer lines get index start whitespace str length if end whitespace buffer insert rect start line start start whitespace  standard utilities create white space end whitespace end offset rect start line start start whitespace end whitespace  move the caret down a line if text null text length return end else return end offset 
 override boolean content inserted j edit buffer buffer int start line int start int num lines int length if this end start return false this end length if this start line start line this start length if num lines this start line buffer get line of offset this start this end line buffer get line of offset this end return true int end virtual column buffer get virtual width this end line end buffer get line start offset this end line if this start start int start virtual column buffer get virtual width this start line start buffer get line start offset this start line this start length int new start virtual column buffer get virtual width start line start buffer get line start offset this start line int total virtual width new int int new end buffer get offset of virtual column this end line end virtual column new start virtual column start virtual column total virtual width if new end end buffer get line start offset this end line new end else end buffer get line end offset this end line extra end virt total virtual width end virtual column else if this start start this start length if num lines this start line buffer get line of offset this start if num lines this end line buffer get line of offset this end int new end virtual column buffer get virtual width end line end buffer get line start offset this end line if start line this end line extra end virt extra end virt end virtual column new end virtual column else if start line this start line extra start virt extra start virt end virtual column new end virtual column return true 
 override boolean content removed j edit buffer buffer int start line int start int num lines int length int end start length boolean changed false if this start start this start end this start start changed true else if this start end this start length changed true if this end start this end end this end start changed true else if this end end this end length changed true if changed num lines this start line buffer get line of offset this start this end line buffer get line of offset this end return changed 
private static int get column on other line j edit buffer buffer int line int col int return value buffer get offset of virtual column line col null if return value return buffer get line end offset line else return buffer get line start offset line return value 
public  widget get widget  view view  widget selection length widget new  selection length widget view return selection length widget 
 selection length widget  view view this view view text area view get text area selection length new  selection length selection length set foreground j edit get color property view status foreground selection length set background j edit get color property view status background 
public j component get component return selection length 
public void update 
public void properties changed 
public void handle message eb message message if message instanceof  view update  view update view update  view update message if view update get view view view update get what  view update edit pane changed if text area null text area remove caret listener selection length text area view get text area if selection length visible text area add caret listener selection length 
 override public void add notify super add notify visible true text area add caret listener this 
 override public void remove notify visible false text area remove caret listener this super remove notify 
public void caret update  caret event e  selection selection text area get selection at offset text area get caret position if selection null set text else int selection end selection get end int selection start selection get start int len if selection instanceof  selection  rect int start line selection get start line int end line selection get end line j edit text area text area view get text area int start line offset text area get line start offset start line int end line offset text area get line start offset end line int lines end line start line int columns selection end end line offset selection start start line offset len lines columns else len selection end selection start set text  integer to string len 
 selection manager  text area text area this text area text area selection new  array list  selection 
 returns the number of selections  this can be used to test for the existence of selections int get selection count return selection size 
 returns the current selection since j edit pre public  selection get selection return selection to array new  selection selection size 
 sets the selection  nested and overlapping selections are merged where possible void set selection  selection selection this selection clear add to selection selection 
 adds to the selection  nested and overlapping selections are merged where possible  null elements of the array are ignored param selection  the new selection since j edit pre void add to selection  selection selection if selection null for int i i selection length i  selection s selection i if s null add to selection s 
void add to selection  selection add me if add me start add me end throw new  illegal argument exception add me start add me end else if add me start add me end if add me instanceof  selection  range return else if add me instanceof  selection  rect if  selection  rect add me extra end virt return  iterator  selection iter selection iterator while iter has next try and merge existing selections one by one with the new selection  selection s iter next if s overlaps add me add me start  math min s start add me start add me end  math max s end add me end iter remove add me start line text area get line of offset add me start add me end line text area get line of offset add me end boolean added false for int i i selection size i  selection s selection get i if add me start s start selection add i add me added true break if added selection add add me text area invalidate line range add me start line add me end line 
 sets the selection  nested and overlapping selections are merged where possible void set selection  selection selection this selection clear if selection null add to selection selection 
 returns the selection containing the specific offset or code null code if there is no selection at that offset param offset  the offset since j edit pre  selection get selection at offset int offset if selection null for  selection s selection if offset s start offset s end return s return null 
 deactivates the specified selection param sel  the selection void remove from selection  selection sel selection remove sel 
 resizes the selection at the specified offset or creates a new one if there is no selection at the specified offset  this is a utility method that is mainly useful in the mouse event handler because it handles the case of end being before offset gracefully unlike the rest of the selection api param offset  the offset param end  the new selection end param extra end virt  only for rectangular selections specifies how far it extends into virtual space param rect  make the selection rectangular void resize selection int offset int end int extra end virt boolean rect boolean reversed false if end offset int tmp offset offset end end tmp reversed true  selection new sel if rect  selection  rect rect sel new  selection  rect offset end if reversed rect sel extra start virt extra end virt else rect sel extra end virt extra end virt new sel rect sel else new sel new  selection  range offset end add to selection new sel 
 returns a sorted array of line numbers on which a selection or selections are present p  this method is the most convenient way to iterate through selected lines in a buffer  the line numbers in the array returned by this method can be passed as a parameter to such methods as link org gjt sp jedit  buffer get line text int int get selected lines  set  integer set new  tree set  integer for  selection s selection int end line s end text area get line start offset s end line s end line s end line for int j s start line j end line j set add j int return value new int set size int i for  integer line set return value i line return return value 
void invert selection  selection new selection new  selection selection size int last offset for int i i selection size i  selection s selection get i new selection i new  selection  range last offset s get start last offset s get end new selection selection size new  selection  range last offset text area get buffer length set selection new selection 
 returns the x co ordinates of the selection start and end on the given line  may return null int get selection start and end int screen line int physical line  selection s int start text area get screen line start offset screen line int end text area get screen line end offset screen line if end s start start s end return null int sel start screen line if text area display manager is line visible s start line sel start screen line text area get screen line of offset s start else sel start screen line int sel end screen line if text area display manager is line visible s end line sel end screen line text area get screen line of offset s end else sel end screen line j edit buffer buffer text area get buffer int line start buffer get line start offset physical line int x x if s instanceof  selection  rect start line start end line start  selection  rect rect  selection  rect s int  start rect get start column buffer int  end rect get end column buffer int line len buffer get line length physical line int total new int int rect start buffer get offset of virtual column physical line  start total if rect start x  start total text area char width rect start line len else x int rect end buffer get offset of virtual column physical line  end total if rect end x  end total text area char width rect end line len else x if end rect start start rect end return null x rect start start x text area offset to xy physical line rect start x x rect end end text area get width x text area offset to xy physical line rect end x else if sel start screen line sel end screen line sel start screen line x text area offset to xy physical line s start line start x x text area offset to xy physical line s end line start x else if screen line sel start screen line x text area offset to xy physical line s start line start x x text area get width else if screen line sel end screen line x x text area offset to xy physical line s end line start x else x x text area get width if x x if x x if x x x return new int x x 
 returns if the given point is inside a selection  used by drag and drop code in  mouse handler below boolean inside selection int x int y int offset text area xy to offset x y  selection s text area get selection at offset offset if s null return false int screen line text area get screen line of offset offset if screen line return false int selection start and end get selection start and end screen line text area get line of offset offset s if selection start and end null return false return x selection start and end x selection start and end 
public  select line range  view view super view j edit get property selectlinerange title true this view view j panel content new j panel new  border layout content set border new  empty border set content pane content j label label new j label j edit get property selectlinerange caption label set border new  empty border content add  border layout north label j panel panel create field panel content add  border layout center panel panel new j panel panel set layout new  box layout panel  box layout x axis panel set border new  empty border panel add  box create glue panel add  box create glue ok new j button j edit get property common ok ok add action listener this get root pane set default button ok panel add ok panel add  box create horizontal strut cancel new j button j edit get property common cancel cancel add action listener this panel add cancel panel add  box create glue content add panel  border layout south gui utilities request focus this start field pack set location relative to view set visible true 
public void ok int start line int end line try start line  integer parse int start field get text end line  integer parse int end field get text catch  number format exception nf get toolkit beep return  buffer buffer view get buffer if start line end line buffer get line count start line end line get toolkit beep return j edit text area text area view get text area  selection s new  selection  range buffer get line start offset start line buffer get line end offset end line if text area is multiple selection enabled text area add to selection s else text area set selection s text area move caret position buffer get line end offset end line dispose 
public void cancel dispose 
public void action performed  action event evt  object source evt get source if source ok ok else if source cancel cancel 
private j panel create field panel  grid bag layout layout new  grid bag layout j panel panel new j panel layout  grid bag constraints cons new  grid bag constraints cons insets new  insets cons gridwidth cons gridheight cons gridx cons gridy cons fill  grid bag constraints both j label label new j label j edit get property selectlinerange start  swing constants right layout set constraints label cons panel add label start field new j text field cons gridx cons weightx f layout set constraints start field cons panel add start field label new j label j edit get property selectlinerange end  swing constants right cons gridx cons weightx f cons gridy layout set constraints label cons panel add label end field new j text field cons gridx cons weightx f layout set constraints end field cons panel add end field return panel 
 service list handler  plugin jar plugin url uri this plugin plugin this uri uri code new  string builder state stack new  stack  string cached services new  linked list  service manager  descriptor 
public  input source resolve entity  string public id  string system id return xml utilities find entity system id services dtd get class 
public void characters char c int off int len  string tag peek element if tag service code append c off len 
public void start element  string uri  string local name  string tag  attributes attrs tag push element tag service name attrs get value name service class attrs get value class 
public void end element  string uri  string local name  string name  string tag peek element if name equals tag if tag equals service  service manager  descriptor d new  service manager  descriptor service class service name code to string plugin  service manager register service d cached services add d code set length pop element else can t happen throw new  internal error 
public void start document try push element null catch  exception e  log log  log error e e 
public  service manager  descriptor get cached services return cached services to array new  service manager  descriptor cached services size 
private  string push element  string name name name null null name intern state stack push name return name 
private  string peek element return state stack peek 
private  string pop element return state stack pop 
 loads a code services xml code file since j edit pre public static void load services  plugin jar plugin url uri  plugin jar  plugin cache entry cache  service list handler dh new  service list handler plugin uri try if xml utilities parse xml uri open stream dh cache null cache cached services dh get cached services catch io exception ioe  log log  log error  service manager class ioe 
 removes all services belonging to the specified plugin param plugin  the plugin since j edit pre public static void unload services  plugin jar plugin  iterator  descriptor descriptors service map key set iterator while descriptors has next  descriptor d descriptors next if d plugin plugin descriptors remove 
 registers a service  plugins should provide a code services xml code file instead of calling this directly param clazz  the service class param name  the service name param code  bean shell code to create an instance of this param plugin  the plugin jar or null if this is a built in service since j edit pre public static void register service  string clazz  string name  string code  plugin jar plugin  descriptor d new  descriptor clazz name code plugin service map put d d 
 unregisters a service param clazz  the service class param name  the service name since j edit pre public static void unregister service  string clazz  string name  descriptor d new  descriptor clazz name service map remove d 
 returns all known service class types since j edit pre public static  string get service types  set  string return value new  hash set  string  set  descriptor key set service map key set for  descriptor d key set return value add d clazz return return value to array new  string return value size 
 returns the names of all registered services with the given class  for example calling this with a parameter of org gjt sp jedit io vfs returns all known virtual file systems param clazz  the class name since j edit pre public static  string get service names  string clazz  list  string return value new  array list  string  set  descriptor key set service map key set for  descriptor d key set if d clazz equals clazz return value add d name return return value to array new  string return value size 
 returns an instance of the given service  the first time this is called for a given service the  bean shell code is evaluated  the result is cached for future invocations so in effect services are singletons param clazz  the service class param name  the service name since j edit pre public static  object get service  string clazz  string name they never taught you this in undergrad computer science  descriptor key new  descriptor clazz name  descriptor value service map get key if value null unknown service clazz name not in table return null else if value code null load services value plugin value plugin get services uri null value service map get key return value get instance 
 registers a service since j edit pre static void register service  descriptor d service map put d d 
 descriptor  string clazz  string name this clazz clazz this name name 
 descriptor  string clazz  string name  string code  plugin jar plugin this clazz clazz this name name this code code this plugin plugin 
 object get instance if instance is null return null else if instance null lazy instantiation instance  bean shell eval null  bean shell get name space code if instance null avoid re running script if it gives us null instance is null true return instance 
public int hash code return name hash code 
public boolean equals  object o if o instanceof  descriptor  descriptor d  descriptor o return d clazz equals clazz d name equals name else return false 
 returns the fold handler with the specified name or null if there is no registered handler with that name param name  the name of the desired fold handler return the  fold handler or null if it doesn t exist since j edit pre public  fold handler get fold handler  string name  fold handler handler  fold handler get service service name return handler 
 returns an array containing the names of all registered fold handlers since j edit pre public  string get fold modes  string handlers get service names service  arrays sort handlers new  standard utilities  string compare  string return handlers 
public void handle message eb message msg if msg instanceof vfs update vfs update vmsg vfs update msg maybe reload vmsg get path 
private void maybe reload  string path  string j edit home j edit get j edit home  string settings directory j edit get settings directory if  misc utilities is url path path  misc utilities resolve symlinks path  on  windows and  mac os path names are case insensitive if vfs manager get vfs for path path get capabilities vfs case insensitive cap path path to lower case j edit home j edit home to lower case if settings directory null settings directory settings directory to lower case xxx does this really belong here  search file set fileset  search and replace get search file set if fileset instanceof  directory list set  directory list set dirset  directory list set fileset  string dir  misc utilities resolve symlinks dirset get directory if path starts with dir dirset invalidate cached list if j edit home null path starts with j edit home path path substring j edit home length else if settings directory null path starts with settings directory path path substring settings directory length else not in settings directory or j edit home directory no need to reload anything return if path starts with  file separator path starts with path path substring if path starts with macros  macros load macros else if path starts with modes path ends with xml path ends with catalog j edit reload modes 
 write the xml declaration  this should be the first output public void write xml declaration throws io exception write xml declaration 
 write the xml declaration of a specific version  this should be the first output public void write xml declaration  string version throws io exception write xml version version encoding encoding new line 
 perform the final step of saving public void finish throws io exception close j edit backup settings file file file delete two stage save file rename to file known last modified file last modified 
 saver throws io exception this new  file file get parent file file get name save 
private  saver  file two stage save file throws io exception super new  output stream writer new  file output stream two stage save file encoding this two stage save file two stage save file 
 construct a  settings xml with specific location and name param settings directory  the settings directory of jedit param name  the file name will be name xml public  settings xml  string settings directory  string name  string filename name xml file new  file  misc utilities construct path settings directory filename 
public  settings xml  file f file f 
 returns true if the file exists public boolean file exists return file exists 
 parse the xml file to load param handler  the handler to receive sax notifications public void load  default handler handler throws io exception xml utilities parse xml new  file input stream file handler known last modified file last modified 
 open the file to save in xml public  saver open saver throws io exception return new  saver 
 returns true if the file has been changed on disk  this is based on the last modified time at the last saving or loading public boolean has changed on disk return file exists file last modified known last modified 
 returns the file s path public  string to string return file to string 
public void paint fold end  gutter gutter  graphics d gfx int screen line int physical line int y int line height j edit buffer buffer gfx set color gutter get fold color int  y y line height int  x gfx draw line  x y  x  y gfx draw line  x  y  x  y boolean nested physical line buffer get line count buffer get fold level physical line if nested gfx draw line  x y  x y line height 
public void paint fold middle  gutter gutter  graphics d gfx int screen line int physical line int y int line height j edit buffer buffer gfx set color gutter get fold color gfx draw line y y line height 
public void paint fold start  gutter gutter  graphics d gfx int screen line int physical line boolean next line visible int y int line height j edit buffer buffer int  y y line height int  x gfx set color gutter get fold color paint fold shape gfx  y  y gfx draw line  x  y  x  y boolean nested buffer get fold level physical line if nested gfx draw line  x y  x  y if next line visible gfx draw line  x  y  x y line height else gfx draw line  x  y  x  y if nested gfx draw line  x  y  x y line height 
 constructor for the  shortcut prefix active event object param bindings  description of the  parameter param active  description of the  parameter public  shortcut prefix active event  hashtable bindings boolean active super new  object this bindings bindings this active active 
 adds a feature to the  change event listener attribute of the  shortcut prefix active event class param l  the feature to be added to the  change event listener attribute public static void add change event listener  change listener l listener list add  change listener class l  log log  log debug  shortcut prefix active event class  listener added listener list get listener list length left 
 description of the  method param l  description of the  parameter public static void remove change event listener  change listener l listener list remove  change listener class l  log log  log debug  shortcut prefix active event class  listener removed listener list get listener list length left 
 description of the  method param bindings  description of the  parameter param listening for shortcut completion  description of the  parameter public static void fire prefix state change  hashtable bindings boolean listening for shortcut completion  log log  log debug  shortcut prefix active event class fire prefix state change called listening listening for shortcut completion  guaranteed to return a non null array  object listeners listener list get listener list  log log  log debug  shortcut prefix active event class listeners length listeners  process the listeners last to first notifying those that are interested in this event for int i listeners length i i  log log  log debug  shortcut prefix active event class fire prefix state change called listening listening for shortcut completion  change event event new  shortcut prefix active event bindings listening for shortcut completion  change listener listeners i state changed event 
 gets the bindings attribute of the  shortcut prefix active event object return  the bindings value public  hashtable get bindings return bindings 
 gets the active attribute of the  shortcut prefix active event object return  the active value public boolean get active return active 
public  shortcuts option pane super shortcuts 
 override protected void  init all bindings new  vector  key binding set layout new  border layout init models select model new j combo box models select model add action listener new  action handler select model set tool tip text j edit get property options shortcuts select tooltip  box north  box create horizontal box north add new j label j edit get property options shortcuts select label north add  box create horizontal strut north add select model filter tf new j text field filter tf set tool tip text j edit get property options shortcuts filter tooltip filter tf get document add document listener new  document listener public void changed update  document event e set filter public void insert update  document event e set filter public void remove update  document event e set filter j button clear button new j button j edit get property options shortcuts clear label clear button add action listener new  action listener public void action performed  action event arg filter tf set text filter tf request focus j panel filter panel new j panel new  flow layout  flow layout left filter panel add new j label j edit get property options shortcuts filter label filter panel add filter tf filter panel add clear button key table new j table filtered model filtered model set table key table key table get table header set reordering allowed false key table get table header add mouse listener new  header mouse handler key table add mouse listener new  table mouse handler  dimension d key table get preferred size d height  math min d height j scroll pane scroller new j scroll pane key table scroller set preferred size d j panel table filter panel new j panel new  border layout table filter panel add  border layout north filter panel table filter panel add  border layout center scroller add  border layout north north add  border layout center table filter panel try select model set selected index j edit get integer property options shortcuts select index catch  illegal argument exception eae 
 override protected void  save if key table get cell editor null key table get cell editor stop cell editing for  shortcuts model model models model save  macros load macros 
private void set filter filtered model set filter filter tf get text 
private void init models  list  key binding all bindings new  vector  key binding models new  vector  shortcuts model  action set action sets j edit get action sets for int i i action sets length i  action set action set action sets i if action set get action count  string model label action set get label if model label null  log log  log error this  empty action set action set get plugin jar  shortcuts model model create model model label action set get action names models add element model all bindings add all model get bindings if models size models add element new  shortcuts model  all all bindings  collections sort models new  standard utilities  string compare  shortcuts model true  shortcuts model current model models element at filtered model new  filtered table model  shortcuts model current model  override public  string prepare filter  string filter return filter to lower case  override public boolean pass filter int row  string filter  string name delegated get binding at row label to lower case return name contains filter 
private  shortcuts model create model  string model label  string actions  list  grab key dialog  key binding bindings new  vector  grab key dialog  key binding actions length for int i i actions length i  string name actions i  edit action ea j edit get action name  string label ea get label  skip certain actions this way if label null continue label gui utilities prettify menu label label add bindings name label bindings return new  shortcuts model model label bindings 
private void add bindings  string name  string label  list  grab key dialog  key binding bindings  grab key dialog  key binding b new  grab key dialog  key binding b create binding name label j edit get property name shortcut b create binding name label j edit get property name shortcut bindings add b 
private  grab key dialog  key binding create binding  string name  string label  string shortcut if shortcut null shortcut length shortcut null  grab key dialog  key binding binding new  grab key dialog  key binding name label shortcut false all bindings add binding return binding 
 override public void mouse clicked  mouse event evt  shortcuts model shortcuts model filtered model get delegated switch key table get table header column at point evt get point case shortcuts model sort break case shortcuts model sort break case shortcuts model sort break set filter 
 override public void mouse clicked  mouse event evt int row key table get selected row int col key table get selected column if col row  grab key dialog gkd new  grab key dialog gui utilities get parent dialog  shortcuts option pane this filtered model get delegated get binding at filtered model get true row row col all bindings null if gkd is ok filtered model set value at gkd get shortcut row col 
public void action performed  action event evt  shortcuts model new model  shortcuts model select model get selected item if filtered model get delegated new model j edit set integer property options shortcuts select index select model get selected index filtered model set delegated new model set filter 
 shortcuts model  string name  list  grab key dialog  key binding bindings this name name this bindings bindings sort 
public  list  grab key dialog  key binding get bindings return bindings 
public void sort int col  collections sort bindings new  key compare col 
public int get column count return 
public int get row count return bindings size 
public  object get value at int row int col switch col case return get binding at row label case return get binding at row shortcut case return get binding at row shortcut default return null 
 override public void set value at  object value int row int col if col return get binding at row col shortcut  string value redraw the whole table because a second shortcut might have changed too fire table data changed 
 override public  string get column name int index switch index case return j edit get property options shortcuts name case return j edit get property options shortcuts shortcut case return j edit get property options shortcuts shortcut default return null 
public void save for  grab key dialog  key binding binding bindings j edit set property binding name shortcut binding shortcut j edit set property binding name shortcut binding shortcut 
public  grab key dialog  key binding get binding at int row int nr  grab key dialog  key binding binding bindings get row return binding nr 
 override public  string to string return name 
 key compare int col this col col 
public int compare  grab key dialog  key binding k  grab key dialog  key binding k  string label k label to lower case  string label k label to lower case if col return  standard utilities compare strings label label true else  string shortcut shortcut if col shortcut k shortcut shortcut k shortcut else shortcut k shortcut shortcut k shortcut if shortcut null shortcut null return else if shortcut null shortcut null return else if shortcut null return  standard utilities compare strings label label true else return  standard utilities compare strings shortcut shortcut true 
public  simple node int i id i 
public void jjt open 
public void jjt close 
public void jjt set parent  node n parent n 
public  node jjt get parent return parent 
public void jjt add child  node n int i if children null children new  node i else if i children length  node c new  node i  system arraycopy children c children length children c children i n 
public  node jjt get child int i return children i 
public  simple node get child int i return  simple node jjt get child i 
public int jjt get num children return children null children length 
public  string to string return  parser tree constants jjt node name id 
public  string to string  string prefix return prefix to string 
public void dump  string prefix  system out println to string prefix if children null for int i i children length i  simple node n  simple node children i if n null n dump prefix 
 detach this node from its parent  this is primarily useful in node serialization see bsh method declaration public void prune jjt set parent null 
 this is the general signature for evaluation of a node public  object eval  call stack callstack  interpreter interpreter throws  eval error throw new  interpreter error  unimplemented or inappropriate for get class get name 
 set the name of the source file or more generally source of the text from which this node was parsed public void set source file  string source file this source file source file 
 get the name of the source file or more generally source of the text from which this node was parsed  this will recursively search up the chain of parent nodes until a source is found or return a string indicating that the source is unknown public  string get source file if source file null if parent null return  simple node parent get source file else return unknown file else return source file 
 get the line number of the starting token public int get line number return first token begin line 
 get the text of the tokens comprising this node public  string get text  string builder text new  string builder  token t first token while t null text append t image if t image equals text append if t last token t image equals t image equals break t t next return text to string 
public  splash screen set cursor  cursor get predefined cursor  cursor wait cursor set background  color white set font default font fm get font metrics default font image get toolkit get image get class get resource org gjt sp jedit icons splash png  media tracker tracker new  media tracker this tracker add image image try tracker wait for all catch  exception e  log log  log error this e  dimension screen get toolkit get screen size sane default win new j window  graphics environment ge  graphics environment get local graphics environment  graphics device gs ge get screen devices  graphics device gd gs if gd null  graphics configuration gconf gd get default configuration if gconf null  rectangle bounds gconf get bounds screen new  dimension bounds width bounds height  dimension size new  dimension image get width this image get height this progress height win set size size win get content pane add this  border layout center win set location screen width size width screen height size height win validate win set visible true 
public void dispose win dispose 
public synchronized void advance log advance time null progress repaint wait for it to be painted to ensure progress is updated continuously try wait catch  interrupted exception ie  log log  log error this ie 
public synchronized void advance  string label log advance time label progress this label label repaint wait for it to be painted to ensure progress is updated continuously try wait catch  interrupted exception ie  log log  log error this ie 
private void log advance time  string label long current time  system current time millis if last label null  log log  log debug  splash screen class last label current time last advance time ms if label null last label label last advance time current time 
 override public synchronized void paint component  graphics g  dimension size get size g set color  color black g draw rect size width size height g draw image image this xxx  this should not be hardcoded g set color  color white g fill rect image get height this win get width progress progress count progress height g set color  color black if label null int draw offset x get width fm string width label int draw offset y image get height this progress height fm get ascent fm get descent paint string g label draw offset x draw offset y  string version version j edit get version int draw offset x get width fm string width version int draw offset y image get height this fm get descent paint string g version draw offset x draw offset y notify 
private void paint string  graphics g  string version int draw offset x int draw offset y g set font label font g set color version color g draw string version draw offset x draw offset y  draw a highlight effect g set color version color g draw string version draw offset x draw offset y 
 override protected void paint fold shape  graphics d gfx int top int bottom gfx draw rect top bottom top 
 creates a new  standalone text area a reference to the property manager is saved and used to read the properties when link  standalone text area properties changed is called param property manager the property manager that contains both shortcut bindings and ui information public  standalone text area i property manager property manager super property manager null this property manager property manager init input handler set mouse handler new  text area mouse handler this todo make  textarea transfer handler standalone text area set transfer handler new  text area transfer handler j edit action set j edit bean shell action action set new  standalone action set property manager this  text area class get resource textarea actions xml add action set action set action set load action set init key bindings init  style property manager if  syntax utilities property manager null  syntax utilities property manager property manager init text area  default fold handler provider fold handler provider new  default fold handler provider  fold handler fold handler provider fold handler provider fold handler provider add fold handler new  explicit fold handler fold handler provider add fold handler new  indent fold handler fold handler provider add fold handler new  dummy fold handler j edit buffer buffer new j edit buffer  token marker token marker new  token marker token marker add rule set new  parser rule set text main buffer set token marker token marker set buffer buffer  string property property manager get property buffer undo count int undo count if property null try undo count  integer parse int property catch  number format exception e this buffer set undo limit undo count  mode mode new  mode text mode set token marker token marker  mode provider instance add mode mode  kill ring set instance new  kill ring  kill ring get instance properties changed 
 initializes the text area by re reading the properties from the property manager passed to the constructor private void init text area init painter init gutter set caret blink enabled get boolean property view caret blink set electric scroll get integer property view electric borders if buffer null return  string property property manager get property buffer undo count int undo count if property null try undo count  integer parse int property catch  number format exception e buffer set undo limit undo count 
private void init gutter  gutter gutter get gutter gutter set expanded get boolean property view gutter line numbers int interval get integer property view gutter highlight interval gutter set highlight interval interval gutter set current line highlight enabled get boolean property view gutter highlight current line gutter set structure highlight enabled get boolean property view gutter structure highlight gutter set structure highlight color get color property view gutter structure highlight color gutter set background get color property view gutter bg color gutter set foreground get color property view gutter fg color gutter set highlighted foreground get color property view gutter highlight color gutter set fold color get color property view gutter fold color gutter set current line foreground get color property view gutter current line color  string alignment get property view gutter number alignment if right equals alignment gutter set line number alignment  gutter right else if center equals alignment gutter set line number alignment  gutter center else left default case gutter set line number alignment  gutter left gutter set font get font property view gutter font int width get integer property view gutter border width gutter set border width get color property view gutter focus border color get color property view gutter no focus border color painter get background 
 init the painter of this textarea private void init painter  text area painter painter get painter painter set block caret enabled false painter set font get font property view font painter set structure highlight enabled get boolean property view structure highlight painter set structure highlight color get color property view structure highlight color painter set eol markers painted get boolean property view eol markers painter set eol marker color get color property view eol marker color painter set wrap guide painted get boolean property view wrap guide painter set wrap guide color get color property view wrap guide color painter set caret color get color property view caret color painter set selection color get color property view selection color painter set multiple selection color get color property view multiple selection color painter set background get color property view bg color painter set foreground get color property view fg color painter set block caret enabled get boolean property view block caret painter set thick caret enabled get boolean property view thick caret painter set line highlight enabled get boolean property view line highlight painter set line highlight color get color property view line highlight color painter set anti alias new  anti alias get property view anti alias painter set fractional font metrics enabled get boolean property view frac font metrics  string default font get property view font int default font size get integer property view fontsize painter set styles  syntax utilities load styles default font default font size  syntax style fold line style new  syntax style for int i i i fold line style i  syntax utilities parse style get property view style fold line i default font default font size true painter set fold line style fold line style 
public  string get property  string name return property manager get property name 
 returns the value of a boolean property param name  the property private boolean get boolean property  string name return get boolean property name false 
 returns the value of a boolean property param name  the property param def  the default value private boolean get boolean property  string name boolean def  string value get property name if value null return def else if value equals true value equals yes value equals on return true else if value equals false value equals no value equals off return false else return def 
 returns the value of an integer property param name  the property private int get integer property  string name return get integer property name 
 returns the value of an integer property param name  the property param def  the default value since j edit pre private int get integer property  string name int def  string value get property name if value null return def else try return  integer parse int value trim catch  number format exception nf return def 
 returns the value of a font property  the family is stored in the code i name i code property the font size is stored in the code i name i size code property and the font style is stored in code i name i style code  for example if code i name i code is code view gutter font code the properties will be named code view gutter font code code view gutter fontsize code and code view gutter fontstyle code param name  the property since j edit pre private  font get font property  string name return get font property name null 
 returns the value of a font property  the family is stored in the code i name i code property the font size is stored in the code i name i size code property and the font style is stored in code i name i style code  for example if code i name i code is code view gutter font code the properties will be named code view gutter font code code view gutter fontsize code and code view gutter fontstyle code param name  the property param def  the default value since j edit pre private  font get font property  string name  font def  string family get property name  string size string get property name size  string style string get property name style if family null size string null style string null return def else int size try size  integer parse int size string catch  number format exception nf return def int style try style  integer parse int style string catch  number format exception nf return def return new  font family style size 
 returns the value of a color property param name  the property name since j edit pre private  color get color property  string name return get color property name  color black 
 returns the value of a color property param name  the property name param def  the default value since j edit pre private  color get color property  string name  color def  string value get property name if value null return def else return  syntax utilities parse color value def 
 reinitializes the textarea by reading the properties from the property manager  override public void properties changed get input handler remove all key bindings j edit action set j edit bean shell action action sets get action context get action sets for j edit action set j edit bean shell action action set action sets action set init key bindings init buffer init text area super properties changed 
 reinitializes the buffer by reading the properties from the property manager private void init buffer  string buffer properties line separator encoding autodetect tab size indent size no tabs default mode undo count wrap max line len word break chars no word sep camel cased words folding collapse folds for int i i buffer properties length i  string value get property buffer buffer properties i if value null buffer unset property buffer properties i else buffer set property buffer properties i value buffer properties changed 
 creates the popup menu since pre  override public void create popup menu  mouse event evt popup new j popup menu add menu item undo  undo add menu item redo  redo popup add separator add menu item cut  cut add menu item copy  copy add menu item paste  paste 
 adds a menu item from the action context to the popup menu and returns the item return the menu item added public j menu item add menu item  string action  string label final j edit bean shell action shell action get action context get action action if shell action null return null j menu item item new j menu item item set action new  abstract action label public void action performed  action event e shell action invoke  standalone text area this popup add item return item 
 create a standalone  text area  if you want to use it in j edit please use link j edit embedded text area j edit embedded text area return a textarea since pre public static  standalone text area create text area final  properties props new  properties props put all load properties org gjt sp jedit jedit keys props props put all load properties org gjt sp jedit jedit props  standalone text area text area new  standalone text area new i property manager public  string get property  string name return props get property name text area get buffer set property folding explicit return text area 
private static  properties load properties  string file name  properties props new  properties  input stream in  text area class get resource as stream file name try props load in catch io exception e  log log  log error  text area class e finally io utilities close quietly in return props 
public  standalone action set i property manager i property manager  text area text area url url super null url this i property manager i property manager this text area text area 
 override protected j edit bean shell action get array int size return new j edit bean shell action size 
 override protected  string get property  string name return i property manager get property name 
public  abstract input handler get input handler return text area get input handler 
 override protected j edit bean shell action create bean shell action  string action name  string code  string selected boolean no repeat boolean no record boolean no remember last return new j edit bean shell action action name code selected no repeat no record no remember last 
public static void main  string args j frame frame new j frame  text area text create text area  mode mode new  mode xml mode set property file modes xml xml  mode provider instance add mode mode text get buffer set mode mode frame get content pane add text frame set default close operation  window constants exit on close frame pack frame set visible true 
 escapes newlines tabs backslashes and quotes in the specified string param str  the string since j edit pre public static  string chars to escapes  string str return chars to escapes str n t 
 escapes the specified characters in the specified string param str  the string param to escape  any characters that require escaping since j edit pre public static  string chars to escapes  string str  string to escape  string builder buf new  string builder for int i i str length i char c str char at i if to escape index of c if c n buf append n else if c t buf append t else buf append buf append c else buf append c return buf to string 
param str a java string return the leading whitespace of that string for indenting subsequent lines since j edit pre public static  string get indent string  string str  string builder indent string new  string builder for int i i str length i char ch str char at i if  character is whitespace ch break indent string append ch return indent string to string 
 returns the number of leading white space characters in the specified string param str  the string public static int get leading white space  string str return get leading white space  char sequence str 
 returns the number of leading white space characters in the specified string param str  the string since j edit pre public static int get leading white space  char sequence str int whitespace loop for whitespace str length switch str char at whitespace case case t whitespace break default break loop return whitespace 
 returns the number of trailing whitespace characters in the specified string param str  the string public static int get trailing white space  string str int whitespace loop for int i str length i i switch str char at i case case t whitespace break default break loop return whitespace 
 returns the width of the leading white space in the specified string param str  the string param tab size  the tab size public static int get leading white space width  string str int tab size return get leading white space width  char sequence str tab size 
 returns the width of the leading white space in the specified string param str  the string param tab size  the tab size since j edit pre public static int get leading white space width  char sequence str int tab size int whitespace loop for int i i str length i switch str char at i case whitespace break case t whitespace tab size whitespace tab size break default break loop return whitespace 
 creates a string of white space with the specified length p  to get a whitespace string tuned to the current buffer s settings call this method as follows pre my whitespace  misc utilities create white space my length buffer get boolean property no tabs buffer get tab size pre param len  the length param tab size  the tab size or if tabs are not to be used public static  string create white space int len int tab size return create white space len tab size 
public static  string truncate white space int len int tab size  string indent str  string builder buf new  string builder int indent for int i indent len i indent str length i char c indent str char at i if c indent buf append c else if c t int with tab indent tab size indent tab size if with tab len for indent len indent buf append else indent with tab buf append c return buf to string 
 creates a string of white space with the specified length p  to get a whitespace string tuned to the current buffer s settings call this method as follows pre my whitespace  misc utilities create white space my length buffer get boolean property no tabs buffer get tab size pre param len  the length param tab size  the tab size or if tabs are not to be used param start  the start offset for tab alignment public static  string create white space int len int tab size int start  string builder buf new  string builder if tab size while len buf append else if len buf append else int count len start tab size tab size if count len start while count buf append t count len tab size while count buf append return buf to string 
 returns the virtual column number taking tabs into account of the specified offset in the segment param seg  the segment param tab size  the tab size public static int get virtual width  segment seg int tab size int virtual position for int i i seg count i char ch seg array seg offset i if ch t virtual position tab size virtual position tab size else virtual position return virtual position 
 returns the array offset of a virtual column number taking tabs into account in the segment param seg  the segment param tab size  the tab size param column  the virtual column number param total virtual width  if this array is non null the total virtual width will be stored in its first location if this method returns return if the column is out of bounds public static int get offset of virtual column  segment seg int tab size int column int total virtual width int virtual position for int i i seg count i char ch seg array seg offset i if ch t int tab width tab size virtual position tab size if virtual position column return i else virtual position tab width else if virtual position column return i else virtual position if total virtual width null total virtual width virtual position return 
 compares two strings p  unlike function  string compare to function this method correctly recognizes and handles embedded numbers  for example it places  my file before  my file p param str  the first string param str  the second string param ignore case  if true case will be ignored return negative  if str lt str if both are the same positive if str gt str since j edit pre public static int compare strings  string str  string str boolean ignore case char char str to char array char char str to char array int len  math min char length char length for int i j i len j len i j char ch char i char ch char j if  character is digit ch  character is digit ch ch ch int  i i int  j j for  i char length  i if  character is digit char  i  i break for  j char length  j if  character is digit char  j  j break int len  i i int len  j j if len len return else if len len return else for int k k len k ch char i k ch char j k if ch ch return ch ch i  i j  j else if ignore case ch  character to lower case ch ch  character to lower case ch if ch ch return ch ch return char length char length 
public  string compare boolean icase this icase icase 
public  string compare 
public int compare e obj e obj return compare strings obj to string obj to string icase 
 returns if two strings are equal  this correctly handles null pointers as opposed to calling code o equals o code since j edit pre public static boolean objects equal  object o  object o if o null if o null return true else return false else if o null return false else return o equals o 
 converts a  unix style glob to a regular expression p becomes becomes aa bb becomes aa bb param glob  the glob pattern since j edit pre public static  string glob to re  string glob if glob starts with re return glob substring final  object neg new  object final  object group new  object  stack  object state new  stack  object  string builder buf new  string builder boolean backslash false for int i i glob length i char c glob char at i if backslash buf append buf append c backslash false continue switch c case backslash true break case buf append break case case case case buf append buf append c break case buf append break case if backslash buf append else buf append break case buf append if i glob length glob char at i buf append state push neg else state push group break case if state is empty state peek group buf append else buf append break case if state is empty buf append if state pop neg buf append else buf append break default buf append c return buf to string 
 implementation of  string region matches for  char sequence param seq  the test  char sequence param toff  offset for the test sequence param other  the sequence to compare to param ooff  offset of the comparison sequence param len  how many characters to compare return  whether the two subsequences are equal see  string region matches int  string int int since j edit pre public static boolean region matches  char sequence seq int toff  char sequence other int ooff int len if toff ooff len return false boolean ret true for int i i len i char c if i toff seq length c seq char at i toff else ret false break char c if i ooff other length c other char at i ooff else ret false break if c c ret false break return ret 
 implementation of  string starts with for  char sequence param seq  the  char sequence param str  string to test return  whether the sequence starts with the test string since j edit pre public static boolean starts with  char sequence seq  string str boolean ret true for int i i str length i if i seq length seq char at i str char at i ret false break return ret 
 returns a boolean from a given object param obj the object param def  the default value return the boolean value if obj is a  boolean true if the value is true yes on false if the value is false no off def if the value is null or anything else since j edit pre public static boolean get boolean  object obj boolean def if obj null return def else if obj instanceof  boolean return  boolean obj boolean value else if true equals obj yes equals obj on equals obj return true else if false equals obj no equals obj off equals obj return false return def 
private  standard utilities 
public  status bar  view view super new  border layout set name  status bar set border new  compound border new  empty border  operating system is mac os ui manager get border  text field border this view view panel new j panel new  border layout box new  box  box layout x axis panel add  border layout east box add  border layout center panel  mouse handler mouse handler new  mouse handler caret status new  tool tip label caret status set name caret status caret status set tool tip text j edit get property view status caret tooltip caret status add mouse listener mouse handler message new j label set message component message mode widget  get widget mode fold widget  get widget fold encoding widget  get widget encoding wrap widget  get widget wrap multi select widget  get widget multi select rect select widget  get widget rect select overwrite widget  get widget overwrite line sep widget  get widget line sep 
public void properties changed  color fg j edit get color property view status foreground  color bg j edit get color property view status background show caret status j edit get boolean property view status show caret status panel set background bg panel set foreground fg caret status set background bg caret status set foreground fg message set background bg message set foreground fg retarded gtk look and feel  font font new j label get font ui manager get font  label font  font metrics fm get font metrics font if show caret status panel add  border layout west caret status caret status set font font  dimension dim new  dimension fm string width caret test str fm get height caret status set preferred size dim update caret status else panel remove caret status  string status bar j edit get property view status if  standard utilities objects equal current bar status bar box remove all  string tokenizer tokenizer new  string tokenizer status bar while tokenizer has more tokens  string token tokenizer next token if  character is letter token char at  widget widget get widget token if widget null  log log  log warning this  widget token doesn t exist continue  component c widget get component c set background bg c set foreground fg box add c widget update widget properties changed else j label label new j label token label set background bg label set foreground fg box add label current bar status bar update buffer status update misc status 
 override public void add notify super add notify vfs manager get io thread pool add progress listener this 
 override public void remove notify super remove notify vfs manager get io thread pool remove progress listener this 
public void status update final  work thread pool thread pool int thread index  swing utilities invoke later new  runnable public void run don t obscure existing message if message null equals message get text trim current message is io return int request count thread pool get request count if request count set message and clear j edit get property view status io done current message is io true else if request count set message j edit get property view status io current message is io true else  object args  integer value of request count set message j edit get property view status io args current message is io true 
public void progress update  work thread pool thread pool int thread index 
 show a message for a short period of time param message  the message since j edit pre public void set message and clear  string message set message message temp timer new  timer new  action listener public void action performed  action event evt so if view is closed in the meantime if is showing set message null temp timer set initial delay temp timer set repeats false temp timer start 
 displays a status message param message the message to display it can be null public void set message  string message if temp timer null temp timer stop temp timer null set message component this message if message null if view get macro recorder null this message set text j edit get property view status recording else this message set text else this message set text message 
public void set message component  component comp current message is io false if comp null message comp comp return message comp comp panel add  border layout center message comp 
public void update caret status if show caret status  buffer buffer view get buffer if buffer is loaded can happen when switching buffers sometimes buffer view get text area get buffer caret status set text return j edit text area text area view get text area int caret position text area get caret position int curr line text area get caret line there must be a better way of fixing this the problem is that this method can sometimes be called as a result of a text area scroll event in which case the caret position has not been updated yet if curr line buffer get line count return hopefully another caret update will come int start text area get line start offset curr line int dot caret position start if dot return int buffer length buffer get length buffer get text start dot seg int virtual position  standard utilities get virtual width seg buffer get tab size for gc seg array null seg count per lengthy discussion on dev list format for caret position is lineno dot virtual caret total e g  no more  top nor  bottom if j edit get boolean property view status show caret linenumber true buf append curr line buf append if j edit get boolean property view status show caret dot true buf append dot if j edit get boolean property view status show caret virtual true virtual position dot buf append buf append virtual position if buf length buf append if j edit get boolean property view status show caret offset true j edit get boolean property view status show caret bufferlength true buf append buf append caret position buf append buf append buffer length buf append else if j edit get boolean property view status show caret offset true buf append buf append caret position buf append else if j edit get boolean property view status show caret bufferlength true buf append buf append buffer length buf append caret status set text buf to string buf set length 
public void update buffer status wrap widget update line sep widget update mode widget update fold widget update encoding widget update 
public void update misc status multi select widget update rect select widget update overwrite widget update 
private  widget get widget  string name if mode equals name return mode widget if fold equals name return fold widget if encoding equals name return encoding widget if wrap equals name return wrap widget if multi select equals name return multi select widget if rect select equals name return rect select widget if overwrite equals name return overwrite widget if line sep equals name return line sep widget return  get widget name 
private  widget  get widget  string name  status widget factory widget factory  status widget factory  service manager get service org gjt sp jedit gui statusbar  status widget name if widget factory null  log log  log error this  widget name doesn t exist return null return widget factory get widget view 
 override public void mouse clicked  mouse event evt  object source evt get source if source caret status evt get click count view get text area show go to line dialog 
public  status bar option pane super status 
 override protected void  init set layout new  border layout  north j panel panel new j panel new  grid layout show statusbar new j check box j edit get property options status visible show statusbar set selected j edit get boolean property view status visible panel add show statusbar show statusbar plain new j check box j edit get property options status plainview visible show statusbar plain set selected j edit get boolean property view status plainview visible panel add show statusbar plain panel add new j label j edit get property options status caption add panel  border layout north  options panel  abstract option pane options panel new  abstract option pane  status  options  foreground color options panel add component j edit get property options status foreground foreground color new  color well button j edit get color property view status foreground  grid bag constraints vertical  background color options panel add component j edit get property options status background background color new  color well button j edit get color property view status background  grid bag constraints vertical  memory foreground color options panel add component j edit get property options status memory foreground mem foreground color new  color well button j edit get color property view status memory foreground  grid bag constraints vertical  memory background color options panel add component j edit get property options status memory background mem background color new  color well button j edit get color property view status memory background  grid bag constraints vertical options panel add separator options panel add component new j label j edit get property options status caret title  caret position display options  caret position format lineno dot virtual caretpos bufferlength view status show caret linenumber true shows line number for caret lineno view status show caret dot true shows offset in line for caret dot view status show caret virtual true shows virtual offset in line for caret virtual view status show caret offset true shows caret offset from start of buffer caretpos view status show caret bufferlength true shows length of buffer bufferlength show caret line number new j check box j edit get property options status caret linenumber  show caret line number j edit get boolean property view status show caret linenumber true show caret line number set name show caret line number show caret dot new j check box j edit get property options status caret dot  show caret offset from start of line j edit get boolean property view status show caret dot true show caret dot set name show caret dot show caret virtual new j check box j edit get property options status caret virtual  show caret virtual offset from start of line j edit get boolean property view status show caret virtual true show caret virtual set name show caret virtual show caret offset new j check box j edit get property options status caret offset  show caret offset from start of file j edit get boolean property view status show caret offset true show caret offset set name show caret offset show caret buffer length new j check box j edit get property options status caret bufferlength  show length of file j edit get boolean property view status show caret bufferlength true show caret buffer length set name show caret buffer length options panel add component show caret line number options panel add component show caret dot options panel add component show caret virtual options panel add component show caret offset options panel add component show caret buffer length widgets panel  string statusbar j edit get property view status  string tokenizer st new  string tokenizer statusbar list model new  default list model while st has more tokens  string token st next token list model add element token list new j list list model list set selection mode  list selection model single selection list add list selection listener new  list handler j panel widgets panel new j panel new  border layout widgets panel add new j scroll pane list  border layout center  create buttons j panel buttons new j panel buttons set border new  empty border buttons set layout new  box layout buttons  box layout x axis  action handler action handler new  action handler add new  rollover button gui utilities load icon  plus png add set tool tip text j edit get property options status add add add action listener action handler buttons add add buttons add  box create horizontal strut remove new  rollover button gui utilities load icon  minus png remove set tool tip text j edit get property options status remove remove add action listener action handler buttons add remove buttons add  box create horizontal strut move up new  rollover button gui utilities load icon  arrow u png move up set tool tip text j edit get property options status move up move up add action listener action handler buttons add move up buttons add  box create horizontal strut move down new  rollover button gui utilities load icon  arrow d png move down set tool tip text j edit get property options status move down move down add action listener action handler buttons add move down buttons add  box create horizontal strut edit new  rollover button gui utilities load icon  button properties png edit set tool tip text j edit get property options status edit edit add action listener action handler buttons add edit buttons add  box create glue update buttons widgets panel add buttons  border layout south j tabbed pane tabs new j tabbed pane tabs add tab  options options panel tabs add  widgets widgets panel add tabs  border layout center 
 override protected void  save j edit set color property view status foreground foreground color get selected color j edit set color property view status background background color get selected color j edit set color property view status memory foreground mem foreground color get selected color j edit set color property view status memory background mem background color get selected color j edit set boolean property view status visible show statusbar is selected j edit set boolean property view status plainview visible show statusbar plain is selected  string builder buf new  string builder for int i i list model get size i if i buf append  string widget name  string list model element at i buf append widget name j edit set property view status buf to string j edit set boolean property view status show caret linenumber show caret line number is selected j edit set boolean property view status show caret dot show caret dot is selected j edit set boolean property view status show caret virtual show caret virtual is selected j edit set boolean property view status show caret offset show caret offset is selected j edit set boolean property view status show caret bufferlength show caret buffer length is selected 
private void update buttons int index list get selected index remove set enabled index list model get size move up set enabled index move down set enabled index index list model get size edit set enabled index 
public void action performed  action event evt  object source evt get source if source add  string value select widget if value null return int index list get selected index if index index list model get size else index list model insert element at value index list set selected index index list ensure index is visible index else if source remove int index list get selected index list model remove element at index if list model get size if list model get size index list set selected index index else list set selected index index update buttons else if source move up int index list get selected index  object selected list get selected value list model remove element at index list model insert element at selected index list set selected index index list ensure index is visible index else if source move down int index list get selected index  object selected list get selected value list model remove element at index list model insert element at selected index list set selected index index list ensure index is visible index else if source edit  string value select widget if value null return int index list get selected index list model insert element at value index list set selected index index list ensure index is visible index 
private  string select widget  widget selection dialog dialog new  widget selection dialog  status bar option pane this  string value dialog get value if value null value length value null return value 
public void value changed  list selection event evt update buttons 
 widget selection dialog  component comp super gui utilities get parent dialog comp j edit get property options status edit title true  button group button group new  button group label radio new j radio button j edit get property options status edit label radio button widget radio new j radio button j edit get property options status edit widget radio button button group add label radio button group add widget radio label label new j label j edit get property options status edit label label label field new j text field widget label new j label j edit get property options status edit widget label widget combo new j combo box  service manager get service names org gjt sp jedit gui statusbar  status widget  action handler action handler new  action handler label radio add action listener action handler widget radio add action listener action handler south panel j panel south panel new j panel south panel set layout new  box layout south panel  box layout x axis south panel set border new  empty border south panel add  box create glue ok new j button j edit get property common ok ok add action listener action handler get root pane set default button ok south panel add ok south panel add  box create horizontal strut cancel new j button j edit get property common cancel cancel add action listener action handler south panel add cancel south panel add  box create glue label field set enabled false widget radio set selected true j panel content new j panel new  border layout content set border new  empty border set content pane content j panel center new j panel center set layout new  box layout center  box layout y axis center add label radio j panel p new j panel new  border layout p add label label  border layout west p add label field center add p center add widget radio p new j panel new  border layout p add widget label  border layout west p add widget combo center add p get content pane add center  border layout center get content pane add south panel  border layout south pack set location relative to gui utilities get parent dialog comp set visible true 
 override public void ok if widget radio is selected value  string widget combo get selected item else value label field get text trim dispose 
 override public void cancel value null dispose 
public  string get value return value 
public void action performed  action event evt  object source evt get source if source ok ok else if source cancel cancel else if source label radio label field set enabled true widget combo set enabled false validate else if source widget radio label field set enabled false widget combo set enabled true validate 
public  string list 
public  string list  object array add all array 
public void add all  object array for int i i array length i add array i to string 
param orig the original string param delim a delimiter to use for splitting return a new  string list containing the split strings public static  string list split  string orig  object delim if orig null orig length return new  string list return new  string list orig split delim to string 
 joins each string in the list with a newline return a joined string representation of this with the newline n as delimiter  override public  string to string return join n 
return an array of  string  override public  string to array int siz size  string result new  string siz  system arraycopy super to array result siz return result 
 the reverse of split given a collection takes each element and places it in a string joined by a delimiter public static  string join  collection c  string delim  string list sl new  string list for  object o c  string s o to string sl add s return sl join delim 
param arr array of objects param delim delimiter to separate strings return a single string with each element in arr converted to a string and concatenated separated by delim public static  string join  object arr  string delim  string list sl new  string list sl add all arr return sl join delim 
 non static version that joins this  string list param delim the delimiter return a joined string with delim inbetween each element public  string join  string delim int s size if s return if s return get else  string builder retval new  string builder retval append get for int i i s i retval append delim get i return retval to string 
public static void main  string args  string teststr a b c d e f  string list split teststr  string joinstr sl join assert teststr equals joinstr  system out println  test  passed 
public static  string split  string s  string delim  vector v new  vector  string tokenizer st new  string tokenizer s delim while st has more tokens v add element st next token  string sa new  string v size v copy into sa return sa 
public static  string bubble sort  string in  vector v new  vector for int i i in length i v add element in i int n v size boolean swap true while swap swap false for int i i n i if  string v element at i compare to  string v element at i  string tmp  string v element at i v remove element at i v insert element at tmp i swap true  string out new  string n v copy into out return out 
public static  string max common prefix  string one  string two int i while one region matches two i i return one substring i 
public static  string method string  string name  class types  string builder sb new  string builder name if types length sb append for int i i types length i  class c types i sb append c null null c get name i types length sb append return sb to string 
 hack  the real method is in  reflect java which is not public public static  string normalize class name  class type return  reflect normalize class name type 
public  match get match  text area text area int offset text area get caret position text area get line start offset text area get caret line if offset int bracket offset  text utilities find matching bracket text area get buffer text area get caret line offset if bracket offset int bracket line text area get line of offset bracket offset return new  match this bracket line bracket offset bracket line bracket offset return null 
public void select match  text area text area text area select to matching bracket 
public  match 
public  match  structure matcher matcher this matcher matcher 
public  match  structure matcher matcher int start line int start int end line int end this matcher this start line start line this start start this end line end line this end end 
 highlight  text area text area this text area text area 
public void paint valid line  graphics d gfx int screen line int physical line int start int end int y if text area get painter is structure highlight enabled return  match match text area get structure match if match null paint highlight gfx screen line start end y match 
private int get offsets int screen line  match match int x x int match start line text area get screen line of offset match start int match end line text area get screen line of offset match end if match start line screen line x match start else x text area get screen line start offset screen line if match end line screen line x match end else x text area get screen line end offset screen line return new int text area offset to xy x x text area offset to xy x x 
private void paint highlight  graphics gfx int screen line int start int end int y  match match if text area is structure highlight visible return if match start end match end start return int match start line text area get screen line of offset match start int match end line text area get screen line of offset match end  font metrics fm text area get painter get font metrics int height fm get height int offsets get offsets screen line match int x offsets int x offsets gfx set color text area get painter get structure highlight color gfx draw line x y x y height gfx draw line x y x y height if match start line screen line screen line gfx draw line x y x y else offsets get offsets screen line match int prev x offsets int prev x offsets gfx draw line  math min x prev x y  math max x prev x y gfx draw line  math min x prev x y  math max x prev x y if match end line screen line gfx draw line x y height x y height 
public  style editor j dialog parent  syntax style style  string style name super parent j edit get property style editor title true initialize parent style style name 
public  style editor j frame parent  syntax style style  string style name super parent j edit get property style editor title true initialize parent style style name 
private void initialize  component comp  syntax style style  string style name j panel content new j panel new  border layout content set border new  empty border set content pane content j panel panel new j panel new  grid layout panel add new j label j edit get property style editor token type panel add new j label style name italics new j check box j edit get property style editor italics italics set selected style get font is italic panel add italics panel add new j label bold new j check box j edit get property style editor bold bold set selected style get font is bold panel add bold panel add new j label  color fg style get foreground color fg color check box new j check box j edit get property style editor fg color fg color check box set selected fg null fg color check box add action listener this panel add fg color check box fg color new  color well button fg fg color set enabled fg null panel add fg color  color bg style get background color bg color check box new j check box j edit get property style editor bg color bg color check box set selected bg null bg color check box add action listener this panel add bg color check box bg color new  color well button bg bg color set enabled bg null panel add bg color content add  border layout center panel  box box new  box  box layout x axis box add  box create glue box add ok new j button j edit get property common ok get root pane set default button ok ok add action listener this box add  box create horizontal strut box add cancel new j button j edit get property common cancel cancel add action listener this box add  box create glue content add  border layout south box pack set location relative to comp set resizable false set visible true 
public void action performed  action event evt  object source evt get source if source ok ok else if source cancel cancel else if source fg color check box fg color set enabled fg color check box is selected else if source bg color check box bg color set enabled bg color check box is selected 
public void ok ok clicked true dispose 
public void cancel dispose 
public  syntax style get style if ok clicked return null  color foreground fg color check box is selected fg color get selected color null  color background bg color check box is selected bg color get selected color null return new  syntax style foreground background new  font  dialog italics is selected  font italic bold is selected  font bold 
public  syntax hilite option pane super syntax 
 override protected void  init set layout new  border layout add  border layout center create style table scroller 
 override protected void  save style model save 
private j scroll pane create style table scroller style model create style table model style table new j table style model style table set row selection allowed false style table set column selection allowed false style table set cell selection enabled false style table get table header set reordering allowed false style table add mouse listener new  mouse handler  table column model tcm style table get column model  table column style column tcm get column style column set cell renderer new  style table model  style renderer  dimension d style table get preferred size d height  math min d height j scroll pane scroller new j scroll pane style table scroller set preferred size d return scroller 
private static  style table model create style table model return new  style table model 
 override public void mouse clicked  mouse event evt int row style table row at point evt get point if row return  syntax style style  syntax style current  syntax style style model get value at row  string token  string style model get value at row j dialog dialog gui utilities get parent dialog  syntax hilite option pane this if dialog null style new  style editor dialog current token get style else  view view gui utilities get view  syntax hilite option pane this style new  style editor view current token get style if style null style model set value at style row 
 style table model style choices new  vector  style choice  token id count start at not to skip  token null for int i i  token id count i  string token name  token token to string byte i add style choice token name view style token name to lower case add style choice j edit get property options syntax fold line view style fold line add style choice j edit get property options syntax fold line view style fold line add style choice j edit get property options syntax fold line view style fold line add style choice j edit get property options syntax fold line view style fold line  collections sort style choices new  standard utilities  string compare  style choice true 
public int get column count return 
public int get row count return style choices size 
public  object get value at int row int col  style choice ch style choices get row switch col case return ch label case return ch style default return null 
 override public void set value at  object value int row int col  style choice ch style choices get row if col ch style  syntax style value fire table rows updated row row 
 override public  string get column name int index switch index case return j edit get property options syntax object case return j edit get property options syntax style default return null 
public void save for int i i style choices size i  style choice ch style choices get i j edit set property ch property gui utilities get style string ch style 
private void add style choice  string label  string property style choices add new  style choice label property gui utilities parse style j edit get property property  dialog 
 style choice  string label  string property  syntax style style this label label this property property this style style 
 override public  string to string return label 
 style renderer set opaque true set border  syntax hilite option pane no focus border set text  hello  world 
public  component get table cell renderer component j table table  object value boolean is selected boolean cell has focus int row int col if value null  syntax style style  syntax style value set foreground style get foreground color if style get background color null set background style get background color else this part sucks set background j edit get color property view bg color set font style get font set border cell has focus ui manager get border  table focus cell highlight border  syntax hilite option pane no focus border return this 
 creates a new  syntax style param fg color  the text color param bg color  the background color param font  the text font public  syntax style  color fg color  color bg color  font font this fg color fg color this bg color bg color this font font 
 returns the text color public  color get foreground color return fg color 
 returns the background color public  color get background color return bg color 
 returns the style font public  font get font return font 
 checks if a subregion of a code  segment code is equal to a character array param ignore case  true if case should be ignored false otherwise param text  the segment param offset  the offset into the segment param match  the character array to match since j edit pre public static boolean region matches boolean ignore case  segment text int offset char match int length offset match length if length text offset text count return false char text array text array for int i offset j i length i j char c text array i char c match j if ignore case c  character to upper case c c  character to upper case c if c c return false return true 
 converts a color object to its hex value  the hex value prefixed is with for example ff param c  the color object since j edit pre public static  string get color hex string  color c  string col string  integer to hex string c get rgb xffffff return substring col string length concat col string 
since j edit pre public static  color parse color  string name  color default color if name null name length return default color else if name char at try return  color decode name catch  number format exception nf return default color else if red equals name return  color red else if green equals name return  color green else if blue equals name return  color blue else if yellow equals name return  color yellow else if orange equals name return  color orange else if white equals name return  color white else if light gray equals name return  color light gray else if gray equals name return  color gray else if dark gray equals name return  color dark gray else if black equals name return  color black else if cyan equals name return  color cyan else if magenta equals name return  color magenta else if pink equals name return  color pink else return default color 
 converts a style string to a style object param str  the style string param family  style strings only specify font style not font family param size  style strings only specify font style not font family param color  if false the styles will be monochrome param default fg color  default foreground color if not specified in style string exception  illegal argument exception if the style is invalid since j edit pre public static  syntax style parse style  string str  string family int size boolean color  color default fg color throws  illegal argument exception  color fg color default fg color  color bg color null boolean italic false boolean bold false  string tokenizer st new  string tokenizer str while st has more tokens  string s st next token if s starts with color if color fg color parse color s substring  color black else if s starts with bg color if color bg color parse color s substring null else if s starts with style for int i i s length i if s char at i i italic true else if s char at i b bold true else throw new  illegal argument exception  invalid style s else throw new  illegal argument exception  invalid directive s return new  syntax style fg color bg color new  font family italic  font italic bold  font bold size 
 converts a style string to a style object param str  the style string param family  style strings only specify font style not font family param size  style strings only specify font style not font family param color  if false the styles will be monochrome exception  illegal argument exception if the style is invalid since j edit pre public static  syntax style parse style  string str  string family int size boolean color throws  illegal argument exception return parse style str family size color  color black 
 loads the syntax styles from the properties giving them the specified base font family and size param family  the font family param size  the font size since j edit pre public static  syntax style load styles  string family int size return load styles family size true 
 loads the syntax styles from the properties giving them the specified base font family and size param family  the font family param size  the font size param color  if false the styles will be monochrome since j edit pre public static  syntax style load styles  string family int size boolean color  syntax style styles new  syntax style  token id count start at not to skip  token null for int i i styles length i try  string style name view style  token token to string byte i to lower case  locale english styles i parse style property manager get property style name family size color catch  exception e  log log  log error  standard utilities class e return styles 
private  syntax utilities 
public  target error  string msg  throwable t  simple node node  call stack callstack boolean in native code super msg node callstack target t this in native code in native code 
public  target error  throwable t  simple node node  call stack callstack this  target error t node callstack false 
public  throwable get target check for easy mistake if target instanceof  invocation target exception return  invocation target exception target get target exception else return target 
public  string to string return super to string n target exception print target error target 
public void print stack trace print stack trace false  system err 
public void print stack trace  print stream out print stack trace false out 
public void print stack trace boolean debug  print stream out if debug super print stack trace out out println  target  stack  trace target print stack trace out 
 generate a printable string showing the wrapped target exception  if the proxy mechanism is available allow the extended print to check for  undeclared throwable exception and print that embedded error public  string print target error  throwable t  string s target to string if  capabilities can generate interfaces s n x print target error t return s 
 extended form of print target error  this indirection is used to print  undeclared throwable exceptions which are possible when the proxy mechanism is available  we are shielded from compile problems by using a bsh script  this is acceptable here because we re not in a critical path  otherwise we d need yet another dynamically loaded module just for this public  string x print target error  throwable t  string get target import java lang reflect  undeclared throwable exception  string result while target instanceof  undeclared throwable exception target target get undeclared throwable result  nested target to string return result  interpreter i new  interpreter try i set target t return  string i eval get target catch  eval error e throw new  interpreter error xprintarget e to string 
 return true if the  target error was generated from native code e g if the script called into a compiled java class which threw the excpetion  we distinguish so that we can print the stack trace for the native code case the stack trace would not be useful if the exception was generated by the script e g if the script explicitly threw an exception the stack trace would simply point to the bsh internals which generated the exception public boolean in native code return in native code 
 creates a new j edit text area param property manager the property manager that contains informations like shortcut bindings param input handler provider the input handler provider protected  text area i property manager property manager  input handler provider input handler provider this input handler provider input handler provider enable events awt event focus event mask awt event key event mask  initialize some misc stuff selection manager new  selection manager this chunk cache new  chunk cache this painter new  text area painter this gutter new  gutter this gutter set mouse actions provider new  mouse actions property manager gutter listener list new  event listener list caret event new  mutable caret event blink true offset xy new  point structure matchers new  linked list  structure matcher structure matchers add new  structure matcher  bracket matcher  initialize the gui set layout new  scroll layout add  scroll layout center painter add  scroll layout left gutter some plugins add stuff in a right hand gutter vertical box new  box  box layout x axis vertical box add vertical new j scroll bar  adjustable vertical vertical set request focus enabled false add  scroll layout right vertical box add  scroll layout bottom horizontal new j scroll bar  adjustable horizontal horizontal set request focus enabled false horizontal set values this ensures that the text area s look is slightly more consistent with the rest of the metal l f while it depends on not so well documented portions of  swing it only affects appearance so future breakage shouldn t matter if ui manager get look and feel instanceof  metal look and feel set border new  text area border vertical put client property j scroll bar is free standing  boolean false horizontal put client property j scroll bar is free standing  boolean false horizontal set border null  add some event listeners vertical add adjustment listener new  adjust handler horizontal add adjustment listener new  adjust handler add focus listener new  focus handler add mouse wheel listener new  mouse wheel handler  this doesn t seem very correct but it fixes a problem when setting the initial caret position for a buffer eg from the recent file list focused component this popup enabled true 
public  fold painter get fold painter return new  triangle fold painter 
 creates an action context and initializes the input handler for this textarea  called when creating a standalone textarea from within j edit public void init input handler action context new j edit action context j edit bean shell action j edit action set j edit bean shell action  override public void invoke action  event object evt j edit bean shell action action action invoke  text area this set mouse handler new  text area mouse handler this input handler provider new  default input handler provider new  text area input handler this  override protected j edit bean shell action get action  string action return action context get action action 
public j edit action context j edit bean shell action j edit action set j edit bean shell action get action context return action context 
public void set mouse handler  mouse input adapter mouse input adapter mouse handler mouse input adapter painter add mouse listener mouse handler painter add mouse motion listener mouse handler 
 override public void set transfer handler  transfer handler new handler super set transfer handler new handler try get drop target add drop target listener new  text area drop handler this catch  too many listeners exception e  log log  log error this e 
 override public  string to string  string builder builder new  string builder  string base version super to string int len base version length builder append base version builder set length len chop off the last builder append caret append caret builder append caret line append caret line builder append caret screen line append caret screen line builder append electric scroll append electric scroll builder append horizontal offset append horizontal offset builder append magic caret append magic caret builder append offset xy append offset xy to string builder append old caret line append old caret line builder append screen last line append screen last line builder append visible lines append visible lines builder append first physical line append get first physical line builder append phys last line append phys last line append return builder to string 
 plugins and macros should not call this method since j edit pre public void dispose  display manager text area disposed this gutter dispose 
since j edit pre public  abstract input handler get input handler return input handler provider get input handler 
 returns the object responsible for painting this text area public final  text area painter get painter return painter 
 returns the gutter to the left of the text area or null if the gutter is disabled public final  gutter get gutter return gutter 
return the display manager used by this text area since j edit pre public  display manager get display manager return display manager 
return true if the caret is blinking false otherwise public final boolean is caret blink enabled return caret blinks 
 toggles caret blinking param caret blinks  true if the caret should blink false otherwise public void set caret blink enabled boolean caret blinks this caret blinks caret blinks if caret blinks blink false if buffer null invalidate line caret line 
return the minimum distance in number of lines from the caret to the nearest edge of the screen top or bottom edge public final int get electric scroll return electric scroll 
 sets the number of lines from the top and bottom of the text area that are always visible param electric scroll  the number of lines always visible from the top or bottom public final void set electric scroll int electric scroll this electric scroll electric scroll 
 returns if clicking the middle mouse button pastes the most recent selection register and if  control dragging inserts the selection at the caret public final boolean is quick copy enabled return quick copy 
 sets if clicking the middle mouse button pastes the most recent selection register and if  control dragging inserts the selection at the caret param quick copy a boolean flag public final void set quick copy enabled boolean quick copy this quick copy quick copy 
 returns the buffer this text area is editing since jedit pre  prior to pre this function returned a  buffer type  if this causes your code to break try calling view get buffer instead of view get text area get buffer public final j edit buffer get buffer return buffer 
 sets the buffer this text area is editing  if you don t run a standalone textarea in j edit please do not call this method use link org gjt sp jedit  edit pane set buffer org gjt sp jedit  buffer instead param buffer  the buffer public void set buffer j edit buffer buffer if this buffer buffer return try buffer changing true if this buffer null dubious set first line if this buffer is loading select none caret line caret caret screen line match null boolean in compound edit false if this buffer null in compound edit this buffer inside compound edit if in compound edit this buffer end compound edit this buffer buffer if in compound edit this buffer begin compound edit chunk cache set buffer buffer gutter set buffer buffer properties changed if display manager null display manager release display manager  display manager get display manager buffer this display manager init if buffer is loading update scroll bar repaint fire scroll event true finally buffer changing false 
 returns true if this text area is editable false otherwise public final boolean is editable return buffer is editable 
 drag and drop of text in j edit is implementing using j edit ap is however since j edit must run with  java this class only has the necessary support to call a hook method via reflection  this method is called by the org gjt sp jedit  java class to signal that a drag is in progress since j edit pre deprecated the org gjt jedit  java class no longer exists  deprecated public boolean is drag in progress return dnd in progress 
 drag and drop of text in j edit is implementing using j edit ap is however since j edit must run with  java this class only has the necessary support to call a hook method via reflection  this method is called by the org gjt sp jedit  java class to signal that a drag is in progress since j edit pre deprecated the org gjt jedit  java class no longer exists  deprecated public void set drag in progress boolean dnd in progress this dnd in progress dnd in progress 
 returns if drag and drop of text is enabled since j edit pre public boolean is drag enabled return dnd enabled 
 sets if drag and drop of text is enabled since j edit pre public void set drag enabled boolean dnd enabled this dnd enabled dnd enabled 
 if set double clicking will join non word characters to form one word since j edit pre public boolean get join non word chars return join non word chars 
 if set double clicking will join non word characters to form one word since j edit pre public void set join non word chars boolean join non word chars this join non word chars join non word chars 
 if set ctrl enables rectangular selection mode while pressed since j edit pre public boolean is ctrl for rectangular selection return ctrl for rectangular selection 
 if set ctrl enables rectangular selection mode while pressed since j edit pre public void set ctrl for rectangular selection boolean ctrl for rectangular selection this ctrl for rectangular selection ctrl for rectangular selection 
 returns the vertical scroll bar position since j edit pre public final int get first line return display manager first line scroll line display manager first line skew 
 sets the vertical scroll bar position param first line  the scroll bar position public void set first line int first line ensure we don t have empty space at the bottom or top etc int max display manager get scroll line count visible lines last line partial if first line max first line max if first line first line if  debug scroll debug  log log  log debug this set first line from get first line to first line int old first line get first line if first line old first line return display manager set first line old first line first line repaint fire scroll event true 
 returns the first visible physical line index since j edit pre public final int get first physical line return display manager first line physical line 
 sets the vertical scroll bar position param phys first line  the first physical line to display since j edit pre public void set first physical line int phys first line set first physical line phys first line 
 sets the vertical scroll bar position param phys first line  the first physical line to display param skew a local screen line delta since j edit pre public void set first physical line int phys first line int skew if  debug scroll debug  log log  log debug this set first physical line phys first line skew int amount phys first line display manager first line physical line display manager set first physical line amount skew repaint fire scroll event true 
 returns the last visible physical line index since j edit pre public final int get last physical line return phys last line 
 returns the last screen line index it is different from link get visible lines because the buffer can have less lines than the visible lines return the last screen line index since j edit pre public int get last screen line return screen last line 
 returns the number of lines visible in this text area return the number of visible lines in the textarea public final int get visible lines return visible lines 
 returns the horizontal offset of drawn lines public final int get horizontal offset return horizontal offset 
 sets the horizontal offset of drawn lines  this can be used to implement horizontal scrolling param horizontal offset offset  the new horizontal offset public void set horizontal offset int horizontal offset if horizontal offset horizontal offset if horizontal offset this horizontal offset return this horizontal offset horizontal offset painter repaint fire scroll event false 
 scrolls up by one line since j edit pre public void scroll up line set first line get first line 
 scrolls up by one page since j edit pre public void scroll up page set first line get first line get visible lines last line partial 
 scrolls down by one line since j edit pre public void scroll down line set first line get first line 
 scrolls down by one page since j edit pre public void scroll down page set first line get first line get visible lines last line partial 
 ensures that the caret is visible by scrolling the text area if necessary param do electric scroll  if true electric scrolling will be performed public void scroll to caret boolean do electric scroll scroll to caret line caret buffer get line start offset caret line do electric scroll 
 ensures that the specified location in the buffer is visible param offset  the offset from the start of the buffer param do electric scroll  if true electric scrolling will be performed since j edit pre public void scroll to int offset boolean do electric scroll int line buffer get line of offset offset scroll to line offset buffer get line start offset line do electric scroll 
 ensures that the specified location in the buffer is visible param line  the line number param offset  the offset from the start of the line param do electric scroll  if true electric scrolling will be performed since j edit pre public void scroll to int line int offset boolean do electric scroll if  debug scroll to debug  log log  log debug this scroll to line count get line count if visible lines if  debug scroll to debug  log log  log debug this visible lines  fix the case when the line is wrapped it was not possible to see the second or next subregion of a line  chunk cache  line info infos chunk cache get line infos for physical line line int subregion  chunk cache get subregion of offset offset infos set first physical line line subregion return  get ready int extra end virt int line length buffer get line length line if offset line length extra end virt char width offset line length offset line length else extra end virt int  electric scroll do electric scroll visible lines electric scroll electric scroll  scroll vertically int screen line chunk cache get screen line of offset line offset int visible lines get visible lines if screen line  we are scrolling to a position that is not on the screen if  debug scroll to debug  log log  log debug this screen line  chunk cache  line info infos chunk cache get line infos for physical line line int subregion  chunk cache get subregion of offset offset infos int prev line display manager get prev visible line get first physical line int next line display manager get next visible line get last physical line if line get first physical line if  debug scroll to debug  log log  log debug this line get first physical line set first physical line line subregion  electric scroll else if line prev line if  debug scroll to debug  log log  log debug this line prev line set first physical line prev line subregion  electric scroll else if line get last physical line if  debug scroll to debug  log log  log debug this line get last physical line set first physical line line subregion  electric scroll visible lines last line partial else if line next line if  debug scroll to debug  log log  log debug this line next line set first physical line next line subregion  electric scroll visible lines last line partial else if  debug scroll to debug  log log  log debug this neither  log log  log debug this  last physical line is get last physical line set first physical line line subregion visible lines if  debug scroll to debug  log log  log debug this  last physical line is get last physical line else if screen line  electric scroll if  debug scroll to debug  log log  log debug this electric up set first line get first line  electric scroll screen line else if screen line visible lines  electric scroll last line partial if  debug scroll to debug  log log  log debug this electric down set first line get first line  electric scroll visible lines screen line last line partial  scroll horizontally if display manager is line visible line return  point point offset to xy line offset offset xy point x extra end virt if point x set horizontal offset horizontal offset point x char width else if point x painter get width char width set horizontal offset horizontal offset painter get width point x char width 
 adds a scroll listener to this text area param listener  the listener since j edit pre public final void add scroll listener  scroll listener listener listener list add  scroll listener class listener 
 removes a scroll listener from this text area param listener  the listener since j edit pre public final void remove scroll listener  scroll listener listener listener list remove  scroll listener class listener 
 returns the physical line number that contains the specified screen line param screen line  the screen line since j edit pre public int get physical line of screen line int screen line return chunk cache get line info screen line physical line 
 returns the screen wrapped line containing the specified offset  returns if the line is not currently visible on the screen param offset  the offset since j edit pre public int get screen line of offset int offset int line buffer get line of offset offset offset buffer get line start offset line return chunk cache get screen line of offset line offset 
 returns the start offset of the specified screen wrapped line param line  the line since j edit pre public int get screen line start offset int line  chunk cache  line info line info chunk cache get line info line if line info physical line return return buffer get line start offset line info physical line line info offset 
 returns the end offset of the specified screen wrapped line param line  the line since j edit pre public int get screen line end offset int line  chunk cache  line info line info chunk cache get line info line if line info physical line return return buffer get line start offset line info physical line line info offset line info length 
 converts a point to an offset  note that unlike in previous j edit versions this method now returns if the y co ordinate is out of bounds param x  the x co ordinate of the point param y  the y co ordinate of the point public int xy to offset int x int y return xy to offset x y true 
 converts a point to an offset  note that unlike in previous j edit versions this method now returns if the y co ordinate is out of bounds param x  the x co ordinate of the point param y  the y co ordinate of the point param round  round up to next letter if past the middle of a letter since j edit pre public int xy to offset int x int y boolean round  font metrics fm painter get font metrics int height fm get height int line y height if line line visible lines return return x to screen line offset line x round 
 converts a point in a given screen line to an offset  note that unlike in previous j edit versions this method now returns if the y co ordinate is out of bounds param x  the x co ordinate of the point param screen line  the screen line param round  round up to next letter if past the middle of a letter since j edit pre public int x to screen line offset int screen line int x boolean round  chunk cache  line info line info chunk cache get line info screen line if line info physical line return get line end offset display manager get last visible line else int offset  chunk x to offset line info chunks x horizontal offset round if offset offset line info offset line info length offset line info offset line info length return get line start offset line info physical line offset 
 converts an offset into a point in the text area painter s co ordinate space param offset  the offset return  the location of the offset on screen or code null code if the specified offset is not visible public  point offset to xy int offset int line buffer get line of offset offset offset buffer get line start offset line  point ret val new  point return offset to xy line offset ret val 
 converts an offset into a point in the text area painter s co ordinate space param line  the line param offset  the offset return  the location of the offset on screen or code null code if the specified offset is not visible public  point offset to xy int line int offset return offset to xy line offset new  point 
 converts a line offset pair into an x y pixel point relative to the upper left corner of the text area param line  the physical line number from top of document param offset  the offset in characters from the start of the line param ret val  the point to store the return value in return code ret val code for convenience or code null code if the specified offset is not visible since j edit pre public  point offset to xy int line int offset  point ret val if display manager is line visible line return null int screen line chunk cache get screen line of offset line offset if screen line return null  font metrics fm painter get font metrics ret val y screen line fm get height  chunk cache  line info info chunk cache get line info screen line ret val x int horizontal offset  chunk offset to x info chunks offset return ret val 
 marks a range of screen lines as needing a repaint param start  the first line param end  the last line since j edit pre public void invalidate screen line range int start int end if buffer is loading return if start end int tmp end end start start tmp if chunk cache need full repaint end visible lines  font metrics fm painter get font metrics int y start fm get height int height end start fm get height painter repaint y painter get width height gutter repaint y gutter get width height 
 marks a line as needing a repaint param line  the physical line to invalidate public void invalidate line int line if is showing buffer is loading line get first physical line line phys last line display manager is line visible line return int start line int end line for int i i visible lines i  chunk cache  line info info chunk cache get line info i if info physical line line info physical line start line start line i if info physical line line info last subregion info physical line end line i break if chunk cache need full repaint end line end line visible lines invalidate screen line range start line end line 
 marks a range of physical lines as needing a repaint param start  the first line to invalidate param end  the last line to invalidate public void invalidate line range int start int end if is showing buffer is loading return if end start int tmp end end start start tmp if end get first physical line start get last physical line return int start screen line int end screen line for int i i visible lines i  chunk cache  line info info chunk cache get line info i if info physical line start info physical line start screen line start screen line i if info physical line end info last subregion info physical line end screen line i break if start screen line start screen line if chunk cache need full repaint end screen line end screen line visible lines invalidate screen line range start screen line end screen line 
 returns the length of the buffer public final int get buffer length return buffer get length 
 returns the number of physical lines in the buffer public final int get line count return buffer get line count 
 returns the line containing the specified offset param offset  the offset public final int get line of offset int offset return buffer get line of offset offset 
 returns the start offset of the specified line param line  the line physical line return  the start offset of the specified line or if the line is invalid public int get line start offset int line return buffer get line start offset line 
 returns the end offset of the specified line param line  the line physical line return  the end offset of the specified line or if the line is invalid public int get line end offset int line return buffer get line end offset line 
 returns the length of the specified line param line  the line public int get line length int line return buffer get line length line 
 returns the specified substring of the buffer param start  the start offset param len  the length of the substring return  the substring public final  string get text int start int len return buffer get text start len 
 copies the specified substring of the buffer into a segment param start  the start offset param len  the length of the substring param segment  the segment public final void get text int start int len  segment segment buffer get text start len segment 
 returns the entire text of this text area public  string get text return buffer get text buffer get length 
 returns the text on the specified line param line index the line number return  the text or null if the line index is invalid public final  string get line text int line index return buffer get line text line index 
 copies the text on the specified line into a  segment  if line index is invalid the segment will contain a null string param line index  the line number physical line param segment the segment into which the data will be stored public final void get line text int line index  segment segment buffer get line text line index segment 
 sets the entire text of this text area param text the new content of the buffer public void set text  string text try buffer begin compound edit buffer remove buffer get length buffer insert text finally buffer end compound edit 
 selects all text in the buffer  preserves the scroll position public final void select all int first line get first line int horiz offset get horizontal offset set selection new  selection  range buffer get length move caret position buffer get length true set first line first line set horizontal offset horiz offset 
 selects the current line since j edit pre public void select line int caret line get caret line int start get line start offset caret line int end get line end offset caret line  selection s new  selection  range start end if multi add to selection s else set selection s move caret position end 
 selects the paragraph at the caret position since j edit pre public void select paragraph int caret line get caret line if get line length caret line get toolkit beep return int start caret line int end caret line while start if get line length start break else start while end get line count if get line length end break else end int selection start get line start offset start int selection end get line end offset end  selection s new  selection  range selection start selection end if multi add to selection s else set selection s move caret position selection end 
 selects the word at the caret position since j edit pre public void select word int line get caret line int line start get line start offset line int offset get caret position line start if get line length line return  string line text get line text line  string no word sep buffer get string property no word sep if offset get line length line offset int word start  text utilities find word start line text offset no word sep true false false int word end  text utilities find word end line text offset no word sep true false false  selection s new  selection  range line start word start line start word end if multi add to selection s else set selection s move caret position line start word end 
 selects from the bracket at the specified position to the corresponding bracket since j edit pre public  selection select to matching bracket int position boolean quick copy int position line buffer get line of offset position int line offset position buffer get line start offset position line if get line length position line int bracket  text utilities find matching bracket buffer position line  math max line offset if bracket  selection s if bracket position if quick copy move caret position position false s new  selection  range bracket position else if quick copy move caret position bracket false s new  selection  range position bracket if multi quick copy select none add to selection s return s return null 
 selects from the bracket at the caret position to the corresponding bracket since j edit pre public void select to matching bracket select to matching bracket caret false 
 selects the code block surrounding the caret since j edit pre public void select block  selection s get selection at offset caret int start end if s null start end caret else start s start end s end  string text get text buffer get length  we can t do the backward scan if start if start get toolkit beep return  scan backwards trying to find a bracket  string open brackets  string close brackets int count char open bracket char close bracket backward scan while start char c text char at start int index open brackets index of c if index if count open bracket c close bracket close brackets char at index break backward scan else if close brackets index of c count  reset count count  scan forward matching that bracket if open bracket get toolkit beep return forward scan do char c text char at end if c close bracket if count end break forward scan else if c open bracket count while end buffer get length s new  selection  range start end if multi add to selection s else set selection s move caret position end 
 returns if the specified line is contained in the currently matched structure s scope since j edit pre public boolean line in structure scope int line if match null return false if match start line caret line return line match start line line caret line else return line match end line line caret line 
 inverts the selection since j edit pre public final void invert selection selection manager invert selection 
 returns the number of selections  this can be used to test for the existence of selections since j edit pre public int get selection count return selection manager get selection count 
 returns the current selection since j edit pre public  selection get selection return selection manager get selection 
 returns the selection with the specified index  this must be between and the return value of code get selection count code since j edit pre param index the index of the selection you want public  selection get selection int index return selection manager selection get index 
 returns the current selection since j edit pre public  iterator  selection get selection iterator return selection manager selection iterator 
 deselects everything public void select none invalidate selected lines set selection  selection null 
 sets the selection  nested and overlapping selections are merged where possible  null elements of the array are ignored param selection  the new selection since j edit pre public void set selection  selection selection invalidate the old selection invalidate selected lines selection manager set selection selection finish caret update caret line no scroll true 
 sets the selection  nested and overlapping selections are merged where possible param selection  the new selection since j edit pre public void set selection  selection selection invalidate selected lines selection manager set selection selection finish caret update caret line no scroll true 
 adds to the selection  nested and overlapping selections are merged where possible param selection  the new selection since j edit pre public void add to selection  selection selection invalidate selected lines selection manager add to selection selection finish caret update caret line no scroll true 
 adds to the selection  nested and overlapping selections are merged where possible param selection  the new selection since j edit pre public void add to selection  selection selection invalidate selected lines selection manager add to selection selection finish caret update caret line no scroll true 
 returns the selection containing the specific offset or code null code if there is no selection at that offset param offset  the offset since j edit pre public  selection get selection at offset int offset return selection manager get selection at offset offset 
 deactivates the specified selection param sel  the selection since j edit pre public void remove from selection  selection sel invalidate selected lines selection manager remove from selection sel finish caret update caret line no scroll true 
 deactivates the selection at the specified offset  if there is no selection at that offset does nothing param offset  the offset since j edit pre public void remove from selection int offset  selection sel get selection at offset offset if sel null return invalidate selected lines selection manager remove from selection sel finish caret update caret line no scroll true 
 resizes the selection at the specified offset or creates a new one if there is no selection at the specified offset  this is a utility method that is mainly useful in the mouse event handler because it handles the case of end being before offset gracefully unlike the rest of the selection api param offset  the offset param end  the new selection end param extra end virt  only for rectangular selections specifies how far it extends into virtual space param rect  make the selection rectangular since j edit pre public void resize selection int offset int end int extra end virt boolean rect  selection s selection manager get selection at offset offset if s null invalidate line range s start line s end line selection manager remove from selection s selection manager resize selection offset end extra end virt rect fire caret event 
 extends the selection at the specified offset or creates a new one if there is no selection at the specified offset  this is different from resizing in that the new chunk is added to the selection in question instead of replacing it param offset  the offset param end  the new selection end since j edit pre public void extend selection int offset int end extend selection offset end 
 extends the selection at the specified offset or creates a new one if there is no selection at the specified offset  this is different from resizing in that the new chunk is added to the selection in question instead of replacing it param offset  the offset param end  the new selection end param extra start virt  extra virtual space at the start param extra end virt  extra virtual space at the end since j edit pre public void extend selection int offset int end int extra start virt int extra end virt  selection s get selection at offset offset if s null invalidate line range s start line s end line selection manager remove from selection s if offset s start offset end end s end else if offset s end offset s start if end offset int tmp end end offset offset tmp if rectangular selection mode s new  selection  rect offset end  selection  rect s extra start virt extra start virt  selection  rect s extra end virt extra end virt else s new  selection  range offset end selection manager add to selection s fire caret event if rectangular selection mode extra end virt int line get line of offset end scroll to line get line length line extra end virt false 
 returns the text in the specified selection param s  the selection since j edit pre public  string get selected text  selection s  string builder buf new  string builder s end s start s get text buffer buf return buf to string 
 returns the text in all active selections param separator  the string to insert between each text chunk for example a newline since j edit pre public  string get selected text  string separator  selection sel selection manager get selection if sel length return null  string builder buf new  string builder for int i i sel length i if i buf append separator sel i get text buffer buf return buf to string 
 returns the text in all active selections with a newline between each text chunk public  string get selected text return get selected text n 
 replaces the selection with the specified text param s  the selection param selected text  the new text since j edit pre public void set selected text  selection s  string selected text if is editable throw new  internal error  text component read only try buffer begin compound edit move caret position s set text buffer selected text  no matter what happends stops us from leaving buffer in a bad state finally buffer end compound edit no no no select none 
 replaces the selection at the caret with the specified text  if there is no selection at the caret the text is inserted at the caret position public void set selected text  string selected text int new caret replace selection selected text if new caret move caret position new caret select none 
 replaces the selection at the caret with the specified text  if there is no selection at the caret the text is inserted at the caret position param selected text  the new selection param move caret  move caret to insertion location if necessary since j edit pre public void set selected text  string selected text boolean move caret int new caret replace selection selected text if move caret new caret move caret position new caret select none 
 set the selection but does not deactivate it and does not move the caret  please use link set selected text  string instead param selected text  the new selection return  the new caret position since pre public int replace selection  string selected text if is editable throw new  runtime exception  text component read only int new caret if get selection count for compatibility with older j edit versions buffer insert caret selected text else try buffer begin compound edit  selection selection get selection for int i i selection length i new caret selection i set text buffer selected text finally buffer end compound edit return new caret 
 returns a sorted array of line numbers on which a selection or selections are present p  this method is the most convenient way to iterate through selected lines in a buffer  the line numbers in the array returned by this method can be passed as a parameter to such methods as link j edit buffer get line text int since j edit pre public int get selected lines if selection manager get selection count return new int caret line return selection manager get selected lines 
 return if change in buffer should scroll this text area since j edit pre public boolean caret auto scroll return focused component this 
 adds a structure matcher since j edit pre public void add structure matcher  structure matcher matcher structure matchers add matcher 
 removes a structure matcher since j edit pre public void remove structure matcher  structure matcher matcher structure matchers remove matcher 
 returns the structure element bracket or xml tag etc matching the one before the caret since j edit pre public  structure matcher  match get structure match return match 
 blinks the caret public final void blink caret if caret blinks blink blink invalidate line caret line else blink true 
 centers the caret on the screen since j edit pre public void center caret int offset get screen line start offset visible lines if offset get toolkit beep else set caret position offset 
 tries to scroll the text area so that the caret is centered on the screen  sometimes gets confused by folds but at least makes the caret visible and guesses better on subsequent attempts since j edit pre public void scroll and center caret if get display manager is line visible get caret line get display manager expand fold get caret line true int physical line get caret line int mid physical line get physical line of screen line visible lines int diff physical line mid physical line set first line get first line diff request focus 
 sets the caret position and deactivates the selection param new caret  the caret position public void set caret position int new caret select none move caret position new caret true 
 sets the caret position and deactivates the selection param new caret  the caret position param do electric scroll  do electric scrolling public void set caret position int new caret boolean do electric scroll select none move caret position new caret do electric scroll 
 sets the caret position without deactivating the selection param new caret  the caret position public void move caret position int new caret move caret position new caret true 
 sets the caret position without deactivating the selection param new caret  the caret position param do electric scroll  do electric scrolling public void move caret position int new caret boolean do electric scroll move caret position new caret do electric scroll electric scroll normal scroll 
 sets the caret position without deactivating the selection param new caret  the caret position param scroll mode  the scroll mode no scroll normal scroll or electric scroll since j edit pre public void move caret position int new caret int scroll mode if new caret new caret buffer get length throw new  illegal argument exception caret out of bounds new caret int old caret line caret line if caret new caret finish caret update old caret line scroll mode false else caret new caret caret line get line of offset new caret magic caret finish caret update old caret line scroll mode true 
 returns a zero based index of the caret position public int get caret position return caret 
 returns the line number containing the caret public int get caret line return caret line 
 returns an internal position used to keep the caret in one column while moving around lines of varying lengths since j edit pre public int get magic caret position if magic caret magic caret chunk cache subregion offset to x caret line caret get line start offset caret line return magic caret 
 sets the magic caret position  this can be used to preserve the column position when moving up and down lines param magic caret  the magic caret position since j edit pre public void set magic caret position int magic caret this magic caret magic caret 
 adds a caret change listener to this text area param listener  the listener public final void add caret listener  caret listener listener listener list add  caret listener class listener 
 removes a caret change listener from this text area param listener  the listener public final void remove caret listener  caret listener listener listener list remove  caret listener class listener 
 moves the caret to the next closing bracket param select true if you want to extend selection since j edit pre public void go to next bracket boolean select int new caret if caret buffer get length  string text get text caret buffer get length caret loop for int i i text length i switch text char at i case case case new caret caret i break loop if new caret get toolkit beep else if select extend selection caret new caret else if multi select none move caret position new caret 
 moves the caret to the next character param select true if you want to extend selection since j edit pre public void go to next character boolean select  selection s get selection at offset caret if select s instanceof  selection  range if multi if caret s end move caret position s end return else set caret position s end return int extra start virt extra end virt if s instanceof  selection  rect extra start virt  selection  rect s extra start virt extra end virt  selection  rect s extra end virt else extra start virt extra end virt int new caret caret if caret buffer get length if select rectangular selection mode s instanceof  selection  rect if s null caret s start extra start virt else extra end virt else get toolkit beep return else if caret get line end offset caret line if select rectangular selection mode s instanceof  selection  rect if s null caret s start extra start virt else extra end virt else int line display manager get next visible line caret line if line get toolkit beep return else new caret get line start offset line else new caret caret if select extend selection caret new caret extra start virt extra end virt else if multi select none move caret position new caret 
 move the caret to the next line param select true if you want to extend selection since j edit pre public void go to next line boolean select  selection s get selection at offset caret boolean rect select s null rectangular selection mode s instanceof  selection  rect int magic get magic caret position int new caret chunk cache get below position caret line caret buffer get line start offset caret line magic rect select select if new caret int end get line end offset caret line if caret end get toolkit beep return else new caret end  change line select new caret set magic caret position magic 
 moves the caret to the next screenful param select true if you want to extend selection since j edit pre public void go to next page boolean select scroll to caret false int magic get magic caret position if caret line display manager get first visible line caret line display manager get next visible line caret line int new caret if get first line get visible lines display manager get scroll line count int last visible line display manager get last visible line new caret get line end offset last visible line else int caret screen line get screen line of offset caret scroll down page new caret x to screen line offset caret screen line magic true if select extend selection caret new caret else if multi select none move caret position new caret false set magic caret position magic 
 moves the caret to the start of the next paragraph param select true if you want to extend selection since j edit pre public void go to next paragraph boolean select int line no get caret line int new caret get buffer length boolean found blank false loop for int i line no i get line count i if display manager is line visible i continue get line text i line segment for int j j line segment count j switch line segment array line segment offset j case case t break default if found blank new caret get line start offset i break loop else continue loop found blank true if select extend selection caret new caret else if multi select none move caret position new caret 
 moves the caret to the start of the next word  note that if the view eat whitespace boolean propery is false this method moves the caret to the end of the current word instead param select true if you want to extend selection since j edit pre public void go to next word boolean select go to next word select false 
 moves the caret to the start of the next word since j edit pre public void go to next word boolean select boolean eat whitespace int line start get line start offset caret line int new caret caret line start  string line text get line text caret line if new caret line text length int next line display manager get next visible line caret line if next line get toolkit beep return new caret get line start offset next line else  string no word sep buffer get string property no word sep boolean camel cased words buffer get boolean property camel cased words new caret  text utilities find word end line text new caret no word sep true camel cased words eat whitespace new caret line start if select extend selection caret new caret else if multi select none move caret position new caret 
 moves the caret to the previous bracket param select true if you want to extend selection since j edit pre public void go to prev bracket boolean select  string text get text caret int new caret loop for int i get caret position i i switch text char at i case case case new caret i break loop if new caret get toolkit beep else if select extend selection caret new caret else if multi select none move caret position new caret 
 moves the caret to the previous character param select true if you want to extend selection since j edit pre public void go to prev character boolean select  selection s get selection at offset caret if caret get toolkit beep return if select s instanceof  selection  range if multi if caret s start move caret position s start return else set caret position s start return int extra start virt int extra end virt int new caret caret if select caret get line end offset caret line if s instanceof  selection  rect extra start virt  selection  rect s extra start virt extra end virt  selection  rect s extra end virt if caret s start if extra start virt new caret caret else extra start virt else if extra end virt new caret caret else extra end virt else new caret caret else if caret get line start offset caret line int line display manager get prev visible line caret line if line get toolkit beep return new caret get line end offset line else new caret caret if select extend selection caret new caret extra start virt extra end virt else if multi select none move caret position new caret 
 moves the caret to the previous line param select true if you want to extend selection since j edit pre public void go to prev line boolean select  selection s get selection at offset caret boolean rect select s null rectangular selection mode s instanceof  selection  rect int magic get magic caret position int new caret chunk cache get above position caret line caret buffer get line start offset caret line magic rect select select if new caret int start get line start offset caret line if caret start get toolkit beep return else new caret start  change line select new caret set magic caret position magic 
 moves the caret to the previous screenful param select true if you want to extend selection since j edit pre public void go to prev page boolean select scroll to caret false int magic get magic caret position if caret line display manager get first visible line caret line display manager get next visible line caret line int new caret if get first line int first visible line display manager get first visible line new caret get line start offset first visible line else int caret screen line get screen line of offset caret scroll up page new caret x to screen line offset caret screen line magic true if select extend selection caret new caret else if multi select none move caret position new caret false set magic caret position magic 
 moves the caret to the start of the previous paragraph param select true if you want to extend selection since j edit pre public void go to prev paragraph boolean select int line no caret line int new caret boolean found blank false loop for int i line no i i if display manager is line visible i continue get line text i line segment for int j j line segment count j switch line segment array line segment offset j case case t break default if found blank new caret get line end offset i break loop else continue loop found blank true if select extend selection caret new caret else if multi select none move caret position new caret 
 moves the caret to the start of the previous word param select true if you want to extend selection since j edit pre public void go to prev word boolean select go to prev word select false 
 moves the caret to the start of the previous word since j edit pre public void go to prev word boolean select boolean eat whitespace int line start get line start offset caret line int new caret caret line start  string line text get line text caret line if new caret if line start get toolkit beep return else int prev line display manager get prev visible line caret line if prev line get toolkit beep return new caret get line end offset prev line else  string no word sep buffer get string property no word sep boolean camel cased words buffer get boolean property camel cased words new caret  text utilities find word start line text new caret no word sep true camel cased words eat whitespace new caret line start if select extend selection caret new caret else if multi select none move caret position new caret 
a dumb home action which only has states start of the whitespace or start of line param select true if we also want to select from the cursor since jedit pre public void home boolean select switch get input handler get last action count case go to start of white space select break default go to start of line select break 
a dumb end action which only has states end of whitespace or end of line param select true if we also want to select from the cursor since jedit pre public void end boolean select switch get input handler get last action count case go to end of white space select break default go to end of line select break 
 on subsequent invocations first moves the caret to the first non whitespace character of the line then the beginning of the line then to the first visible line param select true if you want to extend selection since j edit pre public void smart home boolean select switch get input handler get last action count case go to start of white space select break case go to start of line select break default case go to first visible line select break 
 has states based on of invocations last character of code before inline comment last non whitespace character of the line end of line end of last visible line param select true if you want to extend selection since j edit pre public void smart end boolean select int pos get caret position int npos switch get input handler get last action count case go to end of code select npos get caret position if npos pos go to end of white space select break case go to end of white space select break case go to end of line select break default case go to last visible line select break 
 moves the caret to the beginning of the current line param select true if you want to extend selection since j edit pre public void go to start of line boolean select  selection s get selection at offset caret int line select s null caret line s start line int new caret get line start offset line if select extend selection caret new caret else if multi select none move caret position new caret 
 moves the caret to the end of the current line param select true if you want to extend selection since j edit pre public void go to end of line boolean select  selection s get selection at offset caret int line select s null caret line s end line int new caret get line end offset line if select extend selection caret new caret else if multi select none move caret position new caret so that end followed by up arrow will always put caret at the end of the previous line for example set magic caret position  integer max value 
 moves the caret to the end of the code present on the current line before the comments and whitespace param select true if you want to extend selection since j edit pre public void go to end of code boolean select int line get caret line todo  should token handler be an  text area instance variable  default token handler token handler new  default token handler buffer mark tokens line token handler  token token token handler get tokens char txt get line text line to char array replace comments with whitespace to find end of code while true if token id  token comment token id  token comment token id  token comment token id  token comment for int i token offset i token offset token length i txt i if token next null break token token next int new caret get line length line  standard utilities get trailing white space new  string txt new caret get line start offset line if select extend selection caret new caret else if multi select none move caret position new caret 
 moves the caret to the first non whitespace character of the current line param select true if you want to extend selection since j edit pre public void go to start of white space boolean select  selection s get selection at offset caret int line offset if select s null line caret line offset caret buffer get line start offset line else line s start line offset s start buffer get line start offset line int first indent chunk cache get subregion start offset line offset if first indent get line start offset line first indent  standard utilities get leading white space get line text line if first indent get line length line first indent first indent get line start offset line if select extend selection caret first indent else if multi select none move caret position first indent 
 moves the caret to the last non whitespace character of the current line param select true if you want to extend selection since j edit pre public void go to end of white space boolean select  selection s get selection at offset caret int line offset if select s null line caret line offset caret get line start offset line else line s end line offset s end get line start offset line int last indent chunk cache get subregion end offset line offset if last indent get line end offset line last indent get line length line  standard utilities get trailing white space get line text line if last indent last indent get line length line last indent get line start offset line else last indent if select extend selection caret last indent else if multi select none move caret position last indent 
 moves the caret to the first visible line param select true if you want to extend selection since j edit pre public void go to first visible line boolean select int first visible line get first line electric scroll int first visible get screen line start offset first visible line if first visible first visible get line start offset display manager get first visible line if select extend selection caret first visible else if multi select none move caret position first visible 
 moves the caret to the last visible line param select true if you want to extend selection since j edit pre public void go to last visible line boolean select int last visible if get first line visible lines display manager get scroll line count last visible get line end offset display manager get last visible line else last visible visible lines electric scroll if last line partial last visible if last visible last visible last visible get screen line end offset last visible if last visible last visible get line end offset display manager get last visible line if select extend selection caret last visible else if multi select none move caret position last visible 
 moves the caret to the beginning of the buffer param select true if you want to extend selection since j edit pre public void go to buffer start boolean select int start buffer get line start offset display manager get first visible line if select extend selection caret start else if multi select none move caret position start 
 moves the caret to the end of the buffer param select true if you want to extend selection since j edit pre public void go to buffer end boolean select int end buffer get line end offset display manager get last visible line if select extend selection caret end else if multi select none move caret position end 
 moves the caret to the bracket matching the one before the caret since j edit pre public void go to matching bracket if get line length caret line int dot caret get line start offset caret line int bracket  text utilities find matching bracket buffer caret line  math max dot if bracket select none move caret position bracket false return get toolkit beep 
 handles the insertion of the specified character  it performs the following operations above and beyond simply inserting the text ul li  inserting a tab with a selection will shift to the right li  inserting a back space or a delete will remove a character li  inserting an indent open close bracket will re indent the current line as necessary ul param ch  the character see set selected text  string see is overwrite enabled since j edit pre public void user input char ch if is editable get toolkit beep return  null before add notify if hidden cursor null get painter set cursor hidden cursor switch ch case t user input tab break case b backspace break case u f delete break default boolean indent buffer is electric key ch caret line  string str  string value of ch if get selection count if do word wrap ch insert str indent else replace selection str break 
 returns true if overwrite mode is enabled false otherwise public final boolean is overwrite enabled return overwrite 
 sets overwrite mode public final void set overwrite enabled boolean overwrite blink true caret timer restart this overwrite overwrite invalidate line caret line fire status changed  status listener overwrite changed overwrite 
 toggles overwrite mode since j edit pre public final void toggle overwrite enabled set overwrite enabled overwrite 
 deletes the character before the caret or the selection if one is active since j edit pre public void backspace delete false 
 deletes the word before the caret since j edit pre public void backspace word backspace word false 
 deletes the word before the caret param eat whitespace  if true will eat whitespace since j edit pre public void backspace word boolean eat whitespace if buffer is editable get toolkit beep return if get selection count set selected text return int line start get line start offset caret line int  caret caret line start  string line text get line text caret line if  caret if line start get toolkit beep return  caret else  string no word sep buffer get string property no word sep boolean camel cased words buffer get boolean property camel cased words  caret  text utilities find word start line text  caret no word sep true camel cased words eat whitespace buffer remove  caret line start caret  caret line start 
 deletes the character after the caret since j edit pre public void delete delete true 
 deletes from the caret to the end of the current line since j edit pre public void delete to end of line if buffer is editable get toolkit beep return buffer remove caret get line end offset caret line caret 
 deletes the line containing the caret since j edit pre public void delete line if buffer is editable get toolkit beep return int x chunk cache subregion offset to x caret line caret get line start offset caret line int lines get selected lines try buffer begin compound edit for int i lines length i i int start get line start offset lines i int end get line end offset lines i if end buffer get length if start start end buffer remove start end start finally buffer end compound edit int last line display manager get last visible line if caret line last line int offset chunk cache x to subregion offset last line x true set caret position buffer get line start offset last line offset else int offset chunk cache x to subregion offset caret line x true set caret position get line start offset caret line offset 
 deletes the paragraph containing the caret since j edit pre public void delete paragraph if buffer is editable get toolkit beep return find the beginning of the paragraph int start for int i caret line i i if line contains space and tabs i start get line start offset i break  find the end of the paragraph int end buffer get length for int i caret line i get line count i if display manager is line visible i continue loop if line contains space and tabs i end get line end offset i break buffer remove start end start 
 deletes from the caret to the beginning of the current line since j edit pre public void delete to start of line if buffer is editable get toolkit beep return buffer remove get line start offset caret line caret get line start offset caret line 
 deletes the word in front of the caret since j edit pre public void delete word delete word false 
 deletes the word in front of the caret param eat whitespace  if true will eat whitespace since j edit pre public void delete word boolean eat whitespace if buffer is editable get toolkit beep return if get selection count set selected text return int line start get line start offset caret line int  caret caret line start  string line text get line text caret line if  caret line text length if line start  caret buffer get length get toolkit beep return  caret else  string no word sep buffer get string property no word sep boolean camel cased words buffer get boolean property camel cased words  caret  text utilities find word end line text  caret no word sep true camel cased words eat whitespace buffer remove caret  caret line start caret 
 returns if multiple selection is enabled since j edit pre public final boolean is multiple selection enabled return multi 
 toggles multiple selection since j edit pre public final void toggle multiple selection enabled set multiple selection enabled multi 
 set multiple selection on or off according to the value of code multi code  this only affects the ability to make multiple selections in the user interface macros and plugins can manipulate them regardless of the setting of this flag  in fact in most cases calling this method should not be necessary param multi  should multiple selection be enabled since j edit pre public final void set multiple selection enabled boolean multi this multi multi fire status changed  status listener multi select changed multi painter repaint 
 returns if rectangular selection is enabled since j edit pre public final boolean is rectangular selection enabled return rectangular selection mode 
 toggles rectangular selection since j edit pre public final void toggle rectangular selection enabled set rectangular selection enabled rectangular selection mode if get selection count  selection s get selection remove from selection s if rectangular selection mode add to selection new  selection  rect s get start s get end else add to selection new  selection  range s get start s get end 
 set rectangular selection on or off according to the value of code rectangular selection mode code  this only affects the ability to make multiple selections from the keyboard a rectangular selection can always be created by dragging with the mouse by holding down b  control b regardless of the state of this flag param rectangular selection mode  should rectangular selection be enabled since j edit pre public final void set rectangular selection enabled boolean rectangular selection mode this rectangular selection mode rectangular selection mode fire status changed  status listener rect select changed rectangular selection mode painter repaint 
 moves the caret to the fold containing the one at the caret position since j edit pre public void go to parent fold int line int level buffer get fold level caret line for int i caret line i i if buffer get fold level i level line i break if line get toolkit beep return int magic get magic caret position int new caret buffer get line start offset line chunk cache x to subregion offset line magic true if multi select none move caret position new caret set magic caret position magic 
 moves the caret to the next fold param select true if you want to extend selection since j edit pre public void go to next fold boolean select int next fold for int i caret line i buffer get line count i if buffer is fold start i display manager is line visible i next fold i break if next fold get toolkit beep return int magic get magic caret position int new caret buffer get line start offset next fold chunk cache x to subregion offset next fold magic true if select extend selection caret new caret else if multi select none move caret position new caret set magic caret position magic 
 moves the caret to the previous fold param select true if you want to extend selection since j edit pre public void go to prev fold boolean select int prev fold for int i caret line i i if buffer is fold start i display manager is line visible i prev fold i break if prev fold get toolkit beep return int magic get magic caret position int new caret buffer get line start offset prev fold chunk cache x to subregion offset prev fold magic true if select extend selection caret new caret else if multi select none move caret position new caret set magic caret position magic 
 like link  display manager collapse fold int but also moves the caret to the first line of the fold since j edit pre public void collapse fold collapse fold caret line 
 like link  display manager collapse fold int but also moves the caret to the first line of the fold since j edit pre public void collapse fold int line int x chunk cache subregion offset to x caret line caret get line start offset caret line display manager collapse fold line if display manager is line visible caret line return line display manager get prev visible line caret line if multi cannot use select none beacause the finish caret update method will reopen the fold invalidate selected lines selection manager set selection  selection null move caret position buffer get line start offset line chunk cache x to subregion offset line x true 
 like link  display manager expand fold int boolean but also moves the caret to the first sub fold param fully  if true all subfolds will also be expanded since j edit pre public void expand fold boolean fully int x chunk cache subregion offset to x caret line caret get line start offset caret line int line display manager expand fold caret line fully if fully line if multi select none move caret position get line start offset line chunk cache x to subregion offset line x true 
 selects the fold that contains the caret line number since j edit pre public void select fold select fold caret line 
 selects the fold that contains the specified line number param line  the line number since j edit pre public void select fold int line int lines buffer get fold at line line int new caret get line end offset lines  selection s new  selection  range get line start offset lines new caret if multi add to selection s else set selection s move caret position new caret 
 hides all lines except those in the fold containing the caret since j edit pre public void narrow to fold int lines buffer get fold at line caret line if lines lines buffer get line count get toolkit beep else display manager narrow lines lines 
 hides all lines except those in the selection since j edit pre public void narrow to selection if get selection count get toolkit beep return  selection sel get selection display manager narrow sel get start line sel get end line select none 
 surrounds the selection with explicit fold markers throws  text area exception an exception thrown if the folding mode is not explicit since j edit pre public void add explicit fold throws  text area exception if buffer is editable get toolkit beep return if buffer get string property folding equals explicit throw new  text area exception folding not explicit try buffer begin compound edit if get selection count add explicit fold caret caret caret line caret line else  selection selections get selection  selection selection null int caret back for int i i selections length i selection selections i caret back add explicit fold selection start selection end selection start line selection end line  selection cannot be null because there is at least selection assert selection null set caret position selection start caret back false finally buffer end compound edit 
 prepends each line of the selection with the line comment string since j edit pre public void line comment if buffer is editable get toolkit beep return  string comment buffer get context sensitive property caret line comment if comment null comment length range line comment return comment buffer begin compound edit int lines get selected lines try for int i i lines length i  string text get line text lines i buffer insert get line start offset lines i  standard utilities get leading white space text comment finally buffer end compound edit select none 
 adds comment start and end strings to the beginning and end of the selection since j edit pre public void range comment  string comment start buffer get context sensitive property caret comment start  string comment end buffer get context sensitive property caret comment end if buffer is editable comment start null comment end null comment start length comment end length get toolkit beep return comment start comment end comment end try buffer begin compound edit  selection selection get selection if selection length int old caret caret buffer insert caret comment start buffer insert caret comment end set caret position old caret comment start length for int i i selection length i  selection s selection i if s instanceof  selection  range buffer insert s start comment start buffer insert s end comment end else if s instanceof  selection  rect  selection  rect rect  selection  rect s int start rect get start column buffer int end rect get end column buffer for int j s start line j s end line j buffer insert at column j end comment end buffer insert at column j start comment start select none finally buffer end compound edit 
 formats the paragraph containing the caret since j edit pre public void format paragraph throws  text area exception if buffer is editable get toolkit beep return if max line len throw new  text area exception format maxlinelen  selection selection get selection if selection length buffer begin compound edit for int i i selection length i  selection s selection i set selected text s  text utilities format get selected text s max line len buffer get tab size buffer end compound edit else int line no get caret line int start end buffer get length for int i line no i i if line contains space and tabs i start get line end offset i break for int i line no i get line count i if line contains space and tabs i end get line start offset i break try buffer begin compound edit  string text buffer get text start end start int offset get caret position start int no space offset  text utilities index ignoring whitespace text offset buffer remove start end start text  text utilities format text max line len buffer get tab size buffer insert start text int caret pos start if text length caret pos  math min text length  text utilities ignoring whitespace index text no space offset move caret position caret pos finally buffer end compound edit 
 converts spaces to tabs in the selection since j edit pre public void spaces to tabs  selection selection get selection if buffer is editable get toolkit beep return buffer begin compound edit if selection length set text  text utilities spaces to tabs get text buffer get tab size else for int i i selection length i  selection s selection i set selected text s  text utilities spaces to tabs get selected text s buffer get tab size buffer end compound edit 
 converts tabs to spaces in the selection since j edit pre public void tabs to spaces  selection selection get selection if buffer is editable get toolkit beep return buffer begin compound edit if selection length set text  text utilities tabs to spaces get text buffer get tab size else for int i i selection length i  selection s selection i set selected text s  text utilities tabs to spaces get selected text s buffer get tab size buffer end compound edit 
 converts the selected text to upper case since j edit pre public void to upper case if buffer is editable get toolkit beep return  selection selection get selection int caret if selection length caret get caret position select word selection get selection if selection length if caret set caret position caret get toolkit beep return buffer begin compound edit for int i i selection length i  selection s selection i set selected text s get selected text s to upper case buffer end compound edit if caret set caret position caret 
 converts the selected text to lower case since j edit pre public void to lower case if buffer is editable get toolkit beep return  selection selection get selection int caret if selection length caret get caret position select word selection get selection if selection length if caret set caret position caret get toolkit beep return buffer begin compound edit for int i i selection length i  selection s selection i set selected text s get selected text s to lower case buffer end compound edit if caret set caret position caret 
 removes trailing whitespace from all lines in the selection since j edit pre public void remove trailing white space if buffer is editable get toolkit beep else buffer remove trailing white space get selected lines 
public void insert enter and indent if is editable get toolkit beep else try buffer begin compound edit set selected text n buffer indent line caret line true finally buffer end compound edit 
public void insert tab and indent if is editable get toolkit beep return if get selection count if caret is inside leading whitespace indent  char sequence text buffer get line segment caret line int start buffer get line start offset caret line int white space  standard utilities get leading white space text if caret start white space buffer indent line caret line false return user input t 
 indents all selected lines since j edit pre public void indent selected lines if buffer is editable get toolkit beep else buffer indent lines get selected lines select none 
 shifts the indent to the left since j edit pre public void shift indent left if buffer is editable get toolkit beep else buffer shift indent left get selected lines 
 shifts the indent to the right since j edit pre public void shift indent right if buffer is editable get toolkit beep else buffer shift indent right get selected lines 
 joins the current and the next line or joins all lines in selections since j edit pre public void join lines if buffer is editable get toolkit beep return try buffer begin compound edit boolean done for selection false for  selection selection selection manager get selection while selection start line selection end line  edit from end of selection to minimize invalidations and recaluculations of cached line info such as indent level or fold level join line at selection end line done for selection true  if nothing selected or all selections span only one line join the line at the caret if done for selection int end get line end offset caret line  nothing to do if the caret is on the last line if end buffer get length get toolkit beep return join line at caret line if multi select none move caret position end finally buffer end compound edit 
 adds a component to the left side of the box left of the vertical scroll bar  the  error list plugin uses this to show a global error overview for example  it is possible for more than one component to be added each is added to the left side of the box in turn  adding to the left ensures the scrollbar is always right of all added components param comp  the component since j edit pre public void add left of scroll bar  component comp vertical box add comp 
 removes a component from the box left of the vertical scroll bar param comp  the component since j edit pre public void remove left of scroll bar  component comp vertical box remove comp 
 called by the awt when this component is added to a parent  adds document listener  override public void add notify super add notify  tool tip manager shared instance register component painter  tool tip manager shared instance register component gutter recalculate visible lines if buffer is loading recalculate last physical line properties changed hidden cursor get toolkit create custom cursor get graphics configuration create compatible image  transparency bitmask new  point  hidden 
 called by the awt when this component is removed from it s parent  this clears the pointer to the currently focused component  also removes document listener  override public void remove notify super remove notify  tool tip manager shared instance unregister component painter  tool tip manager shared instance unregister component gutter if focused component this focused component null caret timer stop 
 java compatibility fix to make  tab key work since j edit pre  override public boolean get focus traversal keys enabled return false 
 java compatibility fix to make  tab traversal work in a sane manner since j edit pre public boolean get focus cycle root return true 
 override public void process key event  key event evt get input handler process key event evt source textarea false if evt is consumed super process key event evt 
 adds a component above the gutter text area and vertical scroll bar since j edit pre public void add top component  component comp add  scroll layout top comp 
 removes a component from above the gutter text area and vertical scroll bar since j edit pre public void remove top component  component comp remove comp 
 override public  input method requests get input method requests if input method support null input method support new  input method support this  log log  log debug this  input method support is activated return input method support 
 adds a scroll listener to this text area param listener  the listener since j edit pre public final void add status listener  status listener listener listener list add  status listener class listener 
 removes a scroll listener from this text area param listener  the listener since j edit pre public final void remove status listener  status listener listener listener list remove  status listener class listener 
 called by j edit when necessary  plugins should not call this method public void properties changed if buffer null return int  tab size buffer get tab size char foo new char  tab size for int i i foo length i foo i tab size painter get string width new  string foo char width int  math round painter get font get string bounds foo painter get font render context get width  string old wrap wrap wrap buffer get string property wrap hard wrap wrap equals hard soft wrap wrap equals soft boolean old wrap to width wrap to width int old wrap margin wrap margin set max line length buffer get integer property max line len boolean wrap settings changed wrap equals old wrap old wrap to width wrap to width old wrap margin wrap margin if display manager null buffer changing buffer is loading wrap settings changed display manager invalidate screen line counts display manager notify screen line changes chunk cache invalidate all gutter repaint painter repaint 
 adds a new action set to the textarea s list of  action sets  call this only on standalone textarea param action set the action set to add since j edit pre public void add action set j edit action set j edit bean shell action action set action context add action set action set 
deprecated  do not use  deprecated public final int get mark position  selection s get selection at offset caret if s null return caret if s start caret return s end else if s end caret return s start else return caret 
deprecated  do not use  deprecated public final int get mark line if get selection count return caret line  selection s get selection if s start caret return s end line else if s end caret return s start line else return caret line 
 returns true if the caret is visible false otherwise final boolean is caret visible return blink has focus 
 returns true if the structure highlight is visible false otherwise since j edit pre final boolean is structure highlight visible return match null has focus display manager is line visible match start line display manager is line visible match end line 
void update max horizontal scroll width int max chunk cache get max horizontal scroll width if max max horizontal scroll width max horizontal scroll width max horizontal set values  math max  math min max horizontal scroll width char width painter get width horizontal offset painter get width max horizontal scroll width char width horizontal set unit increment horizontal set block increment painter get width else if horizontal get value horizontal offset horizontal set value horizontal offset 
void recalculate visible lines if painter null return int height painter get height int line height painter get font metrics get height if line height visible lines else if height visible lines last line partial false else visible lines height line height last line partial height line height if last line partial visible lines chunk cache recalculate visible lines this does the trick to eliminate blank space at the end if display manager null buffer null buffer is loading set first line get first line update scroll bar 
void fold structure changed chunk cache invalidate all recalculate last physical line repaint 
 updates the state of the scroll bars  this should be called if the number of lines in the buffer changes or when the size of the text are changes void update scroll bar if buffer null return if  debug scroll debug  log log  log debug this update scroll bar slc display manager get scroll line count if vertical null visible lines if  debug scroll debug  log log  log debug this  vertical ok int line count display manager get scroll line count int first line get first line int visible visible lines last line partial vertical set values first line visible line count vertical set unit increment vertical set block increment visible 
void  finish caret update if queued caret update return try if match null if old caret line match start line invalidate line range old caret line match end line else invalidate line range match start line old caret line match null int new caret screen line chunk cache get screen line of offset caret line caret buffer get line start offset caret line if caret screen line invalidate screen line range new caret screen line new caret screen line else invalidate screen line range caret screen line new caret screen line caret screen line new caret screen line invalidate selected lines  when the user is typing etc we don t want the caret to blink blink true caret timer restart if display manager is line visible caret line if caret line display manager get first visible line caret line display manager get last visible line int collapse folds buffer get integer property collapse folds if collapse folds display manager expand folds collapse folds display manager expand fold caret line false else display manager expand all folds else display manager expand fold caret line false if queued scroll mode electric scroll scroll to caret true else if queued scroll mode normal scroll scroll to caret false update bracket highlight with delay if queued fire caret event fire caret event in case one of the above fails we still want to clear these flags finally queued caret update queued fire caret event false queued scroll mode no scroll 
void invalidate structure match if match null invalidate line range match start line match end line 
void start drag and drop  input event evt boolean copy  transfer handler transfer handler get transfer handler if transfer handler null  log log  log debug this  drag and drop callback transfer handler export as drag this evt copy  transfer handler copy  transfer handler move 
void fire narrow active  object listeners listener list get listener list for int i listeners length i i if listeners i  status listener class try  status listener listeners i narrow active this catch  throwable t  log log  log error this t 
 sets the horizontal offset of drawn lines  this method will check if the offset do not go too far after the last character param horizontal offset offset  the new horizontal offset private void  set horizontal offset int horizontal offset if horizontal offset horizontal offset if horizontal offset this horizontal offset return  scrolling with trackpad or other device should be kept inside bounds int min  math min max horizontal scroll width char width painter get width if horizontal offset min horizontal offset min set horizontal offset horizontal offset 
 repaints the lines containing the selection private void invalidate selected lines to hide line highlight if selections are being added later on invalidate line caret line for  selection s selection manager selection invalidate line range s start line s end line 
the collapsing of scrolling event firing inside compound edits greatly speeds up replace all private void finish caret update int old caret line int scroll mode boolean fire caret event queued fire caret event fire caret event queued scroll mode  math max scroll mode queued scroll mode if queued caret update return this old caret line old caret line queued caret update true if buffer is transaction in progress  finish caret update otherwise  display manager  buffer change handler calls 
private void fire caret event  object listeners listener list get listener list for int i listeners length i i if listeners i  caret listener class try  caret listener listeners i caret update caret event catch  throwable t  log log  log error this t 
private void fire scroll event boolean vertical  object listeners listener list get listener list for int i listeners length i i if listeners i  scroll listener class try if vertical  scroll listener listeners i scrolled vertically this else  scroll listener listeners i scrolled horizontally this catch  throwable t  log log  log error this t 
private void fire status changed int flag boolean value  object listeners listener list get listener list for int i listeners length i i if listeners i  status listener class try  status listener listeners i status changed this flag value catch  throwable t  log log  log error this t 
private void fire bracket selected int line  string text  object listeners listener list get listener list for int i listeners length i i if listeners i  status listener class try  status listener listeners i bracket selected this line text catch  throwable t  log log  log error this t 
private void  change line boolean select int new caret if select  rect params params get rect params caret new caret int extra start virt int extra end virt if params null extra start virt extra end virt else extra start virt params extra start virt extra end virt params extra end virt new caret params new caret extend selection caret new caret extra start virt extra end virt else if multi select none move caret position new caret 
 check if the line contains only spaces and tabs param line index the line index return code true code if the line contains only spaces and tabs private boolean line contains space and tabs int line index get line text line index line segment for int j j line segment count j switch line segment array line segment offset j case case t break default return false return true 
protected void insert  string str boolean indent try  don t overstrike if we re on the end of the line if overwrite indent buffer begin compound edit if overwrite int caret line end get line end offset caret line if caret line end caret buffer remove caret buffer insert caret str if indent buffer indent line caret line true finally if overwrite indent buffer end compound edit 
private void insert tab int tab size buffer get tab size if buffer get boolean property no tabs int line start get line start offset caret line  string line get text line start caret line start int pos for int i i line length i switch line char at pos case t pos break default if pos tab size pos break replace selection  standard utilities create white space tab size pos else replace selection t 
protected void user input tab if get selection count  selection sel get selection if sel instanceof  selection  rect sel start line sel end line sel start buffer get line start offset sel start line sel end buffer get line end offset sel start line insert tab else shift indent right else if get selection count shift indent right else insert tab 
 does hard wrap protected boolean do word wrap boolean space inserted if hard wrap max line len return false buffer get line text caret line line segment int start get line start offset caret line int end get line end offset caret line int len end start int caret pos caret start only wrap if we re at the end of a line or the rest of the line text is whitespace for int i caret pos i len i char ch line segment array line segment offset i if ch ch t return false int tab size buffer get tab size  string word break chars buffer get string property word break chars int last in line last character before wrap int logical length length with tabs expanded int last word offset boolean last was space true for int i i caret pos i char ch line segment array line segment offset i if ch t logical length tab size logical length tab size if last was space logical length max line len last in line i last word offset i last was space true else if ch logical length if last was space logical length max line len last in line i last word offset i last was space true else if word break chars null word break chars index of ch logical length if last was space logical length max line len last in line i last word offset i last was space true else last in line i logical length last was space false boolean return value int insert new line at if space inserted logical length max line len last in line caret pos insert new line at caret pos return value true else if logical length max line len last word offset insert new line at last word offset return value false else return false try buffer begin compound edit buffer insert start insert new line at n caret line would have been incremented since insert new line at caret pos buffer indent line caret line true finally buffer end compound edit only ever return true if space was pressed with logical length max line len return return value 
private static void update bracket highlight with delay structure timer stop structure timer start 
private void update structure highlight if painter is structure highlight enabled gutter is structure highlight enabled return for  structure matcher matcher structure matchers match matcher get match this if match null break if match null if caret line match start line invalidate line range caret line match end line else invalidate line range match start line caret line if display manager is line visible match start line chunk cache get screen line of offset match start line match start get line start offset match start line show structure status message match start line caret line 
private void show structure status message boolean backward  string text buffer get line text match start line trim if backward match start line text length switch text char at case case case case case case text buffer get line text match start line trim text break get rid of embedded tabs not removed by trim fire bracket selected match start line text replace t 
void recalculate last physical line int old screen last line screen last line for int i visible lines i i  chunk cache  line info info chunk cache get line info i if info physical line phys last line info physical line screen last line i break invalidate screen line range old screen last line screen last line 
 rect params int extra start virt int extra end virt int new caret this extra start virt extra start virt this extra end virt extra end virt this new caret new caret 
 used when doing s up down to simplify dealing with virtual space private  rect params get rect params int caret int new caret  selection s get selection at offset caret int virtual width if s instanceof  selection  rect if caret s end virtual width buffer get virtual width s end line s end get line start offset s end line  selection  rect s extra end virt else virtual width buffer get virtual width s start line s start get line start offset s start line  selection  rect s extra start virt else if rectangular selection mode virtual width buffer get virtual width caret line caret buffer get line start offset caret line else return null int new line get line of offset new caret int total virtual width new int int new offset buffer get offset of virtual column new line virtual width total virtual width if new offset int extra virt virtual width total virtual width new caret get line end offset new line boolean bias if s null bias new caret caret else if s start caret bias new caret s end else if s end caret bias new caret s start else bias false  rect params return value if bias return value new  rect params extra virt new caret else return value new  rect params extra virt new caret return return value else return new  rect params get line start offset new line new offset 
private void delete boolean forward if buffer is editable get toolkit beep return if get selection count  selection selections get selection for int i i selections length i  selection s selections i if s instanceof  selection  rect  selection  rect r  selection  rect s int start column r get start column buffer if start column r get end column buffer if forward start column get toolkit beep else tall caret delete r forward else set selected text s null else set selected text s null else if forward if caret buffer get length get toolkit beep return buffer remove caret else if caret get toolkit beep return buffer remove caret 
private void tall caret delete  selection  rect s boolean forward try buffer begin compound edit int width new int int start col s get start column buffer int start line s start line int end line s end line for int i start line i end line i int offset buffer get offset of virtual column i start col width if offset if width start col offset get line length i else if i start line forward shift tall caret left s continue offset buffer get line start offset i if forward if offset buffer get line end offset i buffer remove offset else buffer remove offset finally buffer end compound edit 
private void shift tall caret left  selection  rect s remove from selection s add to selection new  selection  rect buffer s get start line s get start column buffer s get end line s get end column buffer 
private void set max line length int max line len this max line len max line len if max line len if soft wrap wrap to width true wrap margin painter get width char width else wrap to width false wrap margin else stupidity char foo new char max line len for int i i foo length i foo i wrap to width false wrap margin int painter get font get string bounds foo foo length painter get font render context get width 
 add an explicit fold  you should call this method inside a compound edit in the buffer  you must also check if the buffer fold mode is explicit before calling this method param caret start the starting offset param caret end the end offset param line start the start line param line end the end line since j edit pre protected int add explicit fold int caret start int caret end int line start int line end need to fix the caret position so that we get the right rule taking the start offset one char ahead and the end offset one char behing makes sure we get the right rule for the text being wrapped tricky around mode boundaries e g php code embedded in html code int start caret caret start buffer get length caret start caret start int end caret caret end caret end caret end  string start line comment buffer get context sensitive property start caret line comment  string start comment start buffer get context sensitive property start caret comment start  string start comment end buffer get context sensitive property start caret comment end  string end line comment buffer get context sensitive property end caret line comment  string end comment start buffer get context sensitive property end caret comment start  string end comment end buffer get context sensitive property end caret comment end  string start int caret back if start line comment null start start line comment else if start comment start null start comment end null start start comment start start comment end caret back start comment start length else start if start line comment null add a new line if there s text after the comment we re inserting if buffer get line length line start caret start start n else always insert a new line if there s no comment character start n  string end if end line comment null end end line comment else if end comment start null end comment end null end end comment start end comment end else end  string line buffer get line text line start  string whitespace line substring  standard utilities get leading white space line if end line comment null if we re inserting a line comment into a non empty line we ll need to add a line break so we don t comment out existing code if buffer get line length line end caret end end n else always insert a new line if there s no comment character end n if caret end buffer get line start offset line end buffer insert caret end end else  char sequence line text buffer get segment caret end if  character is whitespace line text char at buffer insert caret end end else buffer insert caret end end buffer insert caret start start whitespace return caret back 
 this method will surround each selected line with a range comment  this is used when calling line comment if the edit mode doesn t have a line comment property since j edit pre private void range line comment  string comment start buffer get context sensitive property caret comment start  string comment end buffer get context sensitive property caret comment end if buffer is editable comment start null comment end null comment start length comment end length get toolkit beep return comment start comment end comment end try buffer begin compound edit int lines get selected lines for int i i lines length i  string text get line text lines i if text trim length continue buffer insert get line end offset lines i comment end buffer insert get line start offset lines i  standard utilities get leading white space text comment start finally buffer end compound edit 
 join a line with the next line  if you use this method you have to lock the buffer in compound edit mode param line the line number that will be joined with the next line private void join line at int line if line buffer get line count return int end get line end offset line  char sequence next line text buffer get line segment line buffer remove end  standard utilities get leading white space next line text if next line text length buffer insert end 
 returns if the right click popup menu is enabled  the  gestures plugin uses this api since j edit pre public boolean is right click popup enabled return popup enabled 
 sets if the right click popup menu is enabled  the  gestures plugin uses this api since j edit pre public void set right click popup enabled boolean popup enabled this popup enabled popup enabled 
 returns the right click popup menu public final j popup menu get right click popup return popup 
 sets the right click popup menu param popup  the popup public final void set right click popup j popup menu popup this popup popup 
 do the same thing as right clicking on the text area  the  gestures plugin uses this api since j edit pre public void handle popup trigger  mouse event evt  rebuild popup menu every time the menu is requested create popup menu evt int x evt get x int y evt get y int drag start xy to offset x y painter is block caret enabled is overwrite enabled if get selection count multi move caret position drag start false show popup menu popup this x y false 
 creates the popup menu since pre public void create popup menu  mouse event evt if popup null popup new j popup menu 
 shows the popup menu below the current caret position since pre public void show popup menu if popup is visible has focus  point caret pos offset to xy get caret position if caret pos null  open the context menu below the caret int char height get painter get font metrics get height show popup menu popup painter caret pos x caret pos y char height true 
 shows the specified popup menu ensuring it is displayed within the bounds of the screen param popup  the popup menu param comp  the component to show it for param x  the x co ordinate param y  the y co ordinate param point  if true then the popup originates from a single point otherwise it will originate from the component itself  this affects positioning in the case where the popup does not fit onscreen since j edit pre private static void show popup menu j popup menu popup  component comp int x int y boolean point int offset x int offset y int extra offset point  component win comp while win instanceof  window win null offset x win get x offset y win get y win win get parent if win null  dimension size popup get preferred size  rectangle screen size  graphics environment get local graphics environment get maximum window bounds if x offset x size width win get x screen size width x offset x win get x size width  system err println x overflow if point x size width extra offset else x win get width size width offset x extra offset else x extra offset  system err println y y offset y offset y size height size height win height win get height if y offset y size height win get y screen size height y offset y win get y size height if point y win get height size height offset y extra offset else y size height else y extra offset popup show comp x y else popup show comp x extra offset y extra offset 
public void action performed  action event evt if focused component null focused component has focus focused component blink caret 
 mutable caret event super  text area this 
 override public int get dot return get caret position 
 override public int get mark return get mark position 
public void adjustment value changed  adjustment event evt if scroll bars initialized return if evt get adjustable vertical set first line vertical get value else set horizontal offset horizontal get value 
public void focus gained  focus event evt if buffer changing return if match null if caret line match start line invalidate line range caret line match end line else invalidate line range match start line caret line else invalidate line caret line focused component  text area this 
public void focus lost  focus event evt if is showing return if match null if caret line match start line invalidate line range caret line match end line else invalidate line range match start line caret line else invalidate line caret line 
public void mouse wheel moved  mouse wheel event e move caret depending on pressed control keys  alt move cursor do not select  alt shift or control move cursor select shift scroll horizontally control scroll single line else scroll lines if e is alt down boolean select e is shift down e is control down if e get wheel rotation go to prev line select else go to next line select else if e get scroll type  mouse wheel event wheel block scroll if e is shift down  wheel orientation is reversed so we negate the charwidth  set horizontal offset get horizontal offset e get wheel rotation painter get width else if e get wheel rotation scroll down page else scroll up page else if e is control down e is shift down if e get wheel rotation scroll down page else scroll up page else if e is control down set first line get first line e get wheel rotation else if e get scroll type  mouse wheel event wheel unit scroll if e is shift down  set horizontal offset get horizontal offset char width e get units to scroll else set first line get first line e get units to scroll else if e is shift down  set horizontal offset get horizontal offset char width e get wheel rotation else set first line get first line e get wheel rotation 
public void paint border  component c  graphics g int x int y int width int height g translate x y g set color  metal look and feel get control dark shadow g draw rect width height g set color  metal look and feel get control highlight g draw line width width height g draw line height width height g set color  metal look and feel get control g draw line width width g draw line height height g translate x y 
public  insets get border insets  component c return new  insets 
public  text area dialog  frame frame  string title  string caption  icon icon  string text super frame title true init caption icon text 
public  text area dialog  frame frame  string name  throwable t this frame j edit get property name title j edit get property name message ui manager get icon  option pane error icon  misc utilities throwable to string t 
public  text area dialog  dialog frame  string title  string caption  icon icon  string text super frame title true init caption icon text 
public  text area dialog  dialog frame  string name  throwable t this frame j edit get property name title j edit get property name message ui manager get icon  option pane error icon  misc utilities throwable to string t 
private void init  string caption  icon icon  string text j panel content new j panel new  border layout content set border new  empty border set content pane content  box icon box new  box  box layout y axis icon box add new j label icon icon box add  box create glue content add  border layout west icon box j panel center panel new j panel new  border layout center panel add  border layout north gui utilities create multiline label caption j text area text area new j text area text area set text text text area set line wrap true text area set caret position center panel add  border layout center new j scroll pane text area content add  border layout center center panel  box buttons new  box  box layout x axis buttons add  box create glue j button ok new j button j edit get property common ok ok add action listener new  action handler buttons add ok buttons add  box create glue content add  border layout south buttons get root pane set default button ok pack set location relative to get parent set visible true 
public void ok dispose 
public void cancel dispose 
public void action performed  action event evt dispose 
 text area drop handler  text area text area this text area text area 
 override public void drag enter  drop target drag event dtde  log log  log debug this  drag enter saved buffer text area get buffer text area set drag in progress true text area get buffer begin compound edit saved caret text area get caret position 
 override public void drag over  drop target drag event dtde  point p dtde get location p  swing utilities convert point text area p text area get painter int pos text area xy to offset p x p y text area get painter is block caret enabled text area is overwrite enabled if pos text area move caret position pos  text area electric scroll 
 override public void drag exit  drop target event dtde  log log  log debug this  drag exit text area set drag in progress false text area get buffer end compound edit if text area get buffer saved buffer text area move caret position saved caret  text area electric scroll saved buffer null 
public void drop  drop target drop event dtde  log log  log debug this  drop text area set drag in progress false text area get buffer end compound edit saved buffer null 
public  text area exception  string msg super msg 
 paints a range of screen lines  the default implementation calls link paint valid line  graphics d int int int int int and link paint invalid line  graphics d int int param gfx a graphics context param first line  the first screen line param last line  the last screen line param physical lines  the list of physical line numbers  entries are if the screen line is out of range param start  an array of screen line start offsets param end  an array of screen line end offsets param y  the y co ordinate param line height  the line height since j edit pre public void paint screen line range  graphics d gfx int first line int last line int physical lines int start int end int y int line height for int i i physical lines length i int screen line i first line if physical lines i paint invalid line gfx screen line y else paint valid line gfx screen line physical lines i start i end i y y line height 
 called by the text area when the extension is to paint a screen line which has an associated physical line number in the buffer  note that since one physical line may consist of several screen lines due to soft wrap the start and end offsets of the screen line are passed in as well param gfx  the graphics context param screen line  the screen line number param physical line  the physical line number param start  the offset where the screen line begins from the start of the buffer param end  the offset where the screen line ends from the start of the buffer param y  the y co ordinate of the top of the line s bounding box since j edit pre public void paint valid line  graphics d gfx int screen line int physical line int start int end int y 
 called by the text area when the extension is to paint a screen line which is not part of the buffer  this can happen if the buffer is shorter than the height of the text area for example param gfx  the graphics context param screen line  the screen line number param y  the y co ordinate of the top of the line s bounding box since j edit pre public void paint invalid line  graphics d gfx int screen line int y 
 called by the text area when the mouse hovers over the location specified in the mouse event param x  the x co ordinate param y  the y co ordinate since j edit pre public  string get tool tip text int x int y return null 
protected  text area input handler  text area text area this text area text area bindings current bindings new  hashtable 
 forwards key events directly to the input handler  this is slightly faster than using a  key listener because some  swing overhead is avoided param evt the keyboard event param from the source of the event  since this is the input handler of the textarea it should always be param global it is only true if the event comes from the  default keyboard focus manager since pre  override public void process key event  key event evt int from boolean global if  debug dump key events  log log  log debug this  key event to string evt from from  log log  log debug this view is focused view is focused new  exception evt  preprocess key event evt if evt null return if  debug dump key events  log log  log debug this  key event after workaround to string evt from from boolean focus on text area false switch evt get id case  key event key typed if the user pressed eg c e n n in the search bar we want focus to go back there after the prefix is done if key event interceptor null key event interceptor key typed evt else if is prefix active text area has focus process key event key stroke handling evt from type global process key event sub focus on text area break case  key event key pressed if key event interceptor null key event interceptor key pressed evt else if  key event workaround is bindable evt get key code process key event key stroke handling evt from press global process key event sub focus on text area break case  key event key released if key event interceptor null key event interceptor key released evt break 
 this method returns if the keyboard event can be handled or not param evt the keyboard event return null if the keyboard event cannot be handled or the keyboard event itself otherwise private  key event  preprocess key event  key event evt if evt is consumed return null if  debug dump key events  log log  log debug this  key event preprocessing to string evt return  key event workaround process key event evt 
private void process key event sub boolean focus on text area this is a weird hack we don t want c e a to insert a in the search bar if the search bar has focus if is prefix active focus on text area text area request focus 
 invokes the specified action repeating and recording it as necessary param action  the action since j edit pre  override public void invoke action  string action invoke action get action action 
 invokes the specified action repeating and recording it as necessary param action  the action  override public void invoke action j edit bean shell action action j edit buffer buffer text area get buffer if buffer inside compound edit buffer end compound edit remember the last executed action if action no remember last if last action action last action count else last action action last action count remember old values in case action changes them int  repeat count repeat count execute the action if action no repeat  repeat count action invoke text area else try buffer begin compound edit for int i i  repeat count i action invoke text area finally buffer end compound edit  if repeat was true originally clear it  otherwise it might have been set by the action etc if  repeat count first of all if this action set a read next char do not clear the repeat if read next char null return repeat count 
 handles the given keystroke param key stroke  the key stroke param dry run only calculate the return value do not have any other effect since j edit pre  override public boolean handle key  key event translator  key key stroke boolean dry run char input if key stroke modifiers null key stroke modifiers equals s switch key stroke key case n case t input char key stroke key break default input key stroke input break if read next char null if input if dry run set current bindings bindings invoke read next char input repeat count return true else if dry run read next char null  object o current bindings get key stroke if o null if dry run  don t beep if the user presses some key we don t know about unless a prefix is active  otherwise it will beep when caps lock is pressed etc if current bindings bindings  toolkit get default toolkit beep f should be passed on but c e f shouldn t repeat count set current bindings bindings else if input if key stroke is from global context let user input be only local user input input else this is retarded excuse me while i drool and make stupid noises if  key event workaround is numeric keypad key stroke key  key event workaround numeric keypad key send shortcut prefix off else if o instanceof  hashtable if dry run set current bindings  hashtable o  shortcut prefix active event fire prefix state change current bindings true shortcut on true return true else if o instanceof  string if dry run set current bindings bindings send shortcut prefix off invoke action  string o return true else if o instanceof j edit bean shell action if dry run set current bindings bindings send shortcut prefix off invoke action j edit bean shell action o return true if dry run send shortcut prefix off return false 
protected void user input char ch last action count if repeat count text area user input ch repeat count 
protected void invoke read next char char ch  string char str  standard utilities chars to escapes  string value of ch this might be a bit slow if   char   occurs a lot int index while index read next char index of   char   read next char read next char substring index char str read next char substring index read next char null 
 text area mouse handler  text area text area this text area text area 
 override public void mouse pressed  mouse event evt show cursor control  operating system is mac os evt is meta down  operating system is mac os evt is control down ctrl for rectangular selection true so that  home mouse click  home is not the same as pressing  home twice in a row text area get input handler reset last action count quick copy drag text area is quick copy enabled is middle button evt get modifiers if quick copy drag text area request focus  text area focused component text area if text area get buffer is loading return int x evt get x int y evt get y drag start text area xy to offset x y text area get painter is block caret enabled text area is overwrite enabled drag start line text area get line of offset drag start drag start offset drag start text area get line start offset drag start line if is popup trigger evt text area is right click popup enabled text area handle popup trigger evt return dragged false text area blink true text area invalidate line text area get caret line click count evt get click count if text area is drag enabled text area selection manager inside selection x y click count evt is shift down maybe drag and drop true text area move caret position drag start false return maybe drag and drop false if quick copy drag ignore double clicks of middle button do single click evt else switch click count case do single click evt break case do double click break default case do triple click break 
protected void do single click  mouse event evt int x evt get x int extra end virt if text area chunk cache get line info text area get last screen line last subregion int drag start text area xy to offset x evt get y text area get painter is block caret enabled text area is overwrite enabled int screen line text area get screen line of offset drag start  chunk cache  line info line info text area chunk cache get line info screen line int offset text area get screen line end offset screen line if offset drag start line info last subregion offset float drag start line width text area offset to xy offset x if x drag start line width extra end virt int x drag start line width text area char width if text area get painter is block caret enabled text area is overwrite enabled x text area get horizontal offset text area char width text area char width extra end virt if control ctrl for rectangular selection text area is rectangular selection enabled text area is editable int screen line evt get y text area get painter get font metrics get height if screen line text area get last screen line screen line text area get last screen line  chunk cache  line info info text area chunk cache get line info screen line if info last subregion extra end virt control click in virtual space inserts whitespace and moves caret  string whitespace  standard utilities create white space extra end virt text area get buffer insert drag start whitespace drag start whitespace length if evt is shift down xxx get mark position deprecated text area resize selection text area get mark position drag start extra end virt text area is rectangular selection enabled control ctrl for rectangular selection if quick copy drag text area move caret position drag start false so that shift click drag works drag start line text area get mark line drag start text area get mark position drag start offset drag start text area get line start offset drag start line so that quick copy works dragged true return if quick copy drag text area move caret position drag start false if text area is multiple selection enabled quick copy drag text area select none 
protected void do double click  ignore empty lines if text area get line length drag start line return  string line text text area get line text drag start line  string no word sep text area get buffer get string property no word sep if drag start offset text area get line length drag start line drag start offset boolean join non word chars text area get join non word chars int word start  text utilities find word start line text drag start offset no word sep join non word chars false false int word end  text utilities find word end line text drag start offset no word sep join non word chars false false int line start text area get line start offset drag start line  selection sel new  selection  range line start word start line start word end if text area is multiple selection enabled text area add to selection sel else text area set selection sel if quick copy drag quick copy drag false text area move caret position line start word end false dragged true 
protected void do triple click int new caret text area get line end offset drag start line if drag start line text area get line count new caret  selection sel new  selection  range text area get line start offset drag start line new caret if text area is multiple selection enabled text area add to selection sel else text area set selection sel if quick copy drag quick copy drag false text area move caret position new caret false dragged true 
 override public void mouse moved  mouse event evt show cursor 
 override public void mouse dragged  mouse event evt if is popup trigger evt return if maybe drag and drop text area start drag and drop evt control return if text area is drag in progress return if text area get buffer is loading return  text area painter painter text area get painter if evt get y int delta  math min evt get y painter get font metrics get height text area set first line text area get first line delta else if evt get y painter get height int delta  math max evt get y painter get height painter get font metrics get height if text area last line partial delta text area set first line text area get first line delta switch click count case do single drag evt break case do double drag evt break default case do triple drag evt break 
private void do single drag  mouse event evt dragged true  text area painter painter text area get painter int x evt get x int y evt get y if y y else if y painter get height y painter get height int dot text area xy to offset x y painter is block caret enabled text area is overwrite enabled quick copy drag int dot line text area get line of offset dot int extra end virt if text area chunk cache get line info text area get last screen line last subregion int screen line text area get screen line of offset dot  chunk cache  line info line info text area chunk cache get line info screen line int offset text area get screen line end offset screen line if offset dot line info last subregion offset float dot line width text area offset to xy offset x if x dot line width extra end virt int x dot line width text area char width if painter is block caret enabled text area is overwrite enabled x text area get horizontal offset text area char width text area char width extra end virt text area resize selection drag start dot extra end virt text area is rectangular selection enabled control ctrl for rectangular selection if quick copy drag just scroll to the dragged location text area scroll to dot line dot text area get line start offset dot line false else if dot text area get caret position text area move caret position dot false if text area is rectangular selection enabled extra end virt text area scroll to dot line dot text area get line start offset dot line extra end virt false 
private void do double drag  mouse event evt int mark line start text area get line start offset drag start line int mark line length text area get line length drag start line int mark drag start offset  text area painter painter text area get painter int pos text area xy to offset evt get x  math max  math min painter get height evt get y painter is block caret enabled text area is overwrite enabled int line text area get line of offset pos int line start text area get line start offset line int line length text area get line length line int offset pos line start  string line text text area get line text line  string mark line text text area get line text drag start line  string no word sep text area get buffer get string property no word sep boolean join non word chars text area get join non word chars if mark line start drag start offset line start offset if offset offset line length offset  text utilities find word start line text offset no word sep join non word chars if mark line length mark  text utilities find word end mark line text mark no word sep join non word chars else if offset line length offset  text utilities find word end line text offset no word sep join non word chars if mark mark mark line length mark  text utilities find word start mark line text mark no word sep join non word chars if line start offset text area get caret position return text area resize selection mark line start mark line start offset false text area move caret position line start offset false dragged true 
private void do triple drag  mouse event evt  text area painter painter text area get painter int offset text area xy to offset evt get x  math max  math min painter get height evt get y false int mouse line text area get line of offset offset int mark int mouse if drag start line mouse line mark text area get line end offset drag start line if offset text area get line end offset mouse line mouse offset else mouse text area get line start offset mouse line else mark text area get line start offset drag start line if offset text area get line start offset mouse line mouse offset else if offset text area get line end offset mouse line mouse line text area get line count mouse text area get line end offset mouse line else mouse text area get line end offset mouse line mouse  math min text area get buffer get length mouse if mouse text area get caret position return text area resize selection mark mouse false text area move caret position mouse false dragged true 
 override public void mouse released  mouse event evt if dragged text area is quick copy enabled is middle button evt get modifiers text area request focus  text area focused component text area text area set caret position drag start false else if maybe drag and drop text area is multiple selection enabled text area select none dragged false 
 returns if the specified event is the popup trigger event  this implements precisely defined behavior as opposed to  mouse event is popup trigger param evt  the event since j edit pre public static boolean is popup trigger  mouse event evt return is right button evt get modifiers 
param modifiers  the modifiers flag from a mouse event return true if the modifier match the middle button since j edit pre public static boolean is middle button int modifiers if  operating system is mac os if modifiers  input event button  mask return modifiers  input event alt mask else return modifiers  input event button  mask else return modifiers  input event button  mask 
param modifiers  the modifiers flag from a mouse event return true if the modifier match the right button since j edit pre public static boolean is right button int modifiers if  operating system is mac os if modifiers  input event button  mask return modifiers  input event ctrl mask else return modifiers  input event button  mask else return modifiers  input event button  mask 
protected void show cursor text area get painter set cursor  cursor get predefined cursor  cursor text cursor 
public  text area option pane super textarea 
public void  init  font font new  font selector j edit get font property view font add component j edit get property options textarea font font  text color add component j edit get property options textarea foreground foreground color new  color well button j edit get color property view fg color  grid bag constraints vertical  background color add component j edit get property options textarea background background color new  color well button j edit get color property view bg color  grid bag constraints vertical  caret color caret blink block caret blink caret new j check box j edit get property options textarea blink caret blink caret set selected j edit get boolean property view caret blink block caret new j check box j edit get property options textarea block caret block caret set selected j edit get boolean property view block caret thick caret new j check box j edit get property options textarea thick caret thick caret set selected j edit get boolean property view thick caret  box caret settings new  box  box layout x axis caret settings add new j label j edit get property options textarea caret caret settings add  box create horizontal strut caret settings add blink caret caret settings add block caret caret settings add thick caret add component caret settings caret color new  color well button j edit get color property view caret color  grid bag constraints vertical  selection color add component j edit get property options textarea selection selection color new  color well button j edit get color property view selection color  grid bag constraints vertical  multiple selection color add component j edit get property options textarea multiple selection multiple selection color new  color well button j edit get color property view multiple selection color  grid bag constraints vertical  line highlight line highlight new j check box j edit get property options textarea line highlight line highlight set selected j edit get boolean property view line highlight add component line highlight line highlight color new  color well button j edit get color property view line highlight color  grid bag constraints vertical  structure highlight structure highlight new j check box j edit get property options textarea structure highlight structure highlight set selected j edit get boolean property view structure highlight add component structure highlight structure highlight color new  color well button j edit get color property view structure highlight color  grid bag constraints vertical eol markers eol markers new j check box j edit get property options textarea eol markers eol markers set selected j edit get boolean property view eol markers add component eol markers eol marker color new  color well button j edit get color property view eol marker color  grid bag constraints vertical  wrap guide wrap guide new j check box j edit get property options textarea wrap guide wrap guide set selected j edit get boolean property view wrap guide add component wrap guide wrap guide color new  color well button j edit get color property view wrap guide color  grid bag constraints vertical  electric borders electric borders new j check box j edit get property options textarea electric borders electric borders set selected equals j edit get property view electric borders add component electric borders  anti aliasing anti alias new j combo box  anti alias combo choices anti alias set tool tip text j edit get property options textarea anti alias tooltip  anti alias anti alias value new  anti alias j edit get property view anti alias font set anti alias enabled anti alias value val anti alias add action listener new  action listener public void action performed  action event evt int idx anti alias get selected index font set anti alias enabled idx font repaint anti alias set selected index anti alias value val add component j edit get property options textarea anti alias anti alias  fractional font metrics frac font metrics new j check box j edit get property options textarea frac font metrics frac font metrics set selected j edit get boolean property view frac font metrics add component frac font metrics  strip trailing eol strip trailing eol new j check box j edit get property options text area strip trailing eol strip trailing eol set selected j edit get boolean property strip trailing eol add component strip trailing eol complete from all buffers new j check box j edit get property options text area complete from all buffers complete from all buffers set selected j edit get boolean property complete from all buffers add component complete from all buffers 
public void  save j edit set font property view font font get font j edit set color property view fg color foreground color get selected color j edit set color property view bg color background color get selected color j edit set boolean property view caret blink blink caret is selected j edit set boolean property view block caret block caret is selected j edit set boolean property view thick caret thick caret is selected j edit set color property view caret color caret color get selected color j edit set color property view selection color selection color get selected color j edit set color property view multiple selection color multiple selection color get selected color j edit set boolean property view line highlight line highlight is selected j edit set color property view line highlight color line highlight color get selected color j edit set boolean property view structure highlight structure highlight is selected j edit set color property view structure highlight color structure highlight color get selected color j edit set boolean property view eol markers eol markers is selected j edit set color property view eol marker color eol marker color get selected color j edit set boolean property view wrap guide wrap guide is selected j edit set color property view wrap guide color wrap guide color get selected color j edit set integer property view electric borders electric borders is selected  anti alias nv new  anti alias j edit get property view anti alias nv set anti alias get selected index j edit set property view anti alias nv to string j edit set boolean property view frac font metrics frac font metrics is selected j edit set boolean property strip trailing eol strip trailing eol is selected j edit set boolean property complete from all buffers complete from all buffers is selected 
 it is a bad idea to override this but we need to get the component event before the first repaint  override public void set bounds int x int y int width int height if x get x y get y width get width height get height return super set bounds x y width height text area recalculate visible lines if text area get buffer is loading text area recalculate last physical line text area properties changed text area update max horizontal scroll width text area scroll bars initialized true 
 makes the tab key work in  java since j edit pre  override public boolean get focus traversal keys enabled return false 
 returns the syntax styles used to paint colorized text  entry i n i will be used to paint tokens with id i n i return an array of  syntax styles see org gjt sp jedit syntax  token public final  syntax style get styles return styles 
 sets the syntax styles used to paint colorized text  entry i n i will be used to paint tokens with id i n i param styles  the syntax styles see org gjt sp jedit syntax  token public final void set styles  syntax style styles assumed this is called after a font render context is set up changing font render context settings without a set styles call will not reset cached monospaced font info fonts clear this styles styles styles  token null new  syntax style get foreground null get font repaint 
 returns the caret color public final  color get caret color return caret color 
 sets the caret color param caret color  the caret color public final void set caret color  color caret color this caret color caret color if text area get buffer null text area invalidate line text area get caret line 
 returns the selection color public final  color get selection color return selection color 
 sets the selection color param selection color  the selection color public final void set selection color  color selection color this selection color selection color text area repaint 
 returns the multiple selection color since j edit pre public final  color get multiple selection color return multiple selection color 
 sets the multiple selection color param multiple selection color  the multiple selection color since j edit pre public final void set multiple selection color  color multiple selection color this multiple selection color multiple selection color text area repaint 
 returns the line highlight color public final  color get line highlight color return line highlight color 
 sets the line highlight color param line highlight color  the line highlight color public final void set line highlight color  color line highlight color this line highlight color line highlight color if text area get buffer null text area invalidate line text area get caret line 
 returns true if line highlight is enabled false otherwise public final boolean is line highlight enabled return line highlight 
 enables or disables current line highlighting param line highlight  true if current line highlight should be enabled false otherwise public final void set line highlight enabled boolean line highlight this line highlight line highlight text area repaint 
 returns the structure highlight color since j edit pre public final  color get structure highlight color return structure highlight color 
 sets the structure highlight color param structure highlight color  the bracket highlight color since j edit pre public final void set structure highlight color  color structure highlight color this structure highlight color structure highlight color text area invalidate structure match 
 returns true if structure highlighting is enabled false otherwise since j edit pre public final boolean is structure highlight enabled return structure highlight 
 enables or disables structure highlighting param structure highlight  true if structure highlighting should be enabled false otherwise since j edit pre public final void set structure highlight enabled boolean structure highlight this structure highlight structure highlight text area invalidate structure match 
 returns true if the caret should be drawn as a block false otherwise public final boolean is block caret enabled return block caret 
 sets if the caret should be drawn as a block false otherwise param block caret  true if the caret should be drawn as a block false otherwise public final void set block caret enabled boolean block caret this block caret block caret extension mgr remove extension caret extension if block caret add extension block caret layer caret extension else add extension caret layer caret extension if text area get buffer null text area invalidate line text area get caret line 
 returns true if the caret should be drawn with a thick line false otherwise since j edit pre public final boolean is thick caret enabled return thick caret 
 sets if the caret should be drawn with a thick line param thick caret  true if the caret should be drawn as a block false otherwise since j edit pre public final void set thick caret enabled boolean thick caret this thick caret thick caret if text area get buffer null text area invalidate line text area get caret line 
 returns the eol marker color public final  color get eol marker color return eol marker color 
 sets the eol marker color param eol marker color  the eol marker color public final void set eol marker color  color eol marker color this eol marker color eol marker color repaint 
 returns true if eol markers are drawn false otherwise public final boolean get eol markers painted return eol markers 
 sets if eol markers are to be drawn param eol markers  true if eol markers should be drawn false otherwise public final void set eol markers painted boolean eol markers this eol markers eol markers repaint 
 returns the wrap guide color public final  color get wrap guide color return wrap guide color 
 sets the wrap guide color param wrap guide color  the wrap guide color public final void set wrap guide color  color wrap guide color this wrap guide color wrap guide color repaint 
 returns true if the wrap guide is drawn false otherwise since j edit pre public final boolean is wrap guide painted return wrap guide 
 sets if the wrap guide is to be drawn param wrap guide  true if the wrap guide should be drawn false otherwise public final void set wrap guide painted boolean wrap guide this wrap guide wrap guide repaint 
 returns the fold line style  the first element is the style for lines with a fold level greater than  the remaining elements are for fold levels to public final  syntax style get fold line style return fold line style 
 sets the fold line style  the first element is the style for lines with a fold level greater than  the remaining elements are for fold levels to param fold line style  the fold line style public final void set fold line style  syntax style fold line style this fold line style fold line style repaint 
deprecated use set anti alias  anti alias new mode  deprecated public void set anti alias enabled boolean is enabled set anti alias new  anti alias is enabled 
 as of j edit pre a new jdk subpixel antialias mode is supported since j edit pre public void set anti alias  anti alias new value anti alias new value update rendering hints 
return the  anti alias value that is currently used for  text areas since jedit pre public  anti alias get anti alias return anti alias 
 returns if anti aliasing is enabled since j edit pre deprecated use ref get anti alias  deprecated public boolean is anti alias enabled return anti alias val 
 sets if fractional font metrics should be enabled  has no effect when running on  java since j edit pre public void set fractional font metrics enabled boolean frac font metrics this frac font metrics frac font metrics update rendering hints 
 returns if fractional font metrics are enabled since j edit pre public boolean is fractional font metrics enabled return frac font metrics 
 returns the font render context since j edit pre public  font render context get font render context return font render context 
 adds a text area extension which can perform custom painting and tool tip handling param extension  the extension since j edit pre public void add extension  text area extension extension extension mgr add extension default layer extension repaint 
 adds a text area extension which can perform custom painting and tool tip handling param layer  the layer to add the extension to  note that more than extension can share the same layer param extension  the extension since j edit pre public void add extension int layer  text area extension extension extension mgr add extension layer extension repaint 
 removes a text area extension  it will no longer be asked to perform custom painting and tool tip handling param extension  the extension since j edit pre public void remove extension  text area extension extension extension mgr remove extension extension repaint 
 returns an array of registered text area extensions  useful for debugging purposes since j edit pre public  text area extension get extensions return extension mgr get extensions 
 returns the tool tip to display at the specified location param evt  the mouse event  override public  string get tool tip text  mouse event evt if text area get buffer is loading return null return extension mgr get tool tip text evt get x evt get y 
 returns the font metrics used by this component public  font metrics get font metrics return fm 
 sets the font for this component  this is overridden to update the cached font metrics and to recalculate which lines are visible param font  the font  override public void set font  font font super set font font fm get font metrics font text area recalculate visible lines if text area get buffer null text area get buffer is loading text area recalculate last physical line text area properties changed 
 returns the width of the given string in pixels using the text area s current font since j edit final public float get string width  string str if text area char width return text area char width str length else return float get font get string bounds str get font render context get width 
 repaints the text param  gfx  the graphics context  override public void update  graphics  gfx paint  gfx 
 repaints the text param  gfx  the graphics context  override public void paint  graphics  gfx assert  gfx instanceof  graphics d  graphics d gfx  graphics d  gfx gfx set rendering hints rendering hints font render context gfx get font render context  rectangle clip rect gfx get clip bounds int line height fm get height if line height text area get buffer is loading gfx set color get background gfx fill rect clip rect x clip rect y clip rect width clip rect height else long prepare time  system nano time  because the clip rect s height is usually an even multiple of the font height we subtract from it otherwise one too many lines will always be painted int first line clip rect y line height int last line clip rect y clip rect height line height gfx set color get background gfx set font get font prepare time  system nano time prepare time long lines time  system nano time int num lines last line first line int y first line line height gfx fill rect y get width num lines line height extension mgr paint screen line range text area gfx first line last line y line height lines time  system nano time lines time if  debug paint timer num lines  log log  log debug this repainting num lines lines took prepare time lines time ns text area update max horizontal scroll width 
 implementation of  tab expander interface  returns next tab stop after a specified point param x  the x co ordinate param tab offset  ignored return  the next tab stop after i x i public float next tab stop float x int tab offset int ntabs int x text area tab size return ntabs text area tab size 
 returns the painter s preferred size  override public  dimension get preferred size  dimension dim new  dimension char foo new char for int i i foo length i foo i dim width int get string width new  string foo dim height fm get height return dim 
 returns the painter s minimum size  override public  dimension get minimum size return get preferred size 
 creates a new painter  do not create instances of this class directly  text area painter  text area text area enable events awt event focus event mask awt event key event mask awt event mouse event mask this text area text area anti alias new  anti alias fonts new  hash map extension mgr new  extension manager set autoscrolls true set opaque true set request focus enabled false set double buffered false set cursor  cursor get predefined cursor  cursor text cursor font render context new  font render context null false false add extension line background layer new  paint line background add extension selection layer new  paint selection add extension wrap guide layer new  paint wrap guide add extension bracket highlight layer new  structure matcher  highlight text area add extension text layer new  paint text caret extension new  paint caret 
private void update rendering hints  map  rendering hints  key  object hints new  hash map  rendering hints  key  object hints put  rendering hints key fractionalmetrics frac font metrics  rendering hints value fractionalmetrics on  rendering hints value fractionalmetrics off if anti alias val hints put  rendering hints key antialiasing  rendering hints value antialias off hints put  rendering hints key text antialiasing  rendering hints value text antialias off font render context new  font render context null anti alias val frac font metrics lcd hrgb mode works with jre only which is why we use reflection else if anti alias val sm hrgb render null hints put  rendering hints key text antialiasing sm hrgb render  object font render hint frac font metrics  rendering hints value fractionalmetrics on  rendering hints value fractionalmetrics off  object param list null sm hrgb render font render hint try font render context sm frc constructor new instance param list catch  exception e font render context new  font render context null anti alias val frac font metrics else  standard  antialias  version hints put  rendering hints key rendering  rendering hints value render quality hints put  rendering hints key antialiasing  rendering hints value antialias on hints put  rendering hints key text antialiasing  rendering hints value text antialias on font render context new  font render context null anti alias val frac font metrics rendering hints new  rendering hints hints 
private boolean should paint line highlight int caret int start int end if is line highlight enabled caret start caret end return false int count text area get selection count if count  selection s text area get selection return s get start line s get end line else return count 
 override public void paint valid line  graphics d gfx int screen line int physical line int start int end int y minimise access methods  text area text area  text area painter this text area j edit buffer buffer text area get buffer  paint line highlight and collapsed fold highlight boolean collapsed fold physical line buffer get line count buffer is fold start physical line text area display manager is line visible physical line  syntax style fold line style null if collapsed fold int level buffer get fold level physical line if buffer get fold handler instanceof  indent fold handler level  math max level buffer get indent size if level level fold line style  text area painter this fold line style level int caret text area get caret position boolean paint line highlight should paint line highlight caret start end  color bg color if paint line highlight bg color line highlight color else if collapsed fold bg color fold line style get background color if bg color null bg color get background else bg color get background if paint line highlight collapsed fold gfx set color bg color gfx fill rect y get width fm get height  paint token backgrounds  chunk cache  line info line info text area chunk cache get line info screen line if line info chunks null float base line y fm get height fm get leading fm get descent  chunk paint chunk backgrounds line info chunks gfx text area get horizontal offset base line 
 override public void paint valid line  graphics d gfx int screen line int physical line int start int end int y if text area get selection count return gfx set color text area is multiple selection enabled get multiple selection color get selection color  iterator  selection iter text area get selection iterator while iter has next  selection s iter next paint selection gfx screen line physical line y s 
private void paint selection  graphics d gfx int screen line int physical line int y  selection s int selection start and end text area selection manager get selection start and end screen line physical line s if selection start and end null return int x selection start and end int x selection start and end gfx fill rect x y x x fm get height 
 override public void paint screen line range  graphics d gfx int first line int last line int physical lines int start int end int y int line height if text area wrap margin text area wrap to width is wrap guide painted gfx set color get wrap guide color int x text area get horizontal offset text area wrap margin gfx draw line x y x y last line first line line height 
 override public  string get tool tip text int x int y if text area wrap margin text area wrap to width is wrap guide painted int wrap guide pos text area wrap margin text area get horizontal offset if  math abs x wrap guide pos return  string value of text area get buffer get property max line len return null 
 override public void paint valid line  graphics d gfx int screen line int physical line int start int end int y  chunk cache  line info line info text area chunk cache get line info screen line  font default font get font  color default color get foreground gfx set font default font gfx set color default color int x text area get horizontal offset int original x x float base line y fm get height fm get leading fm get descent if line info chunks null x  chunk paint chunk list line info chunks gfx text area get horizontal offset base line  debug disable glyph vector j edit buffer buffer text area get buffer if line info last subregion gfx set font default font gfx set color eol marker color gfx draw string  math max x text area get horizontal offset text area wrap margin text area char width base line x text area char width else if physical line buffer get line count buffer is fold start physical line text area display manager is line visible physical line int level buffer get fold level physical line if buffer get fold handler instanceof  indent fold handler level  math max level buffer get indent size if level level  syntax style fold line style  text area painter this fold line style level  font font fold line style get font gfx set font font gfx set color fold line style get foreground color int next line int next screen line screen line if next screen line text area get visible lines next line text area chunk cache get line info next screen line physical line else next line text area display manager get next visible line physical line if next line next line text area get line count int count next line physical line  string str count lines float width get string width str gfx draw string str x base line x width else if eol markers gfx set font default font gfx set color eol marker color gfx draw string x base line x text area char width line info width x original x 
 override public void paint valid line  graphics d gfx int screen line int physical line int start int end int y if text area is caret visible return int caret text area get caret position if caret start caret end return int offset caret text area get line start offset physical line text area offset to xy physical line offset text area offset xy int caret x text area offset xy x int line height fm get height gfx set color caret color if text area is overwrite enabled gfx draw line caret x y line height caret x text area char width y line height else if block caret gfx draw rect caret x y text area char width line height else if thick caret gfx draw rect caret x y line height else gfx draw line caret x y caret x y line height 
 override protected  transferable create transferable j component c  log log  log debug this create transferable j edit text area text area j edit text area c if text area get selection count return null else drag source text area return new  text area selection text area 
 override public int get source actions j component c return copy or move 
 override public boolean import data j component c  transferable t  log log  log debug this  import data  log log  log debug this  import data t is data flavor supported text ur ilist data flavor t is data flavor supported text ur ilist data flavor if can import c t get transfer data flavors return false boolean return value try if t is data flavor supported  data flavor java file list flavor return value import file c t else  data flavor uri list string data flavor null  data flavor data flavors t get transfer data flavors for int i i data flavors length i  data flavor data flavor data flavors i if text equals data flavor get primary type uri list equals data flavor get sub type data flavor get representation class  string class uri list string data flavor data flavor break if uri list string data flavor null t is data flavor supported uri list string data flavor return value import uri list c t uri list string data flavor else return value import text c t catch  exception e  log log  log error this e return value false gui utilities get view c to front gui utilities get view c request focus c request focus return return value 
private boolean import file j component c  transferable t throws  exception  log log  log debug this  file list  edit pane edit pane  edit pane gui utilities get component parent c  edit pane class  view view edit pane get view  buffer buffer null  list  file data  list  file t get transfer data  data flavor java file list flavor boolean browsed directory false  buffer set manager buffer set manager j edit get buffer set manager for  file file data if file is directory if browsed directory vfs browser browse directory view file get path browsed directory true continue  buffer  buffer j edit open file edit pane file get path if  buffer null buffer  buffer buffer set manager add buffer edit pane buffer if buffer null edit pane set buffer buffer view to front view request focus edit pane request focus return true 
private boolean import uri list j component c  transferable t  data flavor uri list string data flavor throws  exception  string str  string t get transfer data uri list string data flavor  log log  log debug this uri list str  edit pane edit pane  edit pane gui utilities get component parent c  edit pane class  view view edit pane get view j edit text area text area j edit text area c if drag source null boolean found false  string components str split r n boolean browsed directory false for int i i components length i  string str components i if str length uri uri new uri str this handles the uri decoding if file equals uri get scheme  file file new  file uri get path if file is directory if browsed directory vfs browser browse directory view file get path browsed directory true else vfs manager run in work thread new  dragged url loader text area uri get path found true else  log log  log debug this i do not know how to handle this uri uri ignoring else  this should be the last component because every uri in the list is terminated with a r n even the last one if i components length  log log  log debug this  odd there is an empty line in the uri list which is not the last line if found return true return true 
private boolean import text j component c  transferable t throws  exception  string str  string t get transfer data  data flavor string flavor str str trim  log log  log debug this  string str j edit text area text area j edit text area c if drag source null boolean found false  string components str split n for int i i components length i  string str components i  only examine the string for a url if it came from outside of j edit vfs vfs vfs manager get vfs for path str if vfs instanceof  file vfs str starts with file str str replace n replace r trim if str starts with file str str substring vfs manager run in work thread new  dragged url loader text area str found true if found return true if drag source null text area get buffer drag source get buffer compound edit true text area get buffer begin compound edit same text area text area drag source int caret text area get caret position  selection s text area get selection at offset caret if user drops into the same selection where they started do nothing if s null if same text area return false if user drops into a selection replace selection int start pos s start text area set selected text s str text area set selection new  selection  range start pos start pos str length otherwise just insert the text else if same text area insert pos caret insert offset  selection selections text area get selection for int i i selections length i if selections i end insert pos insert offset insert offset selections i end selections i start else text area get buffer insert caret str text area set selection new  selection  range caret caret str length text area scroll to caret true return true 
 override protected void export done j component c  transferable t int action  log log  log debug this  export done j edit text area text area j edit text area c try  this happens if import data returns false  for example if you drop into the  selection if action none  log log  log debug this  export impossible return if t null  log log  log debug this  null transferrable text area select none else if t is data flavor supported  data flavor string flavor  log log  log debug this  string if same text area if action move text area set selected text null false insert pos insert offset try  string str  string t get transfer data  data flavor string flavor text area get buffer insert insert pos str text area set selection new  selection  range insert pos insert pos str length catch  exception e  log log  log debug this export done in same text area  log log  log debug this e else if action move text area set selected text null false else text area select none finally if compound edit compound edit false text area get buffer end compound edit drag source null 
 override public boolean can import j component c  data flavor flavors j edit text area text area j edit text area c correctly handle text flavor file list flavor text area read only do an or of all flags boolean return value false for int i i flavors length i if flavors i equals  data flavor java file list flavor return value true else if flavors i equals  data flavor string flavor if text area is editable return value true else if flavors i get representation class equals java io  input stream class workaround for  ubuntu  gnome  nautilus import flavors otherwise doesn t work on all  ubuntu installations return value true break  log log  log debug this can import returning return value return return value 
 text area selection j edit text area text area super text area get selected text this text area text area 
 dragged url loader j edit text area text area  string url this text area text area this url url 
public void run  edit pane edit pane  edit pane get text area j edit open file edit pane url 
 returns the token that contains the specified offset param tokens  the token list param offset  the offset since j edit pre public static  token get token at offset  token tokens int offset if offset tokens id  token end return tokens for if tokens id  token end throw new  array index out of bounds exception offset line length if tokens offset tokens length offset return tokens else tokens tokens next 
 given an opening bracket return the corresponding closing bracket and store true in code direction code  given a closing bracket return the corresponding opening bracket and store false in code direction code  otherwise return code code since j edit pre public static char get complementary bracket char ch boolean direction switch ch case if direction null direction true return case if direction null direction false return case if direction null direction true return case if direction null direction false return case if direction null direction true return case if direction null direction false return case if direction null direction true return case if direction null direction false return default return 
 returns the offset of the bracket matching the one at the specified offset of the buffer or if the bracket is unmatched or if the character is not a bracket param buffer  the buffer param line  the line param offset  the offset within that line since j edit pre public static int find matching bracket j edit buffer buffer int line int offset if offset offset buffer get line length line throw new  array index out of bounds exception offset buffer get line length line  segment line text new  segment buffer get line text line line text char c line text array line text offset offset false backwards true forwards boolean direction new boolean corresponding character char cprime get complementary bracket c direction if cprime c is no bracket return because we ve already seen the first bracket int count  default token handler token handler new  default token handler buffer mark tokens line token handler  get the syntax token at offset only tokens with the same type will be checked for the corresponding bracket byte id of bracket get token at offset token handler get tokens offset id boolean have tokens true int start line line  forward search if direction offset for for int i offset i line text count i char ch line text array line text offset i if ch c if have tokens token handler init buffer mark tokens line token handler have tokens true if get token at offset token handler get tokens i id id of bracket count else if ch cprime if have tokens token handler init buffer mark tokens line token handler have tokens true if get token at offset token handler get tokens i id id of bracket count if count return buffer get line start offset line i  go on to next line line if line buffer get line count line start line bracket match limit break buffer get line text line line text offset have tokens false  backward search else offset for for int i offset i i char ch line text array line text offset i if ch c if have tokens token handler init buffer mark tokens line token handler have tokens true if get token at offset token handler get tokens i id id of bracket count else if ch cprime if have tokens token handler init buffer mark tokens line token handler have tokens true if get token at offset token handler get tokens i id id of bracket count if count return buffer get line start offset line i  go on to previous line line if line start line line bracket match limit break buffer get line text line line text offset line text count have tokens false  nothing found return 
 locates the start of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway public static int find word start  string line int pos  string no word sep return find word start line pos no word sep true false 
 locates the start of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway since j edit pre public static int find word start  char sequence line int pos  string no word sep return find word start line pos no word sep true false false 
 similar to perl s join method on lists but works with all collections param c  an iterable collection of  objects param delim a string to put between each object return a joined to string representation of the collection since jedit pre public static  string join  collection  string c  string delim  string builder retval new  string builder  iterator  string itr c iterator if itr has next retval append itr next else return while itr has next retval append delim retval append itr next return retval to string 
 locates the start of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway param join non word chars  treat consecutive non alphanumeric characters as one word since j edit pre public static int find word start  string line int pos  string no word sep boolean join non word chars return find word start line pos no word sep join non word chars false 
 locates the start of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway param join non word chars  treat consecutive non alphanumeric characters as one word param eat whitespace  include whitespace at start of word since j edit pre public static int find word start  string line int pos  string no word sep boolean join non word chars boolean eat whitespace return find word start line pos no word sep join non word chars false eat whitespace 
 locates the start of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway param join non word chars  treat consecutive non alphanumeric characters as one word param camel cased words  treat camel cased parts as words param eat whitespace  include whitespace at start of word since j edit pre public static int find word start  string line int pos  string no word sep boolean join non word chars boolean camel cased words boolean eat whitespace return find word start  char sequence line pos no word sep join non word chars camel cased words eat whitespace 
 locates the start of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway param join non word chars  treat consecutive non alphanumeric characters as one word param camel cased words  treat camel cased parts as words param eat whitespace  include whitespace at start of word since j edit pre public static int find word start  char sequence line int pos  string no word sep boolean join non word chars boolean camel cased words boolean eat whitespace char ch line char at pos if no word sep null no word sep the character under the cursor changes how we behave int type get char type ch no word sep for int i pos i i char last ch ch ch line char at i switch type  whitespace case whitespace only select other whitespace in this case if  character is whitespace ch break word char or symbol stop else return i  word character case word char stop at next last in writing direction upper case char if camel cased don t stop at every upper case char don t treat no word sep as word chars if camel cased words  character is upper case ch  character is upper case last ch  character is letter or digit last ch return i stop at next first in writing direction upper case char if camel cased don t stop at every upper case char else if camel cased words  character is upper case ch  character is upper case last ch return i word char keep going else if  character is letter or digit ch no word sep index of ch break whitespace include in word if eating else if  character is whitespace ch eat whitespace type whitespace break else return i  symbol case symbol if join non word chars pos i return i whitespace include in word if eating if  character is whitespace ch if eat whitespace type whitespace break else return i else if  character is letter or digit ch no word sep index of ch return i else break return 
 locates the end of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway public static int find word end  string line int pos  string no word sep return find word end line pos no word sep true 
 locates the end of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway since j edit pre public static int find word end  char sequence line int pos  string no word sep return find word end line pos no word sep true false false 
 locates the end of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway param join non word chars  treat consecutive non alphanumeric characters as one word since j edit pre public static int find word end  string line int pos  string no word sep boolean join non word chars return find word end line pos no word sep join non word chars false 
 locates the end of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway param join non word chars  treat consecutive non alphanumeric characters as one word param eat whitespace  include whitespace at end of word since j edit pre public static int find word end  string line int pos  string no word sep boolean join non word chars boolean eat whitespace return find word end line pos no word sep join non word chars false eat whitespace 
 locates the end of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway param join non word chars  treat consecutive non alphanumeric characters as one word param camel cased words  treat camel cased parts as words param eat whitespace  include whitespace at end of word since j edit pre public static int find word end  string line int pos  string no word sep boolean join non word chars boolean camel cased words boolean eat whitespace return find word end  char sequence line pos no word sep join non word chars camel cased words eat whitespace 
 locates the end of the word at the specified position param line  the text param pos  the position param no word sep  characters that are non alphanumeric but should be treated as word characters anyway param join non word chars  treat consecutive non alphanumeric characters as one word param camel cased words  treat camel cased parts as words param eat whitespace  include whitespace at end of word since j edit pre public static int find word end  char sequence line int pos  string no word sep boolean join non word chars boolean camel cased words boolean eat whitespace if pos pos char ch line char at pos if no word sep null no word sep the character under the cursor changes how we behave int type get char type ch no word sep for int i pos i line length i char last ch ch ch line char at i switch type  whitespace case whitespace only select other whitespace in this case if  character is whitespace ch break else return i  word character case word char stop at next last upper case char if camel cased don t stop at every upper case char don t treat no word sep as word chars if camel cased words i pos  character is upper case ch  character is letter or digit ch  character is upper case last ch return i stop at next first upper case char if camel caseg don t stop at every upper case char else if camel cased words  character is upper case ch  character is upper case last ch return i else if  character is letter or digit ch no word sep index of ch break whitespace include in word if eating else if  character is whitespace ch eat whitespace type whitespace break else return i  symbol case symbol if join non word chars i pos return i if we see whitespace set flag if  character is whitespace ch if eat whitespace type whitespace break else return i else if  character is letter or digit ch no word sep index of ch return i else break return line length 
 returns the type of the char param ch the character param no word sep  characters that are non alphanumeric but should be treated as word characters anyway return the type of the char link whitespace link word char link symbol private static int get char type char ch  string no word sep int type if  character is whitespace ch type whitespace else if  character is letter or digit ch no word sep index of ch type word char else type symbol return type 
 converts consecutive spaces to tabs in the specified string param in  the string param tab size  the tab size public static  string spaces to tabs  string in int tab size  string builder buf new  string builder int width int whitespace for int i i in length i switch in char at i case whitespace width break case t int tab tab size width tab size width tab whitespace tab break case n if whitespace buf append  standard utilities create white space whitespace tab size width whitespace whitespace width buf append n break default if whitespace buf append  standard utilities create white space whitespace tab size width whitespace whitespace buf append in char at i width break if whitespace buf append  standard utilities create white space whitespace tab size width whitespace return buf to string 
 converts tabs to consecutive spaces in the specified string param in  the string param tab size  the tab size public static  string tabs to spaces  string in int tab size  string builder buf new  string builder int width for int i i in length i switch in char at i case t int count tab size width tab size width count while count buf append break case n width buf append in char at i break default width buf append in char at i break return buf to string 
 formats the specified text by merging and breaking lines to the specified width param text  the text param max line length  the maximum line length param tab size  the tab size public static  string format  string text int max line length int tab size  string builder buf new  string builder int index for int new index text index of n n index if new index break format paragraph text substring index new index max line length tab size buf buf append n n index new index if index text length format paragraph text substring index max line length tab size buf return buf to string 
 inverse of code ignoring whitespace index code param str a string not an empty string param index  the index return  the number of non whitespace characters that precede the index since j edit pre public static int index ignoring whitespace  string str int index int j for int i i index i if  character is whitespace str char at i j return j 
 inverse of code index ignoring whitespace code param str a string not an empty string param index  the index return  the index into the string where the number of non whitespace characters that precede the index is count since j edit pre public static int ignoring whitespace index  string str int index int j for int i i if  character is whitespace str char at i j if j index return i if i str length return i 
 returns if the specified string is all upper case all lower case or title case first letter upper case rest lower case param str  the string since j edit pre public static int get string case  string str if str length return mixed int state char ch str char at if  character is letter ch if  character is upper case ch state upper case else state lower case for int i i str length i ch str char at i if  character is letter ch continue switch state case upper case if  character is lower case ch if i state title case else return mixed break case lower case case title case if  character is upper case ch return mixed break return state 
 converts the specified string to title case by capitalizing the first letter param str  the string since j edit pre public static  string to title case  string str if str length return str else return  character to upper case str char at str substring to lower case 
private static void format paragraph  string text int max line length int tab size  string builder buf align everything to paragraph s leading indent int leading whitespace count  standard utilities get leading white space text  string leading whitespace text substring leading whitespace count int leading whitespace width  standard utilities get leading white space width text tab size buf append leading whitespace int line length leading whitespace width  string tokenizer st new  string tokenizer text while st has more tokens  string word st next token if line length leading whitespace width do nothing else if line length word length max line length buf append n buf append leading whitespace line length leading whitespace width else buf append line length buf append word line length word length 
public static void index ignoring whitespace  string text int max line length int tab size  string buffer buf align everything to paragraph s leading indent int leading whitespace count  standard utilities get leading white space text  string leading whitespace text substring leading whitespace count int leading whitespace width  standard utilities get leading white space width text tab size buf append leading whitespace int line length leading whitespace width  string tokenizer st new  string tokenizer text while st has more tokens  string word st next token if line length leading whitespace width do nothing else if line length word length max line length buf append n buf append leading whitespace line length leading whitespace width else buf append line length buf append word line length word length 
get this is a factory for bsh  this type references  the capabilities of this references in bsh are version dependent up until jdk  the version dependence was to support different default interface implementations i e different sets of listener interfaces which scripted objects were capable of implementing  in jdk the reflection proxy mechanism was introduced which allowed us to implement arbitrary interfaces  this is fantastic a  this object is a thin layer over a namespace comprising a bsh object context  we create it here only if needed for the namespace  note this method could be considered slow because of the way it dynamically factories objects  however i ve also done tests where i hard code the factory to return j this and see no change in the rough test suite time  this references are also cached in  name space static  this get this  name space namespace  interpreter declaring interpreter try  class c if  capabilities can generate interfaces c  class for name org gjt sp jedit bsh x this else if  capabilities have swing c  class for name org gjt sp jedit bsh j this else return new  this namespace declaring interpreter return  this  reflect construct object c new  object namespace declaring interpreter catch  exception e throw new  interpreter error internal error in  this e 
 get a version of this scripted object implementing the specified interface  if this type of  this implements it directly return this else try complain that we don t have the proxy mechanism public  object get interface  class clas throws  util eval error if clas is instance this return this else throw new  util eval error  dynamic proxy mechanism not available  cannot construct interface type clas 
 get a version of this scripted object implementing the specified interfaces public  object get interface  class ca throws  util eval error for int i i ca length i if ca i is instance this throw new  util eval error  dynamic proxy mechanism not available  cannot construct interface type ca i return this 
protected  this  name space namespace  interpreter declaring interpreter this namespace namespace this declaring interpreter declaring interpreter init call stack namespace 
public  name space get name space return namespace 
public  string to string return this reference to  bsh object namespace 
public void run try invoke method run new  object catch  eval error e declaring interpreter error  exception in runnable e 
 invoke specified method as from outside java code using the declaring interpreter and current namespace  the call stack will indicate that the method is being invoked from outside of bsh in native java code  note you must still wrap unwrap args return values using  primitive  primitive unwrap for use outside of  bean shell see org gjt sp jedit bsh  primitive public  object invoke method  string name  object args throws  eval error null callstack one will be created for us return invoke method name args null declaring interpreter null null false declared only 
 invoke a method in this namespace with the specified args interpreter reference callstack and caller info p  note  if you use this method outside of the bsh package and wish to use variables with primitive values you will have to wrap them using bsh  primitive  consider using  this get interface to make a true  java interface for invoking your scripted methods p  this method also implements the default object protocol of to string hash code and equals and the invoke meta method handling as a last resort p  note  the invoke meta method will not catch the  object protocol methods to string hash code  if you want to override them you have to script them directly p see org gjt sp jedit bsh  this invoke method  string method name  object args  interpreter interpreter  call stack callstack  simple node caller info boolean declared only invoke method param callstack if call stack is null a new  call stack will be created and initialized with this namespace param declared only if true then only methods declared directly in the namespace will be visible no inherited or imported methods will be visible see org gjt sp jedit bsh  primitive  primitive invoke method here is generally used by outside code to callback into the bsh interpreter e g when we are acting as an interface for a scripted listener etc  in this case there is no real call stack so we make a default one starting with the special javacode namespace and our namespace as the next public  object invoke method  string method name  object args  interpreter interpreter  call stack callstack  simple node caller info boolean declared only throws  eval error  wrap nulls  this is a bit of a cludge to address a deficiency in the class generator whereby it does not wrap nulls on method delegate  see  class  generator java  if we fix that then we can remove this just have to generate the code there if args null  object oa new  object args length for int i i args length i oa i args i null  primitive null args i args oa if interpreter null interpreter declaring interpreter if callstack null callstack new  call stack namespace if caller info null caller info  simple node javacode  find the bsh method  class types  types get types args  bsh method bsh method null try bsh method namespace get method method name types declared only catch  util eval error e leave null if bsh method null return bsh method invoke args interpreter callstack caller info  no scripted method of that name  implement the required part of the  object protocol public int hash code public boolean equals java lang  object public java lang  string to string if these were not handled by scripted methods we must provide a default impl a default to string that shows the interfaces we implement if method name equals to string return to string a default hash code if method name equals hash code return new  integer this hash code a default equals testing for equality with the  this reference if method name equals equals  object obj args return new  boolean this obj  look for a default invoke handler method in the namespace  note this code duplicates that in  name space get command is that ok try bsh method namespace get method invoke new  class null null catch  util eval error e leave null  call script invoke  string method name  object args if bsh method null return bsh method invoke new  object method name args interpreter callstack caller info throw new  eval error  method  string util method string method name types not found in bsh scripted object namespace get name caller info callstack 
 bind a  this reference to a parent s namespace with the specified declaring interpreter  also re init the callstack  it s necessary to bind a  this reference before it can be used after deserialization  this is used by the bsh load command p  this is a static utility method because it s used by a bsh command bind and the interpreter doesn t currently allow access to direct methods of  this objects small hack public static void bind  this ths  name space namespace  interpreter declaring interpreter ths namespace set parent namespace ths declaring interpreter declaring interpreter 
 allow invocations of these method names on  this type objects  don t give bsh  this a chance to override their behavior p  if the method is passed here the invocation will actually happen on the bsh  this object via the regular reflective method invocation mechanism  if not then the method is evaluated by bsh  this itself as a scripted method call static boolean is exposed this method  string name return name equals get class name equals invoke method name equals get interface  these are necessary to let us test synchronization from scripts name equals wait name equals notify name equals notify all 
public  tip of the day  view view super view j edit get property tip title false j panel content new j panel new  border layout content set border new  empty border set content pane content j label label new j label j edit get property tip caption label set font new  font  sans serif  font plain label set foreground ui manager get color  button foreground content add  border layout north label tip text new j editor pane tip text set editable false tip text set content type text html next tip j scroll pane scroller new j scroll pane tip text scroller set preferred size new  dimension content add  border layout center scroller  action handler action handler new  action handler  box buttons new  box  box layout x axis show next time new j check box j edit get property tip show next time j edit get boolean property tip show show next time add action listener action handler buttons add show next time buttons add  box create horizontal strut buttons add  box create glue next tip new j button j edit get property tip next tip next tip add action listener action handler buttons add next tip buttons add  box create horizontal strut close new j button j edit get property common close close add action listener action handler buttons add close content get root pane set default button close  dimension dim next tip get preferred size dim width  math max dim width close get preferred size width next tip set preferred size dim close set preferred size dim content add  border layout south buttons set default close operation dispose on close pack set location relative to view set visible true 
public void ok dispose 
public void cancel dispose 
private void next tip  file tips new  file  misc utilities construct path j edit get j edit home doc tips list files if tips null tips length tip text set text j edit get property tip not found return int count tips length so that we don t see the same tip again if the user clicks  next  tip int tip to show current tip while tip to show current tip tips tip to show get name ends with html tip to show new  random next int  integer max value count try tip text set page tips tip to show to uri to url catch  exception e  log log  log error this e 
public void action performed  action event evt  object source evt get source if source show next time j edit set boolean property tip show show next time is selected else if source next tip next tip else if source close dispose 
 returns the image public  string to string return image 
 returns a new  token object by default  however if you want you can create and return subclass objects based on the value of of kind  simply add the cases to the switch for all those special cases  for example if you have a subclass of  token called id token that you want to create if of kind is id simlpy add something like case  my parser constants id return new id token to the following switch statement  then you can cast matched token variable to the appropriate type and use it in your lexical actions public static final  token new token int of kind switch of kind default return new  token 
 converts a token type string to a token type constant param value  the token type since j edit pre public static byte string to token  string value try  field f  token class get field value return f get byte null catch  exception e return 
 converts a token type constant to a token type string since j edit pre public static  string token to string byte token return token  token end end token types token 
 creates a new token param id  the id of the token param offset  the start offset of the token param length  the length of the token param rules  the parser rule set that generated this token public  token byte id int offset int length  parser rule set rules this id id this offset offset this length length this rules rules 
 returns a string representation of this token public  string to string return id id offset offset length length 
public  token marker 
public void add rule set  parser rule set rules rule sets put rules get set name rules if rules get set name equals main main rule set rules 
public  parser rule set get main rule set return main rule set 
public  parser rule set get rule set  string set name return rule sets get set name 
since j edit pre public  parser rule set get rule sets return rule sets values to array new  parser rule set rule sets size 
 do not call this method directly call  buffer mark tokens instead param prev context the context of the previous line it can be null param token handler the token handler param line a segment containing the content of the line public synchronized  line context mark tokens  line context prev context  token handler token handler  segment line  set up some instance variables this is to avoid having to pass around lots and lots of parameters this token handler token handler this line line last offset line offset line length line count line offset context new  line context if prev context null context rules get main rule set context escape rule context rules get escape rule else context parent prev context parent context set in rule prev context in rule context rules prev context rules context span end subst prev context span end subst keywords context rules get keywords seen whitespace end false whitespace end line offset  main parser loop int terminate char context rules get terminate char boolean terminated false main loop for pos line offset pos line length pos check if we have to stop parsing happens if the terminate char has been exceeded if terminate char pos line offset terminate char terminated terminated true context new  line context  parser rule set get standard rule set context rules get default context keywords context rules get keywords  check for the escape rule before anything else if context escape rule null handle rule context escape rule false continue main loop check for end of delegate if context parent null context parent in rule null check delegate end context parent in rule seen whitespace end true continue main loop check every rule  character ch  character value of line array pos  list  parser rule rules context rules get rules ch for  parser rule rule rules stop checking rules if there was a match if handle rule rule false seen whitespace end true continue main loop check if current character is a word separator if  character is whitespace ch if seen whitespace end whitespace end pos if context in rule null handle rule context in rule true handle no word break mark keyword false if last offset pos token handler handle token line context rules get default last offset line offset pos last offset context token handler handle token line context rules get default pos line offset context last offset pos else if keywords null context rules get rule count  string no word sep context rules get no word sep if  character is letter or digit ch no word sep index of ch if context in rule null handle rule context in rule true handle no word break mark keyword true token handler handle token line context rules get default last offset line offset context last offset pos seen whitespace end true  mark all remaining characters pos line length if context in rule null handle rule context in rule true handle no word break mark keyword true  unwind any no line break parent delegates unwind while context parent null  parser rule rule context parent in rule if rule null rule action  parser rule no line break  parser rule no line break terminated context context parent keywords context rules get keywords context set in rule null else break unwind token handler handle token line  token end pos line offset context context context intern token handler set line context context for gc this token handler null this line null return context 
private boolean check delegate end  parser rule rule if rule end null return false  line context temp context context context context parent keywords context rules get keywords boolean handled handle rule rule true context temp context keywords context rules get keywords if handled if context in rule null handle rule context in rule true mark keyword true context  line context context parent clone token handler handle token line match token context in rule context in rule context pos line offset pattern count context keywords context rules get keywords context set in rule null last offset pos pattern count move pos to last character of match sequence pos pattern count return true return false 
 checks if the rule matches the line at the current position and handles the rule if it does match private boolean handle rule  parser rule check rule boolean end  some rules can only match in certain locations if end if null check rule up hash chars if check rule up hash char null pos check rule up hash char length line array length check hash string check rule return false else if  arrays binary search check rule up hash chars  character to upper case line array pos return false int offset check rule action  parser rule mark previous last offset pos int pos match end check rule end pos match check rule start pos match if pos match  parser rule at line start  parser rule at line start if offset line offset return false else if pos match  parser rule at whitespace end  parser rule at whitespace end if offset whitespace end return false else if pos match  parser rule at word start  parser rule at word start if offset last offset return false int matched chars  char sequence char seq null  matcher match null  see if the rule s start or end sequence matches here if end check rule action  parser rule mark following the end cannot be a regular expression if check rule action  parser rule regexp end if end if context span end subst null pattern array context span end subst else pattern array check rule end else pattern array check rule start pattern offset pattern count pattern array length matched chars pattern count if  syntax utilities region matches context rules get ignore case line pos pattern array return false else note that all regexps start with a so they only match the start of the string int match start pos line offset char seq new  segment char sequence line pos line offset line count pos line offset match check rule start regexp matcher char seq if match looking at return false else if match start throw new  internal error  can t happen else matched chars match end workaround for hang if match was zero width not sure if there is a better way to handle this if matched chars matched chars  check for an escape sequence if check rule action  parser rule is escape  parser rule is escape pos pattern count  handle start of rule else if end if context in rule null handle rule context in rule true mark keyword check rule action  parser rule mark previous  parser rule mark previous switch check rule action  parser rule major actions seq case  parser rule seq context span end subst null if check rule action  parser rule regexp handle token with spaces token handler check rule token pos line offset matched chars context else token handler handle token line check rule token pos line offset matched chars context a delegate attribute on a seq changes the ruleset from the end of the seq onwards if check rule delegate null context new  line context check rule delegate context parent keywords context rules get keywords break span eol span case  parser rule span case  parser rule eol span context set in rule check rule byte token type match token check rule context in rule context if check rule action  parser rule regexp handle token with spaces token handler token type pos line offset matched chars context else token handler handle token line token type pos line offset matched chars context char span end subst null substitute result of matching the rule start into the end string eg in shell script mode s w is matched into to construct rules for highlighting read ins like this eof eof if char seq null check rule end null span end subst substitute match check rule end context span end subst span end subst context new  line context check rule delegate context keywords context rules get keywords break mark following case  parser rule mark following token handler handle token line match token check rule check rule context pos line offset pattern count context context span end subst null context set in rule check rule break mark previous case  parser rule mark previous context span end subst null if pos last offset token handler handle token line check rule token last offset line offset pos last offset context token handler handle token line match token check rule check rule context pos line offset pattern count context break default throw new  internal error  unhandled major action move pos to last character of match sequence pos matched chars last offset pos break out of inner for loop to check next char  handle end of mark following else if context in rule action  parser rule mark following if pos last offset token handler handle token line context in rule token last offset line offset pos last offset context last offset pos context set in rule null return true 
private void handle no word break if context parent null  parser rule rule context parent in rule if rule null context parent in rule action  parser rule no word break if pos last offset token handler handle token line rule token last offset line offset pos last offset context last offset pos context context parent keywords context rules get keywords context set in rule null 
private void handle token with spaces  token handler token handler byte token type int start int len  line context context int last start int end start len for int i start i end i if  character is whitespace line array i line offset if last i token handler handle token line token type last i last context token handler handle token line token type i context last i if last end token handler handle token line token type last end last context 
private void mark keyword boolean add remaining int len pos last offset if len return  do digits if context rules get highlight digits boolean digit false boolean mixed false for int i last offset i pos i char ch line array i if  character is digit ch digit true else mixed true if mixed  pattern digit re context rules get digit regexp only match against regexp if its not all digits if all digits no point matching if digit if digit re null mixed digit alpha keyword and no regexp don t highlight as digit digit false else int old count line count int old offset line offset line offset last offset line count len  char sequence seq new  segment char sequence line digit digit re matcher seq matches line offset old offset line count old count if digit token handler handle token line  token digit last offset line offset len context last offset pos return  do keywords if keywords null byte id keywords lookup line last offset len if id  token null token handler handle token line id last offset line offset len context last offset pos return  handle any remaining crud if add remaining token handler handle token line context rules get default last offset line offset len context last offset pos 
private static char substitute  matcher match char end  string builder buf new  string builder for int i i end length i char ch end i if ch ch if i end length buf append ch else char digit end i if  character is digit digit buf append ch else if ch buf append match group digit i else  string s match group digit if s length char b  text utilities get complementary bracket s char at null if b b s char at buf append b else buf append ch i else buf append ch char return value new char buf length buf get chars buf length return value return return value 
private byte match token  parser rule rule  parser rule base  line context ctx switch rule match type case  parser rule match type rule return base token case  parser rule match type context return context rules get default default return rule match type 
private boolean check hash string  parser rule rule for int i i rule up hash char length i if  character to upper case line array pos i rule up hash char char at i return false return true 
public  line context  parser rule set rs  line context lc rules rs parent lc null null  line context lc clone spa ns with no delegate need to propagate the escape rule to the child context so this is needed if rs get mode name null escape rule rules get escape rule else escape rule lc escape rule 
public  line context 
public  line context intern  line context obj intern get this if obj null intern put this this return this else return obj 
public int hash code if in rule null return in rule hash code else if rules null return rules hash code else return 
public boolean equals  object obj if obj instanceof  line context  line context lc  line context obj return lc in rule in rule lc rules rules  standard utilities objects equal parent lc parent char arrays equal span end subst lc span end subst else return false 
public  object clone  line context lc new  line context lc in rule in rule lc rules rules lc parent parent null null  line context parent clone lc span end subst span end subst lc escape rule escape rule return lc 
private static boolean char arrays equal char c char c if c null return c null c is not null if c null return false if c length c length return false for int i i c length i if c i c i return false return true 
 sets the current rule being processed and adjusts the escape rule for the context based on the rule public void set in rule  parser rule rule in rule rule if rule null rule escape rule null escape rule rule escape rule else if rules null rules get mode name null escape rule rules get escape rule else if parent null escape rule parent escape rule else escape rule null 
 replaces unprintable characters by their espaced or unicode escaped equivalents in the given string protected static final  string add escapes  string str  string builder retval new  string builder char ch for int i i str length i switch str char at i case continue case b retval append b continue case t retval append t continue case n retval append n continue case f retval append f continue case r retval append r continue case retval append continue case retval append continue case retval append continue default if ch str char at i x ch x e  string s  integer to string ch retval append u s substring s length s length else retval append ch continue return retval to string 
 returns a detailed message for the  error when it is thrown by the token manager to indicate a lexical error  parameters eof seen indicates if eof caused the lexicl error cur lex state lexical state in which this error occured error line line number when the error occured error column column number when the error occured error after prefix that was seen before this error occured curchar the offending character  note  you can customize the lexical error message by modifying this method protected static  string  lexical error boolean eof seen int lex state int error line int error column  string error after char cur char return  lexical error at line error line column error column  encountered eof seen eof add escapes  string value of cur char int cur char after add escapes error after 
 you can also modify the body of this method to customize your error messages  for example cases like loop detected and invalid lexical state are not of end users concern so you can return something like  internal  error  please file a bug report from this method for such cases in the release version of your parser public  string get message return super get message 
public  token mgr error 
public  token mgr error  string message int reason super message error code reason 
public  token mgr error boolean eof seen int lex state int error line int error column  string error after char cur char int reason this  lexical error eof seen lex state error line error column error after cur char reason 
public  tool bar manager  container top  container bottom this top top this bottom bottom 
public void add tool bar int group int layer  component toolbar  entry entry new  entry layer toolbar if group  view top group add tool bar top top tool bars entry else if group  view bottom group add tool bar bottom bottom tool bars entry else throw new  internal error  invalid tool bar group 
public void remove tool bar  component toolbar remove tool bar top top tool bars toolbar remove tool bar bottom bottom tool bars toolbar 
private static void add tool bar  container group  list  entry toolbars  entry entry  see if we should place this toolbar before any others for int i i toolbars size i if entry layer toolbars get i layer toolbars add i entry group add entry toolbar i return  place the toolbar at the bottom of the group toolbars add entry group add entry toolbar 
private static void remove tool bar  container group  list  entry toolbars  component toolbar for int i i toolbars size i if toolbar toolbars get i toolbar group remove toolbar toolbars remove i return 
 entry int layer  component toolbar this layer layer this toolbar toolbar 
public  tool bar option pane super toolbar 
protected void  init set layout new  border layout j panel panel new j panel new  grid layout  show toolbar show toolbar new j check box j edit get property options toolbar show toolbar show toolbar set selected j edit get boolean property view show toolbar panel add show toolbar panel add new j label j edit get property options toolbar caption add  border layout north panel list model new  default list model reload button list j edit get property view toolbar list new j list list model list set selection mode  list selection model single selection list add list selection listener new  list handler list set cell renderer new  button cell renderer add  border layout center new j scroll pane list  create buttons j panel buttons new j panel buttons set border new  empty border buttons set layout new  box layout buttons  box layout x axis  action handler action handler new  action handler add new  rollover button gui utilities load icon j edit get property options toolbar add icon add set tool tip text j edit get property options toolbar add add add action listener action handler buttons add add buttons add  box create horizontal strut remove new  rollover button gui utilities load icon j edit get property options toolbar remove icon remove set tool tip text j edit get property options toolbar remove remove add action listener action handler buttons add remove buttons add  box create horizontal strut move up new  rollover button gui utilities load icon j edit get property options toolbar move up icon move up set tool tip text j edit get property options toolbar move up move up add action listener action handler buttons add move up buttons add  box create horizontal strut move down new  rollover button gui utilities load icon j edit get property options toolbar move down icon move down set tool tip text j edit get property options toolbar move down move down add action listener action handler buttons add move down buttons add  box create horizontal strut edit new  rollover button gui utilities load icon j edit get property options toolbar edit icon edit set tool tip text j edit get property options toolbar edit edit add action listener action handler buttons add edit buttons add  box create glue add reset to defaults button reset new  rollover button gui utilities load icon j edit get property options toolbar reset icon reset set tool tip text j edit get property options toolbar reset reset add action listener action handler buttons add reset update buttons add  border layout south buttons  ceate icons list icon list new  default combo box model  string tokenizer st new  string tokenizer j edit get property icons while st has more elements  string icon st next token icon list add element new  icon list entry gui utilities load icon icon icon 
protected void  save j edit set boolean property view show toolbar show toolbar is selected  string builder buf new  string builder for int i i list model get size i if i buf append  button button  button list model element at i buf append button action name j edit set property button action name icon button icon name j edit set property view toolbar buf to string 
private void update buttons int index list get selected index remove set enabled index list model get size move up set enabled index move down set enabled index index list model get size edit set enabled index 
private void reload button list  string toolbar  string tokenizer st new  string tokenizer toolbar list model clear while st has more tokens  string action name st next token if action name equals list model add element new  tool bar option pane  button null null else  edit action action j edit get action action name if action null continue  string label action get label if label null continue  icon icon  string icon name if action name equals icon name null icon null else icon name j edit get property action name icon if icon name null icon gui utilities load icon j edit get property broken image icon else icon gui utilities load icon icon name if icon null icon gui utilities load icon j edit get property broken image icon list model add element new  button action name icon name icon label 
public int compare  button button  button button return  standard utilities compare strings button label button label true 
 button  string action name  string icon name  icon icon  string label this action name action name this icon name icon name this icon icon this label gui utilities prettify menu label label 
public  string to string return label 
public boolean equals  object o if o instanceof  button return  button o action name equals action name else return false 
 icon list entry  icon icon  string name this icon icon this name name 
public  string to string return name 
public  component get list cell renderer component j list list  object value int index boolean is selected boolean cell has focus super get list cell renderer component list value index is selected cell has focus  button button  button value set icon button icon return this 
public  component get list cell renderer component j list list  object value int index boolean is selected boolean cell has focus super get list cell renderer component list value index is selected cell has focus  icon list entry icon  icon list entry value set icon icon icon return this 
public void action performed  action event evt  object source evt get source if source add  tool bar edit dialog dialog new  tool bar edit dialog  tool bar option pane this icon list null  button selection dialog get selection if selection null return int index list get selected index if index index list model get size else index list model insert element at selection index list set selected index index list ensure index is visible index else if source remove int index list get selected index list model remove element at index if list model get size if list model get size index list set selected index index else list set selected index index update buttons else if source move up int index list get selected index  object selected list get selected value list model remove element at index list model insert element at selected index list set selected index index list ensure index is visible index else if source move down int index list get selected index  object selected list get selected value list model remove element at index list model insert element at selected index list set selected index index list ensure index is visible index else if source edit  tool bar edit dialog dialog new  tool bar edit dialog  tool bar option pane this icon list  button list get selected value  button selection dialog get selection if selection null return int index list get selected index list model set element at selection index list set selected index index list ensure index is visible index else if source reset  string dialog type options toolbar reset dialog int result gui utilities confirm list dialog type null j option pane yes no option j option pane warning message if result j option pane yes option the user should be able to cancel the options dialog so we need to modify the list not the actual property since the default value is not available we reset fetch default value and re set to original  string org toolbar j edit get property view toolbar j edit reset property view toolbar  string default toolbar j edit get property view toolbar j edit set property view toolbar org toolbar reload button list default toolbar reset selection if user had more buttons than default list set selected index list ensure index is visible update buttons 
public void value changed  list selection event evt update buttons 
public  tool bar edit dialog  component comp  default combo box model icon list model  tool bar option pane  button current super gui utilities get parent dialog comp j edit get property options toolbar edit title true j panel content new j panel new  border layout content set border new  empty border set content pane content  action handler action handler new  action handler  button group grp new  button group j panel type panel new j panel new  grid layout type panel set border new  empty border type panel add new j label j edit get property options toolbar edit caption separator new j radio button j edit get property options toolbar edit separator separator add action listener action handler grp add separator type panel add separator action new j radio button j edit get property options toolbar edit action action add action listener action handler grp add action type panel add action content add  border layout north type panel j panel action panel new j panel new  border layout  action set actions list j edit get action sets  string selected action set j edit get property options toolbar selected action set  action set selected item null  vector  action set vec new  vector  action set actions list length for int i i actions list length i  action set action set actions list i if action set get action count vec add action set if action set get label equals selected action set selected item action set combo new j combo box vec if selected item null combo set selected item selected item else j edit unset property options toolbar selected action set combo add action listener action handler action panel add  border layout north combo list new j list list set visible row count list set selection mode  list selection model single selection action panel add  border layout center new j scroll pane list  icon selection j panel icon panel new j panel new  border layout j panel label panel new j panel new  grid layout label panel set border new  empty border j panel comp panel new j panel new  grid layout grp new  button group label panel add builtin new j radio button j edit get property options toolbar edit builtin builtin add action listener action handler grp add builtin label panel add file new j radio button j edit get property options toolbar edit file grp add file file add action listener action handler icon panel add  border layout west label panel builtin combo new j combo box icon list model builtin combo set renderer new  tool bar option pane  icon cell renderer comp panel add builtin combo file button new j button j edit get property options toolbar edit no icon file button set margin new  insets file button set icon gui utilities load icon  blank gif file button set horizontal alignment  swing constants left file button add action listener action handler comp panel add file button icon panel add  border layout center comp panel action panel add  border layout south icon panel content add  border layout center action panel j panel south panel new j panel south panel set layout new  box layout south panel  box layout x axis south panel set border new  empty border south panel add  box create glue ok new j button j edit get property common ok ok add action listener action handler get root pane set default button ok south panel add ok south panel add  box create horizontal strut cancel new j button j edit get property common cancel cancel add action listener action handler south panel add cancel south panel add  box create glue content add  border layout south south panel if current null action set selected true builtin set selected true update list else if current action name equals separator set selected true builtin set selected true else action set selected true  action set set j edit get action set for action current action name combo set selected item set update list list set selected value current true if  misc utilities is url current icon name file set selected true file icon current icon name try file button set icon new  image icon new url file icon catch  malformed url exception mf  log log  log error this mf file button set text  misc utilities get file name file icon else builtin set selected true  list model model builtin combo get model for int i i model get size i  tool bar option pane  icon list entry entry  tool bar option pane  icon list entry model get element at i if entry name equals current icon name builtin combo set selected index i break update enabled pack set location relative to gui utilities get parent dialog comp set visible true 
public void ok is ok true dispose 
public void cancel dispose 
public  tool bar option pane  button get selection if is ok return null if separator is selected return new  tool bar option pane  button null null else  icon icon  string icon name if builtin is selected  tool bar option pane  icon list entry selected icon  tool bar option pane  icon list entry builtin combo get selected item icon selected icon icon icon name selected icon name else icon file button get icon icon name file icon if icon name null icon name  blank gif  string label  string action name if action is selected  tool bar option pane  button button  tool bar option pane  button list get selected value label button label action name button action name else throw new  internal error return new  tool bar option pane  button action name icon name icon label 
private void update enabled combo set enabled action is selected list set enabled action is selected boolean icon controls enabled separator is selected builtin set enabled icon controls enabled file set enabled icon controls enabled builtin combo set enabled icon controls enabled builtin is selected file button set enabled icon controls enabled file is selected 
private void update list  action set action set  action set combo get selected item  string action set label action set get label j edit set property options toolbar selected action set action set label  edit action actions action set get actions  vector  tool bar option pane  button list model new  vector  tool bar option pane  button actions length for int i i actions length i  edit action action actions i  string label action get label if label null continue list model add new  tool bar option pane  button action get name null null label  collections sort list model new  tool bar option pane  button compare list set list data list model 
public void action performed  action event evt  object source evt get source if source instanceof j radio button update enabled if source ok ok else if source cancel cancel else if source combo update list else if source file button  string directory if file icon null directory null else directory  misc utilities get parent of path file icon  string paths gui utilities show vfs file dialog null directory vfs browser open dialog false if paths null return file icon file paths try file button set icon new  image icon new url file icon catch  malformed url exception mf  log log  log error this mf file button set text  misc utilities get file name file icon 
 override public  point get tool tip location  mouse event event return new  point event get x 
public void paint fold start  gutter gutter  graphics d gfx int screen line int physical line boolean next line visible int y int line height j edit buffer buffer int  y y line height gfx set color gutter get fold color if next line visible gfx draw line  y  y gfx draw line  y  y gfx draw line  y  y gfx draw line  y  y gfx draw line  y  y else gfx draw line  y  y gfx draw line  y  y gfx draw line  y  y gfx draw line  y  y gfx draw line  y  y 
public void paint fold end  gutter gutter  graphics d gfx int screen line int physical line int y int line height j edit buffer buffer gfx set color gutter get fold color int  y y line height gfx draw line  y  y gfx draw line  y  y 
public void paint fold middle  gutter gutter  graphics d gfx int screen line int physical line int y int line height j edit buffer buffer 
 constructs a primitive type param sort the sort of the primitive type to be constructed private  type final int sort this sort sort this len 
 constructs a reference type param sort the sort of the reference type to be constructed param buf a buffer containing the descriptor of the previous type param off the offset of this descriptor in the previous buffer param len the length of this descriptor private  type final int sort final char buf final int off final int len this sort sort this buf buf this off off this len len 
 returns the  java type corresponding to the given type descriptor param type descriptor a type descriptor return the  java type corresponding to the given type descriptor public static  type get type final  string type descriptor return get type type descriptor to char array 
 returns the  java type corresponding to the given class param c a class return the  java type corresponding to the given class public static  type get type final  class c if c is primitive if c  integer type return int type else if c  void type return void type else if c  boolean type return boolean type else if c  byte type return byte type else if c  character type return char type else if c  short type return short type else if c  double type return double type else if c  float type return float type else if c  long type return long type else return get type get descriptor c 
 returns the  java types corresponding to the argument types of the given method descriptor param method descriptor a method descriptor return the  java types corresponding to the argument types of the given method descriptor public static  type get argument types final  string method descriptor char buf method descriptor to char array int off int size while true char car buf off if car break else if car l while buf off size else if car size  type args new  type size off size while buf off args size get type buf off off args size len size return args 
 returns the  java types corresponding to the argument types of the given method param method a method return the  java types corresponding to the argument types of the given method public static  type get argument types final  method method  class classes method get parameter types  type types new  type classes length for int i classes length i i types i get type classes i return types 
 returns the  java type corresponding to the return type of the given method descriptor param method descriptor a method descriptor return the  java type corresponding to the return type of the given method descriptor public static  type get return type final  string method descriptor char buf method descriptor to char array return get type buf method descriptor index of 
 returns the  java type corresponding to the return type of the given method param method a method return the  java type corresponding to the return type of the given method public static  type get return type final  method method return get type method get return type 
 returns the  java type corresponding to the given type descriptor param buf a buffer containing a type descriptor param off the offset of this descriptor in the previous buffer return the  java type corresponding to the given type descriptor private static  type get type final char buf final int off int len switch buf off case v return void type case z return boolean type case c return char type case b return byte type case s return short type case i return int type case f return float type case j return long type case d return double type case len while buf off len len if buf off len l len while buf off len len return new  type array buf off len case l default len while buf off len len return new  type object buf off len 
 returns the sort of this  java type return link void void link boolean boolean link char char link byte byte link short short link int int link float float link long long link double double link array array or link object object public int get sort return sort 
 returns the number of dimensions of this array type  this method should only be used for an array type return the number of dimensions of this array type public int get dimensions int i while buf off i i return i 
 returns the type of the elements of this array type  this method should only be used for an array type return  returns the type of the elements of this array type public  type get element type return get type buf off get dimensions 
 returns the name of the class corresponding to this object type  this method should only be used for an object type return the fully qualified name of the class corresponding to this object type public  string get class name return new  string buf off len replace 
 returns the internal name of the class corresponding to this object type  the internal name of a class is its fully qualified name where are replaced by  this method should only be used for an object type return the internal name of the class corresponding to this object type public  string get internal name return new  string buf off len 
 returns the descriptor corresponding to this  java type return the descriptor corresponding to this  java type public  string get descriptor  string builder buf new  string builder get descriptor buf return buf to string 
 returns the descriptor corresponding to the given argument and return types param return type the return type of the method param argument types the argument types of the method return the descriptor corresponding to the given argument and return types public static  string get method descriptor final  type return type final  type argument types  string builder buf new  string builder buf append for int i i argument types length i argument types i get descriptor buf buf append return type get descriptor buf return buf to string 
 appends the descriptor corresponding to this  java type to the given string buffer param buf the string buffer to which the descriptor must be appended private void get descriptor final  string builder buf switch sort case void buf append v return case boolean buf append z return case char buf append c return case byte buf append b return case short buf append s return case int buf append i return case float buf append f return case long buf append j return case double buf append d return case array case object default buf append this buf off len 
 returns the internal name of the given class  the internal name of a class is its fully qualified name where are replaced by param c an object class return the internal name of the given class public static  string get internal name final  class c return c get name replace 
 returns the descriptor corresponding to the given  java type param c an object class a primitive class or an array class return the descriptor corresponding to the given class public static  string get descriptor final  class c  string builder buf new  string builder get descriptor buf c return buf to string 
 returns the descriptor corresponding to the given method param m a link  method  method object return the descriptor of the given method public static  string get method descriptor final  method m  class parameters m get parameter types  string builder buf new  string builder buf append for int i i parameters length i get descriptor buf parameters i buf append get descriptor buf m get return type return buf to string 
 appends the descriptor of the given class to the given string buffer param buf the string buffer to which the descriptor must be appended param c the class whose descriptor must be computed private static void get descriptor final  string builder buf final  class c  class d c while true if d is primitive char car if d  integer type car i else if d  void type car v else if d  boolean type car z else if d  byte type car b else if d  character type car c else if d  short type car s else if d  double type car d else if d  float type car f else if d  long type car j buf append car return else if d is array buf append d d get component type else buf append l  string name d get name int len name length for int i i len i char car name char at i buf append car car buf append return 
 returns the size of values of this type return the size of values of this type i e for tt long tt and tt double tt and otherwise public int get size return sort long sort double 
 returns a jvm instruction opcode adapted to this  java type param opcode a jvm instruction opcode  this opcode must be one of iload istore iaload iastore iadd isub imul idiv irem ineg ishl ishr iushr iand ior ixor and ireturn return an opcode that is similar to the given opcode but adapted to this  java type  for example if this type is tt float tt and tt opcode tt is ireturn this method returns freturn public int get opcode final int opcode if opcode  constants iaload opcode  constants iastore switch sort case void return opcode case boolean case byte return opcode case char return opcode case short return opcode case int return opcode case float return opcode case long return opcode case double return opcode case array case object default return opcode else switch sort case void return opcode case boolean case char case byte case short case int return opcode case float return opcode case long return opcode case double return opcode case array case object default return opcode 
 get the  java types of the arguments public static  class get types  object args if args null return new  class  class types new  class args length for int i i args length i if args i null types i null else if args i instanceof  primitive types i  primitive args i get type else types i args i get class return types 
 is the from signature argument types assignable to the to signature candidate method types  this method handles the special case of null values in to types indicating a loose type and matching anything  should check for strict java here and limit to is java assignable static boolean is signature assignable  class from  class to int round if round java varargs assignable from length to length return false switch round case java base assignable for int i i from length i if is java base assignable to i from i return false return true case java box types assigable for int i i from length i if is java box types assignable to i from i return false return true case java varargs assignable return is signature varargs assignable from to case bsh assignable for int i i from length i if is bsh assignable to i from i return false return true default throw new  interpreter error bad case 
private static boolean is signature varargs assignable  class from  class to return false 
 test if a conversion of the rhs type type to the lhs type type is legal via standard  java assignment conversion rules i e without a cast  the rules include  java autoboxing unboxing p  for  java primitive type classes this method takes primitive promotion into account  the ordinary  class is assignable from does not take primitive promotion conversions into account  note that  java allows additional assignments without a cast in combination with variable declarations and array allocations  those are handled elsewhere maybe should be here with a flag p  this class accepts a null rhs type type indicating that the rhs type was the value  primitive null and allows it to be assigned to any reference lhs type type non primitive p  note that the get assignable form method is the primary bsh method for checking assignability  it adds additional bsh conversions etc see is bsh assignable  class  class param lhs type assigning from rhs type to lhs type param rhs type assigning from rhs type to lhs type static boolean is java assignable  class lhs type  class rhs type return is java base assignable lhs type rhs type is java box types assignable lhs type rhs type 
 is the assignment legal via original  java up to version assignment rules not including auto boxing unboxing param rhs type may be null to indicate primitive null value static boolean is java base assignable  class lhs type  class rhs type  assignment to loose type defer to bsh extensions  note we could shortcut this here if lhs type null return true rather than forcing another round  it s not strictly a  java issue so does it belong here if lhs type null return false null rhs type corresponds to type of  primitive null assignable to any object type if rhs type null return lhs type is primitive if lhs type is primitive rhs type is primitive if lhs type rhs type return true handle primitive widening conversions jls if rhs type  byte type lhs type  short type lhs type  integer type lhs type  long type lhs type  float type lhs type  double type return true if rhs type  short type lhs type  integer type lhs type  long type lhs type  float type lhs type  double type return true if rhs type  character type lhs type  integer type lhs type  long type lhs type  float type lhs type  double type return true if rhs type  integer type lhs type  long type lhs type  float type lhs type  double type return true if rhs type  long type lhs type  float type lhs type  double type return true if rhs type  float type lhs type  double type return true else if lhs type is assignable from rhs type return true return false 
 determine if the type is assignable via  java boxing unboxing rules static boolean is java box types assignable  class lhs type  class rhs type  assignment to loose type defer to bsh extensions if lhs type null return false prim can be boxed and assigned to  object if lhs type  object class return true prim numeric type can be boxed and assigned to number if lhs type  number class rhs type  character type rhs type  boolean type return true  general case prim type to wrapper or vice versa i don t know if this is faster than a flat list of if s like above wrapper map maps both prim to wrapper and wrapper to prim types so this test is symmetric if  primitive wrapper map get lhs type rhs type return true return false 
 test if a type can be converted to another type via  bean shell extended syntax rules a superset of  java conversion rules static boolean is bsh assignable  class to type  class from type try return cast object to type from type null from value assignment true check only valid cast catch  util eval error e  this should not happen with check only true throw new  interpreter error err in cast check e 
 attempt to cast an object instance to a new type if possible via  bean shell extended syntax rules  these rules are always a superset of  java conversion rules  if you wish to impose context sensitive conversion rules then you must test before calling this method p  this method can handle from value  primitive types representing primitive casts as well as from value object casts requiring interface generation etc param to type the class type of the cast result which may include primitive types e g  byte type param from value an  object or bsh  primitive primitive value including  primitive null or  primitive void see is bsh assignable  class  class public static  object cast object  object from value  class to type int operation throws  util eval error if from value null throw new  interpreter error null from value  class from type from value instanceof  primitive  primitive from value get type from value get class return cast object to type from type from value operation false checkonly 
 perform a type conversion or test if a type conversion is possible with respect to  bean shell extended rules  these rules are always a superset of the  java language rules so this method can also perform but not test any  java language assignment or cast conversion p  this method can perform the functionality of testing if an assignment or cast is ultimately possible with respect to  bean shell as well as the functionality of performing the necessary conversion of a value based on the specified target type  this combined functionality is done for expediency and could be separated later p  other methods such as is java assignable should be used to determine the suitability of an assignment in a fine grained or restrictive way based on context before calling this method p a cast is stronger than an assignment operation in that it will attempt to perform primtive operations that cast to a smaller type e g byte my long  these are used in explicit primitive casts primitive delclarations and array declarations i don t believe there are any object conversions which are different between assignment and cast e g scripted object to interface proxy in bsh is done on assignment as well as cast p  this method does not obey strict java you must test first before using this method if you care  see is java assignable p param to type the class type of the cast result which may include primitive types e g  byte type to type may be null to indicate a loose type assignment which matches any from type param from type is the class type of the value to be cast including java primitive type classes for primitives  if from value is or would be  primitive null then from type should be null param from value an  object or bsh  primitive primitive value including  primitive null or  primitive void param check only  if check only is true then from value must be null  from type is checked for the cast to to type  if check only is false then from value must be non null  primitive null is ok and the actual cast is performed throws  util eval error on invalid assignment when operation is assignment throws  util target error wrapping  class cast exception on cast error when operation is cast param operation is  types cast or  types assignment see org gjt sp jedit bsh  primitive get type  notes  this method is currently responsible for auto boxing unboxing conversions  where does that need to go private static  object cast object  class to type  class from type  object from value int operation boolean check only throws  util eval error  lots of preconditions checked here  once things are running smoothly we might comment these out  that s what assertions are for if check only from value null throw new  interpreter error bad cast params if check only from value null throw new  interpreter error bad cast params if from type  primitive class throw new  interpreter error bad from  type need to unwrap if from value  primitive null from type null throw new  interpreter error inconsistent args if from value  primitive void from type  void type throw new  interpreter error inconsistent args if to type  void type throw new  interpreter error loose to type should be null assignment to loose type void type or exactly same type if to type null to type from type return check only valid cast from value  casting to primitive type if to type is primitive if from type  void type from type null from type is primitive  both primitives do primitive cast return  primitive cast primitive to type from type  primitive from value check only operation else if  primitive is wrapper type from type wrapper to primitive  convert value to  primitive and check cast it  object r check only valid cast  class unboxed from type  primitive unbox type from type  primitive prim from value if check only prim from value null must be null in check only else prim from value  primitive  primitive wrap from value unboxed from type return  primitive cast primitive to type unboxed from type prim from value check only operation else  cannot cast from arbitrary object to primitive if check only return invalid cast else throw cast error to type from type operation  else casting to reference type  casting from primitive or void to reference type if from type  void type from type null from type is primitive cast from primitive to wrapper type if  primitive is wrapper type to type from type  void type from type null primitive to wrapper type return check only valid cast  primitive cast wrapper  primitive unbox type to type  primitive from value get value  primitive not null or void to  object class type if to type  object class from type  void type from type null box it return check only valid cast  primitive from value get value  primitive to arbitrary object type  allow  primitive cast to type to handle it as well as cases of  primitive null and  primitive void return  primitive cast primitive to type from type  primitive from value check only operation  if type already assignable no cast necessary  we do this last to allow various errors above to be caught e g cast  primitive  void to  object would pass this if to type is assignable from from type return check only valid cast from value  can we use the proxy mechanism to cast a bsh  this to the correct interface if to type is interface org gjt sp jedit bsh  this class is assignable from from type  capabilities can generate interfaces return check only valid cast org gjt sp jedit bsh  this from value get interface to type  both numeric wrapper types  try numeric style promotion wrapper cast if  primitive is wrapper type to type  primitive is wrapper type from type return check only valid cast  primitive cast wrapper to type from value if check only return invalid cast else throw cast error to type from type operation 
 return a  util eval error or  util target error wrapping a  class cast exception describing an illegal assignment or illegal cast respectively static  util eval error cast error  class lhs type  class rhs type int operation return cast error  reflect normalize class name lhs type  reflect normalize class name rhs type operation 
static  util eval error cast error  string lhs  string rhs int operation if operation assignment return new  util eval error  can t assign rhs to lhs  exception cce new  class cast exception  cannot cast rhs to lhs return new  util target error cce 
public  undo manager j edit buffer buffer this buffer buffer 
public void set limit int limit this limit limit 
public void clear undos first undos last redos first redos last null undo count 
public boolean can undo return undos last null 
public int undo if inside compound edit throw new  internal error  unbalanced begin end compound edit if undos last null return else revise undo id undo count int caret undos last undo redos first undos last undos last undos last prev if undos last null undos first null return caret 
public boolean can redo return redos first null 
public int redo if inside compound edit throw new  internal error  unbalanced begin end compound edit if redos first null return else revise undo id undo count int caret redos first redo undos last redos first if undos first null undos first undos last redos first redos first next return caret 
public void begin compound edit if compound edit count compound edit new  compound edit revise undo id compound edit count 
public void end compound edit if compound edit count  log log  log warning this new  exception  unbalanced begin end compound edit return else if compound edit count if compound edit first null nothing done between begin end calls else if compound edit first compound edit last add edit compound edit first else add edit compound edit compound edit null compound edit count 
public boolean inside compound edit return compound edit count 
public  object get undo id return undo id 
public void content inserted int offset int length  string text boolean clear dirty  edit last get last edit  edit to merge get merge edit if clear dirty to merge instanceof  insert redos first null  insert ins  insert to merge if ins offset offset ins str text concat ins str ins length length return else if ins offset ins length offset ins str ins str concat text ins length length return  insert ins new  insert this offset length text if clear dirty redo clear dirty last undo clear dirty ins if compound edit null compound edit add ins else revise undo id add edit ins 
public void content removed int offset int length  string text boolean clear dirty  edit last get last edit  edit to merge get merge edit if clear dirty to merge instanceof  remove redos first null  remove rem  remove to merge if rem offset offset rem content str rem content str concat text rem content hashcode rem content str hash code rem length length  kill ring get instance changed rem content return else if offset length rem offset rem content str text concat rem content str rem content hashcode rem content str hash code rem length length rem offset offset  kill ring get instance changed rem content return  remove rem new  remove this offset length text if clear dirty redo clear dirty last undo clear dirty rem if compound edit null compound edit add rem else revise undo id add edit rem  kill ring get instance add rem content 
public void reset clear dirty redo clear dirty get last edit if redos first instanceof  compound edit undo clear dirty  compound edit redos first first else undo clear dirty redos first 
private void add edit  edit edit if undos first null undos first undos last edit else undos last next edit edit prev undos last undos last edit redos first redos last null undo count while undo count limit undo count if undos first undos last undos first undos last null else undos first next prev null undos first undos first next 
private  edit get merge edit  edit last get last edit return compound edit null compound edit last last 
private  edit get last edit if undos last instanceof  compound edit return  compound edit undos last last else return undos last 
private void revise undo id undo id new  object 
 insert  undo manager mgr int offset int length  string str this mgr mgr this offset offset this length length this str str 
int undo mgr buffer remove offset length if mgr undo clear dirty this mgr buffer set dirty false return offset 
int redo mgr buffer insert offset str if mgr redo clear dirty this mgr buffer set dirty false return offset length 
public  removed content  string str this str str this hashcode str hash code 
public  string to string return str 
 remove  undo manager mgr int offset int length  string str this mgr mgr this offset offset this length length this content new  removed content str 
int undo mgr buffer insert offset content str if mgr undo clear dirty this mgr buffer set dirty false return offset length 
int redo mgr buffer remove offset length if mgr redo clear dirty this mgr buffer set dirty false return offset 
public int undo int ret val  edit edit last while edit null ret val edit undo edit edit prev return ret val 
public int redo int ret val  edit edit first while edit null ret val edit redo edit edit next return ret val 
public void add  edit edit if first null first last edit else edit prev last last next edit last edit 
public  url vfs super url read cap write cap 
public  string construct path  string parent  string path if parent ends with return parent path else return parent path 
public  input stream  create input stream  object session  string path boolean ignore errors  component comp throws io exception try return new url path open stream catch  malformed url exception mu  log log  log error this mu  string args mu get message vfs manager error comp path ioerror badurl args return null 
public  output stream  create output stream  object session  string path  component comp throws io exception try return new url path open connection get output stream catch  malformed url exception mu  log log  log error this mu  string args mu get message vfs manager error comp path ioerror badurl args return null 
protected  util eval error 
public  util eval error  string s super s 
 re throw as an eval error prefixing msg to the message and specifying the node  if a node already exists the add node is ignored p param msg may be null for no additional message public  eval error to eval error  string msg  simple node node  call stack callstack if  interpreter debug print stack trace if msg null msg else msg msg return new  eval error msg get message node callstack 
public  eval error to eval error  simple node node  call stack callstack return to eval error null node callstack 
public  util target error  string message  throwable t super message this t t 
public  util target error  throwable t this null t 
 override to eval error to throw  target error type public  eval error to eval error  string msg  simple node node  call stack callstack if msg null msg get message else msg msg get message return new  target error msg t node callstack false 
 variable  string name  class type lhs lhs this name name this lhs lhs this type type 
 variable  string name  object value  modifiers modifiers throws  util eval error this name  class null type value modifiers 
 this constructor is used in class generation  variable  string name  string type descriptor  object value  modifiers modifiers throws  util eval error this name  class null type value modifiers this type descriptor type descriptor 
param value may be null if this  variable  string name  class type  object value  modifiers modifiers throws  util eval error this name name this type type this modifiers modifiers set value value declaration 
 set the value of the typed variable param value should be an object or wrapped bsh  primitive type if value is null the appropriate default value will be set for the type e g false for boolean zero for integer types public void set value  object value int context throws  util eval error check this value if has modifier final this value null throw new  util eval error  final variable can t re assign if value null value  primitive get default value type if lhs null lhs assign value false strictjava return todo should add is java castable test for strict java as opposed to is java assignable if type null value  types cast object value type context declaration  types cast  types assignment this value value 
 object get value throws  util eval error if lhs null return lhs get value return value 
a type of null means loosely typed variable public  class get type return type 
public  string get type descriptor return type descriptor 
public  modifiers get modifiers return modifiers 
public  string get name return name 
public boolean has modifier  string name return modifiers null modifiers has modifier name 
public  string to string return  variable super to string name type type value value lhs lhs 
 creates a variable grid layout manager with the specified mode size horizontal and vertical gap eventually taking minimum and maximum sizes into account when distributing free space depending on take sizes into account and the specified distance to the borders param mode  the mode in which to operate  either fixed num rows or fixed num columns param size  the amount of rows for mode fixed num rows or the amount of columns for mode fixed num columns param hgap  the horizontal space between cells param vgap  the vertical space between cells param take sizes into account  whether to take minimum and maximum sizes into account when distributing free space param distance to borders  the distances to the borders throws  illegal argument exception if mode is not either fixed num rows or fixed num columns or size is or hgap or vgap is public  variable grid layout int mode int size int hgap int vgap boolean take sizes into account  insets distance to borders if mode fixed num rows mode fixed num columns throw new  illegal argument exception illegal mode value is mode if size throw new  illegal argument exception size cannot be zero or less value is size if hgap throw new  illegal argument exception hgap cannot be negative value is hgap if vgap throw new  illegal argument exception vgap cannot be negative value is vgap this mode mode this size size this hgap hgap this vgap vgap this take sizes into account take sizes into account this distance to borders  insets distance to borders clone 
 creates a variable grid layout manager with the specified mode size horizontal and vertical gap eventually taking minimum and maximum sizes into account when distributing free space depending on take sizes into account and zero distance to borders param mode  the mode in which to operate  either fixed num rows or fixed num columns param size  the amount of rows for mode fixed num rows or the amount of columns for mode fixed num columns param hgap  the horizontal space between cells param vgap  the vertical space between cells param take sizes into account  whether to take minimum and maximum sizes into account when distributing free space throws  illegal argument exception if mode is not either fixed num rows or fixed num columns or size is or hgap or vgap is public  variable grid layout int mode int size int hgap int vgap boolean take sizes into account this mode size hgap vgap take sizes into account new  insets 
 creates a variable grid layout manager with the specified mode size horizontal and vertical gap and zero distance to borders  the minimum and maximum  component sizes are not taken into account when distributing free space param mode  the mode in which to operate  either fixed num rows or fixed num columns param size  the amount of rows for mode fixed num rows or the amount of columns for mode fixed num columns param hgap  the horizontal space between cells param vgap  the vertical space between cells throws  illegal argument exception if mode is not either fixed num rows or fixed num columns or size is or hgap or vgap is public  variable grid layout int mode int size int hgap int vgap this mode size hgap vgap false new  insets 
 creates a variable grid layout manager with the specified mode and size zero horizontal and vertical gap and zero distance to borders  does not take minimum and maximum  component sizes into account when distributing free space param mode  the mode in which to operate  either fixed num rows or fixed num columns param size  the amount of rows for mode fixed num rows or the amount of columns for mode fixed num columns throws  illegal argument exception if mode is not either fixed num rows or fixed num columns or size is public  variable grid layout int mode int size this mode size false new  insets 
 creates a variable grid layout manager with mode fixed num rows number of rows zero horizontal and vertical gap and zero distance to borders  does not take minimum and maximum  component sizes into account when distributing free space public  variable grid layout this fixed num rows false new  insets 
 not used in this class public void add layout component  string name  component component 
 not used in this class public void add layout component  component component  object constraints 
 not used in this class public void remove layout component  component component 
 always returns public float get layout alignment x  container container return f 
 always returns public float get layout alignment y  container container return f 
public  dimension preferred layout size  container parent return get layout size parent  layout size preferred 
public  dimension minimum layout size  container parent return get layout size parent  layout size minimum 
public  dimension maximum layout size  container parent return get layout size parent  layout size maximum 
public void layout container  container parent synchronized parent get tree lock update parent int ncomponents parent get component count if ncomponents return  pass compute minimum preferred and maximum row heights column widths int total height  arrays fill row heights  arrays fill col widths if take sizes into account  arrays fill minimum row heights  arrays fill minimum col widths  arrays fill maximum row heights  integer max value  arrays fill maximum col widths  integer max value for int r i r nrows r for int c c ncols c i if i ncomponents  component comp parent get component i  dimension d comp get preferred size row heights r  math max row heights r d height col widths c  math max col widths c d width if take sizes into account d comp get minimum size minimum row heights r  math max minimum row heights r d height minimum col widths c  math max minimum col widths c d width d comp get maximum size maximum row heights r  math min maximum row heights r d height maximum col widths c  math min maximum col widths c d width else break if take sizes into account correct cases where minimum row heights row row heights row maximum row heights row is not true by clipping to the minimum row heights and maximum row heights if minimum row heights r maximum row heights r maximum row heights r minimum row heights r row heights r minimum row heights r else if row heights r minimum row heights r row heights r minimum row heights r else if row heights r maximum row heights r row heights r maximum row heights r total height row heights r int total width for int c c ncols c if take sizes into account correct cases where minimum col widths col col widths col maximum col widths col is not true by clipping to the minimum col widths and maximum col widths if minimum col widths c maximum col widths c maximum col widths c minimum col widths c col widths c minimum col widths c else if col widths c minimum col widths c col widths c minimum col widths c else if col widths c maximum col widths c col widths c maximum col widths c total width col widths c  pass redistribute free space  dimension parent size parent get size  insets insets parent get insets int free height parent size height insets top insets bottom nrows vgap distance to borders top distance to borders bottom int free width parent size width insets left insets right ncols hgap distance to borders left distance to borders right redistribute space total height free height take sizes into account nrows row heights minimum row heights maximum row heights redistribute space total width free width take sizes into account ncols col widths minimum col widths maximum col widths  pass layout components for int r y insets top distance to borders top i r nrows y row heights r vgap r for int c x insets left distance to borders left c ncols x col widths c hgap c i if i ncomponents  component comp parent get component i  dimension d comp get maximum size int width col widths c int height row heights r int x correction int y correction if width d width x correction int width d width comp get alignment x width d width if height d height y correction int height d height comp get alignment y height d height comp set bounds x x correction y y correction width height synchronized 
public void invalidate layout  container container 
 returns the string representation of this variable grid layout s values return a string representation of this variable grid layout public  string to string return get class get name mode fixed num rows mode fixed num rows fixed num columns mode fixed num columns unknown mode size size hgap hgap vgap vgap take sizes into account take sizes into account distance to borders distance to borders 
param which if  layout size minimum compute minimum layout size if  layout size maximum compute maximum layout size if  layout size preferred compute preferred layout size private  dimension get layout size  container parent  layout size which synchronized parent get tree lock update parent int ncomponents parent get component count long h long w for int r i r nrows r int row height for int c c ncols c i if i ncomponents switch which case minimum row height  math max row height parent get component i get minimum size height break case maximum row height  math max row height parent get component i get maximum size height break case preferred row height  math max row height parent get component i get preferred size height break default throw new  internal error  missing case branch for  layout size which h row height for int c c ncols c int col width for int r r nrows r int i r ncols c if i ncomponents switch which case minimum col width  math max col width parent get component i get minimum size width break case maximum col width  math max col width parent get component i get maximum size width break case preferred col width  math max col width parent get component i get preferred size width break default throw new  internal error  missing case branch for  layout size which w col width  insets insets parent get insets w insets left insets right ncols hgap distance to borders left distance to borders right h insets top insets bottom nrows vgap distance to borders top distance to borders bottom if w  integer max value w  integer max value if h  integer max value h  integer max value return new  dimension int w int h 
private void update  container container int ncomponents container get component count int old nrows nrows int old ncols ncols if this mode fixed num rows nrows this size ncols ncomponents nrows nrows else ncols this size nrows ncomponents ncols ncols if old nrows nrows row heights new int nrows if take sizes into account minimum row heights new int nrows maximum row heights new int nrows if old ncols ncols col widths new int ncols if take sizes into account minimum col widths new int ncols maximum col widths new int ncols 
private void redistribute space int total size int free size boolean take sizes into account int nelements int element sizes int minimum element sizes int maximum element sizes if total size free size if take sizes into account boolean grow total size free size calculate the size that is available for redistribution free size free size total size grow while free size calculate the amount of elements that can be resized without violating the minimum and maximum sizes and their current cumulated size int modifyable amount int modify size for int i i nelements i if grow element sizes i maximum element sizes i grow element sizes i minimum element sizes i modifyable amount modify size element sizes i boolean check bounds true if all elements are at their minimum or maximum size resize all elements if modifyable amount for int i i nelements i modify size element sizes i check bounds false modifyable amount nelements to prevent an endless loop if the container gets resized to a very small amount if modify size break resize the elements if free size modifyable amount for int i i nelements i if free size check bounds check bounds grow element sizes i maximum element sizes i grow element sizes i minimum element sizes i element sizes i grow if element sizes i element sizes i free size else int modify size addition for int i i nelements i int modifyable size check bounds grow maximum element sizes i element sizes i element sizes i minimum element sizes i  integer max value element sizes i int element modify size int double free size double modify size double element sizes i if element modify size modifyable size element sizes i grow element modify size element modify size modify size addition grow element modify size element modify size free size element modify size else element sizes i grow modifyable size modifyable size modify size addition grow modifyable size modifyable size free size modifyable size if element sizes i element sizes i modify size modify size addition else double d double free size double total size for int i i nelements i element sizes i int element sizes i d 
deprecated  use the form where the constructor takes a capability list  deprecated protected vfs  string name this name 
 creates a new virtual filesystem param name  the name param caps  the capabilities protected vfs  string name int caps this name name this caps caps reasonable defaults this ext attrs new  string ea size ea type 
 creates a new virtual filesystem param name  the name param caps  the capabilities param ext attrs  the extended attributes since j edit pre protected vfs  string name int caps  string ext attrs this name name this caps caps this ext attrs ext attrs 
 returns this vfs s name  the name is used to obtain the label stored in the code vfs i name i label code property public  string get name return name 
 returns the capabilities of this vfs since j edit pre public int get capabilities return caps 
 returns if an additional markers file can be saved by this vfs  default is code true since j edit pre public boolean is markers file supported return true 
 returns the extended attributes supported by this vfs since j edit pre public  string get extended attributes return ext attrs 
 displays a dialog box that should set up a session and return the initial url to browse param session  where the vfs session will be stored param comp  the component that will parent error dialog boxes return  the url since j edit pre deprecated  this function is not used in the j edit core anymore so it doesn t have to be provided anymore  if you want to use it for another purpose like in the ftp plugin feel free to do so  deprecated public  string show browse dialog  object session  component comp return null 
 returns the file name component of the specified path param path  the path since j edit pre public  string get file name  string path if path equals return path while path ends with path ends with  file separator path path substring path length int index  math max path last index of path last index of  file separator char if index index path index of don t want get file name roots to return if index index path length return path return path substring index 
 returns the parent of the specified path  this must be overridden to return a non null value for browsing of this filesystem to work param path  the path since j edit pre public  string get parent of path  string path ignore last character of path to properly handle paths like foo bar int last index path length while last index path char at last index  file separator char path char at last index last index int count  math max last index int index path last index of  file separator char count if index index path last index of count if index this ensures that get file parent protocol for example is protocol and not index path last index of return path substring index 
 constructs a path from the specified directory and file name component  this must be overridden to return a non null value otherwise browsing this filesystem will not work p  unless you are writing a vfs this method should not be called directly  to ensure correct behavior you b must b call link org gjt sp jedit  misc utilities construct path  string  string instead param parent  the parent directory param path  the path since j edit pre public  string construct path  string parent  string path return parent path 
 returns the file separator used by this vfs since j edit pre public char get file separator return 
 returns a temporary file name based on the given path  by default j edit first saves a file to code i name i save code and then renames it to the original file  however some virtual file systems might not support the code code character in filenames so this method permits the vfs to override this behavior  if this method returns code null code two stage save will not be used for that particular file introduced in j edit pre param path  the path name since j edit pre public  string get two stage save name  string path return  misc utilities construct path get parent of path path get file name path save 
 called before a directory is reloaded by the file system browser  can be used to flush a cache etc since j edit pre public void reload directory  string path 
 creates a vfs session  this method is called from the awt thread so it should not do any i o  it could however prompt for a login name and password for example param path  the path in question param comp  the component that will parent any dialog boxes shown return  the session  the session can be null if there were errors since j edit pre public  object create vfs session  string path  component comp return new  object 
 loads the specified buffer  the default implementation posts an i o request to the i o thread param view  the view param buffer  the buffer param path  the path public boolean load  view view  buffer buffer  string path if get capabilities read cap vfs manager error view path vfs not supported load new  string name return false  object session create vfs session path view if session null return false if get capabilities write cap buffer set read only true  buffer io request request new  buffer load request view buffer session this path if buffer is temporary this makes  hyper search much faster request run else vfs manager run in work thread request return true 
 saves the specifies buffer  the default implementation posts an i o request to the i o thread param view  the view param buffer  the buffer param path  the path public boolean save  view view  buffer buffer  string path if get capabilities write cap vfs manager error view path vfs not supported save new  string name return false  object session create vfs session path view if session null return false  when doing a save as the path to save to path will not be the same as the buffer s previous path buffer get path  in that case we want to create a backup of the new path even if the old path was backed up as well backed up property set if path equals buffer get path buffer unset property  buffer backed up vfs manager run in work thread new  buffer save request view buffer session this path return true 
 copy a file to another using vfs param progress the progress observer  it could be null if you don t want to monitor progress  if not null you should probably launch this command in a  work thread param source vfs the source vfs param source session the vfs session param source path the source path param target vfs the target vfs param target session the target session param target path the target path param comp comp  the component that will parent error dialog boxes param can stop could this copy be stopped return true if the copy was successful throws io exception io exception  if an i o error occurs since j edit pre public static boolean copy  progress observer progress vfs source vfs  object source session  string source path vfs target vfs  object target session  string target path  component comp boolean can stop throws io exception if progress null progress set status  initializing  input stream in null  output stream out null try vfs file source vfs file source vfs  get file source session source path comp if source vfs file null throw new  file not found exception source path if progress null progress set maximum source vfs file get length vfs file target vfs file target vfs  get file target session target path comp if target vfs file get type vfs file directory if target vfs file get path equals source vfs file get path return false target path  misc utilities construct path target path source vfs file get name in new  buffered input stream source vfs  create input stream source session source path false comp out new  buffered output stream target vfs  create output stream target session target path comp boolean copy result io utilities copy stream iobufsize progress in out can stop vfs manager send vfs update target vfs target path true return copy result finally io utilities close quietly in io utilities close quietly out 
 copy a file to another using vfs param progress the progress observer  it could be null if you don t want to monitor progress  if not null you should probably launch this command in a  work thread param source path the source path param target path the target path param comp comp  the component that will parent error dialog boxes param can stop if true the copy can be stopped return true if the copy was successful throws io exception io exception  if an i o error occurs since j edit pre public static boolean copy  progress observer progress  string source path  string target path  component comp boolean can stop throws io exception vfs source vfs vfs manager get vfs for path source path  object source session source vfs create vfs session source path comp if source session null  log log  log warning vfs class  unable to get a valid session from source vfs for path source path return false vfs target vfs vfs manager get vfs for path target path  object target session target vfs create vfs session target path comp if target session null  log log  log warning vfs class  unable to get a valid session from target vfs for path target path return false return copy progress source vfs source session source path target vfs target session target path comp can stop 
 inserts a file into the specified buffer  the default implementation posts an i o request to the i o thread param view  the view param buffer  the buffer param path  the path public boolean insert  view view  buffer buffer  string path if get capabilities read cap vfs manager error view path vfs not supported load new  string name return false  object session create vfs session path view if session null return false vfs manager run in work thread new  buffer insert request view buffer session this path return true 
 returns the canonical form of the specified path name  for example code code might be expanded to the user s home directory param session  the session param path  the path param comp  the component that will parent error dialog boxes exception io exception if an i o error occurred since j edit pre public  string  canon path  object session  string path  component comp throws io exception return path 
a convinience method that matches file names against globs and can optionally list the directory recursively param session  the session param directory  the directory  note that this must be a full url including the host name path name and so on  the username and password if needed by the vfs is obtained from the session instance param glob  only file names matching this glob will be returned param recursive  if true subdirectories will also be listed param comp  the component that will parent error dialog boxes exception io exception if an i o error occurred since j edit pre public  string  list directory  object session  string directory  string glob boolean recursive  component comp throws io exception  string retval  list directory session directory glob recursive comp true false return retval 
a convenience method that matches file names against globs and can optionally list the directory recursively param session  the session param directory  the directory  note that this must be a full url including the host name path name and so on  the username and password if needed by the vfs is obtained from the session instance param glob  only file names matching this glob will be returned param recursive  if true subdirectories will also be listed param comp  the component that will parent error dialog boxes exception io exception if an i o error occurred param skip binary ignore binary files do not return them  this will slow down the process since it will open the files param skip hidden skips hidden files directories and backup files  ignores any file beginning with or or ending with or bak since j edit pre public  string  list directory  object session  string directory  string glob boolean recursive  component comp boolean skip binary boolean skip hidden throws io exception vfs file filter filter new  glob vfs file filter glob return  list directory session directory filter recursive comp skip binary skip hidden 
a convenience method that filters the directory listing according to a filter and can optionally list the directory recursively param session  the session param directory  the directory  note that this must be a full url including the host name path name and so on  the username and password if needed by the vfs is obtained from the session instance param filter  the link vfs file filter to use for filtering param recursive  if true subdirectories will also be listed param comp  the component that will parent error dialog boxes exception io exception if an i o error occurred param skip binary ignore binary files do not return them  this will slow down the process since it will open the files param skip hidden skips hidden files directories and backup files  ignores any file beginning with or or ending with or bak since j edit pre public  string  list directory  object session  string directory vfs file filter filter boolean recursive  component comp boolean skip binary boolean skip hidden throws io exception  list  string files new  array list  string list files session new  hash set  string files directory filter recursive comp skip binary skip hidden  string ret val files to array new  string files size  arrays sort ret val new  standard utilities  string compare  string true return ret val 
 lists the specified directory param session  the session param directory  the directory  note that this must be a full url including the host name path name and so on  the username and password if needed by the vfs is obtained from the session instance param comp  the component that will parent error dialog boxes exception io exception if an i o error occurred since j edit pre public vfs file  list files  object session  string directory  component comp throws io exception return  list directory session directory comp 
deprecated  use code  list files code instead  deprecated public  directory entry  list directory  object session  string directory  component comp throws io exception vfs manager error comp directory vfs not supported list new  string name return null 
 returns the specified directory entry param session  the session get it with link vfs create vfs session  string  component param path  the path param comp  the component that will parent error dialog boxes exception io exception if an i o error occurred return  the specified directory entry or null if it doesn t exist since j edit pre public vfs file  get file  object session  string path  component comp throws io exception return  get directory entry session path comp 
 returns the specified directory entry param session  the session get it with link vfs create vfs session  string  component param path  the path param comp  the component that will parent error dialog boxes exception io exception if an i o error occurred return  the specified directory entry or null if it doesn t exist since j edit pre deprecated  use code  get file code instead  deprecated public  directory entry  get directory entry  object session  string path  component comp throws io exception return null 
since j edit pre public  directory entry 
public  directory entry  string name  string path  string delete path int type long length boolean hidden this name name this path path this delete path delete path this symlink path path this type type this length length this hidden hidden if path null maintain backwards compatibility vfs vfs vfs manager get vfs for path path can read vfs get capabilities read cap can write vfs get capabilities write cap 
 deletes the specified url param session  the vfs session param path  the path param comp  the component that will parent error dialog boxes exception io exception if an i o error occurs since j edit pre public boolean  delete  object session  string path  component comp throws io exception return false 
 renames the specified url  some filesystems might support moving ur ls between directories however others may not  do not rely on this behavior param session  the vfs session param from  the old path param to  the new path param comp  the component that will parent error dialog boxes exception io exception if an i o error occurs since j edit pre public boolean  rename  object session  string from  string to  component comp throws io exception return false 
 creates a new directory with the specified url param session  the vfs session param directory  the directory param comp  the component that will parent error dialog boxes exception io exception if an i o error occurs since j edit pre public boolean  mkdir  object session  string directory  component comp throws io exception return false 
 backs up the specified file  this should only be overriden by the local filesystem vfs param session  the vfs session param path  the path param comp  the component that will parent error dialog boxes exception io exception if an i o error occurs since j edit pre public void  backup  object session  string path  component comp throws io exception 
 creates an input stream  this method is called from the i o thread param session the vfs session param path  the path param ignore errors  if true file not found errors should be ignored param comp  the component that will parent error dialog boxes return an inputstream or code null code if there was a problem exception io exception  if an i o error occurs since j edit pre public  input stream  create input stream  object session  string path boolean ignore errors  component comp throws io exception vfs manager error comp path vfs not supported load new  string name return null 
 creates an output stream  this method is called from the i o thread param session the vfs session param path  the path param comp  the component that will parent error dialog boxes exception io exception  if an i o error occurs since j edit pre public  output stream  create output stream  object session  string path  component comp throws io exception vfs manager error comp path vfs not supported save new  string name return null 
 called after a file has been saved param session  the vfs session param buffer  the buffer param path  the path the buffer was saved to can be different from link org gjt sp jedit  buffer get path if the user invoked the b  save a  copy  as b command for example param comp  the component that will parent error dialog boxes exception io exception  if an i o error occurs since j edit pre public void  save complete  object session  buffer buffer  string path  component comp throws io exception 
 called after a file has been saved and we use two stage save first saving to another file  this should re apply permissions for example param session  the vfs session param buffer  the buffer param path  the path the buffer was saved to can be different from link org gjt sp jedit  buffer get path if the user invoked the b  save a  copy  as b command for example param comp  the component that will parent error dialog boxes exception io exception  if an i o error occurs since j edit pre public void  finish two stage save  object session  buffer buffer  string path  component comp throws io exception 
 finishes the specified vfs session  this must be called after all i o with this vfs is complete to avoid leaving stale network connections and such param session  the vfs session param comp  the component that will parent error dialog boxes exception io exception if an i o error occurred since j edit pre public void  end vfs session  object session  component comp throws io exception 
 returns color of the specified file name by matching it against user specified regular expressions since j edit pre public static  color get default color for  string name synchronized lock if colors null load colors for int i i colors size i  color entry entry colors get i if entry re matcher name matches return entry color return null 
 creates a new code  directory entry compare code param sort mix files and dirs  if false directories are put at the top of the listing param sort ignore case  if false upper case comes before lower case public  directory entry compare boolean sort mix files and dirs boolean sort ignore case this sort mix files and dirs sort mix files and dirs this sort ignore case sort ignore case 
public int compare vfs file file vfs file file if sort mix files and dirs if file get type file get type return file get type file get type return  standard utilities compare strings file get name file get name sort ignore case 
private void list files  object session  collection  string stack  list  string files  string directory vfs file filter filter boolean recursive  component comp boolean skip binary boolean skip hidden throws io exception  string resolved path directory if recursive  misc utilities is url directory resolved path  misc utilities resolve symlinks directory  if looking at a symlink do not traverse the resolved path more than once if directory equals resolved path if stack contains resolved path  log log  log error this  recursion in list files directory return stack add resolved path  thread ct  thread current thread  work thread wt null if ct instanceof  work thread wt  work thread ct vfs file  files  list files session directory comp if  files null  files length return for int i i  files length i if wt null wt is aborted break vfs file file  files i if skip hidden file is hidden  misc utilities is backup file get name continue if filter accept file continue if file get type vfs file directory file get type vfs file filesystem if recursive  string canon path  canon path session file get path comp list files session stack files canon path filter recursive comp skip binary skip hidden else  it s a regular file if skip binary try if file is binary session  log log  log notice this file get path skipped as a binary file continue catch io exception e  log log  log error this e may be not binary files add file get path 
private static void load colors synchronized lock colors new  array list  color entry if j edit get boolean property vfs browser colorize return  string glob int i while glob j edit get property vfs browser colors i glob null try colors add new  color entry  pattern compile  standard utilities glob to re glob j edit get color property vfs browser colors i color  color black catch  pattern syntax exception e  log log  log error vfs class  invalid regular expression glob  log log  log error vfs class e i 
 color entry  pattern re  color color this re re this color color 
 opens the specified directory in a new floating file system browser param view  the view param path  the directory s path since j edit pre public static void browse directory in new window  view view  string path  dockable window manager wm view get dockable window manager if path null this is such a bad way of doing it but oh well j edit set temporary property vfs browser path tmp path wm float dockable window vfs browser j edit unset property vfs browser path tmp 
 opens the specified directory in a file system browser param view  the view param path  the directory s path since j edit pre public static void browse directory  view view  string path  dockable window manager wm view get dockable window manager vfs browser browser vfs browser wm get dockable name if browser null wm show dockable window name browser set directory path else if path null this is such a bad way of doing it but oh well j edit set temporary property vfs browser path tmp path wm add dockable window vfs browser j edit unset property vfs browser path tmp 
 returns the browser action context since j edit pre public static  action context get action context return action context 
 creates a new vfs browser param view  the view to open buffers in by default public vfs browser  view view  string position this view null browser true position 
 creates a new vfs browser param view  the view to open buffers in by default param path  the path to display param mode  the browser mode param multiple selection  true if multiple selection should be allowed param position  where the browser is located since j edit pre public vfs browser  view view  string path int mode boolean multiple selection  string position super new  border layout listener list new  event listener list this mode mode this multiple selection multiple selection this view view  dockable window manager dwm view get dockable window manager  key listener key listener dwm close listener name add key listener key listener current encoding j edit get property buffer encoding  system get property file encoding auto detect encoding j edit get boolean property buffer encoding autodetect  action handler action handler new  action handler top box new  box  box layout y axis horizontal layout mode browser  dockable window manager top equals position  dockable window manager bottom equals position toolbar box new  box horizontal layout  box layout x axis  box layout y axis top box add toolbar box  grid bag layout layout new  grid bag layout path and filter panel new j panel layout if is horizontal layout path and filter panel set border new  empty border  grid bag constraints cons new  grid bag constraints cons gridwidth cons gridheight cons gridx cons gridy cons fill  grid bag constraints both cons anchor  grid bag constraints east j label label new j label j edit get property vfs browser path  swing constants right label set border new  empty border layout set constraints label cons path and filter panel add label path field new  history text field vfs browser path path field set name path path field add key listener key listener path field set instant popups true path field set enter adds to history false path field set select all on focus true if mode browser path field add key listener new  key adapter public void key released  key event e if e get key code  key event vk escape path field set text vfs browser this path because its preferred size can be quite wide we don t want it to make the browser way too big so set the preferred width to  dimension pref size path field get preferred size pref size width path field set preferred size pref size path field add action listener action handler cons gridx cons weightx cons gridwidth  grid bag constraints remainder layout set constraints path field cons path and filter panel add path field filter checkbox new j check box j edit get property vfs browser filter filter checkbox set margin new  insets filter checkbox set request focus enabled false filter checkbox set border new  empty border filter checkbox set selected j edit get boolean property vfs browser filter enabled filter checkbox add action listener action handler filter checkbox add key listener key listener filter checkbox set name filter checkbox if mode choose directory dialog cons gridwidth cons gridx cons weightx cons gridy layout set constraints filter checkbox cons path and filter panel add filter checkbox filter field new j combo box filter editor new  history combo box editor vfs browser filter filter editor set tool tip text j edit get property glob tooltip filter editor set instant popups true filter editor set select all on focus true filter editor add action listener action handler filter editor add key listener key listener filter field set name filter field  string filter if mode browser j edit get boolean property vfs browser current buffer filter filter j edit get property vfs browser last filter if filter null filter j edit get property vfs browser default filter else  string ext  misc utilities get file extension view get buffer get name if ext length filter j edit get property vfs browser default filter else filter ext filter field get editor set item new  glob vfs file filter filter filter field add item filter field get editor get item filter editor set item new  glob vfs file filter filter filter field add item filter editor get item filter field add item listener action handler filter field set renderer new vfs file filter renderer loads the registered vfs file filter services  string  filters  service manager get service names vfs file filter service name for int i i  filters length i vfs file filter  filter vfs file filter  service manager get service vfs file filter service name  filters i filter field add item  filter if mode choose directory dialog cons gridwidth  grid bag constraints remainder cons fill  grid bag constraints horizontal cons gridx cons weightx if filter field get item count filter field set editor filter editor filter field set editable true layout set constraints filter field cons path and filter panel add filter field else layout set constraints filter editor cons path and filter panel add filter editor top box add path and filter panel add  border layout north top box add  border layout center browser view new  browser view this if is horizontal layout browser view set border new  empty border default focus component browser view get table properties changed update filter enabled set focus traversal policy new  layout focus traversal policy see vfs browser browse directory if path null path j edit get property vfs browser path tmp if path null path length  string user home  system get property user home  string default path j edit get property vfs browser default path if home equals default path path user home else if working equals default path path  system get property user dir else if buffer equals default path  buffer buffer view get buffer path buffer get directory else if last equals default path  history model path model  history model get model vfs browser path if path model get size path else path path model get item else if favorites equals default path path favorites else unknown value path user home final  string  path path  swing utilities invoke later new  runnable public void run set directory  path 
public void focus on default component path field request focus default focus component request focus 
 only used by vfs file chooser dialog since it embeds this in a dialog void set default focus component j component c default focus component c 
 override public void add notify super add notify  edit bus add to bus this 
 override public void remove notify super remove notify j edit set boolean property vfs browser filter enabled filter checkbox is selected if mode browser j edit get boolean property vfs browser current buffer filter vfs file filter selected filter vfs file filter filter field get selected item if selected filter instanceof  glob vfs file filter j edit set property vfs browser last filter  glob vfs file filter selected filter get glob  edit bus remove from bus this 
public void handle message eb message msg if msg instanceof  properties changed properties changed else if msg instanceof  buffer update  buffer update bmsg  buffer update msg if bmsg get what  buffer update created bmsg get what  buffer update closed browser view update file view else if msg instanceof  plugin update  plugin update pmsg  plugin update msg if pmsg get what  plugin update loaded pmsg get what  plugin update unloaded plugins null plugins can be null if the vfs browser menu bar is hidden plugins update popup menu else if msg instanceof vfs update maybe reload directory vfs update msg get path 
public  view get view return view 
public int get mode return mode 
public boolean is multiple selection enabled return multiple selection 
public boolean is horizontal layout return horizontal layout 
public boolean get show hidden files return show hidden files 
public void set show hidden files boolean show hidden files this show hidden files show hidden files 
 returns the file name filter glob since j edit pre deprecated  use link get vfs file filter instead  this method might return wrong information since j edit pre  deprecated public  string get filename filter if filter checkbox is selected  string filter filter field get selected item to string if filter length return else return filter else return 
 returns the currently active vfs file filter since j edit pre public vfs file filter get vfs file filter if mode choose directory dialog return new  directories only filter return vfs file filter filter field get selected item 
 adds a file filter to the browser since j edit pre public void add vfs file filter vfs file filter filter filter field add item filter if filter field get item count filter field set editor filter editor filter field set editable true  grid bag layout layout  grid bag layout path and filter panel get layout  grid bag constraints cons layout get constraints filter editor cons gridwidth  grid bag constraints remainder cons fill  grid bag constraints horizontal cons gridx cons weightx path and filter panel remove filter editor layout set constraints filter field cons path and filter panel add filter field path and filter panel validate path and filter panel repaint 
public void set filename filter  string filter if filter null filter length equals filter filter checkbox set selected false else filter checkbox set selected true filter editor set item new  glob vfs file filter filter 
public  history text field get directory field return path field 
public  string get directory return path 
since jedit pre public void previous directory if history stack size history stack pop next directory stack push path set directory history stack peek history stack pop 
since j edit pre public void next directory if next directory stack is empty set directory next directory stack pop 
public void set directory  string path if path starts with file path path substring path  misc utilities expand variables path path field set text path if start request return history stack push path browser view save expansion state browser view load directory null path true this path path vfs manager run in awt thread new  runnable public void run end request 
public static  string get root directory if  operating system is mac os  operating system is dos derived return  file roots vfs protocol else return 
 goes to the local drives directory since j edit pre public void root directory set directory get root directory 
public void reload directory used by ftp plugin to clear directory cache vfs manager get vfs for path path reload directory path browser view save expansion state browser view load directory null path false 
 note that all files must be on the same vfs since j edit pre public void delete vfs file files  string dialog type if  misc utilities is url files get delete path  favorites vfs protocol equals  misc utilities get protocol of url files get delete path dialog type vfs browser delete favorites else dialog type vfs browser delete confirm  string builder buf new  string builder  string type str files for int i i files length i buf append files i get path buf append n if files i get type vfs file directory type str directories and their contents  object args buf to string type str int result gui utilities confirm this dialog type args j option pane yes no option j option pane warning message if result j option pane yes option return vfs vfs vfs manager get vfs for path files get delete path if start request return for int i i files length i  object session vfs create vfs session files i get delete path this if session null continue vfs manager run in work thread new  browser io request  browser io request delete this session vfs files i get delete path null null vfs manager run in awt thread new  runnable public void run end request 
public void rename  string from vfs vfs vfs manager get vfs for path from  string filename vfs get file name from  string args filename  string to gui utilities input this vfs browser rename args filename if to null return to  misc utilities construct path vfs get parent of path from to  object session vfs create vfs session from this if session null return if start request return vfs manager run in work thread new  browser io request  browser io request rename this session vfs from to null vfs manager run in awt thread new  runnable public void run end request 
public void rename  string from  string newname vfs vfs vfs manager get vfs for path from  string filename vfs get file name from  string args filename  string to newname if to null filename equals newname return to  misc utilities construct path vfs get parent of path from to  object session vfs create vfs session from this if session null return if start request return vfs manager run in work thread new  browser io request  browser io request rename this session vfs from to null vfs manager run in awt thread new  runnable public void run end request 
public void mkdir  string new directory gui utilities input this vfs browser mkdir null if new directory null return if a directory is selected create new dir in there if a file is selected create new dir inside its parent final vfs file selected get selected files  string parent if selected length parent path else if selected get type vfs file file parent selected get path parent vfs manager get vfs for path parent get parent of path parent else parent selected get path vfs vfs vfs manager get vfs for path parent path is the currently viewed directory in the browser new directory  misc utilities construct path parent new directory  object session vfs create vfs session new directory this if session null return if start request return vfs manager run in work thread new  browser io request  browser io request mkdir this session vfs new directory null null vfs manager run in awt thread new  runnable public void run end request if selected length selected get type vfs file file vfs directory entry table directory entry table browser view get table int selected row directory entry table get selected row vfs directory entry table model model vfs directory entry table model directory entry table get model vfs directory entry table model  entry entry model files selected row if entry expanded browser view clear expansion state browser view load directory entry entry dir entry get path false 
 creates a new file in the current directory since j edit pre public void new file vfs file selected get selected files if selected length vfs file file selected if file get type vfs file directory j edit new file view file get path else vfs vfs vfs manager get vfs for path file get path j edit new file view vfs get parent of path file get path else j edit new file view path 
 show selected file s properties public void file properties vfs file files new  file properties dialog view this files 
 opens a directory search in the current directory since j edit pre public void search in directory vfs file selected get selected files if selected length vfs file file selected search in directory file get path file get type vfs file file else search in directory path true 
 opens a directory search in the specified directory param path  the path name param directory  true if the path is a directory false if it is a file since j edit pre public void search in directory  string path boolean directory  string filter vfs file filter vfsff get vfs file filter if vfsff instanceof  glob vfs file filter filter  glob vfs file filter vfsff get glob else filter if directory  string name  misc utilities get file name path  string ext  misc utilities get file extension name filter ext null ext length filter ext path  misc utilities get parent of path path  search and replace set search file set new  directory list set path filter true  search dialog show search dialog view null  search dialog directory 
 browser view get browser view return browser view 
since j edit pre public vfs file get selected files return browser view get selected files 
 goes to the given file s directory and selects the file in the list param path  the file since j edit pre public void locate file final  string path vfs file filter filter get vfs file filter if filter accept  misc utilities get file name path set filename filter null set directory  misc utilities get parent of path path vfs manager run in awt thread new  runnable public void run browser view get table select file path 
public j component create plugins menu j component plugin menu boolean show manager options  action handler action handler new  action handler if show manager options get mode browser plugin menu add gui utilities load menu item plugin manager false plugin menu add gui utilities load menu item plugin options false if plugin menu instanceof j menu j menu plugin menu add separator else if plugin menu instanceof j popup menu j popup menu plugin menu add separator else we re in a modal dialog  list j menu item vec new  array list j menu item old api  enumeration vfs e vfs manager get filesystems while e has more elements vfs vfs e next element if vfs get capabilities vfs browse cap continue j menu item menu item new j menu item j edit get property vfs vfs get name label menu item set action command vfs get name menu item add action listener action handler vec add menu item new api  edit plugin plugins j edit get plugins for int i i plugins length i j menu item menu item plugins i create browser menu items if menu item null vec add menu item if vec is empty  collections sort vec new  menu item text comparator for int i i vec size i plugin menu add vec get i else j menu item mi new j menu item j edit get property vfs browser plugins no plugins label mi set enabled false plugin menu add mi return plugin menu 
public void add browser listener  browser listener l listener list add  browser listener class l 
public void remove browser listener  browser listener l listener list remove  browser listener class l 
 this method does the double click handling  it is public so that code browser actions xml code can bind to it since j edit pre public void files activated int mode boolean can double click close vfs file selected files browser view get selected files  buffer buffer null check selected for int i i selected files length i vfs file file selected files i if file get type vfs file directory file get type vfs file filesystem if mode m open new view this mode browser browse directory in new window view file get path else set directory file get path else if this mode browser this mode browser dialog if mode m insert view get buffer insert file view file get path continue check selected  buffer  buffer j edit get buffer file get path if  buffer null  hashtable  string  object props new  hashtable  string  object props put j edit buffer encoding current encoding props put  buffer encoding autodetect  boolean value of auto detect encoding  buffer j edit open file view null file get path false props else if double click close can double click close this mode browser dialog selected files length close if this buffer is currently visible in the view  edit pane edit panes view get edit panes for int j j edit panes length j if edit panes j get buffer  buffer j edit close buffer view  buffer return if  buffer null buffer  buffer else if a file is selected in open dialog or save dialog mode just let the listener s handle it if buffer null switch mode case m open view set buffer buffer break case m open new view j edit new view view buffer false break case m open new plain view j edit new view view buffer true break case m open new split view split horizontally set buffer buffer break  object listeners listener list get listener list for int i i listeners length i if listeners i  browser listener class  browser listener l  browser listener listeners i l files activated this selected files 
public void move  string new position boolean horz mode browser  dockable window manager top equals new position  dockable window manager bottom equals new position if horz horizontal layout return horizontal layout horz top box remove toolbar box toolbar box new  box horizontal layout  box layout x axis  box layout y axis top box add toolbar box properties changed 
void directory loaded  object node  object load info boolean add to history vfs manager run in awt thread new  directory loaded awt request node load info add to history 
void files selected vfs file selected files browser view get selected files if mode browser for int i i selected files length i vfs file file selected files i  buffer buffer j edit get buffer file get path if buffer null view null view set buffer buffer  object listeners listener list get listener list for int i i listeners length i if listeners i  browser listener class  browser listener l  browser listener listeners i l files selected this selected files 
void end request request running false 
private  container create menu bar j tool bar menu bar new j tool bar menu bar set floatable false menu bar add new  commands menu button menu bar add  box create horizontal strut menu bar add plugins new  plugins menu button menu bar add  box create horizontal strut menu bar add favorites new  favorites menu button return menu bar 
private  container create tool bar if mode browser return gui utilities load tool bar action context vfs browser toolbar browser else return gui utilities load tool bar action context vfs browser toolbar dialog 
private void properties changed show hidden files j edit get boolean property vfs browser show hidden files sort mix files and dirs j edit get boolean property vfs browser sort mix files and dirs sort ignore case j edit get boolean property vfs browser sort ignore case double click close j edit get boolean property vfs browser double click close browser view properties changed toolbar box remove all if j edit get boolean property vfs browser show toolbar  container toolbar create tool bar if horizontal layout toolbar box add toolbar else toolbar box add toolbar if j edit get boolean property vfs browser show menubar  container menubar create menu bar if horizontal layout toolbar box add menubar else menubar add  box create glue toolbar box add menubar else plugins null favorites null revalidate if path null reload directory 
private boolean start request if request running dump stack trace for debugging purposes  log log  log debug this new  throwable  for debugging purposes gui utilities error this browser multiple io null return false else request running true return true 
private void update filter enabled filter field set enabled filter checkbox is selected filter editor set enabled filter checkbox is selected 
private void maybe reload directory  string dir if  misc utilities is url dir  misc utilities get protocol of url dir equals  favorites vfs protocol if favorites null favorites popup null this is a dirty hack and it relies on the fact that updates for parents are sent before updates for the changed nodes themselves if this was not the case the browser wouldn t be updated properly on delete etc to avoid causing request errors don t reload directory if request already active if maybe reload request running  log log  log warning this vfs update request already in progress return save a file sends vfs update if a vfs file dialog box is shown from the same event frame as the save the vfs update will be delivered before the directory is loaded and before the path is set if path null try maybe reload request running true browser view maybe reload directory dir finally vfs manager run in awt thread new  runnable public void run maybe reload request running false 
public void action performed  action event evt if is processing event return  object source evt get source if source path field source filter checkbox is processing event true reset later update filter enabled  string p path field get text if p null set directory p browser view focus on file view else if source filter field get editor force the editor to refresh filter field get editor set item filter field get editor get item depending on  swing look feel filter field get editor returns some  combo box ui else if source filter editor force the editor to refresh filter editor set item filter editor get item filter field set selected item filter editor get item ugly item state changed does not seem to get fired item state changed new  item event filter field  item event item state changed filter editor get item  item event selected 
public void item state changed  item event e if is processing event return if e get state change  item event selected return is processing event true reset later filter field set editable e get item instanceof  glob vfs file filter update filter enabled  string path path field get text if path null set directory path browser view focus on file view 
 why this method exists since both action performed and item state changed above can change the combo box executing one of them can cause a chain reaction causing the other method to be called  this would cause the vfs subsystem to be called several times which would cause a warning to show up if the first operation is still in progress or cause a second operation to happen which is not really wanted especially if we re talking about a remove vfs  so the methods set a flag saying that something is going on and this method resets the flag after the awt thread is done with the current events private void reset later  swing utilities invoke later new  runnable public void run is processing event false 
 commands menu button set text j edit get property vfs browser commands label set icon gui utilities load icon j edit get property dropdown arrow icon set horizontal text position  swing constants leading set name commands popup new  browser commands menu vfs browser this null  commands menu button this set request focus enabled false set margin new  insets  commands menu button this add mouse listener new  mouse handler if  operating system is mac oslf  commands menu button this put client property j button button type toolbar 
 override public void mouse pressed  mouse event evt if popup is visible popup update gui utilities show popup menu popup  commands menu button this  commands menu button this get height false else popup set visible false 
 plugins menu button set text j edit get property vfs browser plugins label set icon gui utilities load icon j edit get property dropdown arrow icon set horizontal text position  swing constants leading set name plugins  plugins menu button this set request focus enabled false set margin new  insets  plugins menu button this add mouse listener new  mouse handler if  operating system is mac oslf  plugins menu button this put client property j button button type toolbar 
void update popup menu popup null 
private void create popup menu if popup null return popup j popup menu create plugins menu new j popup menu true 
 override public void mouse pressed  mouse event evt create popup menu if popup is visible gui utilities show popup menu popup  plugins menu button this  plugins menu button this get height false else popup set visible false 
 favorites menu button set text j edit get property vfs browser favorites label set icon gui utilities load icon j edit get property dropdown arrow icon set horizontal text position  swing constants leading set name favorites  favorites menu button this set request focus enabled false set margin new  insets  favorites menu button this add mouse listener new  mouse handler if  operating system is mac oslf  favorites menu button this put client property j button button type toolbar 
void create popup menu popup new j popup menu  action handler action handler new  action handler j menu item mi new j menu item j edit get property vfs browser favorites add to favorites label mi set action command add to favorites mi add action listener action handler popup add mi mi new j menu item j edit get property vfs browser favorites edit favorites label mi set action command dir favorites mi add action listener action handler popup add mi popup add separator vfs file favorites  favorites vfs get favorites if favorites length mi new j menu item j edit get property vfs browser favorites no favorites label mi set enabled false popup add mi else  arrays sort favorites new vfs  directory entry compare sort mix files and dirs sort ignore case for int i i favorites length i vfs file favorite favorites i mi new j menu item favorite get path mi set icon  file cell renderer get icon for file favorite false  string cmd favorite get type vfs file file file dir favorite get path mi set action command cmd mi add action listener action handler popup add mi 
public void action performed  action event evt  string action command evt get action command if add to favorites equals action command if any directories are selected add them otherwise add current directory vfs file selected get selected files if selected null selected length if path equals  favorites vfs protocol gui utilities error vfs browser this vfs browser recurse favorites null else  favorites vfs add to favorites path vfs file directory else for int i i selected length i vfs file file selected i  favorites vfs add to favorites file get path file get type else if action command starts with dir set directory action command substring else if action command starts with file switch get mode case browser j edit open file view action command substring break default locate file action command substring break 
 override public void mouse pressed  mouse event evt if popup null popup is visible popup set visible false return if popup null create popup menu gui utilities show popup menu popup  favorites menu button this  favorites menu button this get height false 
 directory loaded awt request  object node  object load info boolean add to history this node node this load info load info this add to history add to history 
public void run  string path  string load info if path null there was an error return vfs file list vfs file load info if node null  this is the new canonical path vfs browser this path path if path field get text equals path path field set text path if path ends with path ends with  file separator ensure consistent history eg we don t want both foo and foo path path substring path length if add to history  history model get model vfs browser path add item path boolean filter enabled filter checkbox is selected  list vfs file directory list new  array list vfs file int directories int files int invisible if list null vfs file filter filter get vfs file filter for int i i list length i vfs file file list i if file is hidden show hidden files invisible continue if filter null filter enabled filter instanceof  directories only filter filter accept file invisible continue if file get type vfs file file files else directories directory list add file  collections sort directory list new vfs  directory entry compare sort mix files and dirs sort ignore case browser view directory loaded node path directory list to notify listeners that any existing selection has been deactivated turns out under some circumstances this method can switch the current buffer in browser mode in any case this is only needed for the directory chooser why so we add a check otherwise poor  rick will go insane if mode choose directory dialog files selected 
 override public  string to string return  string load info 
 if event source hierarchy contains a vfs directory entry table this is the currently selected files there  otherwise this is the currently selected item in the parent directory list private static vfs file get selected files  event object evt vfs browser browser  component source  component evt get source if gui utilities get component parent source  browser view  parent directory list class null  object selected browser get browser view get parent directory list get selected values vfs file return value new vfs file selected length  system arraycopy selected return value selected length return return value else return browser get selected files 
 override public void invoke action  event object evt  edit action action vfs browser browser vfs browser gui utilities get component parent  component evt get source vfs browser class vfs file files get selected files evt browser in the future we will want something better eg having an evt object passed to  edit action invoke for now since all browser actions are written in beanshell we set the browser variable directly  name space global  bean shell get name space try global set variable browser browser global set variable files files  view view browser get view i guess ideally all browsers should have views but since they don t we just use the active view in that case since some actions depend on a view being there and i don t want to add checks to them all if view null view j edit get active view action invoke view catch  util eval error err  log log  log error this err finally try global set variable browser null global set variable files null catch  util eval error err  log log  log error this err 
 history combo box editor  string key super key 
public  object get item if current null current new  glob vfs file filter get text if current get glob equals get text current set glob get text return current 
public void set item  object item if item current if we keep the same object swing will cause an event to be fired on the default button of the dialog causing a beep since no file is selected if item null  glob vfs file filter filter  glob vfs file filter item current new  glob vfs file filter filter get glob set text current get glob return this happens when changing the selected item in the combo the combo has not yet fired an item state changed event so it s not put into non editable mode by the handler above if item instanceof  glob vfs file filter return if item null  glob vfs file filter filter  glob vfs file filter item filter new  glob vfs file filter filter get glob set text filter get glob add current to history current filter else set text current new  glob vfs file filter 
 override protected void process focus event  focus event e awt will call set item when the editor loses focus that can cause weird and unwanted things to happen so ignore lost focus events if e get id  focus event focus lost super process focus event e else set caret position get caret set visible false 
public  component get editor component return this 
 override public  component get list cell renderer component j list list  object value int index boolean is selected boolean cell has focus assert value instanceof vfs file filter  filter is not a vfs file filter super get list cell renderer component list value index is selected cell has focus set text vfs file filter value get description return this 
public boolean accept vfs file file return file get type vfs file directory file get type vfs file filesystem 
public boolean accept  string url return false 
public  string get description return j edit get property vfs browser file filter dir only 
vfs directory entry table  browser view browser view super new vfs directory entry table model this browser view browser view set show grid false set intercell spacing new  dimension set default renderer  entry class renderer new  file cell renderer header get table header header set reordering allowed false add mouse listener new  main mouse handler header add mouse listener new  mouse handler header set default renderer new  header renderer  default table cell renderer header get default renderer set row selection allowed true get column model add column model listener new  column handler set auto resize mode auto resize off 
public boolean select file  string path for int i i get row count i  entry entry  entry get value at i if entry dir entry get path equals path set selected row i return true return false 
public void do type select  string str boolean dirs only if str length clear selection else if get selected row do type select str get row count dirs only else int start get selection model get max selection index boolean ret val do type select str start get row count dirs only if ret val scan from selection to end failed so scan from start to selection do type select str start dirs only 
public vfs file get selected files vfs directory entry table model model vfs directory entry table model get model java util  list vfs file return value new  linked list vfs file int selected rows get selected rows for int i i selected rows length i return value add model files selected rows i dir entry return return value to array new vfs file return value size 
public void get expanded directories  set  string set vfs directory entry table model model vfs directory entry table model get model if model files null for int i i model files length i if model files i expanded set add model files i dir entry get path 
public void toggle expanded final int row vfs directory entry table model model vfs directory entry table model get model  entry entry model files row if entry dir entry get type vfs file file return if entry expanded model collapse vfs manager get vfs for path entry dir entry get path row resize columns else browser view clear expansion state browser view load directory entry entry dir entry get path false vfs manager run in awt thread new  runnable public void run set selected row row 
public void set directory vfs vfs  object node java util  list vfs file list  set  string tmp expanded timer stop type select buffer set length vfs directory entry table model model vfs directory entry table model get model int start index if node null start index model set root vfs list else start index model expand vfs  entry node list start index for int i i list size i  entry e model files start index i  string path e dir entry get path if tmp expanded contains path browser view load directory e path false tmp expanded remove path resize columns 
public void maybe reload directory  string path vfs directory entry table model model vfs directory entry table model get model for int i i model files length i  entry e model files i if e expanded e dir entry get type vfs file file continue vfs file dir entry e dir entry work around for broken ftp plugin  string other path if dir entry get symlink path null other path dir entry get path else other path dir entry get symlink path if  misc utilities paths equal path other path browser view save expansion state browser view load directory e path false return 
public void properties changed renderer properties changed vfs file template new vfs file foo foo foo vfs file file l false set row height renderer get table cell renderer component this new  entry template false false get preferred size height  dimension pref size get preferred size set preferred scrollable viewport size new  dimension pref size width get row height 
 override public void scroll rect to visible  rectangle rect avoid scrolling to the right rect width super scroll rect to visible rect 
 override public void process key event  key event evt if evt get id  key event key pressed vfs directory entry table model model vfs directory entry table model get model int row get selected row  action context ac vfs browser get action context  action context jac j edit get action context  edit action browser up ac get action vfs browser up vfs browser browser browser view get browser switch evt get key code case  key event vk left evt consume if evt get modifiers  input event alt mask browser previous directory else if row if model files row expanded toggle expanded row return for int i row i i if model files i expanded model files i level model files row level set selected row i return  string dir browser view get browser get directory dir  misc utilities get parent of path dir browser view get browser set directory dir break case  key event vk tab evt consume if evt get modifiers  input event shift mask browser view get parent directory list request focus else browser focus on default component break case  key event vk back space evt consume ac invoke action evt browser up break case  key event vk up if evt get modifiers  input event alt mask evt consume ac invoke action evt browser up break case  key event vk delete evt consume  edit action delete act ac get action vfs browser delete ac invoke action evt delete act break case  key event vk n if evt get modifiers ex  input event ctrl down mask  input event ctrl down mask evt consume  edit action ea ac get action vfs browser new file ac invoke action evt ea break case  key event vk insert evt consume  edit action new dir ac get action vfs browser new directory ac invoke action evt new dir break case  key event vk escape  edit action cda jac get action close docking area cda invoke j edit get active view evt consume break case  key event vk f  edit action ren ac get action vfs browser rename evt consume ac invoke action evt ren break case  key event vk f evt consume  edit action reload ac get action vfs browser reload ac invoke action evt reload break case  key event vk f case  key event vk right evt consume if evt get modifiers  input event alt mask browser next directory else if row if model files row expanded toggle expanded row break case  key event vk enter evt consume browser view get browser files activated evt is shift down vfs browser m open new view vfs browser m open false break else if evt get id  key event key typed if evt is control down evt is alt down evt is meta down evt consume return hack if evt is shift down evt get key char n evt consume return vfs browser browser browser view get browser switch evt get key char case evt consume if browser get mode vfs browser browser browser set directory  system get property user home break case evt consume if browser get mode vfs browser browser browser root directory break case evt consume if browser get mode vfs browser browser browser set directory browser get view get buffer get directory break default evt consume type select buffer append evt get key char do type select type select buffer to string browser get mode vfs browser choose directory dialog timer stop timer set initial delay timer set repeats false timer start return if evt is consumed super process key event evt 
public void set selected row int row get selection model set selection interval row row scroll rect to visible get cell rect row true 
private boolean do type select  string str int start int end boolean dirs only vfs file files vfs directory entry table model get model get files int index vfs file find completion files start end str dirs only if index set selected row index return true else return false 
private void resize columns vfs directory entry table model model vfs directory entry table model get model  font render context font render context new  font render context null false false int widths new int model get column count for int i i widths length i  string column name model get column name i if column name null widths i int renderer plain font get string bounds column name font render context get width for int i i widths length i  string ext attr model get extended attribute i widths i  math max widths i model get column width i for int i i model files length i  entry entry model files i  font font entry dir entry get type vfs file file renderer plain font renderer bold font widths  math max widths renderer get entry width entry font font render context widths  table column model columns get column model try resizing columns true for int i i widths length i columns get column i set preferred width widths i columns get column i set width widths i finally resizing columns false do layout 
private void save widths if resizing columns return vfs directory entry table model model vfs directory entry table model get model  table column model columns get column model for int i i model get column count i model set column width i columns get column i get width 
public void action performed  action event evt type select buffer set length 
public void column added  table column model event e 
public void column removed  table column model event e 
public void column moved  table column model event e 
public void column selection changed  list selection event e 
public void column margin changed  change event e save widths 
 override public void mouse clicked  mouse event e super mouse clicked e int ind get selection model get min selection index  entry node  entry get model get value at ind boolean is dir node dir entry get type vfs file directory  edit bus send new vfs path selected j edit get active view node dir entry get path is dir 
 override public void mouse pressed  mouse event evt double click on columns header if evt get source header evt get click count vfs directory entry table model model vfs directory entry table model header get table get model  table column model column model header get column model int view column column model get column index at x evt get x int column column model get column view column get model index save widths if model sort by column column resize columns  log log  log debug this vfs directory entry table sorted by model get column name column model get ascending ascending descending 
 header renderer  default table cell renderer tcr this tcr tcr 
 override public  component get table cell renderer component j table table  object value boolean is selected boolean has focus int row int column j label l j label tcr get table cell renderer component table value is selected has focus row column vfs directory entry table model model vfs directory entry table model table get model  icon icon column model get sort column model get ascending asc icon desc icon null l set icon icon l set horizontal text position l leading return l 
public vfs directory entry table model ext attrs new  array list  extended attribute sort column ascending true 
public void set root vfs vfs  list vfs file list ext attrs clear add extended attributes vfs if files null files length fire table rows deleted files length files new  entry list size for int i i files length i files i new  entry list get i if files length fire table rows inserted files length  arrays sort files new  entry compare get sort attribute sort column ascending fire table structure changed 
public int expand vfs vfs  entry entry  list vfs file list int start index for int i i files length i if files i entry start index i if start index collapse vfs start index add extended attributes vfs entry expanded true if list null make a large enough destination array  entry new files new  entry files length list size  entry subdir files new  entry list size for int i i list size i subdir files i new  entry list get i entry level entry sort expanded entries according to current sort params  arrays sort subdir files new  entry compare get sort attribute sort column ascending make room after expanded entry for subdir files int next index start index  system arraycopy files new files next index  system arraycopy subdir files new files next index list size  system arraycopy files next index new files next index list size files length next index this files new files fire table rows inserted start index start index list size fire table rows updated start index start index fire table structure changed return start index 
public void collapse vfs vfs int index  entry entry files index if entry expanded return entry expanded false int last index index while last index files length  entry e files last index if e level entry level break last index if e expanded remove extended attributes vfs manager get vfs for path e dir entry get path remove extended attributes vfs  entry new files new  entry files length last index index  system arraycopy files new files index  system arraycopy files last index new files index files length last index files new files fire table rows updated index index fire table rows deleted index last index fire table structure changed 
public int get column count return ext attrs size 
public int get row count if files null return else return files length 
public  string get column name int col if col return j edit get property vfs browser name else return j edit get property vfs browser get extended attribute col 
public  class get column class int col return  entry class 
public  object get value at int row int col if files null return null else return files row 
public boolean get ascending return ascending 
public int get sort column return sort column 
public  string get sort attribute int column return column name get extended attribute column 
public boolean sort by column int column toggle ascending descending if column was clicked again ascending sort column column ascending we don t sort by some attributes  string sort by get sort attribute column if sort by vfs ea status return false  arrays sort files new  entry compare sort by ascending remember column sort column column fire table structure changed return true 
public  string get extended attribute int index return ext attrs get index name 
param i  the column index return a saved column width since j edit pre public int get column width int i  string ext attr get extended attribute i return j edit get integer property vfs browser ext attr width 
param i  the column index param w  the column width since j edit pre public void set column width int i int w  string ext attr get extended attribute i j edit set integer property vfs browser ext attr width w 
public vfs file get files vfs file f new vfs file files length for int i i f length i f i files i dir entry return f 
private void add extended attributes vfs vfs  string attrs vfs get extended attributes vfs attr loop for int i i attrs length i for  extended attribute attr ext attrs if attrs i equals attr name attr ref continue vfs attr loop this vfs has an extended attribute which is not in the list add it to the end with a ref count of ext attrs add new  extended attribute attrs i 
private void remove extended attributes vfs vfs  string attrs vfs get extended attributes vfs attr loop for int i i attrs length i  iterator  extended attribute iter ext attrs iterator while iter has next  extended attribute attr iter next if attrs i equals attr name if attr ref we no longer have any dirs using this extended attribute iter remove continue vfs attr loop this vfs has an extended attribute which is not in the list  log log  log warning this  we forgot about attrs i 
 entry vfs file dir entry int level  entry parent this dir entry level this parent parent 
 entry vfs file dir entry int level this dir entry dir entry this level level this extension  misc utilities get file extension dir entry get name 
 extended attribute  string name this name name ref 
 creates a new code  entry compare code  expanded branches are sorted too but keep with their parent entries param sort by  the extended attribute by which to sort the entries param ascending  if false sort order is reversed  entry compare  string sort by boolean ascending this sort mix files and dirs j edit get boolean property vfs browser sort mix files and dirs this sort ignore case j edit get boolean property vfs browser sort ignore case this sort ascending ascending this sort attribute sort by 
public int compare  entry entry  entry entry we want to compare sibling ancestors of the entries if entry level entry level return compare entry entry parent if entry level entry level return compare entry parent entry here we have entries of the same level if entry parent entry parent return compare entry parent entry parent here we have siblings with the same parents let s do the real comparison vfs file file entry dir entry vfs file file entry dir entry if sort mix files and dirs if file get type file get type return file get type file get type int result if the modified attribute is present then we have a  local file if sort attribute vfs ea modified result  long  file vfs  local file file get modified compare to  long  file vfs  local file file get modified sort by size else if sort attribute vfs ea size result  long file get length compare to  long file get length sort by type extension else if sort attribute vfs ea type result  standard utilities compare strings entry extension entry extension sort ignore case default sort by name else result  standard utilities compare strings file get name file get name sort ignore case return sort ascending result result 
 return the index of a file whose name matches the given string in a case insensitive manner  exact matches are preferred param files  the list of files param start  the start index inclusive param end  the end index exclusive param str  the string to match param dirs only  only match directories since j edit pre public static int find completion vfs file files int start int end  string str boolean dirs only for int i start i end i vfs file file files i  string match against  misc utilities is absolute path str file get path file get name if dirs only file get type file continue try exact match first else if match against equals str return i else if match against region matches true str str length return i return 
public static  string find completion  string path  string complete vfs browser browser boolean dirs only  log log  log debug vfs file class find completion path complete dirs only if complete equals return  system get property user home else if complete equals return browser get view get buffer get directory else if complete equals return  misc utilities get parent of path path if  misc utilities is absolute path complete if  misc utilities is url complete return complete else path roots vfs vfs vfs manager get vfs for path path if vfs get capabilities vfs low latency cap return null  object session vfs create vfs session path browser if session null return null try vfs file files vfs  list files session path browser int index find completion files files length complete dirs only if index return files index path catch io exception e vfs manager error e path browser finally try vfs  end vfs session session browser catch io exception e vfs manager error e path browser return null 
 returns the icon for the file since j edit pre public final  icon get icon boolean expanded return get icon expanded j edit  get buffer get symlink path null 
 returns the icon for the file  implementations of  file system browsers can override this method since j edit pre public  icon get icon boolean expanded boolean open buffer return get default icon expanded open buffer 
 returns the default icon for the file since j edit pre public final  icon get default icon boolean expanded boolean open buffer if get type directory return expanded  file cell renderer open dir icon  file cell renderer dir icon else if get type filesystem return  file cell renderer filesystem icon else if open buffer return  file cell renderer open file icon else return  file cell renderer file icon 
 returns the default icon of the file return the default icon of the file since j edit pre public final  icon get default icon boolean expanded return get default icon expanded j edit  get buffer get symlink path null 
since j edit pre public vfs file 
public vfs file  string name  string path  string delete path int type long length boolean hidden this name name this path path this delete path delete path this symlink path path this type type this length length this hidden hidden if path null maintain backwards compatibility vfs vfs vfs manager get vfs for path path can read vfs get capabilities vfs read cap can write vfs get capabilities vfs write cap 
return  the originating virtual file system of this file public vfs get vfs return vfs manager get vfs for path path 
public  string get name return name 
public void set name  string name this name name 
 check if a file is binary file param session the vfs session return code true code if the file was detected as binary throws io exception io exception  if an i o error occurs since j edit pre public boolean is binary  object session throws io exception  input stream in get vfs  create input stream session get path false j edit get active view if in null throw new io exception  unable to get a  stream for this file this try return  misc utilities is binary in finally io utilities close quietly in 
public  string get path return path 
public void set path  string path this path path 
public  string get symlink path return symlink path 
public void set symlink path  string symlink path this symlink path symlink path 
public  string get delete path return delete path 
public void set delete path  string delete path this delete path delete path 
public int get type return type 
public void set type int type this type type 
public long get length return length 
public void set length long length this length length 
public boolean is hidden return hidden 
public void set hidden boolean hidden this hidden hidden 
public boolean is readable return can read 
public void set readable boolean can read this can read can read 
public boolean is writeable return can write 
public void set writeable boolean can write this can write can write 
 returns the value of an extended attribute  note that this returns formatted strings eg  mb for a file size of bytes  if you need access to the raw data access fields and methods of this class param name  the extended attribute name since j edit pre public  string get extended attribute  string name if name equals vfs ea type switch get type case file return j edit get property vfs browser type file case directory return j edit get property vfs browser type directory case filesystem return j edit get property vfs browser type filesystem default throw new  illegal argument exception else if name equals vfs ea status if is readable if is writeable return j edit get property vfs browser status rw else return j edit get property vfs browser status ro else if is writeable return j edit get property vfs browser status append else return j edit get property vfs browser status no else if name equals vfs ea size if get type file return null else return  misc utilities format file size get length else return null 
 returns the color that will be used to display the file return the color of the file public  color get color if color calculated color calculated true color vfs get default color for name return color 
public  string to string return name 
 returns true if the attributes are already fetched see fetch attrs return code true code if the attributes are already fetched protected boolean fetched attrs return fetched attrs 
 fetch some attributes of the file  some attributes are not fetched during file initialization because it takes time  they are fetched here vfs implementation should overwrite this protected void fetch attrs fetched attrs true 
public vfs file chooser dialog  view view  string path int mode boolean multiple selection this view path mode multiple selection true 
 constructs a new vfs file chooser dialog  if code authoshow code is true the dialog will be show automatically and the call will only return after the user disposes of the dialog since j edit pre public vfs file chooser dialog  view view  string path int mode boolean multiple selection boolean autoshow super view get default title true set focus traversal policy new  layout focus traversal policy  init view path mode multiple selection autoshow 
 constructs a new vfs file chooser dialog  this version can specify a dialog as the parent instead of the view since j edit pre public vfs file chooser dialog  dialog parent  view view  string path int mode boolean multiple selection boolean autoshow super parent get default title true set focus traversal policy new  layout focus traversal policy  init view path mode multiple selection autoshow 
 constructs a new vfs file chooser dialog  this version can specify a  frame as the parent instead of the view since j edit pre public vfs file chooser dialog  frame parent  view view  string path int mode boolean multiple selection boolean autoshow super parent get default title true set focus traversal policy new  layout focus traversal policy  init view path mode multiple selection autoshow 
 returns the vfs browser instance used internally return the vfs browser used in the dialog since j edit pre public vfs browser get browser return browser 
 override public void dispose gui utilities save geometry this vfs browser dialog vfs manager get io thread pool remove progress listener work thread handler super dispose 
 override public void ok vfs file files browser get selected files filename filename field get text boolean choosing dir browser get mode vfs browser choose directory dialog if files length if choosing dir is ok true dispose else browser files activated vfs browser m open false return else if choosing dir filename null filename length is ok true dispose return else if filename null filename length get toolkit beep return  string buffer dir browser get view get buffer get directory if filename equals filename buffer dir else if filename starts with filename starts with  file separator filename  misc utilities construct path buffer dir filename substring final int type filename  misc utilities expand variables filename final  string path  misc utilities construct path browser get directory filename final vfs vfs vfs manager get vfs for path path  object session vfs create vfs session path this if session null return vfs manager run in work thread new  get file type request vfs session path type vfs manager run in awt thread new  runnable public void run switch type case vfs file file if browser get mode vfs browser choose directory dialog break if vfs instanceof  file vfs if do file exists warning path break is ok true if browser get mode vfs browser browser dialog  hashtable props new  hashtable props put j edit buffer encoding browser current encoding j edit open file browser get view browser get directory path false props dispose break case vfs file directory case vfs file filesystem browser set directory path break 
 override public void cancel dispose 
public  string get selected files if is ok return null if browser get mode vfs browser choose directory dialog if browser get selected files length return get selected files vfs file directory vfs file filesystem else return new  string browser get directory else if filename null filename length  string path browser get directory return new  string  misc utilities construct path path filename else return get selected files vfs file file vfs file file 
private static  string get default title return j edit get property vfs browser title 
private void  init  view view  string path int mode boolean multiple selection boolean autoshow j panel content new j panel new  border layout set content pane content  string name if mode vfs browser choose directory dialog name null else if path null path ends with  file separator path ends with name null else vfs vfs vfs manager get vfs for path path name vfs get file name path path vfs get parent of path path if vfs get capabilities vfs browse cap path null browser new vfs browser view path mode multiple selection null browser add browser listener new  browser handler content add  border layout center browser j panel panel new j panel panel set layout new  box layout panel  box layout x axis panel set border new  empty border filename field new vfs file name field browser null filename field set text name filename field select all filename field set name filename browser set default focus component filename field  box box new  box  box layout y axis box add  box create glue box add filename field box add  box create glue j label label new j label j edit get property vfs browser dialog filename label set displayed mnemonic j edit get property vfs browser dialog filename mnemonic char at label set label for filename field panel add label panel add  box create horizontal strut panel add box panel add  box create horizontal strut ok new j button ok set name ok get root pane set default button ok switch mode case vfs browser open dialog case vfs browser browser dialog ok set text j edit get property vfs browser dialog open break case vfs browser choose directory dialog ok set text j edit get property vfs browser dialog choose dir so that it doesn t resize  dimension dim ok get preferred size ok set preferred size dim break case vfs browser save dialog ok set text j edit get property vfs browser dialog save break ok add action listener new  action handler panel add ok panel add  box create horizontal strut cancel new j button j edit get property common cancel cancel set name cancel cancel add action listener new  action handler panel add cancel content add  border layout south panel vfs manager get io thread pool add progress listener work thread handler new  work thread handler pack gui utilities load geometry this vfs browser dialog gui utilities request focus this filename field if autoshow set visible true 
private boolean do file exists warning  string filename if browser get mode vfs browser save dialog new  file filename exists  string args  misc utilities get file name filename int result gui utilities confirm browser fileexists args j option pane yes no option j option pane warning message if result j option pane yes option return true return false 
private  string get selected files int type int type  list  string l new  array list  string vfs file selected files browser get selected files for int i i selected files length i vfs file file selected files i if file get type type file get type type l add file get path return l to array new  string l size 
public void action performed  action event evt if evt get source ok ok else if evt get source cancel cancel 
public void files selected vfs browser browser vfs file files boolean choosing dir browser get mode vfs browser choose directory dialog if files length if choosing dir ok set text j edit get property vfs browser dialog choose dir else if files length if choosing dir ok set text j edit get property vfs browser dialog choose dir vfs file file files if file get type vfs file file  string path file get path  string directory browser get directory  string parent  misc utilities get parent of path path if  misc utilities paths equal parent directory path file get name filename field set text path filename field select all else if choosing dir ok set text j edit get property vfs browser dialog choose dir filename field set text null 
public void files activated vfs browser browser vfs file files filename field select all if files length user pressed enter when the vfs table or file name field has focus with nothing selected ok return for int i i files length i if files i get type vfs file file  string path files i get path vfs vfs vfs manager get vfs for path path if browser get mode vfs browser save dialog vfs instanceof  file vfs if do file exists warning path return is ok true filename field set text null if browser get mode vfs browser choose directory dialog dispose return else return 
public void status update final  work thread pool thread pool int thread index  swing utilities invoke later new  runnable public void run int request count thread pool get request count if request count get content pane set cursor  cursor get default cursor else if request count get content pane set cursor  cursor get predefined cursor  cursor wait cursor 
public void progress update  work thread pool thread pool int thread index 
 get file type request vfs vfs  object session  string path int type this vfs vfs this session session this path path this type type 
public void run try vfs file entry vfs  get file session path browser if entry null non existent file type vfs file file else type entry get type catch io exception e vfs manager error e path browser finally try vfs  end vfs session session browser catch io exception e vfs manager error e path browser 
vfs file name field vfs browser browser  string model super model set enter adds to history false this browser browser  dimension dim get preferred size dim width  integer max value set maximum size dim  enable tab pressed for completion instead of focas traversal final int forward  keyboard focus manager forward traversal keys  hash set awt key stroke keys new  hash set awt key stroke get focus traversal keys forward keys remove awt key stroke get awt key stroke pressed tab set focus traversal keys forward keys 
public void process key event  key event evt if evt get id  key event key pressed  string path get text switch evt get key code case  key event vk tab do complete path break case  key event vk left if evt get modifiers  key event alt mask browser previous directory evt consume else browser get browser view get table process key event evt super process key event evt break case  key event vk up if evt get modifiers  key event alt mask  string p browser get directory browser set directory  misc utilities get parent of path p evt consume else browser get browser view get table process key event evt break case  key event vk right if evt get modifiers  key event alt mask evt consume browser next directory else super process key event evt break case  key event vk down case  key event vk page up case  key event vk page down browser get browser view get table process key event evt break case  key event vk enter browser files activated evt is shift down vfs browser m open new view vfs browser m open false set text null evt consume break default super process key event evt break else if evt get id  key event key typed char ch evt get key char if ch x ch x f ch xff super process key event evt  string path get text  browser view view browser get browser view view select none if  misc utilities get last separator index path int mode browser get mode fix for bug we don t type complete in save dialog boxes  press tab to do an explicit complete view get table do type select path mode vfs browser choose directory dialog mode vfs browser save dialog else super process key event evt 
public  string do complete  string path  string complete boolean dirs only  log log  log debug vfs file name field class do complete path complete dirs only for if complete length return path int index  misc utilities get first separator index complete if index return path  until the very last path component we only complete on directories  string new path vfs file find completion path complete substring index browser true if new path null return null path new path complete complete substring index 
private void do complete  string current text int index  misc utilities get last separator index current text  string dir if index dir current text substring index else dir if  misc utilities is absolute path current text if dir starts with dir dir substring dir do complete vfs browser get root directory dir false if dir null return browser set directory dir vfs manager wait for requests if index if current text starts with current text current text substring else current text current text substring index else if dir length dir do complete browser get directory dir false if dir null return browser set directory dir vfs manager wait for requests current text current text substring index  browser view view browser get browser view view select none view get table do type select current text browser get mode vfs browser choose directory dialog  string new text vfs file files view get selected files if files length new text current text else  string path files get path  string name files get name  string parent  misc utilities get parent of path path if  misc utilities is absolute path current text current text starts with browser get directory new text path else if  misc utilities paths equal parent browser get directory new text name else new text path set text new text 
private void go to parent  string name  misc utilities get file name browser get directory  string parent  misc utilities get parent of path browser get directory browser set directory parent vfs vfs vfs manager get vfs for path parent if vfs get capabilities vfs low latency cap vfs manager wait for requests set text name browser get browser view get table do type select name browser get mode vfs browser choose directory dialog 
 do not call public static void init int count j edit get integer property io thread count io thread pool new  work thread pool j edit i o count jar class loader class loader new jar class loader for int i i io thread pool get thread count i io thread pool get thread i set context class loader class loader 
 do not call public static void start io thread pool start 
 returns the local filesystem vfs since j edit pre public static vfs get file vfs return file vfs 
 returns the url vfs since j edit pre public static vfs get url vfs return url vfs 
deprecated  use code get vfs for protocol code instead public static vfs get vfs by name  string name in new api protocol always equals name vfs vfs vfs  service manager get service service name if vfs null return vfs hash get name else return vfs 
 returns the vfs for the specified protocol param protocol  the protocol since j edit pre public static vfs get vfs for protocol  string protocol if protocol equals file return file vfs else vfs vfs vfs  service manager get service service protocol if vfs null vfs protocol hash get protocol if vfs null return vfs else return url vfs 
 returns the vfs for the specified path param path  the path since j edit pre public static vfs get vfs for path  string path if  misc utilities is url path return get vfs for protocol  misc utilities get protocol of url path else return file vfs 
deprecated  write a code services xml code file instead see link org gjt sp jedit  service manager public static void register vfs  string protocol vfs vfs  log log  log debug vfs manager class  registered vfs get name filesystem for protocol protocol vfs hash put vfs get name vfs protocol hash put protocol vfs 
deprecated  use code get vf ss code instead public static  enumeration vfs get filesystems return vfs hash elements 
 returns a list of all registered filesystems since j edit pre public static  string get vf ss the sooner ppl move to the new api the less we ll need crap like this  list  string return value new  linked list  string  string new api  service manager get service names service if new api null for int i i new api length i return value add new api i  enumeration  string old api vfs hash keys while old api has more elements return value add old api next element return return value to array new  string return value size 
 returns the i o thread pool public static  work thread pool get io thread pool return io thread pool 
 returns when all pending requests are complete since j edit pre public static void wait for requests io thread pool wait for requests 
 returns if the last request caused an error public static boolean error occurred return error 
 returns the number of pending i o requests public static int get request count return io thread pool get request count 
 executes the specified runnable in the awt thread once all pending i o requests are complete since j edit pre public static void run in awt thread  runnable run io thread pool add work request run true 
 executes the specified runnable in one of the i o threads since j edit pre public static void run in work thread  runnable run io thread pool add work request run false 
 handle an i o error since j edit pre public static void error io exception e  string path  component comp  log log  log error vfs manager class e vfs manager error comp path ioerror new  string e to string 
deprecated  call the other code error code method instead public static void error final  component comp final  string error final  object args if we are already in the awt thread take a shortcut if  swing utilities is event dispatch thread gui utilities error comp error args return the error chicanery ensures that stuff like vfs manager wait for requests if vfs manager error occurred will work because the below runnable will only be executed in the next event vfs manager error true run in awt thread new  runnable public void run vfs manager error false if comp null comp is showing gui utilities error null error args else gui utilities error comp error args 
 reports an i o error param comp  the component param path  the path name that caused the error param message prop  the error message property name param args  positional parameters since j edit pre public static void error  component comp final  string path  string message prop  object args final  frame frame j option pane get frame for component comp synchronized error lock error true errors add new  error list dialog  error entry path message prop args if errors size vfs manager run in awt thread new  runnable public void run  string caption j edit get property ioerror caption errors size new  integer  integer value of errors size new  error list dialog frame is showing frame j edit get first view j edit get property ioerror title caption errors false errors clear error false 
 sends a vfs update message param vfs  the vfs param path  the path that changed param parent  true if an update should be sent for the path s parent too since j edit pre public static void send vfs update vfs vfs  string path boolean parent if parent send vfs update vfs vfs get parent of path path false send vfs update vfs path false else have to do this hack until vfs path class is written if path length path ends with path ends with java io  file separator path path substring path length synchronized vfs update lock for int i i vfs updates size i vfs update msg vfs updates get i if msg get path equals path don t send two updates for the same path return vfs updates add new vfs update path if vfs updates size we were the first to add an update add update sending runnable to awt thread vfs manager run in awt thread new  send vfs updates safely 
public void run synchronized vfs update lock the vfs browser has what you might call a design flaw it doesn t update properly unless the vfs update for a parent arrives before any updates for the children sorting the list alphanumerically guarantees this  collections sort vfs updates new  standard utilities  string compare vfs update for int i i vfs updates size i  edit bus send vfs updates get i vfs updates clear 
private vfs manager 
param source the  view that is considered the source of this event param is directory true if the path is pointing to a folder false if it s a regular file param path  the selected path public vfs path selected  view source  string path boolean is directory super source this path path this is dir is directory 
public  view get view return  view get source 
return  the selected url or file path public  string get path return path 
return true if this is a directory node public boolean is directory return is dir 
 creates a vfs update message param path  the path in question public vfs update  string path super null if path null throw new  null pointer exception  path must be non null this path path 
 returns the path that changed public  string get path return path 
public  string param string return path path super param string 
 returns the dockable window manager associated with this view since j edit pre public  dockable window manager get dockable window manager return dockable window manager 
public static  string get docking framework name  string framework j edit get property view docking framework property original docking framework return framework 
public static  docking framework provider get docking framework provider if docking framework provider null  string framework get docking framework name docking framework provider  docking framework provider  service manager get service docking framework provider service framework if docking framework provider null  log log  log error  view class  no docking framework framework available using the original one docking framework provider  docking framework provider  service manager get service docking framework provider service original docking framework return docking framework provider 
 returns the view s tool bar since j edit pre public  container get tool bar return tool bar 
 adds a tool bar to this view param tool bar  the tool bar public void add tool bar  component tool bar add tool bar default group default layer tool bar 
 adds a tool bar to this view param group  the tool bar group to add to param tool bar  the tool bar see org gjt sp jedit gui  tool bar manager since j edit pre public void add tool bar int group  component tool bar add tool bar group default layer tool bar 
 adds a tool bar to this view param group  the tool bar group to add to param layer  the layer of the group to add to param tool bar  the tool bar see org gjt sp jedit gui  tool bar manager since j edit pre public void add tool bar int group int layer  component tool bar tool bar manager add tool bar group layer tool bar get root pane revalidate 
 removes a tool bar from this view param tool bar  the tool bar public void remove tool bar  component tool bar if tool bar manager null return if tool bar null return tool bar manager remove tool bar tool bar get root pane revalidate 
 shows the wait cursor  this method and link hide wait cursor are implemented using a reference count of requests for wait cursors so that nested calls work correctly however you should be careful to use these methods in tandem p  to ensure that link hide wait cursor is always called after a link show wait cursor use a code try code code finally code block like this pre try view show wait cursor finally view hide wait cursor pre public synchronized void show wait cursor if wait count  cursor cursor  cursor get predefined cursor  cursor wait cursor set cursor cursor visit new  set cursor visitor cursor 
 hides the wait cursor public synchronized void hide wait cursor if wait count wait count if wait count still needed even though glass pane has a wait cursor  cursor cursor  cursor get predefined cursor  cursor default cursor set cursor cursor visit new  set cursor visitor cursor 
 returns the search bar since j edit pre public final  search bar get search bar return search bar 
 returns the action bar since j edit pre public final  action bar get action bar return action bar 
 returns the status bar  the link org gjt sp jedit gui  status bar set message  string and link org gjt sp jedit gui  status bar set message and clear  string methods can be called on the return value of this method to display status information to the user since j edit pre public  status bar get status return status 
 quick search since j edit pre public void quick incremental search boolean word if search bar null search bar new  search bar this true if search bar get parent null add tool bar top group search bar layer search bar search bar set hyper search false j edit text area text area get text area if word  string text text area get selected text if text null text area select word text text area get selected text else if text index of n text null if text null  search and replace get regexp text  search and replace escape regexp text false search bar get field set text text search bar get field request focus search bar get field select all 
 quick  hyper search since j edit pre public void quick hyper search boolean word j edit text area text area get text area if word  string text text area get selected text if text null text area select word text text area get selected text if text null text index of n if  search and replace get regexp text  search and replace escape regexp text false  history model get model find add item text  search and replace set search string text  search and replace set search file set new  current buffer set  search and replace hyper search this return if search bar null search bar new  search bar this true if search bar get parent null add tool bar top group search bar layer search bar search bar set hyper search true search bar get field set text null search bar get field request focus search bar get field select all 
 shows the action bar if needed and sends keyboard focus there since j edit pre public void action bar if action bar null action bar new  action bar this true if action bar get parent null add tool bar bottom group action bar layer action bar action bar go to action bar 
 returns the listener that will handle all key events in this view if any return the key event interceptor or null public  key listener get key event interceptor return input handler get key event interceptor 
 sets the listener that will handle all key events in this view  for example the complete word command uses this so that all key events are passed to the word list popup while it is visible param listener  the key event interceptor public void set key event interceptor  key listener listener input handler set key event interceptor listener 
 returns the input handler public  input handler get input handler return input handler 
 sets the input handler param input handler  the new input handler public void set input handler  input handler input handler this input handler input handler 
 returns the macro recorder public  macros  recorder get macro recorder return recorder 
 sets the macro recorder param recorder  the macro recorder public void set macro recorder  macros  recorder recorder this recorder recorder 
 forwards key events directly to the input handler  this is slightly faster than using a  key listener because some  swing overhead is avoided  override public void process key event  key event evt input handler process key event evt view false if evt is consumed super process key event evt 
 forwards key events directly to the input handler  this is slightly faster than using a  key listener because some  swing overhead is avoided public void process key event  key event evt boolean called from text area process key event evt called from text area text area view 
 forwards key events directly to the input handler  this is slightly faster than using a  key listener because some  swing overhead is avoided public void process key event  key event evt int from process key event evt from false 
 forwards key events directly to the input handler  this is slightly faster than using a  key listener because some  swing overhead is avoided deprecated do not use try link org gjt sp jedit gui  input handler process key event java awt event  key event int boolean  deprecated public void process key event  key event evt int from boolean global input handler process key event evt from global if evt is consumed super process key event evt 
 splits the view horizontally return the new edit pane since j edit pre public  edit pane split horizontally return split j split pane vertical split 
 splits the view vertically return the new edit pane since j edit pre public  edit pane split vertically return split j split pane horizontal split 
 splits the view param orientation the orientation link javax swing j split pane horizontal split or link javax swing j split pane vertical split return the new edit pane since j edit pre public  edit pane split int orientation  perspective manager set perspective dirty true edit pane save caret info  edit pane old edit pane edit pane  string action j edit get property editpane bufferset new  buffer set manager  new buffer set action buffer set action  buffer set manager  new buffer set action from string action  edit pane new edit pane if buffer set action  buffer set manager  new buffer set action empty new edit pane create edit pane null else new edit pane create edit pane old edit pane get buffer set edit pane new edit pane new edit pane load caret info j component old parent j component old edit pane get parent final j split pane new split pane new j split pane orientation j edit get boolean property appearance continuous layout new split pane set one touch expandable true new split pane set border null new split pane set minimum size new  dimension new split pane set resize weight int parent size orientation j split pane vertical split old edit pane get height old edit pane get width final int divider position int parent size new split pane get divider size new split pane set divider location divider position if old parent instanceof j split pane j split pane old split pane j split pane old parent int divider pos old split pane get divider location  component left old split pane get left component if left old edit pane old split pane set left component new split pane else old split pane set right component new split pane new split pane set left component old edit pane new split pane set right component new edit pane old split pane set divider location divider pos else split pane new split pane new split pane set left component old edit pane new split pane set right component new edit pane set main content new split pane  swing utilities invoke later new  runnable public void run new split pane set divider location divider position new edit pane focus on text area return new edit pane 
 unsplits the view since j edit pre public void unsplit if split pane null last split config get split config  perspective manager set perspective dirty true for  edit pane  edit pane get edit panes if edit pane  edit pane merge buffer sets edit pane  edit pane  edit pane close set main content edit pane split pane null update title edit pane focus on text area else get toolkit beep 
 removes the current split since j edit pre public void unsplit current if split pane null last split config get split config  perspective manager set perspective dirty true find first split pane parenting current edit pane  component comp edit pane while comp instanceof j split pane comp null comp comp get parent get rid of any edit pane that is a child of the current edit pane s parent splitter for  edit pane  edit pane get edit panes if gui utilities is ancestor of comp  edit pane  edit pane edit pane merge buffer sets edit pane  edit pane  edit pane close j component parent comp null null j component comp get parent if parent instanceof j split pane j split pane parent split j split pane parent int pos parent split get divider location if parent split get left component comp parent split set left component edit pane else parent split set right component edit pane parent split set divider location pos parent revalidate else set main content edit pane split pane null update title edit pane focus on text area else get toolkit beep 
 restore the split configuration as it was before unsplitting since j edit pre public void resplit if last split config null get toolkit beep else set split config null last split config 
 split configurations are recorded in a simple rpn language return  the split configuration describing where splitpanes are which buffers are open in each  edit pane etc public  string get split config  string builder split config new  string builder if split pane null get split config split pane split config else append to split config split config edit pane return split config to string 
sets the split configuration as per the split config param buffer if null checks all buffers to restore  view s split config param split config the split config as returned by get split config public void set split config  buffer buffer  string split config try  component comp restore split config buffer split config set main content comp catch io exception e this should never throw an exception throw new  internal error 
 moves keyboard focus to the next text area since j edit pre public void next text area  edit pane edit panes get edit panes for int i i edit panes length i if edit pane edit panes i if i edit panes length edit panes focus on text area else edit panes i focus on text area break 
 moves keyboard focus to the previous text area since j edit pre public void prev text area  edit pane edit panes get edit panes for int i i edit panes length i if edit pane edit panes i if i edit panes edit panes length focus on text area else edit panes i focus on text area break 
 returns the top level split pane if any return the top j split pane if any since j edit pre public j split pane get split pane return split pane 
 returns the current edit pane s buffer return the current edit pane s buffer it can be null public  buffer get buffer if edit pane null return null else return edit pane get buffer 
 sets the current edit pane s buffer param buffer  the buffer public void set buffer  buffer buffer set buffer buffer false 
 sets the current edit pane s buffer param buffer  the buffer param disable file status check  disables file status checking regardless of the state of the check file status property public void set buffer  buffer buffer boolean disable file status check set buffer buffer disable file status check true 
 sets the current edit pane s buffer param buffer  the buffer param disable file status check  disables file status checking regardless of the state of the check file status property param focus  whether the textarea should request focus since j edit pre public void set buffer  buffer buffer boolean disable file status check boolean focus edit pane set buffer buffer focus int check j edit get integer property check file status if disable file status check check  general option pane check file status all check  general option pane check file status operations check  general option pane check file status focus buffer j edit check buffer status this true 
 if this buffer is open in one of the view s edit panes sets focus to that edit pane  otherwise opens the buffer in the currently active edit pane param buffer  the buffer return the current edit pane since j edit pre public  edit pane go to buffer  buffer buffer return show buffer buffer true 
 if this buffer is open in one of the view s edit panes activates that edit pane  otherwise opens the buffer in the currently active edit pane  but the focus is not moved param buffer  the buffer to show return the current edit pane since j edit pre public  edit pane show buffer  buffer buffer return show buffer buffer false 
 returns the current edit pane s text area return the current edit pane s text area or b null b if there is no edit pane yet public j edit text area get text area if edit pane null return null else return edit pane get text area 
 returns the current edit pane return the current edit pane since j edit pre public  edit pane get edit pane return edit pane 
 returns all edit panes return an array of all edit panes in the view since j edit pre public  edit pane get edit panes if split pane null  edit pane ep edit pane return ep else  list  edit pane vec new  array list  edit pane get edit panes vec split pane  edit pane ep new  edit pane vec size vec to array ep return ep 
 returns the view s local buffer set which can be shared by several editpanes return the view s buffer set since j edit pre public  buffer set get local buffer set return local buffer set 
return a  view config instance for the current view since j edit pre public  view config get view config  view config config new  view config config plain view is plain view config split config get split config config ext state get extended state config docking dockable window manager get docking layout config  string prefix config plain view plain view view switch config ext state case  frame maximized both case  frame iconified config x j edit get integer property prefix x get x config y j edit get integer property prefix y get y config width j edit get integer property prefix width get width config height j edit get integer property prefix height get height break case  frame maximized vert config x get x config y j edit get integer property prefix y get y config width get width config height j edit get integer property prefix height get height break case  frame maximized horiz config x j edit get integer property prefix x get x config y get y config width j edit get integer property prefix width get width config height get height break case  frame normal default config x get x config y get y config width get width config height get height break return config 
 returns true if this view has been closed with link j edit close view  view return true if the view is closed public boolean is closed return closed 
 returns true if this is an auxilliary view with no dockable windows return true if the view is plain since j edit pre public boolean is plain view return plain view 
 returns the next view in the list return the next view public  view get next return next 
 returns the previous view in the list return the preview view public  view get prev return prev 
public void handle message eb message msg if msg instanceof  properties changed properties changed else if msg instanceof  search settings changed if search bar null search bar update else if msg instanceof  buffer update handle buffer update  buffer update msg else if msg instanceof  edit pane update handle edit pane update  edit pane update msg 
 override public  dimension get minimum size return new  dimension 
 this socket is closed when the buffer is closed public void set wait socket  socket wait socket this wait socket wait socket 
 override public  string to string return get class get name j edit get active view this active inactive 
 updates the title bar public void update title  list  buffer buffers new  array list  buffer  edit pane edit panes get edit panes for int i i edit panes length i  buffer buffer edit panes i get buffer if buffers contains buffer buffers add buffer  string builder title new  string builder  on  mac os x apps are not supposed to show their name in the title bar if  operating system is mac os title append j edit get property view title boolean unsaved changes false for int i i buffers size i if i title append  buffer buffer buffers get i title append show full path buffer is new file buffer get path true buffer get name if buffer is dirty unsaved changes true title append j edit get property view title dirty set title title to string 
public  component get prefix focus owner return prefix focus owner 
public void set prefix focus owner  component prefix focus owner this prefix focus owner prefix focus owner 
 visit the the editpanes and textareas of the view param visitor the visitor since j edit pre public void visit j edit visitor visitor  edit pane panes get edit panes for int i i panes length i  edit pane edit pane panes i visitor visit edit pane visitor visit edit pane get text area 
 view  buffer buffer  view config config full screen mode false menu bar null plain view config plain view enable events awt event key event mask set icon image gui utilities get editor icon main panel new j panel main panel set layout new  border layout dockable window manager get docking framework provider create this  dockable window factory get instance config dockable window manager set main panel main panel top tool bars new j panel new  variable grid layout  variable grid layout fixed num columns bottom tool bars new j panel new  variable grid layout  variable grid layout fixed num columns tool bar manager new  tool bar manager top tool bars bottom tool bars status new  status bar this input handler new  default input handler this  default input handler j edit get input handler local buffer set new  buffer set set split config buffer config split config get content pane add  border layout center dockable window manager dockable window manager init tool bar and status bar gets added in properties changed depending in the tool bar alternate layout setting properties changed set default close operation do nothing on close add window listener new  window handler set focus traversal policy new  my focus traversal policy  edit bus add to bus this gui utilities add size saver this null plain view plain view view 
public void update full screen props boolean alternate layout j edit get boolean property view toolbar alternate layout boolean show menu j edit get boolean property full screen includes menu boolean show toolbars j edit get boolean property full screen includes toolbar boolean show status j edit get boolean property full screen includes status if show menu menu bar get j menu bar set j menu bar null else if menu bar null set j menu bar menu bar if alternate layout  note  bottom toolbar is the action bar which is always enabled if show toolbars get content pane remove top tool bars else get content pane add  border layout north top tool bars if show status remove tool bar status else add tool bar bottom group status bar layer status else  note  bottom toolbar is the action bar which is always enabled if show toolbars main panel remove top tool bars else main panel add top tool bars  border layout north if show status get content pane remove status else get content pane add  border layout south status 
public void toggle full screen full screen mode full screen mode  graphics device sd get graphics configuration get device dispose if full screen mode update full screen props windowed bounds get bounds set undecorated true set bounds sd get default configuration get bounds validate else boolean show status plain view j edit get boolean property view status plainview visible j edit get boolean property view status visible if menu bar null get j menu bar menu bar set j menu bar menu bar boolean alternate layout j edit get boolean property view toolbar alternate layout if alternate layout get content pane add  border layout north top tool bars if show status add tool bar bottom group status bar layer status else main panel add top tool bars  border layout north if show status get content pane add  border layout south status set undecorated false set bounds windowed bounds set visible true to front so you can keep typing in your editpane afterwards edit pane get text area request focus 
 if the view contains dirty buffers which will be closed on closing the view show the confirmation dialog for user return true if there are no such buffers or user select ok to close the view false if user select  cancel boolean confirm to close dirty  set  buffer checking buffers get open buffers for  view view j edit get views if view this checking buffers remove all view get open buffers for  buffer buffer checking buffers if buffer is dirty return new  close dialog this checking buffers is ok return true 
void close  edit bus send new  view update this  view update closed closed true save dockable window geometry and close em dockable window manager close  edit bus remove from bus this dispose  edit pane edit panes get edit panes for int i i edit panes length i edit panes i close null some variables so that retaining references to closed views won t hurt as much tool bar manager null tool bar null search bar null split pane null input handler null recorder null get content pane remove all notify clients with wait if wait socket null try wait socket get output stream write wait socket get output stream flush wait socket get input stream close wait socket get output stream close wait socket close catch io exception io  log log  log error this io 
private void set main content  component c if main content null main panel remove main content main content c main panel add main content  border layout center main panel revalidate main panel repaint 
private static void get edit panes  list  edit pane vec  component comp if comp instanceof  edit pane vec add  edit pane comp else if comp instanceof j split pane j split pane split j split pane comp get edit panes vec split get left component get edit panes vec split get right component 
private  edit pane show buffer  buffer buffer boolean focus if edit pane get buffer buffer edit pane get text area get visible lines if focus edit pane focus on text area return edit pane  edit pane edit panes get edit panes for int i i edit panes length i  edit pane ep edit panes i if ep get buffer buffer ignore zero height splits etc ep get text area get visible lines set edit pane ep if focus ep focus on text area return ep set buffer buffer false focus return edit pane 
private static void get split config j split pane split pane  string builder split config  component right split pane get right component append to split config split config right split config append  component left split pane get left component append to split config split config left split config append split config append split pane get divider location split config append split config append split pane get orientation j split pane vertical split vertical horizontal 
 append the  component to the split config  the component must be a j split pane or an  edit pane param split config the split config param component the component private static void append to split config  string builder split config  component component if component instanceof j split pane the component is a j split pane get split config j split pane component split config else the component is an edit pane  edit pane edit pane  edit pane component split config append split config append  standard utilities chars to escapes edit pane get buffer get path split config append buffer  buffer set buffer set edit pane get buffer set  buffer buffers buffer set get all buffers for  buffer buffer buffers if buffer is new file split config append split config append  standard utilities chars to escapes buffer get path split config append buff split config append split config append edit pane get buffer set scope split config append bufferset 
private  component restore split config  buffer buffer  string split config throws io exception this is where checked exceptions piss me off this method only uses a  string reader which can never throw an exception if buffer null return edit pane create edit pane buffer else if split config null return edit pane create edit pane j edit get first buffer  buffer buffers j edit get buffers  stack  object stack new  stack  object we create a stream tokenizer for parsing a simple stack based language  stream tokenizer st new  stream tokenizer new  string reader split config st whitespace chars all printable ascii characters st word chars st comment char st quote char st eol is significant false boolean continuous layout j edit get boolean property appearance continuous layout  list  buffer edit pane buffers new  array list  buffer loop while true switch st next token case  stream tokenizer tt eof break loop case  stream tokenizer tt word if st sval equals vertical st sval equals horizontal int orientation st sval equals vertical j split pane vertical split j split pane horizontal split int divider  integer stack pop int value  object obj stack pop  object obj stack pop  backward compatibility with pre bufferset versions if obj instanceof  buffer  buffer b buffer  buffer obj j edit get global buffer set add buffer at b obj edit pane create edit pane b  buffer set  scope global if obj instanceof  buffer  buffer b  buffer obj j edit get global buffer set add buffer at b obj create edit pane b  buffer set  scope global stack push split pane new j split pane orientation continuous layout  component obj  component obj split pane set one touch expandable true split pane set border null split pane set minimum size new  dimension split pane set divider location divider else if st sval equals buffer  object obj stack pop if obj instanceof  integer int index  integer obj int value if index index buffers length buffer buffers index else if obj instanceof  string  string path  string obj buffer j edit get buffer path if buffer null buffer j edit open file this path if buffer null buffer j edit get first buffer stack push buffer else if st sval equals buff  string path  string stack pop buffer j edit get buffer path if buffer null  log log  log warning this  buffer path doesn t exist else edit pane buffers add buffer else if st sval equals bufferset  buffer set  scope scope  buffer set  scope from string  string stack pop buffer  buffer stack pop edit pane create edit pane buffer scope stack push edit pane  buffer set manager buffer set manager j edit get buffer set manager  buffer set buffer set edit pane get buffer set int i for  buffer buff edit pane buffers if buff buffer buffer set add buffer at buffer i else buffer set manager add buffer buffer set buff i edit pane buffers clear break case  stream tokenizer tt number stack push int st nval break case stack push st sval break  backward compatibility with pre bufferset versions  object obj stack peek if obj instanceof  buffer j edit get global buffer set add buffer at  buffer obj obj edit pane create edit pane  buffer obj  buffer set  scope global update gutter borders return  component obj 
 reloads various settings from the properties private void properties changed set j menu bar gui utilities load menu bar view mbar load tool bars show full path j edit get boolean property view show full path update title status properties changed remove tool bar status get content pane remove status boolean show status plain view j edit get boolean property view status plainview visible j edit get boolean property view status visible if j edit get boolean property view toolbar alternate layout get content pane add  border layout north top tool bars get content pane add  border layout south bottom tool bars if show status add tool bar bottom group status bar layer status else main panel add top tool bars  border layout north main panel add bottom tool bars  border layout south if show status get content pane add  border layout south status update buffer switcher states get root pane revalidate if split pane null gui utilities init continuous layout split pane  swing utilities update component tree ui get root pane if full screen mode update full screen props 
 enables or  disables the  focus  buffer  switcher menu item in the  view menu depending on the visible state of the buffer switcher  the menu item is intended to have the same effect as clicking on the buffer switcher combo box and it doesn t make sense to have this action available if the buffer switcher isn t visible  also shows or hides the  buffer  switcher itself since this can be invoked after the toggle buffer switcher action public void update buffer switcher states boolean show j edit get boolean property view show buffer switcher j menu bar menubar get j menu bar if menubar null return  string viewmenu label j edit get property view label viewmenu label viewmenu label replace  string sbs label j edit get property focus buffer switcher label sbs label sbs label replace j menu viewmenu null for int i i menubar get menu count i j menu menu menubar get menu i if menu get text equals viewmenu label viewmenu menu break if viewmenu null for int i i viewmenu get menu component count i  component item viewmenu get menu component i if item instanceof j menu item j menu item item get text equals sbs label j menu item item set enabled show viewmenu invalidate  toggle the visibility of the  buffer switcher itself for  view v j edit get views for  edit pane ep v get edit panes ep load buffer switcher 
private void load tool bars if j edit get boolean property view show toolbar plain view if tool bar null tool bar manager remove tool bar tool bar tool bar gui utilities load tool bar view toolbar add tool bar top group system bar layer tool bar else if tool bar null remove tool bar tool bar tool bar null if search bar null search bar properties changed remove tool bar search bar if j edit get boolean property view show searchbar plain view if search bar null search bar new  search bar this false add tool bar top group search bar layer search bar 
private  edit pane create edit pane  buffer buffer return create edit pane buffer  buffer set  scope from string j edit get property editpane bufferset default 
private  edit pane create edit pane  buffer buffer  buffer set  scope scope  edit pane edit pane new  edit pane this buffer scope j edit text area text area edit pane get text area text area add focus listener new  focus handler text area add caret listener new  caret handler text area add scroll listener new  scroll handler  edit bus send new  edit pane update edit pane  edit pane update created return edit pane 
private void set edit pane  edit pane edit pane this edit pane edit pane status update caret status status update buffer status status update misc status repaint the gutter so that the border color reflects the focus state update gutter borders  edit bus send new  view update this  view update edit pane changed 
private void handle buffer update  buffer update msg  buffer buffer msg get buffer if msg get what  buffer update dirty changed msg get what  buffer update loaded  edit pane edit panes get edit panes for int i i edit panes length i if edit panes i get buffer buffer update title break 
private void handle edit pane update  edit pane update msg  edit pane edit pane msg get edit pane if edit pane get view this msg get what  edit pane update buffer changed edit pane get buffer is loaded close duplicate buffers msg status update caret status status update buffer status status update misc status 
private void close duplicate buffers  edit pane update epu if j edit get boolean property buffersets exclusive return  edit pane ep epu get edit pane  only one view needs to handle this message since we iterate through all the other views if ep get view this return  buffer b ep get buffer for  view v j edit get views for  edit pane epc v get edit panes if it s my editpane skip it if epc ep continue  if it s view scope it has to be of a different view if epc get buffer set scope  buffer set  scope view v this continue  if it s global forget it if epc get buffer set j edit get global buffer set continue  is it in the bufferset if epc get buffer set index of b continue found it open in a disjoint bufferset j edit get buffer set manager remove buffer epc b 
 updates the borders of all gutters in this view to reflect the currently focused text area since j edit final private void update gutter borders  edit pane edit panes get edit panes for int i i edit panes length i edit panes i get text area get gutter update border 
private  set  buffer get open buffers  set  buffer open buffers new  hash set  buffer for  edit pane edit pane get edit panes open buffers add all  arrays as list edit pane get buffer set get all buffers return open buffers 
 merge a  edit pane s  buffer set into another one  this is used on unsplitting panes not to close buffers static private void merge buffer sets  edit pane target  edit pane source  buffer set source buffer set source get buffer set  buffer set target buffer set target get buffer set if source buffer set target buffer set j edit get buffer set manager merge buffer set target buffer set source buffer set 
public void caret update  caret event evt if evt get source get text area status update caret status 
 override public void focus gained  focus event evt walk up hierarchy looking for an  edit pane  component comp  component evt get source while comp instanceof  edit pane if comp null return comp comp get parent if comp edit pane set edit pane  edit pane comp else update gutter borders 
public void scrolled vertically  text area text area if get text area text area status update caret status 
public void scrolled horizontally  text area text area 
 override public void window activated  window event evt boolean edit pane changed j edit get active view internal  view this j edit set active view  view this  people have reported hangs with jdk might be caused by modal dialogs being displayed from window activated  swing utilities invoke later new  runnable public void run int check j edit get integer property check file status if check  general option pane check file status focus check  general option pane check file status all j edit check buffer status  view this false else if check  general option pane check file status focus buffer j edit check buffer status  view this true if edit pane changed  edit bus send new  view update  view this  view update activated 
 override public void window closing  window event evt j edit close view  view this 
public  view config 
public  view config boolean plain view this plain view plain view  string prefix plain view plain view view x j edit get integer property prefix x y j edit get integer property prefix y width j edit get integer property prefix width height j edit get integer property prefix height ext state j edit get integer property prefix extended state  frame normal 
public  view config boolean plain view  string split config int x int y int width int height int ext state this plain view plain view this split config split config this x x this y y this width width this height height this ext state ext state 
private boolean is inside screen  view parent  rectangle r  rectangle bounds if parent null bounds gui utilities get screen bounds else bounds parent get graphics configuration get bounds int min width j edit get integer property view min startup width int min height j edit get integer property view min startup height return r x bounds width min width r x r width min width r y bounds height min height r y r height min height 
public void adjust  view parent  view config config if config width config height  rectangle desired new  rectangle config x config y config width config height if is inside screen parent desired set location relative to parent else if  operating system is x  debug geometry workaround new gui utilities  unix workaround this view desired config ext state else set bounds desired set extended state config ext state else set location relative to parent 
 override public  component get default component  container focus cycle root return gui utilities get view focus cycle root get text area 
 set cursor visitor  cursor cursor this cursor cursor 
 override public void visit  edit pane edit pane edit pane set cursor cursor 
public  view option pane super view 
 override protected void  init  view dock layout layout icon gui utilities load icon dock layout png layout icon gui utilities load icon dock layout png layout icon gui utilities load icon dock layout png layout icon gui utilities load icon dock layout png j panel layout panel new j panel new  border layout if j edit get boolean property view docking alternate layout layout new j label j edit get boolean property view toolbar alternate layout layout icon layout icon else layout new j label j edit get boolean property view toolbar alternate layout layout icon layout icon layout set border new  empty border layout panel add  border layout center layout j panel buttons new j panel new  grid layout buttons set border new  empty border buttons add alternate docking layout new j button j edit get property options view alternate docking layout  action handler action handler new  action handler alternate docking layout add action listener action handler buttons add alternate tool bar layout new j button j edit get property options view alternate tool bar layout alternate tool bar layout add action listener action handler layout panel add  border layout south buttons  titled border border new  titled border j edit get property options view view layout border set title justification  titled border center layout panel set border border add component layout panel  show full path show full path new j check box j edit get property options view show full path show full path set selected j edit get boolean property view show full path add component show full path  show search bar show searchbar new j check box j edit get property options view show searchbar show searchbar set selected j edit get boolean property view show searchbar add component show searchbar  beep on search auto wrap beep on search auto wrap new j check box j edit get property options view beep on search auto wrap beep on search auto wrap set selected j edit get boolean property search beep on search auto wrap add component beep on search auto wrap  show buffer switcher show buffer switcher new j check box j edit get property options view show buffer switcher show buffer switcher set selected j edit get boolean property view show buffer switcher add component show buffer switcher show buffer switcher add action listener action handler  buffer switcher max row count buffer switcher max row count new j text field j edit get property buffer switcher max row count add component j edit get property options view buffer switcher max rows count buffer switcher max row count buffer switcher max row count set editable show buffer switcher is selected default buffer set new j combo box default buffer set add item  buffer set  scope global default buffer set add item  buffer set  scope view default buffer set add item  buffer set  scope editpane default buffer set set selected item  buffer set  scope from string j edit get property editpane bufferset default add component j edit get property options editpane bufferset default default buffer set new buffer set behavior new j combo box new buffer set behavior add item  buffer set manager  new buffer set action copy new buffer set behavior add item  buffer set manager  new buffer set action empty new buffer set behavior add item  buffer set manager  new buffer set action currentbuffer new buffer set behavior set selected item  buffer set manager  new buffer set action from string j edit get property editpane bufferset new add component new j label j edit get property options editpane bufferset contain new buffer set behavior  sort buffers sort buffers new j check box j edit get property options view sort buffers sort buffers set selected j edit get boolean property sort buffers sort buffers add action listener new  action listener public void action performed  action event evt sort by name set enabled sort buffers is selected add component sort buffers  sort buffers by names sort by name new j check box j edit get property options view sort by name sort by name set selected j edit get boolean property sort by name sort by name set enabled sort buffers is selected add component sort by name full screen includes menu new j check box j edit get property options view full screen includes menu full screen includes menu set selected j edit get boolean property full screen includes menu add component full screen includes menu full screen includes toolbar new j check box j edit get property options view full screen includes toolbar full screen includes toolbar set selected j edit get boolean property full screen includes toolbar add component full screen includes toolbar full screen includes status new j check box j edit get property options view full screen includes status full screen includes status set selected j edit get boolean property full screen includes status add component full screen includes status 
 override protected void  save j edit set boolean property view docking alternate layout layout get icon layout icon layout get icon layout icon j edit set boolean property view toolbar alternate layout layout get icon layout icon layout get icon layout icon j edit set boolean property view show full path show full path is selected j edit set boolean property view show searchbar show searchbar is selected j edit set boolean property search beep on search auto wrap beep on search auto wrap is selected j edit set boolean property view show buffer switcher show buffer switcher is selected j edit set property buffer switcher max row count buffer switcher max row count get text j edit set property editpane bufferset default default buffer set get selected item to string j edit set property editpane bufferset new  buffer set manager  new buffer set action new buffer set behavior get selected item get name j edit set boolean property sort buffers sort buffers is selected j edit set boolean property sort by name sort by name is selected j edit set boolean property full screen includes menu full screen includes menu is selected j edit set boolean property full screen includes toolbar full screen includes toolbar is selected j edit set boolean property full screen includes status full screen includes status is selected 
public void action performed  action event evt if evt get source alternate docking layout if layout get icon layout icon layout set icon layout icon else if layout get icon layout icon layout set icon layout icon else if layout get icon layout icon layout set icon layout icon else if layout get icon layout icon layout set icon layout icon else if evt get source alternate tool bar layout if layout get icon layout icon layout set icon layout icon else if layout get icon layout icon layout set icon layout icon else if layout get icon layout icon layout set icon layout icon else if layout get icon layout icon layout set icon layout icon else if evt get source show buffer switcher buffer switcher max row count set editable show buffer switcher is selected 
 creates a new view update message param view  the view param what  what happened public  view update  view view  object what super view if what null throw new  null pointer exception  what must be non null this what what 
 returns what caused this view update public  object get what return what 
 returns the view involved public  view get view return  view get source 
public  string param string return what what super param string 
public void apply j edit buffer buffer int this line index int prev line index int prev prev line index  list  indent action indent actions  don t apply this rule if the current line is empty  char sequence current buffer get line segment this line index boolean found false for int i i current length i if  character is whitespace current char at i found true break if found return  check if the previous line is empty if prev line index  char sequence previous buffer get line segment prev line index for int i i previous length i if  character is whitespace previous char at i return indent actions add new  indent action  no increase 
 sets if the request can be aborted public void set abortable boolean abortable  thread thread  thread current thread if thread instanceof  work thread  work thread thread set abortable abortable 
 sets the status text param status  the status text public void set status  string status  thread thread  thread current thread if thread instanceof  work thread  work thread thread set status status 
 sets the progress value param value  the progress value deprecated use link set value long public void set progress value int value  thread thread  thread current thread if thread instanceof  work thread  work thread thread set progress value value 
 sets the maximum progress value param value  the progress value deprecated use link set maximum long public void set progress maximum int value  thread thread  thread current thread if thread instanceof  work thread  work thread thread set progress maximum value 
 update the progress value param value the new value since j edit pre public void set value long value  thread thread  thread current thread if thread instanceof  work thread if large values  work thread thread set progress value int value else  work thread thread set progress value int value 
 update the maximum value param value the new maximum value since j edit pre public void set maximum long value  thread thread  thread current thread if thread instanceof  work thread if value  integer max value large values true  work thread thread set progress maximum int value else large values false  work thread thread set progress maximum int value 
public  work thread  work thread pool pool  thread group group  string name super group name so that j edit doesn t exit with no views open automatically set daemon true set priority  thread min priority this pool pool 
 sets if the current request can be aborted  if set to true and already aborted the thread will be stopped param abortable true if the  work thread is abortable since j edit pre public void set abortable boolean abortable synchronized abort lock this abortable abortable if aborted stop new  abort 
 returns if the work thread is currently running a request return true if a request is currently running public boolean is request running return request running 
public boolean is aborted synchronized abort lock return aborted 
 returns the status text return the status label public  string get status return status 
 sets the status text param status the new status of the thread since j edit pre public void set status  string status this status status pool fire progress changed this 
 returns the progress value return the progress value public int get progress value return progress value 
 sets the progress value param progress value the new progress value since j edit pre public void set progress value int progress value this progress value progress value pool fire progress changed this 
 returns the progress maximum return the maximum value of the progression public int get progress maximum return progress maximum 
 sets the maximum progress value param progress maximum the maximum value of the progression since j edit pre public void set progress maximum int progress maximum this progress maximum progress maximum pool fire progress changed this 
 aborts the currently running request if allowed since j edit pre public void abort current request synchronized abort lock if abortable aborted stop new  abort aborted true 
public void run  log log  log debug this  work request thread starting get name for do requests 
private void do requests  work thread pool  request request for request pool get next request if request null break else request running true pool fire status changed this do request request request running false pool fire status changed this synchronized pool wait for all lock notify a running wait for requests method pool wait for all lock notify all synchronized pool lock wait for more requests try pool lock wait catch  interrupted exception ie  log log  log error this ie 
private void do request  work thread pool  request request  log log  log debug  work thread class  running in work thread request try request run run catch  abort a  log log  log error  work thread class  unhandled abort a catch  throwable t  log log  log error  work thread class  exception in work thread t finally synchronized abort lock aborted abortable false status null progress value progress maximum pool request done pool fire status changed this 
public  abort super  work request aborted 
 creates a new work thread pool with the specified number of work threads param name  the thread name prefix param count  the number of work threads public  work thread pool  string name int count listener list new  event listener list if count thread group new  thread group name threads new  work thread count for int i i threads length i threads i new  work thread this thread group name i else  log log  log warning this  async i o disabled 
 starts all the threads in this thread pool public void start not really needed since threads don t start until after synchronized lock started true if awt request count request count queue awt runner if threads null for int i i threads length i threads i start 
 adds a work request to the queue param run  the runnable param in awt  if true will be executed in awt thread  otherwise will be executed in work thread public void add work request  runnable run boolean in awt if threads null run run return synchronized lock if there are no requests execute awt requests immediately if started in awt request count awt request count  log log  log debug this awt immediate run if  swing utilities is event dispatch thread run run else  swing utilities invoke later run return  request request new  request run  add to awt queue if in awt if first awt request null last awt request null first awt request last awt request request else last awt request next request last awt request request awt request count if no requests are running request done will not be called so we must queue the awt runner ourselves if started request count queue awt runner  add to work thread queue else if first request null last request null first request last request request else last request next request last request request request count lock notify all 
 waits until all requests are complete public void wait for requests if threads null return synchronized wait for all lock while request count try wait for all lock wait catch  interrupted exception ie  log log  log error this ie if  swing utilities is event dispatch thread do any queued awt runnables do awt requests else try  swing utilities invoke and wait new  run requests in awt thread catch  exception e  log log  log error this e 
 returns the number of pending requests return the pending request count public int get request count return request count 
 returns the number of threads in this pool return the thread count public int get thread count if threads null return else return threads length 
 returns the specified thread param index  the index of the thread return a  work thread public  work thread get thread int index return threads index 
 adds a progress listener to this thread pool param listener  the listener public void add progress listener  work thread progress listener listener listener list add  work thread progress listener class listener 
 removes a progress listener from this thread pool param listener  the listener public void remove progress listener  work thread progress listener listener listener list remove  work thread progress listener class listener 
void fire status changed  work thread thread final  object listeners listener list get listener list if listeners length int index for int i i threads length i if threads i thread index i break for int i listeners length i i if listeners i  work thread progress listener class  work thread progress listener listeners i status update  work thread pool this index 
void fire progress changed  work thread thread final  object listeners listener list get listener list if listeners length int index for int i i threads length i if threads i thread index i break for int i listeners length i i if listeners i  work thread progress listener class  work thread progress listener listeners i progress update  work thread pool this index 
void request done synchronized lock request count if request count first awt request null queue awt runner 
 request get next request synchronized lock  request request first request if request null return null first request first request next if first request null last request null if request already run throw new  internal error aiee  request run twice request run request already run true  string buffer buf new  string buffer request queue is now  request  request request next while  request null buf append  request id if  request next null buf append  request  request next  log log  log debug this buf to string return request 
 must always be called with the lock held private void do awt requests while request count first awt request null do awt request get next awt request 
 must always be called with the lock held param request the request to run private void do awt request  request request  log log  log debug this  running in awt thread request try request run run catch  throwable t  log log  log error  work thread class  exception in awt thread  log log  log error  work thread class t awt request count 
 must always be called with the lock held private void queue awt runner if awt runner queued awt runner queued true  swing utilities invoke later new  run requests in awt thread  log log  log debug this awt runner queued 
private  request get next awt request  request request first awt request first awt request first awt request next if first awt request null last awt request null if request already run throw new  internal error aiee  request run twice request run request already run true  string buffer buf new  string buffer awt request queue is now  request  request request next while  request null buf append  request id if  request next null buf append  request  request next  log log  log debug this buf to string return request 
 request  runnable run this run run 
public  string to string return id id run run 
public void run synchronized lock awt runner queued false if request count do awt requests 
public  widget get widget  view view  widget wrap new  wrap widget view return wrap 
public  wrap widget final  view view wrap new  tool tip label wrap set horizontal alignment  swing constants center wrap set tool tip text j edit get property view status wrap tooltip this view view wrap add mouse listener new  mouse adapter  override public void mouse clicked  mouse event evt view get buffer toggle word wrap view 
public j component get component return wrap 
public void update  buffer buffer view get buffer  string wrap buffer get string property wrap if wrap equals none this wrap set text else if wrap equals hard this wrap set text h else if wrap equals soft this wrap set text s 
public void properties changed retarded gtk look and feel  font font new j label get font ui manager get font  label font  font metrics fm wrap get font metrics font  dimension dim new  dimension  math max  math max fm char width fm char width h fm char width s fm get height wrap set preferred size dim wrap set maximum size dim 
public  string detect encoding  input stream sample throws io exception  length of longest xml pi used for encoding detection xml version encoding final int xml pi length byte  xml pi new byte xml pi length int offset int count while count sample read  xml pi offset xml pi length offset offset count if offset xml pi length break return get xml encoding new  string  xml pi offset ascii 
 extract xml encoding name from pi private static  string get xml encoding  string xml pi if xml pi starts with xml return null int index xml pi index of encoding if index index xml pi length return null char ch xml pi char at index int end index xml pi index of ch index if end index return null  string encoding xml pi substring index end index try if  charset is supported encoding return encoding else  log log  log warning xml encoding detector class xml pi specifies unsupported encoding encoding catch  illegal charset name exception e  log log  log warning xml encoding detector class xml pi specifies illegal encoding encoding e return null 
 converts lt gt amp in the string to their html entity equivalents p  if code xml code is true then character entities are used to convert illegal xml characters mainly ascii control characters p param str  the string param xml  whether to allow xml constructs public static  string chars to entities  string str boolean xml  string builder buf new  string builder str length for int i i str length i char ch str char at i control characters excluding t r and n  see http www w org  international questions qa controls if x ch ch x f x f ch ch x f ch r ch n ch t if xml ch x buf append append int ch append else  the character is illegal  but put a pi instead to make it recoverable in certain apps buf append illegal xml character append int ch append continue switch ch case buf append lt break case buf append gt break case buf append amp break default buf append ch break return buf to string 
 convenience method for parsing an xml file  this method will wrap the resource in an  input source and set the source s system id to jedit jar so the source should be able to handle any external entities by itself p sax  errors are caught and are not propagated to the caller instead an error message is printed to j edit s activity log  so if you need custom error handling b do not use this method b p  the given stream is closed before the method returns regardless whether there were errors or not p return true if any error occured during parsing false if success public static boolean parse xml  input stream in  default handler handler throws io exception try xml reader parser xml reader factory create xml reader  input source isrc new  input source new  buffered input stream in isrc set system id jedit jar parser set content handler handler parser set dtd handler handler parser set entity resolver handler parser set error handler handler parser parse isrc catch sax parse exception se int line se get line number  log log  log error xml utilities class while parsing from in sax parse exception line line se return true catch sax exception e  log log  log error xml utilities class e return true finally try if in null in close catch io exception io  log log  log error xml utilities class io return false 
 tries to find the given system id in the context of the given class  if the given system id ends with the given test string then try to load a resource using the  class s code get resource as stream code method using the test string as the resource p  this is used a lot internally while parsing xml files used by j edit but anyone is free to use the method if it sounds usable p public static  input source find entity  string system id  string test  class where if system id null system id ends with test try return new  input source new  buffered input stream where get resource as stream test catch  exception e  log log  log error xml utilities class  error while opening test  log log  log error xml utilities class e return null 
private xml utilities 
public x mode handler  string mode name this mode name mode name marker new  token marker marker add rule set new  parser rule set mode name main state stack new  stack  tag decl 
public  input source resolve entity  string public id  string system id return xml utilities find entity system id xmode dtd x mode handler class 
public void characters char c int off int len peek element set text c off len 
public void start element  string uri  string local name  string q name  attributes attrs  tag decl tag push element q name attrs if q name equals whitespace  log log  log warning this mode name whitespace rule no longer needed else if q name equals keywords keywords new  keyword map rules get ignore case else if q name equals rules if tag last set name null tag last set name main rules marker get rule set tag last set name if rules null rules new  parser rule set mode name tag last set name marker add rule set rules rules set ignore case tag last ignore case rules set highlight digits tag last highlight digits if tag last digit re null try rules set digit regexp  pattern compile tag last digit re tag last ignore case  pattern case insensitive catch  pattern syntax exception e error regexp e if tag last escape null rules set escape rule  parser rule create escape rule tag last escape rules set default tag last default id rules set no word sep tag last no word sep 
public void end element  string uri  string local name  string name  tag decl tag pop element if name equals tag tag name if tag last delegate set null tag tag name equals import tag last delegate set get mode name equals mode name  mode mode  mode provider instance get mode tag last delegate set get mode name if reload modes contains mode reload modes add mode property if tag tag name equals property props put prop name prop value props else if tag tag name equals props if peek element tag name equals rules rules set properties props else mode props props props new  hashtable  string  string rules else if tag tag name equals rules rules set keywords keywords keywords null rules null import else if tag tag name equals import prevent lockups if rules equals tag last delegate set rules add rule set tag last delegate set terminate else if tag tag name equals terminate rules set terminate char tag term char seq else if tag tag name equals seq if tag last start null error empty tag seq return rules add rule  parser rule create sequence rule tag last start pos match tag last start to string tag last delegate set tag last token id seq regexp else if tag tag name equals seq regexp if tag last start null error empty tag seq regexp return try if null tag last hash chars rules add rule  parser rule create regexp sequence rule tag last start pos match tag last hash chars to char array tag last start to string tag last delegate set tag last token id find parent rules last ignore case else rules add rule  parser rule create regexp sequence rule tag last hash char tag last start pos match tag last start to string tag last delegate set tag last token id find parent rules last ignore case catch  pattern syntax exception re error regexp re span else if tag tag name equals span if tag last start null error empty tag begin return if tag last end null error empty tag end return rules add rule  parser rule create span rule tag last start pos match tag last start to string tag last end pos match tag last end to string tag last delegate set tag last token id tag last match type tag last no line break tag last no word break tag last escape span regexp else if tag tag name equals span regexp if tag last start null error empty tag begin return if tag last end null error empty tag end return try if null tag last hash chars rules add rule  parser rule create regexp span rule tag last start pos match tag last hash chars to char array tag last start to string tag last end pos match tag last end to string tag last delegate set tag last token id tag last match type tag last no line break tag last no word break find parent rules last ignore case tag last escape else rules add rule  parser rule create regexp span rule tag last hash char tag last start pos match tag last start to string tag last end pos match tag last end to string tag last delegate set tag last token id tag last match type tag last no line break tag last no word break find parent rules last ignore case tag last escape catch  pattern syntax exception re error regexp re eol span else if tag tag name equals eol span if tag last start null error empty tag eol span return rules add rule  parser rule create eol span rule tag last start pos match tag last start to string tag last delegate set tag last token id tag last match type eol span regexp else if tag tag name equals eol span regexp if tag last start null error empty tag eol span regexp return try if null tag last hash chars rules add rule  parser rule create regexp eol span rule tag last start pos match tag last hash chars to char array tag last start to string tag last delegate set tag last token id tag last match type find parent rules last ignore case else rules add rule  parser rule create regexp eol span rule tag last hash char tag last start pos match tag last start to string tag last delegate set tag last token id tag last match type find parent rules last ignore case catch  pattern syntax exception re error regexp re mark following else if tag tag name equals mark following if tag last start null error empty tag mark following return rules add rule  parser rule create mark following rule tag last start pos match tag last start to string tag last token id tag last match type mark previous else if tag tag name equals mark previous if tag last start null error empty tag mark previous return rules add rule  parser rule create mark previous rule tag last start pos match tag last start to string tag last token id tag last match type  keywords else if tag tag name equals end tag tag name equals begin tag tag name equals keywords tag tag name equals mode byte token  token string to token tag tag name if token add keyword tag last keyword to string token else can t happen throw new  internal error 
public void start document props new  hashtable  string  string push element null null reload modes new  vector  mode 
public void end document  parser rule set rulesets marker get rule sets for int i i rulesets length i rulesets i resolve imports for  mode mode reload modes mode set token marker null mode load if necessary 
 returns the  token marker return a  token marker it cannot be null public  token marker get token marker return marker 
public  hashtable  string  string get mode properties return mode props 
private void add keyword  string k byte id if k null error empty keyword null return if keywords null return keywords add k id 
private  tag decl push element  string name  attributes attrs if name null  tag decl tag new  tag decl name attrs state stack push tag return tag else state stack push null return null 
private  tag decl peek element return state stack peek 
private  tag decl pop element return state stack pop 
 finds the first element whose tag matches tag name searching backwards in the stack private  tag decl find parent  string tag name for int idx state stack size idx idx  tag decl tag state stack get idx if tag tag name equals tag name return tag return null 
public  tag decl  string tag name  attributes attrs this tag name tag name  string tmp prop name attrs get value name prop value attrs get value value tmp attrs get value type if tmp null last token id  token string to token tmp if last token id error token invalid tmp last match type  parser rule match type rule check for the deprecated exclude match and warn if found tmp attrs get value exclude match if tmp null  log log  log warning this mode name exclude match is deprecated if true equals ignore case tmp last match type  parser rule match type context override with the newer match type if present tmp attrs get value match type if tmp null if context equals tmp last match type  parser rule match type context else if rule equals tmp last match type  parser rule match type rule else last match type  token string to token tmp if last match type error token invalid tmp last at line start true equals attrs get value at line start last at whitespace end true equals attrs get value at whitespace end last at word start true equals attrs get value at word start last no line break true equals attrs get value no line break last no word break true equals attrs get value no word break last ignore case attrs get value ignore case null true equals attrs get value ignore case last highlight digits true equals attrs get value highlight digits last digit re attrs get value digit re tmp attrs get value no word sep if tmp null last no word sep tmp tmp attrs get value at char if tmp null try term char  integer parse int tmp catch  number format exception e error termchar invalid tmp term char last escape attrs get value escape last set name attrs get value set tmp attrs get value delegate if tmp null  string delegate mode delegate set name int index tmp index of if index delegate mode tmp substring index delegate set name tmp substring index else delegate mode mode name delegate set name tmp  token marker delegate marker get token marker delegate mode if delegate marker null error delegate invalid tmp else last delegate set delegate marker get rule set delegate set name if delegate marker marker last delegate set null stupid hack to handle referencing a rule set that is defined later last delegate set new  parser rule set delegate mode delegate set name last delegate set set default  token invalid marker add rule set last delegate set else if last delegate set null error delegate invalid tmp tmp attrs get value default if tmp null last default id  token string to token tmp if last default id error token invalid tmp last default id  token null last hash char attrs get value hash char last hash chars attrs get value hash chars if null last hash char null last hash chars error hash char and hash chars mutually exclusive null last hash chars null 
public void set text char c int off int len if tag name equals eol span tag name equals eol span regexp tag name equals mark previous tag name equals mark following tag name equals seq tag name equals seq regexp tag name equals begin  tag decl target this if tag name equals begin target state stack get state stack size if target last start null target last start new  string buffer target last start append c off len target last start pos match target last at line start  parser rule at line start target last at whitespace end  parser rule at whitespace end target last at word start  parser rule at word start target last at line start false target last at word start false target last at whitespace end false else target last start append c off len else if tag name equals end  tag decl target state stack get state stack size if target last end null target last end new  string buffer target last end append c off len target last end pos match this last at line start  parser rule at line start this last at whitespace end  parser rule at whitespace end this last at word start  parser rule at word start target last at line start false target last at word start false target last at whitespace end false else target last end append c off len else if last keyword null last keyword new  string buffer last keyword append c off len 
public x this  name space namespace  interpreter declaring interp super namespace declaring interp 
public  string to string return this reference x this to  bsh object namespace 
 get dynamic proxy for interface caching those it creates public  object get interface  class clas return get interface new  class clas 
 get dynamic proxy for interface caching those it creates public  object get interface  class ca if interfaces null interfaces new  hashtable  make a hash of the interface hashcodes in order to cache them int hash for int i i ca length i hash ca i hash code  object hash key new  integer hash  object interf interfaces get hash key if interf null  class loader class loader ca get class loader interf  proxy new proxy instance class loader ca invocation handler interfaces put hash key interf return interf 
public  object invoke  object proxy  method method  object args throws  throwable try return invoke impl proxy method args catch  target error te  unwrap target exception  if the interface declares that it throws the ex it will be delivered  if not it will be wrapped in an  undeclared throwable throw te get target catch  eval error ee  ease debugging x this this refers to the enclosing class instance if  interpreter debug  interpreter debug  eval error in scripted interface x this this to string ee throw ee 
public  object invoke impl  object proxy  method method  object args throws  eval error  string method name method get name  call stack callstack new  call stack namespace  if equals is not explicitly defined we must override the default implemented by the  this object protocol for scripted object  to support x this equals must test for equality with the generated proxy object not the scripted bsh  this object otherwise callers from outside in  java will not see a the proxy object as equal to itself  bsh method equals method null try equals method namespace get method equals new  class  object class catch  util eval error e leave null if method name equals equals equals method null  object obj args return new  boolean proxy obj  if to string is not explicitly defined override the default to show the proxy interfaces  bsh method to string method null try to string method namespace get method to string new  class catch  util eval error e leave null if method name equals to string to string method null  class ints proxy get class get interfaces x this this refers to the enclosing class instance  string builder sb new  string builder x this this to string nimplements for int i i ints length i sb append ints i get name ints length return sb to string  class param types method get parameter types return  primitive unwrap invoke method method name  primitive wrap args param types 
public cb zip  input stream final  input stream input bs set stream input initialize init block setup block 
private static void bad block header cadvise 
private static void block overrun cadvise 
private static void cadvise  system out println crc  error throw new c coruption error 
private static void compressed stream eof cadvise 
private static void crc error cadvise 
public int read if m stream end return else int ret char m current char switch m current state case start block state break case rand part a state break case rand part b state setup rand part b break case rand part c state setup rand part c break case no rand part a state break case no rand part b state setup no rand part b break case no rand part c state setup no rand part c break default break return ret char 
private void set decompress structure sizes int new size k if new size k new size k m block size k m block size k throw new io exception  invalid block size m block size k new size k if new size k return int n base block size new size k m ll new char n m tt new int n 
private void setup block int cftab new int char ch cftab for int i i i cftab i m unzftab i for int i i i cftab i cftab i for int i i m last i ch m ll i m tt cftab ch i cftab ch cftab null m t pos m tt m orig ptr count i ch not a char and not eof if m block randomised m r n to go m r t pos setup rand part a else setup no rand part a 
private void setup no rand part a if i m last ch prev ch ch m ll m t pos m t pos m tt m t pos i m current char ch m current state no rand part b state m crc update crc ch else end block init block setup block 
private void setup no rand part b if ch ch prev m current state no rand part a state count setup no rand part a else count if count z m ll m t pos m t pos m tt m t pos m current state no rand part c state j setup no rand part c else m current state no rand part a state setup no rand part a 
private void setup no rand part c if j z m current char ch m crc update crc ch j else m current state no rand part a state i count setup no rand part a 
private void setup rand part a if i m last ch prev ch ch m ll m t pos m t pos m tt m t pos if m r n to go m r n to go rand nums m r t pos m r t pos if m r t pos m r t pos m r n to go ch m r n to go i m current char ch m current state rand part b state m crc update crc ch else end block init block setup block 
private void setup rand part b if ch ch prev m current state rand part a state count setup rand part a else count if count z m ll m t pos m t pos m tt m t pos if m r n to go m r n to go rand nums m r t pos m r t pos if m r t pos m r t pos m r n to go z m r n to go j m current state rand part c state setup rand part c else m current state rand part a state setup rand part a 
private void setup rand part c if j z m current char ch m crc update crc ch j else m current state rand part a state i count setup rand part a 
private void get and move to front decode int next sym int limit last base block size m block size k m orig ptr read variable sized int recv decoding tables int eob m n in use int group no int group pos  setting up the unzftab entries here is not strictly necessary but it does save having to do it later in a separate pass and so saves a block s worth of cache misses for int i i i m unzftab i final char yy new char for int i i i yy i char i m last int zt int zn int zvec int zj group no group pos g size zt m selector group no zn m min lens zt zvec bs r zn while zvec m limit zt zn zn while m bs live int zzi try zzi m input read catch io exception e compressed stream eof break if zzi compressed stream eof break m bs buff m bs buff zzi xff m bs live zj m bs buff m bs live m bs live zvec zvec zj next sym m perm zt zvec m base zt zn while true if next sym eob break if next sym runa next sym runb char ch int s int n do if next sym runa s s n else if next sym runb s s n n n if group pos group no group pos g size group pos zt m selector group no zn m min lens zt zvec bs r zn while zvec m limit zt zn zn while m bs live int zzi char thech try thech char m input read catch io exception e compressed stream eof if thech compressed stream eof zzi thech m bs buff m bs buff zzi xff m bs live zj m bs buff m bs live m bs live zvec zvec zj next sym m perm zt zvec m base zt zn while next sym runa next sym runb s ch m seq to unseq yy m unzftab ch s while s m last m ll m last ch s if m last limit last block overrun continue else char tmp m last if m last limit last block overrun tmp yy next sym m unzftab m seq to unseq tmp m ll m last m seq to unseq tmp  this loop is hammered during decompression hence the unrolling for j next sym j j yy j yy j int j next sym for j j yy j yy j yy j yy j yy j yy j yy j yy j for j j yy j yy j yy tmp if group pos group no group pos g size group pos zt m selector group no zn m min lens zt zvec bs r zn while zvec m limit zt zn zn while m bs live char ch try ch char m input read catch io exception e compressed stream eof m bs buff m bs buff ch xff m bs live zj m bs buff m bs live m bs live zvec zvec zj next sym m perm zt zvec m base zt zn continue 
private void bs finished with stream m input null 
private int read variable sized int final int num bits return bs r num bits 
private char read unsigned char return char bs r 
private int read int int u u u bs r u u bs r u u bs r u u bs r return u 
private int bs r final int n while m bs live n char ch try ch char m input read catch final io exception ioe compressed stream eof if ch compressed stream eof m bs buff m bs buff ch xff m bs live final int result m bs buff m bs live n n m bs live n return result 
private void bs set stream final  input stream input m input input m bs live m bs buff 
private void complete m stored combined crc read int if m stored combined crc m computed combined crc crc error bs finished with stream m stream end true 
private void end block m computed block crc m crc get final crc a bad crc is considered a fatal error if m stored block crc m computed block crc crc error m computed combined crc m computed combined crc m computed combined crc m computed combined crc m computed block crc 
private void hb create decode tables final int limit final int base final int perm final char length final int min len final int max len final int alpha size int pp for int i min len i max len i for int j j alpha size j if length j i perm pp j pp for int i i max code len i base i for int i i alpha size i base length i for int i i max code len i base i base i for int i i max code len i limit i int vec for int i min len i max len i vec base i base i limit i vec vec for int i min len i max len i base i limit i base i 
private void init block final char magic read unsigned char final char magic read unsigned char final char magic read unsigned char final char magic read unsigned char final char magic read unsigned char final char magic read unsigned char if magic x magic x magic x magic x magic x magic x complete return if magic x magic x magic x magic x magic x magic x bad block header m stream end true return m stored block crc read int if bs r m block randomised true else m block randomised false curr block no get and move to front decode m crc initialise crc m current state start block state 
private void initialize final char magic read unsigned char final char magic read unsigned char if magic h magic magic bs finished with stream m stream end true return set decompress structure sizes magic m computed combined crc 
private void make maps m n in use for int i i i if m in use i m seq to unseq m n in use char i m unseq to seq i char m n in use m n in use 
private void recv decoding tables build in use table make maps final int alpha size m n in use  now the selectors final int group count bs r final int selector count bs r for int i i selector count i int run while bs r run m selector mtf i char run  undo the mtf values for the selectors final char pos new char n groups for char v v group count v pos v v for int i i selector count i int v m selector mtf i final char tmp pos v while v pos v pos v v pos tmp m selector i tmp final char len new char n groups max alpha size  now the coding tables for int i i group count i int curr bs r for int j j alpha size j while bs r if bs r curr else curr len i j char curr  create the  huffman decoding tables for int k k group count k int min len int max len for int i i alpha size i if len k i max len max len len k i if len k i min len min len len k i hb create decode tables m limit k m base k m perm k len k min len max len alpha size m min lens k min len 
private void build in use table final boolean in use new boolean  receive the mapping table for int i i i if bs r in use i true else in use i false for int i i i m in use i false for int i i i if in use i for int j j j if bs r m in use i j true 
public cb zip  output stream final  output stream output throws io exception this output 
public cb zip  output stream final  output stream output final int block size throws io exception bs set stream output m work factor int out block size block size if out block size out block size if out block size out block size m block size k out block size allocate compress structures initialize init block 
private static void hb make code lengths char len int freq int alpha size int max len  nodes and heap entries run from  entry for both the heap and nodes is a sentinel int n nodes  nodes and heap entries run from  entry for both the heap and nodes is a sentinel int n heap  nodes and heap entries run from  entry for both the heap and nodes is a sentinel int n  nodes and heap entries run from  entry for both the heap and nodes is a sentinel int n  nodes and heap entries run from  entry for both the heap and nodes is a sentinel int i  nodes and heap entries run from  entry for both the heap and nodes is a sentinel int j  nodes and heap entries run from  entry for both the heap and nodes is a sentinel int k boolean too long int heap new int max alpha size int weights new int max alpha size int parent new int max alpha size for i i alpha size i weights i freq i freq i while true n nodes alpha size n heap heap weights parent for i i alpha size i parent i n heap heap n heap i int zz int tmp zz n heap tmp heap zz while weights tmp weights heap zz heap zz heap zz zz heap zz tmp if n heap max alpha size panic while n heap n heap heap heap n heap n heap int zz int yy int tmp zz tmp heap zz while true yy zz if yy n heap break if yy n heap weights heap yy weights heap yy yy if weights tmp weights heap yy break heap zz heap yy zz yy heap zz tmp n heap heap heap n heap n heap int zz int yy int tmp zz tmp heap zz while true yy zz if yy n heap break if yy n heap weights heap yy weights heap yy yy if weights tmp weights heap yy break heap zz heap yy zz yy heap zz tmp n nodes parent n n nodes parent n n nodes final int v weights n final int v weights n final int weight calculate weight v v weights n nodes weight parent n nodes n heap heap n heap n nodes int zz int tmp zz n heap tmp heap zz while weights tmp weights heap zz heap zz heap zz zz heap zz tmp if n nodes max alpha size panic too long false for i i alpha size i j k i while parent k k parent k j len i char j if j max len too long true if too long break for i i alpha size i j weights i j j weights i j 
private static int calculate weight final int v final int v final int upper v upper byte mask v upper byte mask final int v  lower v lower byte mask final int v  lower v lower byte mask final int nnnn v  lower v  lower v  lower v  lower return upper nnnn 
private static void panic  system out println panic throw new c error 
public void close throws io exception if m closed return if m run length write run m current char end block end compression m closed true super close m bs stream close 
public void finalize throws  throwable close 
public void flush throws io exception super flush m bs stream flush 
modified by  oliver  merkel param bv  description of  parameter exception java io io exception  description of  exception public void write int bv throws io exception int b bv if m current char if m current char b m run length if m run length write run m current char m run length else write run m run length m current char b else m current char b m run length 
private void allocate compress structures int n base block size m block size k m block new char n num overshoot bytes m quadrant new int n num overshoot bytes m zptr new int n m ftab new int if m block null m quadrant null m zptr null m ftab null int total draw n num overshoot bytes n num overshoot bytes n compress out of memory total draw n  the back end needs a place to store the mtf values whilst it calculates the coding tables  we could put them in the zptr array  however these values will fit in a short so we overlay szptr at the start of zptr in the hope of reducing the number of cache misses induced by the multiple traversals of the mtf values when calculating coding tables  seems to improve compression speed by about szptr zptr m szptr new short n 
private void bs finished with stream throws io exception while m bs live int ch m bs buff try m bs stream write ch write bit catch io exception e throw e m bs buff m bs live 
private void bs put int vs int num bits int c throws io exception bs w num bits c 
private void bs put u char int c throws io exception bs w c 
private void bs putint int u throws io exception bs w u xff bs w u xff bs w u xff bs w u xff 
private void bs set stream  output stream f m bs stream f m bs live m bs buff 
private void bs w int n int v throws io exception while m bs live int ch m bs buff try m bs stream write ch write bit catch io exception e throw e m bs buff m bs live m bs buff v m bs live n m bs live n 
private void do reversible transformation int i m work limit m work factor m last m work done m block randomised false m first attempt true main sort if m work done m work limit m first attempt randomise block m work limit m work done m block randomised true m first attempt false main sort m orig ptr for i i m last i if m zptr i m orig ptr i break if m orig ptr panic 
private void end block throws io exception m block crc m crc get final crc m combined crc m combined crc m combined crc m combined crc m block crc sort the block and establish posn of original string do reversible transformation a byte block header the value chosen arbitrarily as x a bit value does not really give a strong enough guarantee that the value will not appear by chance in the compressed datastream  worst case probability of this event for a k block is about e for bits e for bits and e for bits  for a compressed file of size  gb about blocks only a bit marker will do nb normal compression decompression do not rely on these statistical properties  they are only important when trying to recover blocks from damaged files bs put u char x bs put u char x bs put u char x bs put u char x bs put u char x bs put u char x  now the block s crc so it is in a known place bs putint m block crc  now a single bit indicating randomisation if m block randomised bs w else bs w  finally block s contents proper move to front code and send 
private void end compression throws io exception  now another magic bit number x to indicate the end of the last block sqrt pi if you want to know i did want to use e but it contains too much repetition for me to feel statistically comfortable  call me paranoid bs put u char x bs put u char x bs put u char x bs put u char x bs put u char x bs put u char x bs putint m combined crc bs finished with stream 
private boolean full gt u int i int i int k char c char c int s int s c m block i c m block i if c c return c c i i c m block i c m block i if c c return c c i i c m block i c m block i if c c return c c i i c m block i c m block i if c c return c c i i c m block i c m block i if c c return c c i i c m block i c m block i if c c return c c i i k m last do c m block i c m block i if c c return c c s m quadrant i s m quadrant i if s s return s s i i c m block i c m block i if c c return c c s m quadrant i s m quadrant i if s s return s s i i c m block i c m block i if c c return c c s m quadrant i s m quadrant i if s s return s s i i c m block i c m block i if c c return c c s m quadrant i s m quadrant i if s s return s s i i if i m last i m last i if i m last i m last i k m work done while k return false 
private void generate mtf values char yy new char int i int j char tmp char tmp int z pend int wr int eob make maps eob m n in use for i i eob i m mtf freq i wr z pend for i i m n in use i yy i char i for i i m last i char ll i ll i m unseq to seq m block m zptr i j tmp yy j while ll i tmp j tmp tmp tmp yy j yy j tmp yy tmp if j z pend else if z pend z pend while true switch z pend case m szptr wr short runa wr m mtf freq runa break case m szptr wr short runb wr m mtf freq runb break if z pend break z pend z pend z pend m szptr wr short j wr m mtf freq j if z pend z pend while true switch z pend case m szptr wr short runa wr m mtf freq runa break case m szptr wr short runb wr m mtf freq runb break if z pend break z pend z pend m szptr wr short eob wr m mtf freq eob m n mtf wr 
private void hb assign codes int code char length int min len int max len int alpha size int n int vec int i vec for n min len n max len n for i i alpha size i if length i n code i vec vec vec 
private void init block block no m crc initialise crc m last ch for int i i i m in use i false is just a paranoia constant m allowable block size base block size m block size k 
private void initialize throws io exception  write magic bytes h indicating file format huffmanised followed by a digit indicating block size k bs put u char h bs put u char m block size k m combined crc 
private void main sort int i int j int ss int sb int running order new int int copy new int boolean big done new boolean int c int c  in the various block sized structures live data runs from to last num overshoot bytes inclusive  first set up the overshoot area for block if verbosity fprintf stderr sort initialise n for i i num overshoot bytes i m block m last i m block i m last for i i m last num overshoot bytes i m quadrant i m block m block m last if m last  use simple sort since the full sorting mechanism has quite a large constant overhead for i i m last i m zptr i i m first attempt false m work done m work limit simple sort m last else for i i i big done i false for i i i m ftab i c m block for i i m last i c m block i m ftab c c c c for i i i m ftab i m ftab i c m block for i i m last i c m block i j c c c c m ftab j m zptr m ftab j i j m block m last m block m ftab j m zptr m ftab j m last  now ftab contains the first loc of every small bucket  calculate the running order from smallest to largest big bucket for i i i running order i i int vv int h do h h while h do h h for i h i i vv running order i j i while m ftab running order j h m ftab running order j h m ftab vv m ftab vv running order j running order j h j j h if j h break running order j vv while h  the main sorting loop for i i i  process big buckets starting with the least full ss running order i  complete the big bucket ss by quicksorting any unsorted small buckets ss j  hopefully previous pointer scanning phases have already completed many of the small buckets ss j so we don t have to sort them at all for j j j sb ss j if m ftab sb setmask setmask int lo m ftab sb clearmask int hi m ftab sb clearmask if hi lo q sort lo hi if m work done m work limit m first attempt return m ftab sb setmask  the ss big bucket is now done  record this fact and update the quadrant descriptors  remember to update quadrants in the overshoot area too if necessary  the if i test merely skips this updating for the last bucket processed since updating for the last bucket is pointless big done ss true if i int bb start m ftab ss clearmask int bb size m ftab ss clearmask bb start int shifts while bb size shifts shifts for j j bb size j int a update m zptr bb start j int q val j shifts m quadrant a update q val if a update num overshoot bytes m quadrant a update m last q val if bb size shifts panic  now scan this big bucket so as to synthesise the sorted order for small buckets t ss for all t ss for j j j copy j m ftab j ss clearmask for j m ftab ss clearmask j m ftab ss clearmask j c m block m zptr j if big done c m zptr copy c m zptr j m last m zptr j copy c for j j j m ftab j ss setmask 
private void make maps int i m n in use for i i i if m in use i m seq to unseq m n in use char i m unseq to seq i char m n in use m n in use 
private char med char a char b char c char t if a b t a a b b t if b c t b b c c t if a b b a return b 
private void move to front code and send throws io exception bs put int vs m orig ptr generate mtf values send mtf values 
private void q sort int lo st int hi st int d st int un lo int un hi int lt lo int gt hi int med int n int m int sp int lo int hi int d  stack elem stack new  stack elem qsort stack size for int count count qsort stack size count stack count new  stack elem sp stack sp m ll lo st stack sp m hh hi st stack sp m dd d st sp while sp if sp qsort stack size panic sp lo stack sp m ll hi stack sp m hh d stack sp m dd if hi lo small thresh d depth thresh simple sort lo hi d if m work done m work limit m first attempt return continue med med m block m zptr lo d m block m zptr hi d m block m zptr lo hi d un lo lo lt lo lo un hi hi gt hi hi while true while true if un lo un hi break n m block m zptr un lo d med if n int temp temp m zptr un lo m zptr un lo m zptr lt lo m zptr lt lo temp lt lo un lo continue if n break un lo while true if un lo un hi break n m block m zptr un hi d med if n int temp temp m zptr un hi m zptr un hi m zptr gt hi m zptr gt hi temp gt hi un hi continue if n break un hi if un lo un hi break int temp temp m zptr un lo m zptr un lo m zptr un hi m zptr un hi temp un lo un hi if gt hi lt lo stack sp m ll lo stack sp m hh hi stack sp m dd d sp continue n lt lo lo un lo lt lo lt lo lo un lo lt lo vswap lo un lo n n m hi gt hi gt hi un hi hi gt hi gt hi un hi vswap un lo hi m m n lo un lo lt lo m hi gt hi un hi stack sp m ll lo stack sp m hh n stack sp m dd d sp stack sp m ll n stack sp m hh m stack sp m dd d sp stack sp m ll m stack sp m hh hi stack sp m dd d sp 
private void randomise block int i int r n to go int r t pos for i i i m in use i false for i i m last i if r n to go r n to go char rand nums r t pos r t pos if r t pos r t pos r n to go m block i r n to go handle bit signed numbers m block i x ff m in use m block i true 
private void send mtf values throws io exception char len new char n groups max alpha size int v int t int i int j int gs int ge int bt int bc int iter int n selectors int alpha size int min len int max len int sel ctr int n groups alpha size m n in use for t t n groups t for v v alpha size v len t v char greater icost  decide how many coding tables to use if m n mtf panic if m n mtf n groups else if m n mtf n groups else if m n mtf n groups else if m n mtf n groups else n groups  generate an initial set of coding tables int n part int rem f int t freq int a freq n part n groups rem f m n mtf gs while n part t freq rem f n part ge gs a freq while a freq t freq ge alpha size ge a freq m mtf freq ge if ge gs n part n groups n part n groups n part a freq m mtf freq ge ge for v v alpha size v if v gs v ge len n part v char lesser icost else len n part v char greater icost n part gs ge rem f a freq int rfreq new int n groups max alpha size int fave new int n groups short cost new short n groups  iterate up to n iters times to improve the tables for iter iter n iters iter for t t n groups t fave t for t t n groups t for v v alpha size v rfreq t v n selectors gs while true  set group start end marks if gs m n mtf break ge gs g size if ge m n mtf ge m n mtf  calculate the cost of this group as coded by each of the coding tables for t t n groups t cost t if n groups short cost short cost short cost short cost short cost short cost for i gs i ge i short icv m szptr i cost len icv cost len icv cost len icv cost len icv cost len icv cost len icv cost cost cost cost cost cost cost cost cost cost cost cost else for i gs i ge i short icv m szptr i for t t n groups t cost t len t icv  find the coding table which is best for this group and record its identity in the selector table bc bt for t t n groups t if cost t bc bc cost t bt t fave bt m selector n selectors char bt n selectors  increment the symbol frequencies for the selected table for i gs i ge i rfreq bt m szptr i gs ge  recompute the tables based on the accumulated frequencies for t t n groups t hb make code lengths len t rfreq t alpha size rfreq null fave null cost null if n groups panic if n selectors n selectors g size panic  compute mtf values for the selectors char pos new char n groups char ll i char tmp char tmp for i i n groups i pos i char i for i i n selectors i ll i m selector i j tmp pos j while ll i tmp j tmp tmp tmp pos j pos j tmp pos tmp m selector mtf i char j int code new int n groups max alpha size  assign actual codes for the tables for t t n groups t min len max len for i i alpha size i if len t i max len max len len t i if len t i min len min len len t i if max len panic if min len panic hb assign codes code t len t min len max len alpha size  transmit the mapping table boolean in use new boolean for i i i in use i false for j j j if m in use i j in use i true for i i i if in use i bs w else bs w for i i i if in use i for j j j if m in use i j bs w else bs w  now the selectors bs w n groups bs w n selectors for i i n selectors i for j j m selector mtf i j bs w bs w for t t n groups t int curr len t bs w curr for i i alpha size i while curr len t i bs w curr while curr len t i bs w curr bs w  and finally the block data proper sel ctr gs while true if gs m n mtf break ge gs g size if ge m n mtf ge m n mtf for i gs i ge i bs w len m selector sel ctr m szptr i code m selector sel ctr m szptr i gs ge sel ctr if sel ctr n selectors panic 
private void simple sort int lo int hi int d int i int j int h int big n int hp int v big n hi lo if big n return hp while m incs hp big n hp hp for hp hp h m incs hp i lo h while true copy if i hi break v m zptr i j i while full gt u m zptr j h d v d m zptr j m zptr j h j j h if j lo h break m zptr j v i copy if i hi break v m zptr i j i while full gt u m zptr j h d v d m zptr j m zptr j h j j h if j lo h break m zptr j v i copy if i hi break v m zptr i j i while full gt u m zptr j h d v d m zptr j m zptr j h j j h if j lo h break m zptr j v i if m work done m work limit m first attempt return 
private void vswap int p int p int n int temp while n temp m zptr p m zptr p m zptr p m zptr p temp p p n 
private void write run throws io exception if m last m allowable block size m in use m current char true for int i i m run length i m crc update crc char m current char switch m run length case m last m block m last char m current char break case m last m block m last char m current char m last m block m last char m current char break case m last m block m last char m current char m last m block m last char m current char m last m block m last char m current char break default m in use m run length true m last m block m last char m current char m last m block m last char m current char m last m block m last char m current char m last m block m last char m current char m last m block m last char m run length break else end block init block write run 
public  console install installer new  install  string app name installer get property app name  string app version installer get property app version  buffered reader in new  buffered reader new  input stream reader  system in  system out println app name app version installer  operating system os  operating system get operating system  string install dir os get install directory app name app version  system out print  installation directory install dir  system out flush  string  install dir read line in if  install dir length install dir  install dir else  system out println  will use default  operating system os task os tasks os get os tasks installer for int i i os tasks length i  operating system os task os task os tasks i  string label os task get label label null means no configurable options if label null  string dir os task get directory  system out print label dir  system out flush dir read line in os task set enabled true if dir length if dir equals off os task set enabled false else os task set directory dir else  system out println will use default int comp count installer get integer property comp count  vector components new  vector comp count  system out println  program components to install for int i i comp count i  string fileset installer get property comp i fileset  string os dep installer get property comp i os if os dep null if os get class get name ends with os dep continue  system out print  install installer get property comp i name installer get property comp i disk size  kb y n  string line read line in if line length line char at y line char at y components add element fileset  system out println  starting installation  console progress progress new  console progress  install thread thread new  install thread installer progress install dir os tasks xxx components thread start 
private  string read line  buffered reader in try  string line in read line if line null  system err println n eof in input  system exit can t happen throw new  internal error return line catch io exception io  system err println n i o error io  system exit can t happen throw new  internal error 
public void set maximum int max 
public void advance int value 
public void done  system out println  installation complete 
public void message  string message  system out println message 
public void error  string message  system err println  an error occurred message 
protected crc initialise crc 
int get final crc return m global crc 
void initialise crc m global crc xffffffff 
void update crc final int in ch int temp m global crc in ch if temp temp temp m global crc m global crc crc  table temp 
public static void main  string args  string java version  system get property java version if java version compare to  string message  you are running  java version java version from  system get property java vendor n  this installer requires  java or later if args length j option pane show message dialog null message j edit installer j option pane error message else  system err println message  system exit if args length new  swing install else if args length args equals text new  console install else if args length args equals auto new  non interactive install args else  system err println  usage  system err println java jar installer jar  system err println java jar installer jar text  system err println java jar installer jar auto install dir unix script dir unix man dir  system err println text parameter starts installer in text only mode  system err println auto parameter starts installer in non interactive mode 
public  install props new  properties try  input stream in get class get resource as stream installer install props props load in in close catch io exception io  system err println  error loading install props io print stack trace buf new byte 
public  string get property  string name return props get property name 
public int get integer property  string name try return  integer parse int props get property name catch  exception e return 
public void copy  input stream in  string outfile  progress progress throws io exception  file out file new  file outfile  operating system get operating system mkdirs out file get parent  buffered output stream out new  buffered output stream new  file output stream out file int count for count in read buf  math min in available buf length if count count break out write buf count if progress null progress advance count in close out close 
public  install thread  install installer  progress progress  string install dir  operating system os task os tasks int size  vector components super  install thread this installer installer this progress progress this install dir install dir this os tasks os tasks this size size this components components 
public void run progress set maximum size return value ignored already signalled in  server killer progress message stopping any j edit server  server killer quitj edit server try install user selected packages for int i i components size i  string comp  string components element at i progress message  installing comp install component comp do operating system specific stuff creating startup scripts installing man pages etc for int i i os tasks length i progress message  performing task os tasks i get name os tasks i perform install dir components catch  file not found exception fnf progress error  the installer could not create the destination directory n  maybe you do not have write permission return catch io exception io progress error io to string return progress done 
private void install component  string name throws io exception  input stream in new  buffered input stream get class get resource as stream name tar bz skip header bytes maybe should check if they re valid or not in read in read  tar input stream tar input new  tar input stream new cb zip  input stream in  tar entry entry while entry tar input get next entry null if entry is directory continue  string file name entry get name  system err println file name  string outfile install dir  file separator char file name replace  file separator char installer copy tar input outfile progress tar input close 
public  invalid header exception super 
public  invalid header exception  string msg super msg 
public  non interactive install  string args  string install dir args installer new  install  operating system os  operating system get operating system  operating system os task os tasks os get os tasks installer for int i i args length i  string arg args i int index arg index of if index  system err println  invalid parameter arg continue  string task name arg substring index  string task dir arg substring index for int j j os tasks length j  operating system os task os task os tasks j if os task get name equals task name if task dir equals off os task set enabled false else os task set enabled true os task set directory task dir break int comp count installer get integer property comp count  vector components new  vector comp count for int i i comp count i  string fileset installer get property comp i fileset  string os dep installer get property comp i os if os dep null if os get class get name ends with os dep continue components add element fileset  console progress progress new  console progress  install thread thread new  install thread installer progress install dir os tasks xxx components thread start 
public os task  install installer  string name this installer installer this name name this label installer get property ostask name label this directory get default directory installer on by default enabled true 
public  string get name return name 
public  string get label return label 
public  string get default directory  install installer return null 
public  string get directory return directory 
public boolean is enabled return enabled 
public void set enabled boolean enabled this enabled enabled 
public void set directory  string directory this directory directory 
public os task get os tasks  install installer return new os task 
public void mkdirs  string directory throws io exception  file file new  file directory if file exists file mkdirs 
public static  operating system get operating system if os null return os if  system get property mrj version null os new  mac os else  string os name  system get property os name if os name index of  windows os new  windows else if os name index of os os new  half an os else if os name index of vms os new vms else os new  unix return os 
public  string get install directory  string name  string version  string dir usr local share if new  file dir can write dir  system get property user home return new  file dir name to lower case version get path 
public  string get extra class path return 
public  script os task  install installer super installer unix script 
public  string get default directory  install installer  string dir usr local if new  file dir can write dir  system get property user home return new  file dir bin get path 
public void perform  string install dir  vector filesets throws io exception if enabled return mkdirs directory  string name installer get property app name create app start script  string script directory  file separator char name to lower case  delete existing copy new  file script delete  write simple script  file writer out new  file writer script out write bin sh n out write n out write  runs j edit  programmer s  text  editor n out write n out write n out write  set jvm heap initial and maximum sizes in megabytes n out write java heap max size n out write n out write default java home  system get property java home n out write if z java home then n out write t java home default java home n out write fi n out write n out write  launch application n out write n  string jar install dir  file separator name to lower case jar out write exec java home bin java  xmx java heap max size m jar jar n out close  make it executable  string chmod args chmod script exec chmod args 
public  man page os task  install installer super installer unix man 
public  string get default directory  install installer  string dir usr local if new  file dir can write dir  system get property user home return new  file dir man man get path 
public void perform  string install dir  vector filesets throws io exception if enabled return mkdirs directory  string name installer get property app name install man page  string manpage installer get property ostask unix man manpage  input stream in get class get resource as stream manpage installer copy in new  file directory manpage get path null 
public os task get os tasks  install installer return new os task new  script os task installer new  man page os task installer 
public void mkdirs  string directory throws io exception  file file new  file directory if file exists  string mkdir args mkdir m p directory exec mkdir args 
public void exec  string args throws io exception  process proc  runtime get runtime exec args proc get input stream close proc get output stream close proc get error stream close try proc wait for catch  interrupted exception ie 
public  string get install directory  string name  string version return  applications name version 
public  string get extra class path return  system  library  java 
public  string get install directory  string name  string version  string program dir  system getenv  program files  here is a workaround for the case that the environment variable is not defined  windows and me are known as such environments  this makes sense while j edit supports jre jre doesn t support  windows and me if program dir null  this is a hint for what is needed here program dir  program files return program dir name version 
public j edit launcher os task  install installer super installer jedit launcher 
public  string get default directory  install installer return null 
public void perform  string install dir  vector filesets if enabled filesets contains jedit windows return run j edit launcher installation  file executable new  file install dir jedit exe if executable exists return  string args executable get path i  system get property java home  file separator bin try  runtime get runtime exec args wait for catch io exception io catch  interrupted exception ie 
public os task get os tasks  install installer return new os task new j edit launcher os task installer 
public  string get install directory  string name  string version return c name version 
public  string get install directory  string name  string version return name to lower case version 
try to contact a running instance of j edit  server and ask it to close return true either if no server was detected or the server was shut down false otherwise public static boolean quitj edit server default server file location  string settings directory  system get property user home  file port file  file f new  file settings directory port file new  file f jedit server if port file exists try  buffered reader in new  buffered reader new  file reader port file  string check in read line if check equals b  system out println  wrong port file format return false int port  integer parse int in read line int key  integer parse int in read line  socket socket new  socket  inet address get by name port  data output stream out new  data output stream socket get output stream out write int key we can t close the socket cleanly because we want to wait for complete exit and then it s too late so the socket is closed when the jvm is shut down  string script script j edit exit null true n out write utf script block until its closed try socket get input stream read catch  exception e should get an exception in close out close catch  file not found exception fnfe it exists we checked that earlier catch  unknown host exception uhe localhost doesn t exist catch io exception ioe  system out println  exception while trying to connect to existing server  system out println ioe  system out println  don t worry too much return false warn the user return true 
try to connect to any running server instance and close it exit with an error code on failure but not if no server was found public static void main  string args boolean success quitj edit server if success  system exit 
public  swing install installer new  install os tasks  operating system get operating system get os tasks installer app name installer get property app name app version installer get property app version set title app name app version installer j panel content new j panel new  wizard layout set content pane content caption new j label caption set font new  font  sans serif  font bold  action handler action handler new  action handler cancel button new j button  cancel cancel button set request focus enabled false cancel button add action listener action handler prev button new j button  previous prev button set request focus enabled false prev button add action listener action handler next button new j button next button set request focus enabled false next button add action listener action handler content add caption content add cancel button content add prev button content add next button  string clazz  operating system get operating system get class get name  string completed info done clazz substring clazz index of html pages new  component new  text panel installer get property app readme new  text panel installer get property app license choose directory new  choose directory select components new  select components progress new  swing progress new  text panel completed info for int i i pages length i content add pages i page changed set default close operation do nothing on close add window listener new  window handler  dimension screen get toolkit get screen size pack set location screen width get size width screen height get size height set visible true 
void install  vector components new  vector int size j panel comp select components comp  vector ids select components filesets for int i i comp get component count i if j check box comp get component i get model is selected size installer get integer property comp ids element at i real size components add element installer get property comp ids element at i fileset  string install dir choose directory install dir get text  map os task dirs choose directory os task dirs  iterator keys os task dirs key set iterator while keys has next  operating system os task os task  operating system os task keys next  string dir j text field os task dirs get os task get text if dir null dir trim length os task set enabled true os task set directory dir else os task set enabled false  install thread thread new  install thread installer progress install dir os tasks size components progress set thread thread thread start 
private void page changed switch current page case caption set text  installing app name next button set text  next prev button set enabled false next button set enabled true break case caption set text installer get property app license title next button set text  next prev button set enabled true next button set enabled true break case caption set text  specify where app name is to be installed next button set text  next prev button set enabled true if choose directory is ok next button set enabled false break case caption set text  choose components to install next button set text  install prev button set enabled true next button set enabled true break case caption set text  installing app name next button set text  finish prev button set enabled false next button set enabled false install break case caption set text  installation complete next button set text  finish prev button set enabled false next button set enabled true cancel button set enabled false break get root pane invalidate get root pane validate 
public void action performed  action event evt  object source evt get source if source cancel button  system exit else if source prev button current page page changed else if source next button if current page pages length  system exit else current page page changed 
public void window closing  window event evt  system exit 
public void add layout component  string name  component comp 
public void remove layout component  component comp 
public  dimension preferred layout size  container parent  dimension dim new  dimension  dimension caption size caption get preferred size dim width caption size width for int i i pages length i  dimension  dim pages i get preferred size dim width  math max  dim width dim width dim height  math max  dim height dim height dim width padding dim height padding dim height next button get preferred size height dim height caption size height return dim 
public  dimension minimum layout size  container parent return preferred layout size parent 
public void layout container  container parent  dimension size parent get size  dimension caption size caption get preferred size caption set bounds padding padding caption size width caption size height make all buttons the same size  dimension button size cancel button get preferred size button size width  math max button size width prev button get preferred size width button size width  math max button size width next button get preferred size width cancel button goes on far left cancel button set bounds padding size height button size height padding button size width button size height prev and next buttons are on the right prev button set bounds size width button size width padding size height button size height padding button size width button size height next button set bounds size width button size width padding size height button size height padding button size width button size height calculate size for current page  rectangle current page bounds new  rectangle current page bounds x padding current page bounds y padding caption size height current page bounds width size width current page bounds x padding current page bounds height size height button size height current page bounds y padding for int i i pages length i  component page pages i page set bounds current page bounds page set visible i current page 
 text panel  string file super new  border layout j editor pane text new j editor pane try text set page  text panel this get class get resource file catch  exception e text set text  error loading file e print stack trace text set editable false j scroll pane scroll pane new j scroll pane text  dimension dim new  dimension dim width dim height scroll pane set preferred size dim  text panel this add  border layout center scroll pane 
public  dir verifier j component parent  object pos super message new j text area message set editable false message set background parent get background this parent parent this pos pos 
public boolean should yield focus j component input return verify input 
public boolean verify j component input if input instanceof j text component  string dir j text component input get text if check null dir check exist not directory dir check exist not empty dir check relative dir everything is perfect clean label if message get parent null  swing utilities invoke later new  runnable public void run parent remove message parent revalidate parent repaint else if message get parent null  swing utilities invoke later new  runnable public void run parent add message pos parent revalidate parent repaint else message repaint return true 
private boolean check null  string file if file trim length message set foreground  color red message set text installer get property dir null return false else return true 
private boolean check relative  string dir  file f new  file dir if f is absolute  string msg installer get property dir relative try  string full f get canonical path message set foreground  color orange message set text msg n full catch io exception ioe message set foreground  color red msg installer get property dir cant resolve message set text msg return false else return true 
private boolean check exist not directory  string dir  file f new  file dir if f exists f is directory message set foreground  color red message set text installer get property dir not directory return false else return true 
private boolean check exist not empty  string dir  file f new  file dir  string cnt f list if cnt null cnt length message set foreground  color orange message set text installer get property dir not empty return false else return true 
 choose directory super new  border layout os task dirs new  hash map j panel directory panel new j panel new  grid bag layout install dir add field directory panel  install program in  operating system get operating system get install directory app name app version install dir add focus listener new  focus adapter public void focus lost  focus event fe next button set enabled is ok for int i i os tasks length i  operating system os task os task os tasks i  string label os task get label if label null j text field field add field directory panel label os task get directory os task dirs put os task field  choose directory this add  border layout north directory panel 
boolean is ok if install dir get text length return false  file f new  file install dir get text return f exists f is directory 
private j text field add field j panel directory panel  string label  string default text new line c gridy message j text field field new j text field default text c insets bottom c gridx c gridwidth c insets left c insets right c anchor  grid bag constraints line start  dir verifier verif new  dir verifier directory panel c clone field set input verifier verif c insets bottom c gridx c gridy c gridwidth c anchor  grid bag constraints line end directory panel add new j label label  swing constants right c c gridx c fill  grid bag constraints horizontal c anchor  grid bag constraints center c insets left c insets right c weightx directory panel add field c j button choose new j button  choose choose set request focus enabled false choose add action listener new  action handler field c gridx c insets left c insets right c fill  grid bag constraints none c weightx directory panel add choose c return field 
 action handler j text field field this field field 
public void action performed  action event evt  file directory new  file field get text j file chooser chooser new j file chooser directory get parent chooser set file selection mode j file chooser directories only chooser set selected file directory if chooser show open dialog  swing install this j file chooser approve option field set text chooser get selected file get path field get input verifier verify field 
 select components super new  border layout comp create comp panel  select components this add  border layout north comp size label new j label  swing constants left  select components this add  border layout south size label update size 
public void action performed  action event evt update size 
private j panel create comp panel filesets new  vector int count installer get integer property comp count j panel panel new j panel new  grid layout count  string os class  operating system get operating system get class get name os class os class substring os class index of for int i i count i  string os installer get property comp i os if os null os class equals os continue j check box check box new j check box installer get property comp i name installer get property comp i disk size  kb check box get model set selected true check box add action listener this check box set request focus enabled false filesets add element new  integer i panel add check box  dimension dim panel get preferred size dim width  integer max value panel set maximum size dim return panel 
private void update size int size for int i i filesets size i if j check box comp get component i get model is selected size installer get integer property comp filesets element at i disk size size label set text  estimated disk usage of selected components size  kb 
 swing progress super new  border layout progress new j progress bar progress set string painted true  swing progress this add  border layout north progress 
public void set maximum final int max  swing utilities invoke later new  runnable public void run progress set maximum max 
public void advance final int value try  swing utilities invoke and wait new  runnable public void run progress set value progress get value value  thread yield catch  exception e 
public void done  swing utilities invoke later new  runnable public void run current page page changed 
public void error final  string message  swing utilities invoke later new  runnable public void run dispose j option pane show message dialog null message  installation aborted j option pane error message  system exit 
public void message final  string message  swing utilities invoke later new  runnable public void run progress set string message 
public void set thread  install thread thread this thread thread 
public  tar buffer  input stream in stream this in stream  tar buffer default blksize 
public  tar buffer  input stream in stream int block size this in stream block size  tar buffer default rcdsize 
public  tar buffer  input stream in stream int block size int record size this in stream in stream this out stream null this initialize block size record size 
public  tar buffer  output stream out stream this out stream  tar buffer default blksize 
public  tar buffer  output stream out stream int block size this out stream block size  tar buffer default rcdsize 
public  tar buffer  output stream out stream int block size int record size this in stream null this out stream out stream this initialize block size record size 
 initialization common to all constructors private void initialize int block size int record size this debug false this block size block size this record size record size this recs per block this block size this record size this block buffer new byte this block size if this in stream null this curr blk idx this curr rec idx this recs per block else this curr blk idx this curr rec idx 
 get the tar  buffer s block size  blocks consist of multiple records public int get block size return this block size 
 get the tar  buffer s record size public int get record size return this record size 
 set the debugging flag for the buffer param debug  if true print debugging output public void set debug boolean debug this debug debug 
 determine if an archive record indicate  end of  archive  end of archive is indicated by a record that consists entirely of null bytes param record  the record data to check public boolean is eof record byte record for int i sz this get record size i sz i if record i return false return true 
 skip over a record on the input stream public void skip record throws io exception if this debug  system err println  skip record rec idx this curr rec idx blk idx this curr blk idx if this in stream null throw new io exception reading via skip from an output buffer if this curr rec idx this recs per block if this read block return undone this curr rec idx 
 read a record from the input stream and return the data return  the record data public byte read record throws io exception if this debug  system err println  read record rec idx this curr rec idx blk idx this curr blk idx if this in stream null throw new io exception reading from an output buffer if this curr rec idx this recs per block if this read block return null byte result new byte this record size  system arraycopy this block buffer this curr rec idx this record size result this record size this curr rec idx return result 
return false if  end  of  file else true private boolean read block throws io exception if this debug  system err println  read block blk idx this curr blk idx if this in stream null throw new io exception reading from an output buffer this curr rec idx int offset int bytes needed this block size for bytes needed long num bytes this in stream read this block buffer offset bytes needed note  we have fit eof and the block is not full  this is a broken archive  it does not follow the standard blocking algorithm  however because we are generous and it requires little effort we will simply ignore the error and continue as if the entire block were read  this does not appear to break anything upstream  we used to return false in this case  thanks to  yohann  roussel alcatel fr for this fix if num bytes break offset num bytes bytes needed num bytes if num bytes this block size if this debug  system err println  read block incomplete read num bytes of this block size bytes read this curr blk idx return true 
 get the current block number zero based return  the current zero based block number public int get current block num return this curr blk idx 
 get the current record number within the current block zero based  thus current offset current block num recs per blk current rec num return  the current zero based record number public int get current record num return this curr rec idx 
 write an archive record to the archive param record  the record data to write to the archive public void write record byte record throws io exception if this debug  system err println  write record rec idx this curr rec idx blk idx this curr blk idx if this out stream null throw new io exception writing to an input buffer if record length this record size throw new io exception record to write has length record length which is not the record size of this record size if this curr rec idx this recs per block this write block  system arraycopy record this block buffer this curr rec idx this record size this record size this curr rec idx 
 write an archive record to the archive where the record may be inside of a larger array buffer  the buffer must be offset plus record size long param buf  the buffer containing the record data to write param offset  the offset of the record data within buf public void write record byte buf int offset throws io exception if this debug  system err println  write record rec idx this curr rec idx blk idx this curr blk idx if this out stream null throw new io exception writing to an input buffer if offset this record size buf length throw new io exception record has length buf length with offset offset which is less than the record size of this record size if this curr rec idx this recs per block this write block  system arraycopy buf offset this block buffer this curr rec idx this record size this record size this curr rec idx 
 write a  tar buffer block to the archive private void write block throws io exception if this debug  system err println  write block blk idx this curr blk idx if this out stream null throw new io exception writing to an input buffer this out stream write this block buffer this block size this out stream flush this curr rec idx this curr blk idx 
 flush the current data block if it has any data in it private void flush block throws io exception if this debug  system err println  tar buffer flush block called if this out stream null throw new io exception writing to an input buffer if this curr rec idx this write block 
 close the  tar buffer  if this is an output buffer also flush the current block before closing public void close throws io exception if this debug  system err println  tar buffer close buffer if this out stream null this flush block if this out stream  system out this out stream  system err this out stream close this out stream null else if this in stream null if this in stream  system in this in stream close this in stream null 
 construct an entry with only a name  this allows the programmer to construct the entry s header by hand  file is set to null public  tar entry  string name this initialize this name tar header this header name 
 construct an entry for a file  file is set to file and the header is constructed from information from the file param file  the file that the entry represents public  tar entry  file file throws  invalid header exception this initialize this get file tar header this header file 
 construct an entry from an archive s header bytes  file is set to null param header buf  the header bytes from a tar archive entry public  tar entry byte header buf throws  invalid header exception this initialize this parse tar header this header header buf 
 initialization code common to all constructors private void initialize this file null this header new  tar header 
 determine if the two entries are equal  equality is determined by the header names being equal return it  entry to be checked for equality return  true if the entries are equal public boolean equals  tar entry it return this header name to string equals it header name to string 
 determine if the given entry is a descendant of this entry  descendancy is determined by the name of the descendant starting with this entry s name param desc  entry to be checked as a descendent of this return  true if entry is a descendant of this public boolean is descendent  tar entry desc return desc header name to string starts with this header name to string 
 get this entry s header return  this entry s  tar header public  tar header get header return this header 
 get this entry s name return  this entry s name public  string get name return this header name to string 
 set this entry s name param name  this entry s new name public void set name  string name this header name new  string buffer name 
 get this entry s user id return  this entry s user id public int get user id return this header user id 
 set this entry s user id param user id  this entry s new user id public void set user id int user id this header user id user id 
 get this entry s group id return  this entry s group id public int get group id return this header group id 
 set this entry s group id param group id  this entry s new group id public void set group id int group id this header group id group id 
 get this entry s user name return  this entry s user name public  string get user name return this header user name to string 
 set this entry s user name param user name  this entry s new user name public void set user name  string user name this header user name new  string buffer user name 
 get this entry s group name return  this entry s group name public  string get group name return this header group name to string 
 set this entry s group name param group name  this entry s new group name public void set group name  string group name this header group name new  string buffer group name 
 convenience method to set this entry s group and user ids param user id  this entry s new user id param group id  this entry s new group id public void set ids int user id int group id this set user id user id this set group id group id 
 convenience method to set this entry s group and user names param user name  this entry s new user name param group name  this entry s new group name public void set names  string user name  string group name this set user name user name this set group name group name 
 set this entry s modification time  the parameter passed to this method is in  java time param time  this entry s new modification time public void set mod time long time this header mod time time 
 set this entry s modification time param time  this entry s new modification time public void set mod time  date time this header mod time time get time 
 set this entry s modification time param time  this entry s new modification time public  date get mod time return new  date this header mod time 
 get this entry s file return  this entry s file public  file get file return this file 
 get this entry s file size return  this entry s file size public long get size return this header size 
 set this entry s file size param size  this entry s new file size public void set size long size this header size size 
 convenience method that will modify an entry s name directly in place in an entry header buffer byte array param outbuf  the buffer containing the entry header to modify param new name  the new name to place into the header buffer public void adjust entry name byte outbuf  string new name int offset offset  tar header get name bytes new  string buffer new name outbuf offset  tar header namelen 
 return whether or not this entry represents a directory return  true if this entry is a directory public boolean is directory if this file null return this file is directory if this header null if this header link flag  tar header lf dir return true if this header name to string ends with return true return false 
 fill in a  tar header with information from a  file param hdr  the  tar header to fill in param file  the file from which to get the header information public void get file tar header  tar header hdr  file file throws  invalid header exception this file file  string name file get path  string osname  system get property os name if osname null  strip off drive letters review  would a better check be  file separator  string  win  prefix  windows  string prefix osname substring  win  prefix length if prefix equals ignore case  win  prefix if  file separator char  per  patrick  beard  string  win  prefix windows if osname to lower case starts with  win  prefix if name length char ch name char at char ch name char at if ch ch a ch z ch a ch z name name substring name name replace  file separator char  no absolute pathnames  windows and  posix paths can start with  network drive so we loop on starting s for name starts with name name substring hdr link name new  string buffer hdr name new  string buffer name if file is directory hdr mode hdr link flag  tar header lf dir if hdr name char at hdr name length hdr name append else hdr mode hdr link flag  tar header lf normal undone  when  file lets us get the user name use it hdr size file length hdr mod time file last modified hdr check sum hdr dev major hdr dev minor 
 if this entry represents a file and the file is a directory return an array of  tar entries for this entry s children return  an array of  tar entry s for this entry s children public  tar entry get directory entries throws  invalid header exception if this file null this file is directory return new  tar entry  string list this file list  tar entry result new  tar entry list length for int i i list length i result i new  tar entry new  file this file list i return result 
 compute the checksum of a tar entry header param buf  the tar entry s header buffer return  the computed checksum public long compute check sum byte buf long sum for int i i buf length i sum buf i return sum 
 write an entry s header information to a header buffer param outbuf  the tar entry header buffer to fill in public void write entry header byte outbuf int offset offset  tar header get name bytes this header name outbuf offset  tar header namelen offset  tar header get octal bytes this header mode outbuf offset  tar header modelen offset  tar header get octal bytes this header user id outbuf offset  tar header uidlen offset  tar header get octal bytes this header group id outbuf offset  tar header gidlen long size this header size offset  tar header get long octal bytes size outbuf offset  tar header sizelen offset  tar header get long octal bytes this header mod time outbuf offset  tar header modtimelen int cs offset offset for int c c  tar header chksumlen c outbuf offset byte outbuf offset this header link flag offset  tar header get name bytes this header link name outbuf offset  tar header namelen offset  tar header get name bytes this header magic outbuf offset  tar header magiclen offset  tar header get name bytes this header user name outbuf offset  tar header unamelen offset  tar header get name bytes this header group name outbuf offset  tar header gnamelen offset  tar header get octal bytes this header dev major outbuf offset  tar header devlen offset  tar header get octal bytes this header dev minor outbuf offset  tar header devlen for offset outbuf length outbuf offset long check sum this compute check sum outbuf  tar header get check sum octal bytes check sum outbuf cs offset  tar header chksumlen 
 parse an entry s  tar header information from a header buffer param hdr  the  tar header to fill in from the buffer information param header  the tar entry header buffer to get information from public void parse tar header  tar header hdr byte header throws  invalid header exception int offset hdr name  tar header parse name header offset  tar header namelen offset  tar header namelen hdr mode int  tar header parse octal header offset  tar header modelen offset  tar header modelen hdr user id int  tar header parse octal header offset  tar header uidlen offset  tar header uidlen hdr group id int  tar header parse octal header offset  tar header gidlen offset  tar header gidlen hdr size  tar header parse octal header offset  tar header sizelen offset  tar header sizelen hdr mod time  tar header parse octal header offset  tar header modtimelen offset  tar header modtimelen hdr check sum int  tar header parse octal header offset  tar header chksumlen offset  tar header chksumlen hdr link flag header offset hdr link name  tar header parse name header offset  tar header namelen offset  tar header namelen hdr magic  tar header parse name header offset  tar header magiclen offset  tar header magiclen hdr user name  tar header parse name header offset  tar header unamelen offset  tar header unamelen hdr group name  tar header parse name header offset  tar header gnamelen offset  tar header gnamelen hdr dev major int  tar header parse octal header offset  tar header devlen offset  tar header devlen hdr dev minor int  tar header parse octal header offset  tar header devlen 
 fill in a  tar header given only the entry s name param hdr  the  tar header to fill in param name  the tar entry name public void name tar header  tar header hdr  string name boolean is dir name ends with hdr check sum hdr dev major hdr dev minor hdr name new  string buffer name hdr mode is dir hdr user id hdr group id hdr size hdr check sum hdr mod time new java util  date get time hdr link flag is dir  tar header lf dir  tar header lf normal hdr link name new  string buffer hdr user name new  string buffer hdr group name new  string buffer hdr dev major hdr dev minor 
public  tar header this magic new  string buffer  tar header tmagic this name new  string buffer this link name new  string buffer  string user  system get property user name if user length user user substring this user id this group id this user name new  string buffer user this group name new  string buffer 
 tar headers can be cloned public  object clone  tar header hdr null try hdr  tar header super clone hdr name this name null null new  string buffer this name to string hdr mode this mode hdr user id this user id hdr group id this group id hdr size this size hdr mod time this mod time hdr check sum this check sum hdr link flag this link flag hdr link name this link name null null new  string buffer this link name to string hdr magic this magic null null new  string buffer this magic to string hdr user name this user name null null new  string buffer this user name to string hdr group name this group name null null new  string buffer this group name to string hdr dev major this dev major hdr dev minor this dev minor catch  clone not supported exception ex ex print stack trace return hdr 
 get the name of this entry return  teh entry s name public  string get name return this name to string 
 parse an octal string from a header buffer  this is used for the file permission mode value param header  the header buffer from which to parse param offset  the offset into the buffer from which to parse param length  the number of header bytes to parse return  the long value of the octal string public static long parse octal byte header int offset int length throws  invalid header exception long result boolean still padding true int end offset length for int i offset i end i if header i break if header i byte header i if still padding continue if header i byte break still padding false result result header i return result 
 parse an entry name from a header buffer param header  the header buffer from which to parse param offset  the offset into the buffer from which to parse param length  the number of header bytes to parse return  the header s entry name public static  string buffer parse name byte header int offset int length throws  invalid header exception  string buffer result new  string buffer length int end offset length for int i offset i end i if header i break result append char header i return result 
 determine the number of bytes in an entry name param header  the header buffer from which to parse param offset  the offset into the buffer from which to parse param length  the number of header bytes to parse return  the number of bytes in a header s entry name public static int get name bytes  string buffer name byte buf int offset int length int i for i i length i name length i buf offset i byte name char at i for i length i buf offset i return offset length 
 parse an octal integer from a header buffer param header  the header buffer from which to parse param offset  the offset into the buffer from which to parse param length  the number of header bytes to parse return  the integer value of the octal bytes public static int get octal bytes long value byte buf int offset int length byte result new byte length int idx length buf offset idx idx buf offset idx byte idx if value buf offset idx byte idx else for long val value idx val idx buf offset idx byte byte byte val val val for idx idx buf offset idx byte return offset length 
 parse an octal long integer from a header buffer param header  the header buffer from which to parse param offset  the offset into the buffer from which to parse param length  the number of header bytes to parse return  the long value of the octal bytes public static int get long octal bytes long value byte buf int offset int length byte temp new byte length  tar header get octal bytes value temp length  system arraycopy temp buf offset length return offset length 
 parse the checksum octal integer from a header buffer param header  the header buffer from which to parse param offset  the offset into the buffer from which to parse param length  the number of header bytes to parse return  the integer value of the entry s checksum public static int get check sum octal bytes long value byte buf int offset int length  tar header get octal bytes value buf offset length buf offset length byte buf offset length return offset length 
public  tar input stream  input stream is this is  tar buffer default blksize  tar buffer default rcdsize 
public  tar input stream  input stream is int block size this is block size  tar buffer default rcdsize 
public  tar input stream  input stream is int block size int record size super is this buffer new  tar buffer is block size record size this read buf null this one buf new byte this debug false this has hit eof false this e factory null 
 sets the debugging flag param debug f  true to turn on debugging public void set debug boolean debug f this debug debug f 
 sets the debugging flag param debug f  true to turn on debugging public void set entry factory  entry factory factory this e factory factory 
 sets the debugging flag in this stream s  tar buffer param debug f  true to turn on debugging public void set buffer debug boolean debug this buffer set debug debug 
 closes this stream  calls the  tar buffer s close method public void close throws io exception this buffer close 
 get the record size being used by this stream s  tar buffer return  the  tar buffer record size public int get record size return this buffer get record size 
 get the available data that can be read from the current entry in the archive  this does not indicate how much data is left in the entire archive only in the current entry  this value is determined from the entry s size header field and the amount of data already read from the current entry return  the number of available bytes for the current entry public int available throws io exception return this entry size this entry offset 
 skip bytes in the input buffer  this skips bytes in the current entry s data not the entire archive and will stop at the end of the current entry s data if the number to skip extends beyond that point param num to skip  the number of bytes to skip public void skip int num to skip throws io exception review  this is horribly inefficient but it ensures that we properly skip over bytes via the  tar buffer byte skip buf new byte for int num num to skip num int num read this read skip buf num skip buf length skip buf length num if num read break num num read 
 since we do not support marking just yet we return false return  false public boolean mark supported return false 
 since we do not support marking just yet we do nothing param mark limit  the limit to mark public void mark int mark limit 
 since we do not support marking just yet we do nothing public void reset 
 get the next entry in this tar archive  this will skip over any remaining data in the current entry if there is one and place the input stream at the header of the next entry and read the header and instantiate a new  tar entry from the header bytes and return that entry  if there are no more entries in the archive null will be returned to indicate that the end of the archive has been reached return  the next  tar entry in the archive or null public  tar entry get next entry throws io exception if this has hit eof return null if this curr entry null int num to skip this entry size this entry offset if this debug  system err println  tar input stream skip curr entry this curr entry get name sz this entry size off this entry offset skipping num to skip bytes if num to skip this skip num to skip this read buf null byte header buf this buffer read record if header buf null if this debug  system err println read null record this has hit eof true else if this buffer is eof record header buf if this debug  system err println read eof record this has hit eof true if this has hit eof this curr entry null else try if this e factory null this curr entry new  tar entry header buf else this curr entry this e factory create entry header buf if header buf u header buf s header buf t header buf a header buf r throw new  invalid header exception header magic is not ustar but header buf header buf header buf header buf header buf or dec int header buf int header buf int header buf int header buf int header buf if this debug  system err println  tar input stream set currentry this curr entry get name size this curr entry get size this entry offset review  how do we resolve this discrepancy this entry size int this curr entry get size catch  invalid header exception ex this entry size this entry offset this curr entry null throw new  invalid header exception bad header in block this buffer get current block num record this buffer get current record num ex get message return this curr entry 
 reads a byte from the current tar archive entry  this method simply calls read byte int int return  the byte read or at eof public int read throws io exception int num this read this one buf if num return num else return this one buf 
 reads bytes from the current tar archive entry  this method simply calls read byte int int param buf  the buffer into which to place bytes read return  the number of bytes read or at eof public int read byte buf throws io exception return this read buf buf length 
 reads bytes from the current tar archive entry  this method is aware of the boundaries of the current entry in the archive and will deal with them as if they were this stream s start and eof param buf  the buffer into which to place bytes read param offset  the offset at which to place bytes read param num to read  the number of bytes to read return  the number of bytes read or at eof public int read byte buf int offset int num to read throws io exception int total read if this entry offset this entry size return if num to read this entry offset this entry size num to read this entry size this entry offset if this read buf null int sz num to read this read buf length this read buf length num to read  system arraycopy this read buf buf offset sz if sz this read buf length this read buf null else int new len this read buf length sz byte new buf new byte new len  system arraycopy this read buf sz new buf new len this read buf new buf total read sz num to read sz offset sz for num to read byte rec this buffer read record if rec null  unexpected eof throw new io exception unexpected eof with num to read bytes unread int sz num to read int rec len rec length if rec len sz  system arraycopy rec buf offset sz this read buf new byte rec len sz  system arraycopy rec sz this read buf rec len sz else sz rec len  system arraycopy rec buf offset rec len total read sz num to read sz offset sz this entry offset total read return total read 
 copies the contents of the current tar archive entry directly into an output stream param out  the  output stream into which to write the entry s data public void copy entry contents  output stream out throws io exception byte buf new byte for int num read this read buf buf length if num read break out write buf num read 
public  tar entry create entry  string name return new  tar entry name 
public  tar entry create entry  file path throws  invalid header exception return new  tar entry path 
public  tar entry create entry byte header buf throws  invalid header exception return new  tar entry header buf 
public  tar output stream  output stream os this os  tar buffer default blksize  tar buffer default rcdsize 
public  tar output stream  output stream os int block size this os block size  tar buffer default rcdsize 
public  tar output stream  output stream os int block size int record size super os this buffer new  tar buffer os block size record size this debug false this assem len this assem buf new byte record size this record buf new byte record size this one buf new byte 
 sets the debugging flag param debug f  true to turn on debugging public void set debug boolean debug f this debug debug f 
 sets the debugging flag in this stream s  tar buffer param debug f  true to turn on debugging public void set buffer debug boolean debug this buffer set debug debug 
 ends the tar archive without closing the underlying  output stream  the result is that the eof record of nulls is written public void finish throws io exception this write eof record 
 ends the tar archive and closes the underlying  output stream  this means that finish is called followed by calling the  tar buffer s close public void close throws io exception this finish this buffer close 
 get the record size being used by this stream s  tar buffer return  the  tar buffer record size public int get record size return this buffer get record size 
 put an entry on the output stream  this writes the entry s header record and positions the output stream for writing the contents of the entry  once this method is called the stream is ready for calls to write to write the entry s contents  once the contents are written close entry b must b be called to ensure that all buffered data is completely written to the output stream param entry  the  tar entry to be written to the archive public void put next entry  tar entry entry throws io exception if entry get header name length  tar header namelen throw new  invalid header exception file name entry get header name is too long  tar header namelen bytes entry write entry header this record buf this buffer write record this record buf this curr bytes if entry is directory this curr size else this curr size int entry get size 
 close an entry  this method must be called for all file entries that contain data  the reason is that we must buffer data written to the stream in order to satisfy the buffer s record based writes  thus there may be data fragments still being assembled that must be written to the output stream before this entry is closed and the next entry written public void close entry throws io exception if this assem len for int i this assem len i this assem buf length i this assem buf i this buffer write record this assem buf this curr bytes this assem len this assem len if this curr bytes this curr size throw new io exception entry closed at this curr bytes before the this curr size bytes specified in the header were written 
 writes a byte to the current tar archive entry  this method simply calls read byte int int param b  the byte written public void write int b throws io exception this one buf byte b this write this one buf 
 writes bytes to the current tar archive entry  this method simply calls read byte int int param w buf  the buffer to write to the archive return  the number of bytes read or at eof public void write byte w buf throws io exception this write w buf w buf length 
 writes bytes to the current tar archive entry  this method is aware of the current entry and will throw an exception if you attempt to write bytes past the length specified for the current entry  the method is also painfully aware of the record buffering required by  tar buffer and manages buffers that are not a multiple of recordsize in length including assembling records from small buffers  this method simply calls read byte int int param w buf  the buffer to write to the archive param w offset  the offset in the buffer from which to get bytes param num to write  the number of bytes to write public void write byte w buf int w offset int num to write throws io exception if this curr bytes num to write this curr size throw new io exception request to write num to write bytes exceeds size in header of this curr size bytes  we have to deal with assembly  the programmer can be writing little byte chunks for all we know and we must assemble complete records for writing review  maybe this should be in  tar buffer  could that help to eliminate some of the buffer copying if this assem len if this assem len num to write this record buf length int a len this record buf length this assem len  system arraycopy this assem buf this record buf this assem len  system arraycopy w buf w offset this record buf this assem len a len this buffer write record this record buf this curr bytes this record buf length w offset a len num to write a len this assem len else this assem len num to write this record buf length  system arraycopy w buf w offset this assem buf this assem len num to write w offset num to write this assem len num to write num to write num to write  when we get here we have either o  an empty assemble buffer o  no bytes to write num to write for num to write if num to write this record buf length  system arraycopy w buf w offset this assem buf this assem len num to write this assem len num to write break this buffer write record w buf w offset int num this record buf length this curr bytes num num to write num w offset num 
 write an eof end of archive record to the tar archive  an eof record consists of a record of all zeros private void write eof record throws io exception for int i i this record buf length i this record buf i this buffer write record this record buf 
public  variable grid layout int mode int size int hgap int vgap if mode fixed num rows mode fixed num columns throw new  illegal argument exception illegal mode value is mode if size throw new  illegal argument exception size cannot be zero or less value is size if hgap throw new  illegal argument exception hgap cannot be negative value is hgap if vgap throw new  illegal argument exception vgap cannot be negative value is vgap this mode mode this size size this hgap hgap this vgap vgap 
 creates a variable grid layout manager with the specified mode and zero horizontal and vertical gap public  variable grid layout int mode int size this mode size 
 creates a variable grid layout manager with mode fixed num rows number of rows and zero horizontal and vertical gap public  variable grid layout this fixed num rows 
 not used in this class public void add layout component  string name  component component 
 not used in this class public void add layout component  component component  object constraints 
 not used in this class public void remove layout component  component component 
 always returns public float get layout alignment x  container container return f 
 always returns public float get layout alignment y  container container return f 
public  dimension preferred layout size  container parent return get layout size parent 
public  dimension minimum layout size  container parent return get layout size parent 
public  dimension maximum layout size  container parent return get layout size parent 
public void layout container  container parent synchronized parent get tree lock update parent int ncomponents parent get component count if ncomponents return  pass compute preferred row heights column widths int total height for int r i r nrows r for int c c ncols c i if i ncomponents  dimension d parent get component i get preferred size row heights r  math max row heights r d height col widths c  math max col widths c d width else break total height row heights r int total width for int c c ncols c total width col widths c  pass redistribute free space  dimension parent size parent get size  insets insets parent get insets int free height parent size height insets top insets bottom nrows vgap int free width parent size width insets left insets right ncols hgap if total height free height double dy double free height double total height for int r r nrows r row heights r int double row heights r dy if total width free width double dx double free width double total width for int c c ncols c col widths c int double col widths c dx  pass layout components for int r y insets top i r nrows y row heights r vgap r for int c x insets left c ncols x col widths c hgap c i if i ncomponents parent get component i set bounds x y col widths c row heights r synchronized 
public void invalidate layout  container container 
 returns the string representation of this variable grid layout s values return a string representation of this variable grid layout public  string to string return get class get name mode mode size size hgap hgap vgap vgap 
param which if compute minimum layout size if compute maximum layout size otherwise compute preferred layout size private  dimension get layout size  container parent int which synchronized parent get tree lock update parent int ncomponents parent get component count int h int w for int r i r nrows r int row height for int c c ncols c i if i ncomponents switch which case row height  math max row height parent get component i get minimum size height break case row height  math max row height parent get component i get maximum size height break default row height  math max row height parent get component i get preferred size height break else break h row height for int c c ncols c int col width for int r r nrows r int i r ncols c if i ncomponents switch which case col width  math max col width parent get component i get minimum size width break case col width  math max col width parent get component i get maximum size width break default col width  math max col width parent get component i get preferred size width break else break w col width  insets insets parent get insets return new  dimension w insets left insets right ncols hgap h insets top insets bottom nrows vgap 
private void update  container container int ncomponents container get component count int old nrows nrows int old ncols ncols if this mode fixed num rows nrows this size ncols ncomponents nrows nrows else ncols this size nrows ncomponents ncols ncols if old nrows nrows row heights new int nrows if old ncols ncols col widths new int ncols 
